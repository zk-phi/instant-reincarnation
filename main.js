(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __reExport = (target, module, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toModule = (module) => {
    return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
  };

  // node_modules/facefilter/dist/jeelizFaceFilter.module.js
  var require_jeelizFaceFilter_module = __commonJS({
    "node_modules/facefilter/dist/jeelizFaceFilter.module.js"(exports, module) {
      var JEELIZFACEFILTERGEN = function() {
        function Fb(a2) {
          var c2 = null, d2 = null, e2 = null, m2 = 0;
          this.A = function(n2) {
            this.Cf(n2.pb);
            e2.Be({ qc: n2.qc, nc: n2.nc });
          };
          this.We = function(n2) {
            return c2[n2];
          };
          this.Cf = function(n2) {
            var q2 = null;
            m2 = n2.length;
            c2 = n2.map(function(r2, l2) {
              r2 = Object.assign({}, r2, { index: l2, parent: this, vb: q2, ff: l2 === m2 - 1 });
              return q2 = l2 = l2 === 0 ? Gb.instance(r2) : Hb.instance(r2);
            });
            d2 = c2[0];
            e2 = c2[m2 - 1];
            c2.forEach(function(r2, l2) {
              l2 !== 0 && r2.uf();
            });
          };
          this.V = function(n2) {
            var q2 = n2;
            c2.forEach(function(r2) {
              q2 = r2.V(q2, false);
            });
            return q2;
          };
          this.Ve = function() {
            return d2.F();
          };
          this.Xb = function() {
            return e2.Xe();
          };
          this.nd = function() {
            return e2.nd();
          };
          this.m = function() {
            c2 && (c2.forEach(function(n2) {
              n2.m();
            }), e2 = d2 = c2 = null, m2 = 0);
          };
          typeof a2 !== "undefined" && this.A(a2);
        }
        function db(a2, c2) {
          var d2 = c2 % 8;
          return a2[(c2 - d2) / 8] >> 7 - d2 & 1;
        }
        function Ib(a2) {
          var c2 = JSON.parse(a2);
          a2 = c2.ne;
          var d2 = c2.nf, e2 = c2.n;
          var m2 = typeof btoa === "undefined" ? Buffer.from(c2.data, "base64").toString("latin1") : atob(c2.data);
          var n2 = m2.length;
          c2 = new Uint8Array(n2);
          for (var q2 = 0; q2 < n2; ++q2)
            c2[q2] = m2.charCodeAt(q2);
          m2 = new Float32Array(e2);
          n2 = new Float32Array(d2);
          q2 = a2 + d2 + 1;
          for (var r2 = 0; r2 < e2; ++r2) {
            for (var l2 = q2 * r2, v2 = db(c2, l2) === 0 ? 1 : -1, C2 = l2 + 1, E2 = 1, g2 = 0, t2 = C2 + a2 - 1; t2 >= C2; --t2)
              g2 += E2 * db(c2, t2), E2 *= 2;
            C2 = g2;
            l2 = l2 + 1 + a2;
            E2 = n2.length;
            g2 = 0;
            for (t2 = l2; t2 < l2 + E2; ++t2)
              n2[g2] = db(c2, t2, true), ++g2;
            for (E2 = l2 = 0; E2 < d2; ++E2)
              l2 += n2[E2] * Math.pow(2, -E2 - 1);
            m2[r2] = l2 === 0 && C2 === 0 ? 0 : v2 * (1 + l2) * Math.pow(2, 1 + C2 - Math.pow(2, a2 - 1));
          }
          return m2;
        }
        function Ya() {
          return [ia.ready, ia.play, ia.pause].indexOf(na) !== -1;
        }
        function eb() {
          if (na === ia.play)
            return false;
          na = ia.play;
          Ma.stop();
          qb(0);
        }
        function rb() {
          if (na !== ia.play)
            return false;
          Ma.stop();
          na = ia.pause;
          return true;
        }
        function Fa(a2, c2, d2, e2, m2) {
          a2 = 4 * (3 * c2 + a2) + d2;
          return e2 + (X2.buffer[a2] / 255 + X2.buffer[a2 + 12] / 65025) * (m2 - e2);
        }
        function fb() {
          b2.pixelStorei(b2.UNPACK_FLIP_Y_WEBGL, false);
          va.ha();
          U2.reset();
          Y2.reset();
          A2.R();
          A2.ad();
          b2.disable(b2.DEPTH_TEST);
          b2.disable(b2.BLEND);
          U2.Ja();
          A2.Ba();
        }
        function Jb() {
          va.P();
          b2.viewport(0, 0, 3, 2 * O2.o);
          A2.set("s53");
          X2.Da.g(0);
          U2.l(false, false);
          return aa.xb(0, 0, 3, 2 * O2.o, X2.buffer);
        }
        function qb() {
          na !== ia.pause && (ea.isCleanGLStateAtEachIteration && (A2.ad(), U2.reset(), U2.Ja(), b2.disable(b2.DEPTH_TEST), b2.pixelStorei(b2.UNPACK_FLIP_Y_WEBGL, false), A2.Ba()), pa.rc(Kb, Jb, Lb, Mb, ea.animateProcessOrder));
        }
        function Kb() {
          va.ha();
          if (!B2.kb)
            if (B2.jb)
              B2.element.needsUpdate && (B2.N.Rf(B2.element.arrayBuffer), B2.element.needsUpdate = false);
            else {
              var a2 = B2.element.currentTime, c2 = a2 - B2.wb;
              0 > c2 && (B2.wb = a2);
              1e3 * c2 < ba.Tf || (B2.wb += c2, B2.N.refresh());
            }
          a2 = pa.od();
          if (O2.W.length > a2)
            O2.W.splice(0, O2.W.length - a2);
          else
            for (; O2.W.length < a2; )
              O2.W.push(0);
          if (O2.o !== 1)
            if (qa.every(Nb)) {
              for (var d2 = 0, e2 = c2 = 0; e2 < qa.length; ++e2)
                qa[e2].detected > d2 && (d2 = qa[e2].detected, c2 = 0);
              for (d2 = 0; d2 < a2; ++d2)
                O2.W[d2] = c2;
            } else {
              c2 = Math.round(ba.pf * a2);
              c2 = Math.min(1, c2);
              d2 = O2.Fd;
              for (var m2 = e2 = 0; e2 < a2; ++e2) {
                if (!gb(qa[d2]) && ++m2 > c2) {
                  do
                    ++d2 === O2.o && (d2 = 0);
                  while (!gb(qa[d2]));
                }
                O2.W[e2] = d2++;
                d2 %= O2.o;
              }
              O2.Fd = d2;
            }
          for (a2 = 0; a2 < pa.od(); ++a2)
            O2.pa = O2.W[a2], O2.mc = (0.5 + O2.pa) / O2.o, O2.Ad = O2.W.lastIndexOf(O2.pa) === a2, A2.set("s55"), c2 = qa[O2.pa], A2.G("u43", 1 + Na.uc * (Math.cos(c2.ry) - 1)), Q2.ua && A2.G("u42", c2.rz), O2.o !== 1 && A2.G("u41", O2.mc), Z2.xa.da(), B2.N.g(0), X2.Da.g(1), U2.l(false, false), Z2.xa.g(0), Oa.V(Z2.xa);
          pa.ae();
        }
        function Lb() {
          for (var a2 = 0; a2 < O2.o; ++a2)
            if (O2.W.indexOf(a2) !== -1) {
              var c2 = a2, d2 = Sa[c2], e2 = [c2], m2 = qa[c2], n2 = hb[c2], q2 = 2 * c2;
              d2.Wa = Fa(1, q2, 3, 0, 1);
              m2.detected = wa.$(m2.detected, d2.Wa, ba.ke);
              if (d2.Wa < ea.multiDetectionThresholdFactors[0] * ea.threshold)
                d2.Aa = Math.floor(d2.Aa / 2), Q2.ua && (m2.rz = 0, m2.ry = 0);
              else {
                var r2 = X2.Pa;
                d2.x = Fa(0, q2, 1, -1, 1);
                d2.y = Fa(0, q2, 2, -1, 1);
                d2.ca = Fa(0, q2, 3, 0, 1);
                d2.sc = Fa(1, q2, 0, -r2[0], r2[0]);
                d2.tc = Fa(1, q2, 1, -r2[1], r2[1]);
                d2.Qa = Fa(1, q2, 2, -r2[2], r2[2]);
                for (r2 = 0; r2 < X2.aa; ++r2)
                  d2.hd[r2] = X2.Na[r2](Fa(2, q2, r2, 0, 1));
                e2.Rb = d2.x - m2.xRaw;
                e2.Sb = d2.y - m2.yRaw;
                e2.Qb = d2.ca - m2.sRaw;
                e2.Nb = d2.sc - m2.rx;
                e2.Ob = d2.tc - m2.ry;
                e2.Pb = Q2.ua ? d2.Qa : d2.Qa - m2.rz;
                q2 = pa.Qe();
                e2 = (1 - Za.qb(sa.translationFactorRange[0], sa.translationFactorRange[1], Math.sqrt(e2.Rb * e2.Rb + e2.Sb * e2.Sb + e2.Qb * e2.Qb) / q2)) * (1 - Za.qb(sa.rotationFactorRange[0], sa.rotationFactorRange[1], Math.sqrt(e2.Nb * e2.Nb + e2.Ob * e2.Ob + e2.Pb * e2.Pb) / q2)) * Za.qb(sa.qualityFactorRange[0], sa.qualityFactorRange[1], d2.Wa);
                c2 = n2[++ib[c2] % n2.length] = e2;
                for (q2 = 0; q2 < n2.length; ++q2)
                  c2 = Math.min(c2, n2[q2]);
                c2 = Math.max(0.5, c2);
                e2 = Math.min(c2, e2);
                n2 = wa.$(sa.alphaRange[1], sa.alphaRange[0], Math.pow(e2, ba.me));
                m2.xRaw = wa.$(m2.xRaw, d2.x, n2);
                m2.yRaw = wa.$(m2.yRaw, d2.y, n2);
                m2.sRaw = wa.$(m2.sRaw, d2.ca, n2);
                m2.rx = wa.$(m2.rx, d2.sc, n2);
                m2.ry = wa.$(m2.ry, d2.tc, n2);
                m2.rz = Q2.ua ? m2.rz + sa.followZRotAlphaFactor * n2 * d2.Qa : wa.$(m2.rz, d2.Qa, n2);
                c2 = m2.sRaw * Na.Mb * Math.sin(m2.ry);
                e2 = Math.sin(m2.rz) * c2 / Pa;
                m2.x = m2.xRaw + Math.cos(m2.rz) * c2;
                m2.y = m2.yRaw + e2;
                m2.s = m2.sRaw;
                n2 = Math.max(n2, ba.le);
                for (c2 = 0; c2 < X2.aa; ++c2)
                  m2.expressions[c2] = wa.$(m2.expressions[c2], d2.hd[c2], n2);
                ++d2.Aa;
              }
            }
          va.Pf();
          ea.isCleanGLStateAtEachIteration && (va.reset(), Y2.reset(), b2.enable(b2.DEPTH_TEST));
          Q2.Va && (O2.o === 1 ? Q2.Va(qa[0]) : Q2.Va(qa));
          ea.isCleanGLStateAtEachIteration && b2.disable(b2.BLEND);
        }
        function Mb() {
          na === ia.play && Ma.rc(qb);
        }
        function sb() {
          Z2.xa = Y2.instance({
            isPot: true,
            isFloat: false,
            width: Oa.Ve()
          });
          for (var a2 = ba.Yd, c2 = O2.o, d2 = new Float32Array([0, 0.5, 0.5, 0, 0, 0, 0, 0, 0, 0, 0, 0]), e2 = new Float32Array(d2.length * O2.o), m2 = 0, n2; m2 < O2.o; ++m2)
            for (n2 = 0; n2 < d2.length; ++n2)
              e2[m2 * d2.length + n2] = d2[n2];
          X2.Da = Ob.instance({ width: a2, height: c2, isFloat: true, isPot: false, array: e2 });
        }
        function Pb() {
          function a2(c2) {
            for (var d2 = [], e2 = 0; e2 < O2.o; ++e2)
              d2.push(JSON.parse(JSON.stringify(c2)));
            return d2;
          }
          X2.buffer = new Uint8Array(8 * ba.Yd * O2.o);
          Sa = a2({ Wa: 0, x: 0, y: 0, ca: 1, sc: 0, tc: 0, Qa: 0, hd: new Float32Array(X2.aa), Aa: 0 });
          qa = a2({
            detected: 0,
            x: 0,
            y: 0,
            s: 1,
            xRaw: 0,
            yRaw: 0,
            sRaw: 1,
            rx: 0,
            ry: 0,
            rz: 0,
            expressions: new Float32Array(X2.aa)
          });
          a2({ Rb: 0, Sb: 0, Qb: 0, Nb: 0, Ob: 0, Pb: 0 });
        }
        function jb() {
          A2.T("s55", [{ type: "1i", name: "u1", value: 0 }, { type: "1i", name: "u39", value: 1 }, { type: "2f", name: "u40", value: Z2.H }, { type: "1f", name: "u41", value: 0.5 }, { type: "1f", name: "u42", value: 0 }]);
          A2.T("s56", [
            { type: "1i", name: "u44", value: 0 },
            { type: "1i", name: "u39", value: 1 },
            { type: "1f", name: "u47", value: ba.Nf },
            { type: "1f", name: "u48", value: ea.threshold },
            { type: "3f", name: "u46", value: [X2.O[0] * Z2.H[0], X2.O[1] * Z2.H[1], X2.O[2]] },
            { type: "1f", name: "u41", value: 0.5 },
            { type: "1f", name: "u49", value: 1 },
            { type: "1f", name: "u42", value: 0 }
          ]);
          var a2 = [{ type: "1i", name: "u44", value: 0 }];
          A2.T("s57", a2);
          A2.T("s58", a2);
          A2.T("s53", [{ type: "1i", name: "u39", value: 0 }, { type: "1f", name: "u52", value: Z2.H[0] }, { type: "2f", name: "u51", value: [0, 0.5 / O2.o] }]);
        }
        function kb() {
          Z2.H[0] = 1;
          Z2.H[1] = Z2.D / Z2.M;
          tb.A({ ub: ea.overlapFactors, Kd: ea.nScaleLevels, D: Z2.D, M: Z2.M, Td: ea.scale0Factor, O: X2.O, Ud: ea.scanCenterFirst });
        }
        function Qb(a2) {
          if (Q2.Fa)
            ub(typeof Q2.Fa === "string" ? JSON.parse(Q2.Fa) : Q2.Fa, a2);
          else {
            var c2 = Q2.Mc;
            c2.toUpperCase().split(".").pop() !== "JSON" && (c2 += ba.neuralNetworkPath);
            vb.get(c2, function(d2) {
              d2 = JSON.parse(d2);
              ub(d2, a2);
            });
          }
        }
        function ub(a2, c2) {
          if (a2.exportData) {
            var d2 = a2.exportData;
            d2.rotationEulerAnglesFactors && (X2.Pa = d2.rotationEulerAnglesFactors);
            d2.translationScalingFactors && (X2.O = d2.translationScalingFactors);
            typeof d2.nExpressions !== "undefined" && (X2.aa = d2.nExpressions);
            Na.uc = 0.4;
            Na.Mb = 0.7;
            typeof d2.fgScaleXFactor !== "undefined" && (Na.uc = d2.fgScaleXFactor);
            typeof d2.fgDisplaceXFactor !== "undefined" && (Na.Mb = d2.fgDisplaceXFactor);
          }
          X2.aa || (X2.aa = ba.Jd);
          if (!X2.Na)
            for (X2.Na = [], d2 = 0; d2 < X2.aa; ++d2)
              X2.Na.push(ba.Ke);
          c2(a2);
        }
        function Rb() {
          if (Qa.A({ Jb: Q2.ia, width: Z2.D, height: Z2.M, debug: false, Ld: function() {
            Ha("GLCONTEXT_LOST");
          }, antialias: Q2.antialias, premultipliedAlpha: true }))
            return true;
          Ha("GL_INCOMPATIBLE");
          return false;
        }
        function gb(a2) {
          return a2.detected > ea.multiDetectionThresholdFactors[1] * ea.threshold;
        }
        function Nb(a2) {
          return !gb(a2);
        }
        function wb(a2, c2, d2, e2) {
          return d2 > a2 ? Math.max(0, a2 + c2 / 2 - (d2 - e2 / 2)) : Math.max(0, d2 + e2 / 2 - (a2 - c2 / 2));
        }
        function Sb() {
          return Sa.some(function(a2, c2) {
            if (c2 === O2.pa)
              return false;
            c2 = Sa[O2.pa];
            if (c2.Aa > a2.Aa || 3 > a2.Aa || wb(c2.x, c2.ca, a2.x, a2.ca) < ba.Hd * c2.ca)
              return false;
            var d2 = Z2.D / Z2.M;
            return wb(c2.y, c2.ca * d2, a2.y, a2.ca * d2) > ba.Hd * c2.ca * d2;
          });
        }
        function Tb() {
          var a2 = O2.pa;
          X2.Da.Bf(1);
          O2.o !== 1 && (b2.viewport(0, 0, 3, O2.o), A2.set("s0"), A2.Xd("u1", 1), U2.l(false, false), A2.Xd("u1", 0));
          b2.viewport(0, a2, 1, 1);
          A2.set("s56");
          Q2.ua && A2.G("u42", qa[a2].rz);
          O2.o !== 1 && A2.G("u41", O2.mc);
          if (1 < O2.o) {
            var c2 = Sb() ? 0 : 1;
            A2.G("u49", c2);
          }
          A2.Gf("u45", tb.get());
          U2.l(false, false);
          O2.Ad && (b2.viewport(1, a2, 1, 1), A2.set("s57"), A2.G("u49", 1), U2.l(false, false), b2.viewport(2, a2, 1, 1), A2.set("s58"), U2.l(false, false));
        }
        function xb() {
          B2.N && B2.N.remove();
          B2.jb = B2.element.isFakeVideo ? true : false;
          if (B2.jb) {
            var a2 = yb();
            a2 = { isFlipY: false, array: B2.element.arrayBuffer, width: a2.w, height: a2.wa, isKeepArray: true };
          } else
            a2 = { I: B2.element };
          B2.zc = Y2.instance(Object.assign({ isPot: false, isLinear: true, isFloat: false }, a2));
          B2.N = B2.zc;
        }
        function Ia() {
          var a2 = [{ type: "mat2", name: "u38", value: B2.v }];
          A2.T("s54", [{ type: "1i", name: "u1", value: 0 }].concat(a2));
          A2.T("s55", a2);
        }
        function Ja() {
          B2.L[0] = 0.5;
          B2.L[1] = 0.5;
          var a2 = B2.H[1] / B2.H[0];
          Pa = Qa.U() / Qa.F();
          Math.abs(oa.rotate) === 90 && (a2 = 1 / a2);
          a2 > Pa ? B2.L[1] *= Pa / a2 : B2.L[0] *= a2 / Pa;
          A2.T("s56", [{ name: "u50", type: "1f", value: Pa }]);
          B2.v[0] = 0;
          B2.v[1] = 0;
          B2.v[2] = 0;
          B2.v[3] = 0;
          switch (oa.rotate) {
            case 0:
              B2.v[0] = B2.L[0];
              B2.v[3] = B2.L[1];
              break;
            case 180:
              B2.v[0] = -B2.L[0];
              B2.v[3] = -B2.L[1];
              break;
            case 90:
              B2.v[1] = B2.L[0];
              B2.v[2] = -B2.L[1];
              break;
            case -90:
              B2.v[1] = -B2.L[0], B2.v[2] = B2.L[1];
          }
          oa.flipX && (B2.v[0] *= -1, B2.v[2] *= -1);
          B2.kb || (B2.v[1] *= -1, B2.v[3] *= -1);
        }
        function yb() {
          var a2 = { w: B2.element.videoWidth || B2.element.width, wa: B2.element.videoHeight || B2.element.height };
          if (!a2.w || !a2.wa || 4 > a2.w || 4 > a2.wa)
            throw Error("INVALID VIDEO DIMENSIONS - width = " + a2.w + " height = " + a2.wa);
          return a2;
        }
        function lb() {
          var a2 = yb(), c2 = B2.H[0] !== a2.w || B2.H[1] !== a2.wa;
          c2 && (B2.H[0] = a2.w, B2.H[1] = a2.wa);
          return c2;
        }
        function $a(a2, c2) {
          if (na === ia.error)
            return false;
          B2.element = a2;
          lb();
          c2 && c2();
          return true;
        }
        function zb(a2, c2, d2) {
          a2 && a2();
          B2.La = { video: { facingMode: { exact: oa.facingMode }, width: { min: oa.minWidth, max: oa.maxWidth, ideal: oa.idealWidth }, height: { min: oa.minHeight, max: oa.maxHeight, ideal: oa.idealHeight } }, audio: false };
          W2.Oc(B2.La, oa.deviceId);
          W2.get(B2.element ? B2.element : W2.Ze(), function(e2) {
            c2 && c2(e2);
            d2(e2);
          }, function() {
            Ha("WEBCAM_UNAVAILABLE");
          }, B2.La);
        }
        function Ha(a2) {
          na !== ia.error && (na = ia.error, Q2.Ka && Q2.Ka(a2));
        }
        var wa = {
          Qg: function(a2) {
            return Math.ceil(Math.log2(a2));
          },
          jh: function(a2) {
            return Math.log2(a2);
          },
          fh: function(a2) {
            return Math.log2(a2) % 1 === 0;
          },
          dg: function(a2) {
            var c2 = [0, 0, 0, 0];
            a2.forEach(function(d2) {
              c2[0] += d2[0];
              c2[1] += d2[1];
              c2[2] += d2[2];
              c2[3] += d2[3];
            });
            return c2;
          },
          eg: function(a2, c2, d2) {
            return Math.min(Math.max(a2, c2), d2);
          },
          hg: function(a2) {
            return a2 * Math.PI / 180;
          },
          oh: function(a2, c2) {
            c2 = Math.pow(10, c2);
            return Math.round(a2 * c2) / c2;
          },
          ph: function(a2) {
            return Math.round(1e6 * a2) / 1e6;
          },
          Rg: function(a2, c2) {
            return (100 * a2 / c2).toFixed(3);
          },
          $: function(a2, c2, d2) {
            return a2 * (1 - d2) + c2 * d2;
          },
          Ge: function(a2, c2) {
            return wa.ye(a2 - c2);
          },
          ye: function(a2) {
            for (; a2 > Math.PI; )
              a2 -= 2 * Math.PI;
            for (; a2 <= -Math.PI; )
              a2 += 2 * Math.PI;
            return a2;
          },
          kg: function(a2, c2) {
            return Math.abs(wa.Ge(a2, c2));
          },
          Uf: function(a2, c2) {
            return Math.atan2(Math.sin(a2) + Math.sin(c2), Math.cos(a2) + Math.cos(c2));
          }
        }, vb = { get: function(a2, c2, d2) {
          var e2 = new XMLHttpRequest();
          e2.open("GET", a2, true);
          e2.withCredentials = false;
          e2.onreadystatechange = function() {
            e2.readyState === 4 && (e2.status === 200 || e2.status === 0 ? c2(e2.responseText) : typeof d2 !== "undefined" && d2(e2.status));
          };
          e2.send();
        }, Ng: function(a2, c2) {
          vb.get(a2, function(d2) {
            c2(JSON.parse(d2));
          });
        }, lh: function(a2, c2, d2) {
          var e2 = new XMLHttpRequest();
          e2.open("POST", a2, true);
          e2.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
          e2.onreadystatechange = function() {
            e2.readyState !== 4 || e2.status !== 200 && e2.status !== 0 || d2(e2.responseText);
          };
          e2.send(c2);
        }, Bg: function(a2, c2) {
          var d2 = new XMLHttpRequest();
          d2.open("POST", a2, true);
          d2.responseType = "arraybuffer";
          d2.onload = function() {
            c2(d2.response);
          };
          d2.send();
        } }, Ub = { create: function(a2, c2) {
          for (var d2 = Array(c2), e2 = 0; e2 < c2; ++e2)
            d2[e2] = a2;
          return d2;
        }, ig: function(a2, c2) {
          for (var d2 = 0; d2 < a2.length; ++d2)
            c2[d2] = a2[d2];
        }, clone: function(a2) {
          for (var c2 = Array(a2.length), d2 = 0; d2 < a2.length; ++d2)
            c2[d2] = a2[d2];
          return c2;
        }, sh: function(a2, c2, d2) {
          a2.forEach(function(e2, m2) {
            c2[m2] = e2 * d2;
          });
        }, Ch: function(a2) {
          for (var c2 = a2.length - 1; 0 < c2; --c2) {
            var d2 = Math.floor(Math.random() * (c2 + 1)), e2 = a2[c2];
            a2[c2] = a2[d2];
            a2[d2] = e2;
          }
        }, Mf: function(a2) {
          return Array.isArray(a2) || a2.constructor === Float32Array || a2.constructor === Uint8Array;
        } }, mb = { Kb: function(a2, c2) {
          if (c2 === 0 || typeof a2 !== "object")
            return a2;
          a2 = Object.assign({}, a2);
          c2 = c2 === void 0 || c2 === -1 ? -1 : c2 - 1;
          for (var d2 in a2)
            a2[d2] = mb.Kb(a2[d2], c2);
          return a2;
        } }, Za = { Dh: function(a2, c2, d2) {
          a2 = Math.min(Math.max((d2 - a2) / (c2 - a2), 0), 1);
          return a2 * a2 * (3 - 2 * a2);
        }, qb: function(a2, c2, d2) {
          return Math.min(Math.max((d2 - a2) / (c2 - a2), 0), 1);
        }, vg: function(a2, c2, d2, e2) {
          return Math.pow(Math.min(Math.max((e2 - a2) / (c2 - a2), 0), 1), d2);
        }, Hh: function() {
          return 0;
        }, kh: function() {
          return 1;
        }, ih: function(a2) {
          return a2;
        }, sg: function(a2) {
          return a2 * a2;
        }, xg: function(a2) {
          return a2 * (2 - a2);
        }, pg: function(a2) {
          return 0.5 > a2 ? 2 * a2 * a2 : -1 + (4 - 2 * a2) * a2;
        }, ng: function(a2) {
          return a2 * a2 * a2;
        }, wg: function(a2) {
          return --a2 * a2 * a2 + 1;
        }, og: function(a2) {
          return 0.5 > a2 ? 4 * a2 * a2 * a2 : (a2 - 1) * (2 * a2 - 2) * (2 * a2 - 2) + 1;
        }, tg: function(a2) {
          return a2 * a2 * a2 * a2;
        }, yg: function(a2) {
          return 1 - --a2 * a2 * a2 * a2;
        }, qg: function(a2) {
          return 0.5 > a2 ? 8 * a2 * a2 * a2 * a2 : 1 - 8 * --a2 * a2 * a2 * a2;
        }, ug: function(a2) {
          return a2 * a2 * a2 * a2 * a2;
        }, zg: function(a2) {
          return 1 + --a2 * a2 * a2 * a2 * a2;
        }, rg: function(a2) {
          return 0.5 > a2 ? 16 * a2 * a2 * a2 * a2 * a2 : 1 + 16 * --a2 * a2 * a2 * a2 * a2;
        } }, Vb = { Me: function(a2, c2, d2) {
          switch (a2) {
            case "relu":
              return d2 + "=max(vec4(0.,0.,0.,0.)," + c2 + ");";
            case "elu":
              return d2 + "=mix(exp(-abs(" + c2 + "))-vec4(1.,1.,1.,1.)," + c2 + ",step(0.," + c2 + "));";
            case "elu01":
              return d2 + "=mix(0.1*exp(-abs(" + c2 + "))-vec4(0.1,0.1,0.1,0.1)," + c2 + ",step(0.," + c2 + "));";
            case "arctan":
              return d2 + "=atan(3.14159265359*texture2D(u0,vUV))/3.14159265359;";
            case "copy":
              return "";
            default:
              return false;
          }
        } }, A2 = function() {
          function a2(u2, f2, y2) {
            f2 = u2.createShader(f2);
            u2.shaderSource(f2, y2);
            u2.compileShader(f2);
            return u2.getShaderParameter(f2, u2.COMPILE_STATUS) ? f2 : false;
          }
          function c2(u2, f2, y2) {
            f2 = a2(u2, u2.VERTEX_SHADER, f2);
            y2 = a2(u2, u2.FRAGMENT_SHADER, y2);
            u2 === b2 && q2.push(f2, y2);
            var G2 = u2.createProgram();
            u2.attachShader(G2, f2);
            u2.attachShader(G2, y2);
            u2.linkProgram(G2);
            return G2;
          }
          function d2(u2, f2) {
            f2.C = f2.C ? true : false;
            if (!f2.C) {
              f2.ta === void 0 && (f2.ta = "precision lowp float;attribute vec2 a0;varying vec2 vv0;void main(){gl_Position=vec4(a0,0.,1.),vv0=a0*.5+vec2(.5,.5);}");
              f2.Ta === void 0 && (f2.Ta = ["a0"]);
              f2.Ha === void 0 && (f2.Ha = [2]);
              if (f2.precision === void 0 || f2.precision === "highp")
                f2.precision = E2;
              f2.id = v2++;
              f2.Vd !== void 0 && (f2.Vd.forEach(function(G2, L2) {
                f2.h = f2.h.replace(G2, f2.yb[L2]);
              }), f2.Vd.splice(0));
              f2.Hc = 0;
              f2.Ha.forEach(function(G2) {
                f2.Hc += 4 * G2;
              });
              f2.ra = c2(u2, f2.ta, "precision " + f2.precision + " float;\n" + f2.h);
              f2.B = {};
              f2.i.forEach(function(G2) {
                f2.B[G2] = u2.getUniformLocation(f2.ra, G2);
              });
              f2.attributes = {};
              f2.Ia = [];
              f2.Ta.forEach(function(G2) {
                var L2 = u2.getAttribLocation(f2.ra, G2);
                f2.attributes[G2] = L2;
                f2.Ia.push(L2);
              });
              if (f2.j) {
                u2.useProgram(f2.ra);
                l2 = f2;
                r2 = f2.id;
                for (var y2 in f2.j)
                  u2.uniform1i(f2.B[y2], f2.j[y2]);
              }
              f2.qa = true;
            }
          }
          function e2(u2) {
            xa.Ff(M2);
            r2 !== u2.id && (M2.R(), r2 = u2.id, l2 = u2, b2.useProgram(u2.ra), u2.Ia.forEach(function(f2) {
              f2 !== 0 && b2.enableVertexAttribArray(f2);
            }));
          }
          function m2(u2, f2, y2) {
            d2(u2, f2, y2);
            u2.useProgram(f2.ra);
            u2.enableVertexAttribArray(0);
            r2 = -1;
            return l2 = f2;
          }
          function n2() {
            return { h: "uniform sampler2D u1;varying vec2 vv0;void main(){gl_FragColor=texture2D(u1,vv0);}", i: ["u1"], j: { u1: 0 } };
          }
          var q2 = [], r2 = -1, l2 = null, v2 = 0, C2 = false, E2 = "highp", g2 = ["u1"], t2 = ["u0"], x2 = { u1: 0 }, k2 = { u0: 0 }, p2 = { u1: 0, u2: 1 }, H2 = { u3: 0 }, I2 = {
            s0: n2(),
            s1: { h: "uniform sampler2D u1;varying vec2 vv0;void main(){gl_FragColor=texture2D(u1,vv0);}", i: g2, j: x2, precision: "lowp" },
            s2: {
              h: "uniform sampler2D u1,u2;varying vec2 vv0;void main(){vec4 a=texture2D(u2,vv0),b=texture2D(u1,vv0);gl_FragColor=a*b;}",
              i: ["u1", "u2"],
              j: p2
            },
            s3: { h: "uniform sampler2D u1;uniform vec2 u4,u5;varying vec2 vv0;void main(){vec2 a=vv0*u4+u5;gl_FragColor=texture2D(u1,a);}", i: ["u1", "u4", "u5"], j: x2, C: true },
            s4: { h: "uniform sampler2D u1;varying vec2 vv0;const vec4 f=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u1,vv0);gl_FragColor=a.r*f;}", i: g2, j: x2 },
            s5: { h: "uniform sampler2D u1,u2;varying vec2 vv0;const vec4 f=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u2,vv0),b=texture2D(u1,vv0);gl_FragColor=a.a*b.r*f;}", i: ["u1", "u2"], j: p2 },
            s6: {
              h: "uniform sampler2D u1;varying vec2 vv0;void main(){gl_FragColor=texture2D(u1,vec2(1.-vv0.x,vv0.y));}",
              i: g2,
              j: x2
            },
            s7: { h: "uniform sampler2D u1;varying vec2 vv0;void main(){gl_FragColor=texture2D(u1,vec2(vv0.x,1.-vv0.y));}", i: g2, j: x2 },
            s8: { h: "uniform sampler2D u0;uniform float u4;varying vec2 vv0;void main(){vec4 a=texture2D(u0,vv0);gl_FragColor=a*u4;}", i: ["u0", "u4"], j: k2 },
            s9: { h: "uniform sampler2D u0;uniform float u4;varying vec2 vv0;const vec4 f=vec4(.25,.25,.25,.25),g=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u0,vv0);float b=dot(a*u4,f);gl_FragColor=b*g;}", i: ["u0", "u4"], j: k2 },
            s10: {
              h: "uniform sampler2D u1;varying vec2 vv0;const vec4 e=vec4(1.,1.,1.,1.);void main(){float a=.25*dot(e,texture2D(u1,vv0));gl_FragColor=a*e;}",
              i: g2,
              j: x2
            },
            s11: { h: "uniform sampler2D u1,u6;uniform float u7;const vec4 f=vec4(1.,1.,1.,1.);varying vec2 vv0;void main(){vec4 a=texture2D(u1,vv0),b=texture2D(u6,vv0);gl_FragColor=mix(b,a,u7*f);}", i: ["u1", "u6", "u7"], j: { u1: 0, u6: 1 } },
            s12: { h: "uniform sampler2D u1;uniform vec2 u8;varying vec2 vv0;void main(){gl_FragColor=.25*(texture2D(u1,vv0+u8)+texture2D(u1,vv0+u8*vec2(1.,-1.))+texture2D(u1,vv0+u8*vec2(-1.,-1.))+texture2D(u1,vv0+u8*vec2(-1.,1.)));}", i: ["u1", "u8"], j: x2 },
            s13: {
              h: "uniform sampler2D u1;uniform vec4 u9;varying vec2 vv0;float g(float a,float b){a=floor(a)+.5;return floor(a/exp2(b));}float h(float a,float b){return floor(a*exp2(b)+.5);}float i(float a,float b){return mod(a,h(1.,b));}float e(float c,float a,float b){a=floor(a+.5),b=floor(b+.5);return i(g(c,a),b-a);}vec4 j(float a){if(a==0.)return vec4(0.,0.,0.,0.);float k=128.*step(a,0.);a=abs(a);float c=floor(log2(a)),l=c+127.,b=(a/exp2(c)-1.)*8388608.,d=l/2.,m=fract(d)*2.,n=floor(d),o=e(b,0.,8.),p=e(b,8.,16.),q=m*128.+e(b,16.,23.),r=k+n;return vec4(o,p,q,r)/255.;}void main(){float a=dot(texture2D(u1,vv0),u9);gl_FragColor=j(a);}",
              i: ["u1", "u9"],
              j: x2
            },
            s14: { h: "uniform sampler2D u0;varying vec2 vv0;const vec4 e=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u0,vv0),b=e/(e+exp(-a));gl_FragColor=b;}", i: t2, j: k2, C: true },
            s15: { h: "uniform sampler2D u0;varying vec2 vv0;const vec4 f=vec4(0.,0.,0.,0.);void main(){vec4 a=texture2D(u0,vv0);gl_FragColor=max(f,a);}", i: t2, j: k2 },
            s16: { h: "uniform sampler2D u0;varying vec2 vv0;const vec4 f=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u0,vv0);gl_FragColor=mix(exp(-abs(a))-f,a,step(0.,a));}", i: t2, j: k2 },
            s17: { h: "uniform sampler2D u0;varying vec2 vv0;const vec4 f=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u0,vv0),b=exp(-abs(a))-f;gl_FragColor=mix(.1*b,a,step(0.,a));}", i: t2, j: k2 },
            s18: { h: "uniform sampler2D u0,u7,u10;varying vec2 vv0;const vec4 f=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u0,vv0),c=texture2D(u7,vv0),d=texture2D(u10,vv0),b=a/d;gl_FragColor=c*mix(exp(-abs(b))-f,b,step(0.,a));}", i: ["u0", "u7", "u10"], j: { u0: 0, u7: 1, u10: 2 }, C: true },
            s19: {
              h: "uniform sampler2D u0;const float e=3.141593;varying vec2 vv0;void main(){gl_FragColor=atan(e*texture2D(u0,vv0))/e;}",
              i: t2,
              j: k2
            },
            s20: { h: "uniform sampler2D u0;varying vec2 vv0;const vec4 f=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u0,vv0),b=log(f+a);gl_FragColor=b;}", i: t2, j: k2, C: true },
            s21: { h: "uniform sampler2D u0,u11;uniform float u12;const vec2 e=vec2(.5,.5);const float f=1e-5;const vec4 g=vec4(1.,1.,1.,1.),i=vec4(0.,0.,0.,0.);varying vec2 vv0;void main(){vec4 a=texture2D(u11,e);float b=u12*u12;vec4 c=max(b*a,f*g);gl_FragColor=texture2D(u0,vv0)/c;}", i: ["u0", "u11", "u12"], j: { u0: 0, u11: 1 }, C: true },
            s22: {
              h: "uniform sampler2D u1;uniform vec2 u13;varying vec2 vv0;void main(){float a=u13.x*u13.y;vec2 b=floor(vv0*a)/a,c=fract(vv0*a),d=floor(b*u13.y),f=floor(u13.x*fract(b*u13.y)),g=(f*u13.y+d)/a;gl_FragColor=texture2D(u1,g+c/a);}",
              i: ["u1", "u13"],
              j: x2
            },
            s23: { h: "uniform sampler2D u14,u15,u16;varying vec2 vv0;void main(){vec4 a=texture2D(u16,vv0);vec2 b=a.rg,c=a.ba;vec4 d=texture2D(u14,b),f=texture2D(u15,c);gl_FragColor=d*f;}", i: ["u14", "u15", "u16"], j: { u15: 0, u14: 1, u16: 2 }, C: true },
            s24: { h: "uniform float u17;uniform sampler2D u14,u15;varying vec2 vv0;void main(){vec2 a=fract(vv0*u17);vec4 b=texture2D(u14,vv0),c=texture2D(u15,a);gl_FragColor=b*c;}", i: ["u15", "u14", "u17"], j: { u15: 0, u14: 1 } },
            s25: {
              h: "uniform float u17;uniform sampler2D u14,u15,u18,u19,u20,u21;varying vec2 vv0;const vec4 e=vec4(1.,1.,1.,1.),g=vec4(1e-3,1e-3,1e-3,1e-3);void main(){vec2 h=vv0*u17,l=floor(h),c=h-l;vec4 m=texture2D(u14,vv0),d=texture2D(u15,c),a=texture2D(u21,vv0);a=a*255.;vec4 n=texture2D(u18,c),o=texture2D(u19,c),p=texture2D(u20,c),i=step(-g,-a),b=e-i,j=b*step(-e-g,-a);b*=e-j;vec4 k=b*step(-2.*e-g,-a);b*=e-k;vec4 q=b;d=i*d+j*n+k*o+q*p,gl_FragColor=m*d;}",
              i: "u14 u15 u17 u21 u18 u19 u20".split(" "),
              j: { u15: 0, u14: 1, u21: 3, u18: 4, u19: 5, u20: 6 },
              C: true
            },
            s26: {
              h: "uniform sampler2D u14,u15,u22;uniform float u17,u23,u24,u25;varying vec2 vv0;const vec2 j=vec2(1.,1.);void main(){vec2 a=floor(u23*vv0),b=u23*vv0-a;float c=u17/u23;vec2 d=floor(b*c),f=b*c-d,g=(a+f)/u23;float k=u23*u25/u17;vec2 l=k*d,h=(l+f*u24)/u25,i=step(h,j);vec4 m=texture2D(u14,g),n=texture2D(u15,h),o=m*n*i.x*i.y,p=texture2D(u22,g);gl_FragColor=o*u24*u24+p;}",
              i: "u14 u15 u17 u23 u24 u25 u22".split(" "),
              j: { u15: 0, u14: 1, u22: 2 }
            },
            s27: { h: "uniform sampler2D u14,u15;varying vec2 vv0;void main(){vec4 a=texture2D(u14,vv0),b=texture2D(u15,vv0);gl_FragColor=a*b;}", i: ["u14", "u15"], j: { u15: 0, u14: 1 }, C: true },
            s28: { h: "uniform sampler2D u1,u22;uniform float u26;varying vec2 vv0;void main(){gl_FragColor=texture2D(u22,vv0)+u26*texture2D(u1,vv0);}", i: ["u1", "u22", "u26"], j: { u1: 0, u22: 1 } },
            s29: {
              h: "varying vec2 vv0;uniform sampler2D u1;const vec4 f=vec4(1.,1.,1.,1.),g=vec4(.299,.587,.114,0.);void main(){vec4 a=texture2D(u1,vv0);gl_FragColor=dot(a,g)*f;}",
              i: g2,
              j: x2,
              precision: "lowp"
            },
            s30: { h: "varying vec2 vv0;uniform sampler2D u1;uniform float u27;const vec3 f=vec3(.299,.587,.114);void main(){vec3 a=texture2D(u1,vv0).rgb,b=texture2D(u1,vv0+vec2(0.,u27)).rgb,c=texture2D(u1,vv0+vec2(u27,u27)).rgb,d=texture2D(u1,vv0+vec2(u27,0.)).rgb;gl_FragColor=vec4(dot(a,f),dot(b,f),dot(c,f),dot(d,f));}", i: ["u1", "u27"], j: x2, precision: "lowp" },
            s31: {
              h: "varying vec2 vv0;uniform sampler2D u1;uniform float u27;const vec3 f=vec3(.299,.587,.114);void main(){vec3 a=texture2D(u1,vv0).rgb,b=texture2D(u1,vv0+vec2(0.,u27)).rgb,c=texture2D(u1,vv0+vec2(u27,u27)).rgb,d=texture2D(u1,vv0+vec2(u27,0.)).rgb;gl_FragColor=vec4(a.r,b.g,c.b,dot(d,f));}",
              i: ["u1", "u27"],
              j: x2,
              precision: "lowp"
            },
            s32: {
              h: "varying vec2 vv0;uniform sampler2D u1,u2;uniform float u28;const vec4 f=vec4(1.,1.,1.,1.);void main(){vec4 a=vec4(0.);a-=texture2D(u1,vec2(vv0.x-u28,vv0.y-u28))*1.,a-=texture2D(u1,vec2(vv0.x-u28,vv0.y))*2.,a-=texture2D(u1,vec2(vv0.x-u28,vv0.y+u28))*1.,a+=texture2D(u1,vec2(vv0.x+u28,vv0.y-u28))*1.,a+=texture2D(u1,vec2(vv0.x+u28,vv0.y))*2.,a+=texture2D(u1,vec2(vv0.x+u28,vv0.y+u28))*1.;vec4 b=vec4(0.);b-=texture2D(u1,vec2(vv0.x-u28,vv0.y-u28))*1.,b-=texture2D(u1,vec2(vv0.x,vv0.y-u28))*2.,b-=texture2D(u1,vec2(vv0.x+u28,vv0.y-u28))*1.,b+=texture2D(u1,vec2(vv0.x-u28,vv0.y+u28))*1.,b+=texture2D(u1,vec2(vv0.x,vv0.y+u28))*2.,b+=texture2D(u1,vec2(vv0.x+u28,vv0.y+u28))*1.;vec3 c=sqrt(a.rgb*a.rgb+b.rgb*b.rgb);vec4 e=vec4(c,texture2D(u1,vv0).a),g=texture2D(u2,vv0);gl_FragColor=g.a*e.r*f;}",
              i: ["u1", "u2", "u28"],
              j: p2,
              C: true
            },
            s33: { h: "varying vec2 vv0;uniform sampler2D u1,u2;uniform float u28;const vec4 j=vec4(1.,1.,1.,1.);const vec2 k=vec2(1.,1.);void main(){float h=0.;vec2 l=k*u28,a,b;float c,d,i=0.;for(float e=-4.;e<=4.;e+=1.)for(float f=-4.;f<=4.;f+=1.)a=vec2(e,f),c=length(a)/2.,d=exp(-c*c),b=vv0+l*a,h+=d*texture2D(u1,b).r,i+=d;vec4 m=texture2D(u2,vv0);gl_FragColor=m.a*(texture2D(u1,b).r-h/i)*j;}", i: ["u1", "u2", "u28"], j: p2, C: true },
            s34: {
              h: "uniform sampler2D u3;uniform vec2 u8;varying vec2 vv0;vec4 e(vec4 a,vec4 b){vec4 c=step(a,b);return mix(a,b,c);}const vec2 g=vec2(.5,.5),h=vec2(1.,0.),i=vec2(0.,1.);void main(){vec2 a=vv0-u8*g;vec4 b=texture2D(u3,a),c=texture2D(u3,a+u8*h),d=texture2D(u3,a+u8*i),j=texture2D(u3,a+u8),k=e(b,c),l=e(d,j);gl_FragColor=e(k,l);}",
              i: ["u3", "u8"],
              j: H2
            },
            s35: { h: "uniform sampler2D u3;uniform vec2 u8;varying vec2 vv0;const vec2 k=vec2(1.,0.),l=vec2(0.,1.),m=vec2(2.,0.),n=vec2(0.,2.);vec4 e(vec4 a,vec4 b){vec4 c=step(a,b);return mix(a,b,c);}vec4 f(vec2 a){vec4 b=texture2D(u3,a),c=texture2D(u3,a+u8*k),d=texture2D(u3,a+u8*l),g=texture2D(u3,a+u8),h=e(b,c),i=e(d,g);return e(h,i);}void main(){vec2 a=vv0+u8*vec2(-.55,-1.05);vec4 b=f(a),c=f(a+u8*m),d=f(a+u8*2.),g=f(a+u8*n),h=e(b,c),i=e(d,g);gl_FragColor=e(h,i);}", i: ["u3", "u8"], j: H2, C: true },
            s36: { h: "uniform sampler2D u1;varying vec2 vv0;void main(){vec4 a=texture2D(u1,vv0);gl_FragColor=a*a;}", i: ["u1"], j: x2, precision: "lowp", C: true },
            s37: {
              h: "uniform sampler2D u1;uniform vec2 u8;varying vec2 vv0;const float e=15444.;void main(){vec4 a=1001./e*texture2D(u1,vv0-3.*u8)+2002./e*texture2D(u1,vv0-2.*u8)+3003./e*texture2D(u1,vv0-u8)+3432./e*texture2D(u1,vv0)+3003./e*texture2D(u1,vv0+u8)+2002./e*texture2D(u1,vv0+2.*u8)+1001./e*texture2D(u1,vv0+3.*u8);gl_FragColor=a;}",
              i: ["u8", "u1"],
              j: x2,
              precision: "lowp",
              C: true
            },
            s38: { h: "uniform sampler2D u1,u11,u29;varying vec2 vv0;const vec4 f=vec4(1.,1.,1.,1.);const float g=.1;void main(){vec4 a=texture2D(u11,vv0),b=texture2D(u29,vv0),c=texture2D(u1,vv0),d=max(f*g,b-a*a),h=sqrt(d);gl_FragColor=(c-a)/h;}", i: ["u1", "u11", "u29"], j: { u1: 0, u11: 1, u29: 2 }, C: true }
          }, N2 = { s39: {
            h: "uniform float u17,u30;uniform sampler2D u14,u15,u22;varying vec2 vv0;const vec2 ZERO2=vec2(0.,0.),ONE2=vec2(1.,1.),HALF2=vec2(.5,.5),EPS2=vec2(1e-5,1e-5);void main(){vec4 sum=texture2D(u22,vv0);float toSparsity=1.1111;vec2 uvFrom,uvWeight,xyPatch=ZERO2,eps2=EPS2/u17,xyTo=floor(vv0*u17+eps2);float weightSize=toSparsity*u17;vec2 halfFromSparsity=ONE2*(toSparsity-1.)/2.;for(float patch_x=0.;patch_x<1.1111;patch_x+=1.){xyPatch.x=patch_x;for(float patch_y=0.;patch_y<1.1111;patch_y+=1.)xyPatch.y=patch_y,uvFrom=(xyTo+HALF2+u30*(xyPatch-halfFromSparsity))/u17,uvFrom+=step(uvFrom,-eps2),uvFrom-=step(ONE2-eps2,uvFrom),uvWeight=(xyTo*toSparsity+xyPatch+HALF2)/weightSize,sum+=texture2D(u14,uvWeight)*texture2D(u15,uvFrom);}gl_FragColor=sum,gl_FragColor*=2.2222;}",
            i: ["u17", "u14", "u15", "u22", "u30"],
            yb: ["1.1111", "gl_FragColor\\*=2.2222;"]
          }, s40: {
            h: "uniform float u17,u30,u25;uniform sampler2D u14,u15,u22;varying vec2 vv0;const vec2 ZERO2=vec2(0.,0.),ONE2=vec2(1.,1.),HALF2=vec2(.5,.5),EPS2=vec2(1e-4,1e-4);void main(){vec4 sum=texture2D(u22,vv0);float fromSparsity=1.1111,shrinkFactor=3.3333;vec2 uvFrom,uvWeight,xyFrom,xyPatchTo,xyPatch=ZERO2,xyShrink=ZERO2,eps2=EPS2/u25,xyTo=floor(vv0*u17+eps2);float weightSize=fromSparsity*u25;vec2 halfFromSparsity=ONE2*(fromSparsity-1.)/2.;float toSparsity=weightSize/u17;vec2 xyFrom0=xyTo*shrinkFactor;for(float patch_x=0.;patch_x<1.1111;patch_x+=1.){xyPatch.x=patch_x;for(float patch_y=0.;patch_y<1.1111;patch_y+=1.){xyPatch.y=patch_y;for(float shrink_x=0.;shrink_x<3.3333;shrink_x+=1.){xyShrink.x=shrink_x;for(float shrink_y=0.;shrink_y<3.3333;shrink_y+=1.)xyShrink.y=shrink_y,xyFrom=xyFrom0+xyShrink+shrinkFactor*u30*(xyPatch-halfFromSparsity),uvFrom=(xyFrom+HALF2)/u25,uvFrom+=step(uvFrom,-eps2),uvFrom-=step(ONE2-eps2,uvFrom),xyPatchTo=xyPatch*shrinkFactor+xyShrink,uvWeight=(xyTo*toSparsity+xyPatchTo+HALF2)/weightSize,sum+=texture2D(u14,uvWeight)*texture2D(u15,uvFrom);}}}gl_FragColor=sum,gl_FragColor*=2.2222;}",
            i: "u17 u25 u14 u15 u22 u30".split(" "),
            yb: ["1.1111", "gl_FragColor\\*=2.2222;", "3.3333"]
          } }, z2 = null, J2 = null, M2 = {
            nb: function() {
              return C2;
            },
            A: function() {
              if (!C2) {
                z2 = mb.Kb(I2, 2);
                J2 = mb.Kb(N2, 2);
                E2 = "highp";
                for (var u2 in z2)
                  d2(b2, z2[u2], u2);
                A2.set("s0");
                b2.enableVertexAttribArray(0);
                C2 = true;
              }
            },
            Qc: function(u2) {
              u2.forEach(function(f2) {
                M2.Pc(f2);
              });
            },
            Pc: function(u2) {
              z2[u2.id] = u2;
              d2(b2, u2, u2.id);
            },
            sd: function(u2, f2, y2) {
              f2 || (f2 = u2);
              z2[f2] = Object.create(J2[u2]);
              z2[f2].ef = true;
              J2[u2].yb && J2[u2].yb.forEach(function(G2, L2) {
                z2[f2].h = z2[f2].h.replace(new RegExp(G2, "g"), y2[L2]);
              });
              d2(b2, z2[f2], f2);
            },
            set: function(u2) {
              var f2 = z2[u2];
              f2.C && (f2.C = false, d2(b2, f2, u2));
              e2(f2);
            },
            Ra: function(u2) {
              return m2(u2, n2(), "s41");
            },
            wc: function(u2) {
              return m2(u2, { h: "void main(){gl_FragColor=vec4(.5,.5,.5,.5);}", i: [], precision: "highp" }, "s42");
            },
            Je: function(u2) {
              return typeof z2[u2] === "undefined" ? false : z2[u2].qa;
            },
            R: function() {
              r2 !== -1 && (r2 = -1, l2.Ia.forEach(function(u2) {
                u2 !== 0 && b2.disableVertexAttribArray(u2);
              }));
            },
            yc: function() {
              var u2 = 0;
              l2.Ia.forEach(function(f2, y2) {
                y2 = l2.Ha[y2];
                b2.vertexAttribPointer(f2, y2, b2.FLOAT, false, l2.Hc, u2);
                u2 += 4 * y2;
              });
            },
            ad: function() {
              b2.enableVertexAttribArray(0);
            },
            Ba: function() {
              M2.zb(b2);
            },
            zb: function(u2) {
              u2.vertexAttribPointer(l2.Ia[0], 2, u2.FLOAT, false, 8, 0);
            },
            Xd: function(u2, f2) {
              b2.uniform1i(l2.B[u2], f2);
            },
            G: function(u2, f2) {
              b2.uniform1f(l2.B[u2], f2);
            },
            sa: function(u2, f2, y2) {
              b2.uniform2f(l2.B[u2], f2, y2);
            },
            wh: function(u2, f2) {
              b2.uniform2fv(l2.B[u2], f2);
            },
            Gf: function(u2, f2) {
              b2.uniform3fv(l2.B[u2], f2);
            },
            xh: function(u2, f2, y2, G2) {
              b2.uniform3f(l2.B[u2], f2, y2, G2);
            },
            yh: function(u2, f2, y2, G2, L2) {
              b2.uniform4f(l2.B[u2], f2, y2, G2, L2);
            },
            xc: function(u2, f2) {
              b2.uniform4fv(l2.B[u2], f2);
            },
            zh: function(u2, f2) {
              b2.uniformMatrix2fv(l2.B[u2], false, f2);
            },
            Ah: function(u2, f2) {
              b2.uniformMatrix3fv(l2.B[u2], false, f2);
            },
            Bh: function(u2, f2) {
              b2.uniformMatrix4fv(l2.B[u2], false, f2);
            },
            T: function(u2, f2) {
              M2.set(u2);
              f2.forEach(function(y2) {
                switch (y2.type) {
                  case "4f":
                    b2.uniform4fv(l2.B[y2.name], y2.value);
                    break;
                  case "3f":
                    b2.uniform3fv(l2.B[y2.name], y2.value);
                    break;
                  case "2f":
                    b2.uniform2fv(l2.B[y2.name], y2.value);
                    break;
                  case "1f":
                    b2.uniform1f(l2.B[y2.name], y2.value);
                    break;
                  case "1i":
                    b2.uniform1i(l2.B[y2.name], y2.value);
                    break;
                  case "mat2":
                    b2.uniformMatrix2fv(l2.B[y2.name], false, y2.value);
                    break;
                  case "mat3":
                    b2.uniformMatrix3fv(l2.B[y2.name], false, y2.value);
                    break;
                  case "mat4":
                    b2.uniformMatrix4fv(l2.B[y2.name], false, y2.value);
                }
              });
            },
            Pg: function() {
              return "lowp";
            },
            m: function() {
              b2.disableVertexAttribArray(0);
              M2.R();
              for (var u2 in z2) {
                var f2 = z2[u2];
                f2.qa && (f2.qa = false, b2.deleteProgram(f2.ra));
                f2.ef && delete z2[u2];
              }
              q2.forEach(function(y2) {
                b2.deleteShader(y2);
              });
              q2.splice(0);
              v2 = 0;
              C2 = false;
              l2 = null;
              r2 = -1;
            }
          };
          return M2;
        }(), b2 = null, Qa = function() {
          function a2(g2) {
            console.log("ERROR in ContextFF: ", g2);
            return false;
          }
          function c2(g2) {
            function t2() {
              Ca.m();
              aa.reset();
              k2.getExtension("WEBGL_lose_context").loseContext();
            }
            if (navigator.userAgent && navigator.userAgent.indexOf("forceWebGL1") !== -1)
              return false;
            var x2 = document.createElement("canvas");
            x2.setAttribute("width", 5);
            x2.setAttribute("height", 5);
            var k2 = null;
            try {
              k2 = x2.getContext("webgl2", g2);
            } catch (p2) {
              return false;
            }
            if (!k2)
              return false;
            d2(k2);
            aa.bd(k2);
            g2 = aa.Lb(k2);
            if (!g2.ja && !g2.ka)
              return t2(), false;
            g2 = Ca.Tc(k2, g2);
            t2();
            return g2 ? true : false;
          }
          function d2(g2) {
            g2.clearColor(0, 0, 0, 0);
            g2.disable(g2.DEPTH_TEST);
            g2.disable(g2.BLEND);
            g2.disable(g2.DITHER);
            g2.disable(g2.STENCIL_TEST);
            g2.disable(g2.CULL_FACE);
            g2.GENERATE_MIPMAP_HINT && g2.hint(g2.GENERATE_MIPMAP_HINT, g2.FASTEST);
            g2.disable(g2.SAMPLE_ALPHA_TO_COVERAGE);
            g2.disable(g2.SAMPLE_COVERAGE);
            g2.depthFunc(g2.LEQUAL);
            g2.clearDepth(1);
          }
          var e2 = null, m2 = null, n2 = null, q2 = null, r2 = true, l2 = null, v2 = null, C2 = [], E2 = { F: function() {
            return e2.width;
          }, U: function() {
            return e2.height;
          }, Gg: function() {
            return e2;
          }, Eg: function() {
            return b2;
          }, la: function() {
            return r2;
          }, flush: function() {
            b2.flush();
          }, Pe: function() {
            l2 || (l2 = new Uint8Array(e2.width * e2.height * 4));
            b2.readPixels(0, 0, e2.width, e2.height, b2.RGBA, b2.UNSIGNED_BYTE, l2);
            return l2;
          }, Ig: function() {
            return e2.toDataURL("image/jpeg");
          }, Jg: function() {
            va.P();
            m2 || (m2 = document.createElement("canvas"), n2 = m2.getContext("2d"));
            m2.width = e2.width;
            m2.height = e2.height;
            for (var g2 = E2.Pe(), t2 = n2.createImageData(m2.width, m2.height), x2 = m2.width, k2 = m2.height, p2 = t2.data, H2 = 0; H2 < k2; ++H2)
              for (var I2 = k2 - H2 - 1, N2 = 0; N2 < x2; ++N2) {
                var z2 = 4 * (H2 * x2 + N2), J2 = 4 * (I2 * x2 + N2);
                p2[z2] = g2[J2];
                p2[z2 + 1] = g2[J2 + 1];
                p2[z2 + 2] = g2[J2 + 2];
                p2[z2 + 3] = g2[J2 + 3];
              }
            n2.putImageData(t2, 0, 0);
            return m2.toDataURL("image/png");
          }, Hg: function(g2) {
            !m2 && g2 && (m2 = document.createElement("canvas"), n2 = m2.getContext("2d"));
            var t2 = g2 ? m2 : document.createElement("canvas");
            t2.width = e2.width;
            t2.height = e2.height;
            (g2 ? n2 : t2.getContext("2d")).drawImage(e2, 0, 0);
            return t2;
          }, A: function(g2) {
            g2.Ce && !g2.Jb ? e2 = document.getElementById(g2.Ce) : g2.Jb && (e2 = g2.Jb);
            e2 || (e2 = document.createElement("canvas"));
            e2.width = g2 && g2.width !== void 0 ? g2.width : 512;
            e2.height = g2 && g2.height !== void 0 ? g2.height : 512;
            typeof g2 === "undefined" && (g2 = {});
            g2.premultipliedAlpha === void 0 && (g2.premultipliedAlpha = false);
            g2.wd === void 0 && (g2.wd = true);
            g2.antialias === void 0 && (g2.antialias = false);
            if (b2)
              r2 = b2 instanceof WebGL2RenderingContext;
            else {
              r2 = true;
              var t2 = {
                antialias: g2.antialias,
                alpha: true,
                preserveDrawingBuffer: true,
                premultipliedAlpha: g2.premultipliedAlpha,
                stencil: false,
                depth: g2.wd
              };
              navigator && navigator.userAgent && navigator.userAgent.indexOf("noAntialiasing") !== -1 && (t2.antialias = false);
              var x2 = c2(t2);
              !x2 && t2.antialias && (t2.antialias = false, x2 = c2(t2));
              x2 && (b2 = e2.getContext("webgl2", t2));
              b2 ? r2 = true : ((b2 = e2.getContext("webgl", t2)) || (b2 = e2.getContext("experimental-webgl", t2)), r2 = false);
            }
            if (!b2)
              return a2("WebGL1 and 2 are not enabled");
            (q2 = b2.getExtension("WEBGL_lose_context")) && g2.Ld && (v2 = g2.Ld, e2.addEventListener("webglcontextlost", v2, false));
            if (!aa.A())
              return a2("Not enough GL capabilities");
            d2(b2);
            A2.A();
            U2.A();
            if (!Ca.Tc(b2, aa.Oe()))
              return a2("Cannot filter float textures");
            C2.forEach(function(k2) {
              k2(b2);
            });
            C2.splice(0);
            return true;
          }, $f: function() {
            return new Promise(function(g2) {
              b2 ? g2(b2) : C2.push(g2);
            });
          }, m: function() {
            b2 && (aa.m(), A2.m(), Ca.m());
            q2 && v2 && (e2.removeEventListener("webglcontextlost", v2, false), q2 = v2 = null);
            b2 = l2 = n2 = m2 = e2 = null;
            C2.splice(0);
          } };
          return E2;
        }(), xa = function() {
          function a2() {
            c2 === null && (typeof A2 !== "undefined" ? c2 = A2 : typeof JEShaders !== "undefined" && (c2 = JEShaders));
          }
          var c2 = null;
          a2();
          return { reset: function() {
            c2 = null;
          }, Ff: function(d2) {
            c2 !== d2 && (c2 && c2.R(), c2 = d2);
          }, nb: function() {
            return c2.nb();
          }, Ba: function() {
            return c2.Ba();
          }, zb: function(d2) {
            return c2.zb(d2);
          }, yc: function() {
            return c2.yc();
          }, R: function() {
            return c2.R();
          }, set: function(d2) {
            return c2.set(d2);
          }, Ra: function(d2) {
            a2();
            return c2.Ra(d2);
          }, wc: function(d2) {
            a2();
            return c2.wc(d2);
          } };
        }(), Ba = function() {
          function a2(h2) {
            b2.bindTexture(b2.TEXTURE_2D, h2);
          }
          function c2(h2) {
            f2[0] = h2;
            h2 = y2[0];
            var F2 = h2 >> 16 & 32768, K2 = h2 >> 12 & 2047, P2 = h2 >> 23 & 255;
            return 103 > P2 ? F2 : 142 < P2 ? F2 | 31744 | ((P2 == 255 ? 0 : 1) && h2 & 8388607) : 113 > P2 ? (K2 |= 2048, F2 | (K2 >> 114 - P2) + (K2 >> 113 - P2 & 1)) : F2 = (F2 | P2 - 112 << 10 | K2 >> 1) + (K2 & 1);
          }
          function d2(h2) {
            var F2 = new Uint16Array(h2.length);
            h2.forEach(function(K2, P2) {
              F2[P2] = c2(K2);
            });
            return F2;
          }
          function e2() {
            if (G2.$b !== null)
              return G2.$b;
            var h2 = n2(d2([0.5, 0.5, 0.5, 0.5]));
            return h2 === null ? true : G2.$b = h2;
          }
          function m2() {
            if (G2.ac !== null)
              return G2.ac;
            var h2 = n2(new Uint8Array([127, 127, 127, 127]));
            return h2 === null ? true : G2.ac = h2;
          }
          function n2(h2) {
            if (!xa.nb() || !k2)
              return null;
            var F2 = null, K2 = Math.sqrt(h2.length / 4);
            try {
              var P2 = b2.getError();
              if (P2 === "FUCKING_BIG_ERROR")
                return false;
              F2 = L2.instance({ isFloat: false, S: true, array: h2, width: K2 });
              P2 = b2.getError();
              if (P2 !== b2.NO_ERROR)
                return false;
            } catch (ra) {
              return false;
            }
            la.P();
            b2.viewport(0, 0, K2, K2);
            b2.clearColor(0, 0, 0, 0);
            b2.clear(b2.COLOR_BUFFER_BIT);
            xa.set("s0");
            F2.Rc(0);
            ma.l(true, true);
            h2 = 4 * K2 * K2;
            P2 = new Uint8Array(h2);
            b2.readPixels(0, 0, K2, K2, b2.RGBA, b2.UNSIGNED_BYTE, P2);
            K2 = true;
            for (var da = 0; da < h2; ++da)
              K2 = K2 && 3 > Math.abs(P2[da] - 127);
            F2.remove();
            la.ha();
            return K2;
          }
          var q2 = 0, r2 = null, l2 = 0, v2 = null, C2 = null, E2 = null, g2 = null, t2 = null, x2 = null, k2 = false, p2 = [], H2 = {
            isFloat: false,
            isPot: true,
            isLinear: false,
            isMipmap: false,
            isAnisotropicFiltering: false,
            isMirrorX: false,
            isMirrorY: false,
            isSrgb: false,
            isKeepArray: false,
            isFlipY: null,
            width: 0,
            height: 0,
            url: null,
            array: null,
            data: null,
            I: null,
            Zb: null,
            df: false,
            S: false,
            oa: null,
            sb: 4,
            ic: 0
          }, I2 = false, N2 = null, z2 = null, J2 = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]], M2 = false, u2 = false, f2 = new Float32Array(1), y2 = new Int32Array(f2.buffer), G2 = { $b: null, ac: null }, L2 = { A: function() {
            k2 || (t2 = [b2.RGBA, null, b2.RGBA, b2.RGBA], x2 = [b2.RGBA, null, b2.RGBA, b2.RGBA], r2 = [b2.TEXTURE0, b2.TEXTURE1, b2.TEXTURE2, b2.TEXTURE3, b2.TEXTURE4, b2.TEXTURE5, b2.TEXTURE6, b2.TEXTURE7], M2 = typeof JEContext !== "undefined", u2 = typeof aa !== "undefined", M2 && JEContext.gh() && r2.push(b2.TEXTURE8, b2.TEXTURE9), v2 = [-1, -1, -1, -1, -1, -1, -1, -1], g2 = [b2.UNSIGNED_BYTE, b2.FLOAT, b2.FLOAT], k2 = true);
          }, af: function() {
            if (!C2) {
              for (var h2 = new Float32Array(16384), F2 = 0; 16384 > F2; ++F2)
                h2[F2] = 2 * Math.random() - 1;
              C2 = { random: L2.instance({ isFloat: true, isPot: true, array: h2, width: 64 }), de: L2.instance({ isFloat: false, isPot: true, width: 1, array: new Uint8Array([0, 0, 0, 0]) }) };
            }
            L2.Sf();
          }, Xg: function() {
            return C2.de;
          }, Sf: function() {
            g2[1] = aa.Vb(b2);
          }, Df: function() {
            x2 = t2 = [b2.RGBA, b2.RGBA, b2.RGBA, b2.RGBA];
          }, Sd: function(h2) {
            A2.set("s1");
            la.P();
            var F2 = h2.F(), K2 = h2.U();
            b2.viewport(0, 0, F2, K2);
            h2.g(0);
            ma.l(false, false);
          }, mh: function(h2, F2) {
            L2.Sd(h2);
            b2.readPixels(0, 0, h2.F(), h2.U(), b2.RGBA, b2.UNSIGNED_BYTE, F2);
          }, nh: function(h2, F2) {
            L2.Sd(h2);
            return aa.xb(0, 0, h2.F(), h2.U(), F2);
          }, kd: function(h2, F2, K2, P2, da, ra, za) {
            h2.activeTexture(h2.TEXTURE0);
            var w2 = h2.createTexture();
            h2.bindTexture(h2.TEXTURE_2D, w2);
            da = da instanceof Float32Array ? da : new Float32Array(da);
            h2.texParameteri(h2.TEXTURE_2D, h2.TEXTURE_WRAP_S, h2.CLAMP_TO_EDGE);
            h2.texParameteri(h2.TEXTURE_2D, h2.TEXTURE_WRAP_T, h2.CLAMP_TO_EDGE);
            h2.texParameteri(h2.TEXTURE_2D, h2.TEXTURE_MAG_FILTER, h2.NEAREST);
            h2.texParameteri(h2.TEXTURE_2D, h2.TEXTURE_MIN_FILTER, h2.NEAREST);
            h2.pixelStorei(h2.UNPACK_FLIP_Y_WEBGL, ra);
            h2.texImage2D(h2.TEXTURE_2D, 0, h2.RGBA, K2, P2, 0, h2.RGBA, h2.FLOAT, da);
            h2.bindTexture(h2.TEXTURE_2D, null);
            h2.pixelStorei(h2.UNPACK_FLIP_Y_WEBGL, false);
            za && (la.ha(), A2.Ra(h2));
            h2.viewport(0, 0, K2, P2);
            h2.framebufferTexture2D(h2.FRAMEBUFFER, h2.COLOR_ATTACHMENT0, h2.TEXTURE_2D, F2, 0);
            h2.bindTexture(h2.TEXTURE_2D, w2);
            za ? ma.l(true, true) : U2.ab(h2);
            h2.deleteTexture(w2);
            k2 && (v2[0] = -1, E2 = null, q2 = 0);
          }, Fb: function(h2) {
            h2 !== q2 && (b2.activeTexture(r2[h2]), q2 = h2);
          }, instance: function(h2) {
            function F2() {
              R2 = w2.I.videoWidth !== void 0 ? w2.I.videoWidth : w2.I.width;
              T2 = w2.I.videoHeight !== void 0 ? w2.I.videoHeight : w2.I.height;
            }
            function K2(D2) {
              var S2 = b2.getError();
              if (S2 === "FUCKING_BIG_ERROR")
                return false;
              b2.texImage2D(b2.TEXTURE_2D, 0, ja, fa, ha, D2);
              S2 = b2.getError();
              S2 !== b2.NO_ERROR && fa !== b2.RGBA && (fa = b2.RGBA, b2.texImage2D(b2.TEXTURE_2D, 0, ja, fa, ha, D2));
              return true;
            }
            function P2() {
              if (!Ab) {
                a2(ta);
                Aa && b2.pixelStorei(b2.UNPACK_FLIP_Y_WEBGL, Aa);
                w2.isPot ? (b2.texParameteri(b2.TEXTURE_2D, b2.TEXTURE_WRAP_S, w2.isMirrorX ? b2.MIRRORED_REPEAT : b2.REPEAT), b2.texParameteri(b2.TEXTURE_2D, b2.TEXTURE_WRAP_T, w2.isMirrorY ? b2.MIRRORED_REPEAT : b2.REPEAT)) : (b2.texParameteri(b2.TEXTURE_2D, b2.TEXTURE_WRAP_S, b2.CLAMP_TO_EDGE), b2.texParameteri(b2.TEXTURE_2D, b2.TEXTURE_WRAP_T, b2.CLAMP_TO_EDGE));
                w2.isAnisotropicFiltering && typeof JESETTINGS !== "undefined" && b2.texParameterf(b2.TEXTURE_2D, JEContext.Kg().TEXTURE_MAX_ANISOTROPY_EXT, JESETTINGS.Wf);
                b2.texParameteri(b2.TEXTURE_2D, b2.TEXTURE_MAG_FILTER, w2.isLinear ? b2.LINEAR : b2.NEAREST);
                w2.isLinear ? b2.texParameteri(b2.TEXTURE_2D, b2.TEXTURE_MIN_FILTER, w2.isMipmap && !Ka ? b2.NEAREST_MIPMAP_LINEAR : b2.LINEAR) : b2.texParameteri(b2.TEXTURE_2D, b2.TEXTURE_MIN_FILTER, w2.isMipmap && !Ka ? b2.NEAREST_MIPMAP_NEAREST : b2.NEAREST);
                fa = t2[w2.sb - 1];
                ja = x2[w2.sb - 1];
                ha = g2[nb];
                if (aa.la()) {
                  var D2 = aa.Re();
                  fa === b2.RGBA && ha === b2.FLOAT ? w2.isMipmap || w2.isLinear ? ja = Ca.Te(b2) : aa.Uc() ? D2 && (ja = D2) : ja = b2.RGBA16F || b2.RGBA : fa === b2.RGB && ha === b2.FLOAT && D2 && (ja = D2, fa = b2.RGBA);
                }
                if (w2.S && !w2.isFloat || w2.isFloat && w2.isMipmap && Ca.hf())
                  ja = aa.Se(), ha = aa.Vb(b2);
                w2.ic && (ab = w2.ic);
                w2.isSrgb && w2.sb === 4 && (fa = JEContext.Vg());
                if (w2.I)
                  K2(w2.I);
                else if (w2.url)
                  K2(Ga);
                else if (ua) {
                  D2 = ua;
                  try {
                    b2.getError() !== "FUCKING_BIG_ERROR" && (b2.texImage2D(b2.TEXTURE_2D, 0, ja, R2, T2, 0, fa, ha, D2), b2.getError() !== b2.NO_ERROR && (b2.texImage2D(b2.TEXTURE_2D, 0, ja, R2, T2, 0, fa, ha, null), b2.getError() !== b2.NO_ERROR && b2.texImage2D(b2.TEXTURE_2D, 0, b2.RGBA, R2, T2, 0, b2.RGBA, b2.UNSIGNED_BYTE, null)));
                  } catch (hc) {
                    b2.texImage2D(b2.TEXTURE_2D, 0, ja, R2, T2, 0, fa, ha, null);
                  }
                  w2.isKeepArray || (ua = null);
                } else
                  D2 = b2.getError(), D2 !== "FUCKING_BIG_ERROR" && (b2.texImage2D(b2.TEXTURE_2D, 0, ja, R2, T2, 0, fa, ha, null), D2 = b2.getError(), D2 !== b2.NO_ERROR && (fa = b2.RGBA, w2.S && ha !== b2.FLOAT && (ha = b2.FLOAT, b2.texImage2D(b2.TEXTURE_2D, 0, ja, R2, T2, 0, fa, ha, null))));
                if (w2.isMipmap) {
                  if (!Ka && ca)
                    ca.Ub(), bb = true;
                  else if (Ka) {
                    D2 = Math.log2(Math.min(R2, T2));
                    Ra = Array(1 + D2);
                    Ra[0] = ta;
                    for (var S2 = 1; S2 <= D2; ++S2) {
                      var ka = Math.pow(2, S2), V2 = R2 / ka;
                      ka = T2 / ka;
                      var La = b2.createTexture();
                      a2(La);
                      b2.texParameteri(b2.TEXTURE_2D, b2.TEXTURE_MIN_FILTER, b2.NEAREST);
                      b2.texParameteri(b2.TEXTURE_2D, b2.TEXTURE_MAG_FILTER, b2.NEAREST);
                      b2.texImage2D(b2.TEXTURE_2D, 0, ja, V2, ka, 0, fa, ha, null);
                      a2(null);
                      Ra[S2] = La;
                    }
                    bb = true;
                  }
                }
                a2(null);
                v2[q2] = -1;
                Aa && b2.pixelStorei(b2.UNPACK_FLIP_Y_WEBGL, false);
                Ta = true;
                w2.oa && ca && (w2.oa(ca), w2.oa = null);
              }
            }
            function da() {
              for (var D2 = R2 * T2, S2 = 2 * D2, ka = 3 * D2, V2 = 0; V2 < D2; ++V2)
                ya[0][V2] = Ua[V2], ya[1][V2] = Ua[V2 + D2], ya[2][V2] = Ua[V2 + S2], ya[3][V2] = Ua[V2 + ka];
            }
            function ra() {
              var D2 = R2 * T2 * 4;
              Da = [new Uint8Array(D2), new Uint8Array(D2), new Uint8Array(D2), new Uint8Array(D2)];
              ya = [new Float32Array(Da[0].buffer), new Float32Array(Da[1].buffer), new Float32Array(Da[2].buffer), new Float32Array(Da[3].buffer)];
              cb = new Uint8Array(4 * D2);
              Ua = new Float32Array(cb.buffer);
              Va = true;
            }
            function za() {
              Ea.Gb = new Uint8Array(R2 * T2 * 4);
              Ea.ld = new Float32Array(Ea.buffer);
              Ea.Y = true;
            }
            var w2 = Object.assign({}, H2, h2), Wa = l2++;
            w2.isFlipY === null && (w2.isFlipY = w2.url || w2.array ? true : false);
            w2.data && (w2.array = typeof w2.data === "string" ? Ib(w2.data) : w2.isFloat ? new Float32Array(w2.data) : new Uint8Array(w2.data), w2.isFlipY = false);
            var nb = 0, Bb = w2.I ? true : false, Xa = null, ob = null, Cb = false, pb = null;
            w2.S = w2.S || w2.isFloat;
            w2.S && (nb = 1);
            !w2.df && w2.isFloat && u2 && !aa.Uc() && (w2.isFloat = false);
            w2.isFloat && (nb = 2);
            w2.isAnisotropicFiltering && M2 && !JEContext.$g() && (w2.isAnisotropicFiltering = false);
            var ta = w2.Zb || b2.createTexture(), Ga = null, ua = false, R2 = 0, T2 = 0, Ta = false, Ab = false, Va = false, ya = null, Da = null, cb = null, Ua = null, ja = null, fa = null, ha = null, Aa = w2.isFlipY, Wb = (h2 = w2.S && w2.isMipmap) && Ca.te(), Ka = h2 && Wb ? true : false, Ra = null, ab = -1, bb = false, Ea = { Y: false, Gb: null, ld: null };
            w2.width && (R2 = w2.width, T2 = w2.height ? w2.height : R2);
            var ca = { get: function() {
              return ta;
            }, F: function() {
              return R2;
            }, U: function() {
              return T2;
            }, Yg: function() {
              return w2.url;
            }, ah: function() {
              return w2.isFloat;
            }, dh: function() {
              return w2.S;
            }, eh: function() {
              return w2.isLinear;
            }, Ub: function() {
              b2.generateMipmap(b2.TEXTURE_2D);
            }, re: function(D2, S2) {
              Ka ? (D2 || (D2 = ca.pd()), L2.Fb(S2), a2(Ra[D2]), v2[S2] = -1) : ca.g(S2);
            }, pd: function() {
              ab === -1 && (ab = Math.log(R2) / Math.log(2));
              return ab;
            }, Le: function(D2) {
              if (Ka) {
                D2 || (D2 = ca.pd());
                A2.set("s12");
                L2.Fb(0);
                for (var S2 = R2, ka = T2, V2 = 1; V2 <= D2; ++V2)
                  S2 /= 2, ka /= 2, A2.sa("u8", 0.25 / S2, 0.25 / ka), b2.viewport(0, 0, S2, ka), a2(Ra[V2 - 1]), b2.framebufferTexture2D(la.eb(), b2.COLOR_ATTACHMENT0, b2.TEXTURE_2D, Ra[V2], 0), ma.l(false, V2 === 1);
                v2[0] = -1;
              } else
                ca.Ub();
            }, vh: function(D2) {
              (Bb = !Ub.Mf(D2)) ? (ua = null, w2.I = D2, F2()) : ua = D2;
            }, g: function(D2) {
              if (!Ta)
                return false;
              L2.Fb(D2);
              if (v2[D2] === Wa)
                return false;
              a2(ta);
              v2[D2] = Wa;
              return true;
            }, Rc: function(D2) {
              b2.activeTexture(r2[D2]);
              q2 = D2;
              a2(ta);
              v2[D2] = Wa;
            }, u: function() {
              E2 = ca;
              b2.framebufferTexture2D(la.eb(), b2.COLOR_ATTACHMENT0, b2.TEXTURE_2D, ta, 0);
            }, da: function() {
              E2 = ca;
              b2.viewport(0, 0, R2, T2);
              b2.framebufferTexture2D(la.eb(), b2.COLOR_ATTACHMENT0, b2.TEXTURE_2D, ta, 0);
            }, Fc: L2.Fc, resize: function(D2, S2) {
              R2 = D2;
              T2 = S2;
              P2();
            }, clone: function(D2) {
              D2 = L2.instance({ width: R2, height: T2, S: w2.S, isFloat: w2.isFloat, isLinear: w2.isLinear, isMirrorY: w2.isMirrorY, isFlipY: D2 ? !Aa : Aa, isPot: w2.isPot });
              xa.set("s0");
              la.ha();
              D2.u();
              b2.viewport(0, 0, R2, T2);
              ca.g(0);
              ma.l(true, true);
              return D2;
            }, Hf: function() {
              b2.viewport(0, 0, R2, T2);
            }, remove: function() {
              b2.deleteTexture(ta);
              Ab = true;
              p2.splice(p2.indexOf(ca), 1);
              ca = null;
            }, refresh: function() {
              ca.Rc(0);
              Aa && b2.pixelStorei(b2.UNPACK_FLIP_Y_WEBGL, true);
              Bb ? b2.texImage2D(b2.TEXTURE_2D, 0, ja, fa, ha, w2.I) : b2.texImage2D(b2.TEXTURE_2D, 0, ja, R2, T2, 0, fa, ha, ua);
              Aa && b2.pixelStorei(b2.UNPACK_FLIP_Y_WEBGL, false);
            }, Rd: function() {
              Va || ra();
              b2.readPixels(0, 0, R2, 4 * T2, b2.RGBA, b2.UNSIGNED_BYTE, cb);
              da();
              return ya;
            }, xf: function() {
              Va || ra();
              return aa.xb(0, 0, R2, 4 * T2, cb).then(function() {
                da();
                return ya;
              });
            }, zf: function() {
              Ea.Y || za();
              b2.readPixels(0, 0, R2, T2, b2.RGBA, b2.UNSIGNED_BYTE, Ea.Gb);
              return Ea.ld;
            }, yf: function() {
              Ea.Y || za();
              return aa.xb(0, 0, R2, T2, Ea.Gb);
            }, Zc: function(D2) {
              la.P();
              A2.set("s13");
              ca.g(0);
              if (D2)
                b2.viewport(0, 0, R2, T2), A2.xc("u9", 0.25, 0.25, 0.25, 0.25), ma.l(false, true);
              else
                for (D2 = 0; 4 > D2; ++D2)
                  b2.viewport(0, T2 * D2, R2, T2), A2.xc("u9", J2[D2]), ma.l(false, D2 === 0);
            }, Rf: function(D2) {
              var S2 = ha === g2[0] && !m2();
              a2(ta);
              Aa && b2.pixelStorei(b2.UNPACK_FLIP_Y_WEBGL, true);
              S2 ? (Cb || (Xa = document.createElement("canvas"), Xa.width = R2, Xa.height = T2, ob = Xa.getContext("2d"), pb = ob.createImageData(R2, T2), Cb = true), pb.data.set(D2), ob.putImageData(pb, 0, 0), b2.texImage2D(b2.TEXTURE_2D, 0, ja, fa, ha, Xa)) : b2.texImage2D(b2.TEXTURE_2D, 0, ja, R2, T2, 0, fa, ha, D2);
              v2[q2] = Wa;
              Aa && b2.pixelStorei(b2.UNPACK_FLIP_Y_WEBGL, false);
            }, Gh: function(D2, S2) {
              a2(ta);
              S2 && b2.pixelStorei(b2.UNPACK_FLIP_Y_WEBGL, true);
              b2.texImage2D(b2.TEXTURE_2D, 0, ja, fa, ha, D2);
              v2[q2] = Wa;
              S2 && b2.pixelStorei(b2.UNPACK_FLIP_Y_WEBGL, false);
            }, th: function(D2, S2) {
              var ka = R2 * T2, V2 = 4 * ka;
              D2 = w2.S ? D2 ? "RGBE" : "JSON" : "RGBA";
              S2 && (D2 = S2);
              S2 = aa.la() && false;
              var La = null;
              switch (D2) {
                case "RGBE":
                  La = "s43";
                  break;
                case "JSON":
                  La = S2 ? "s0" : "s13";
                  break;
                case "RGBA":
                case "RGBAARRAY":
                  La = "s7";
              }
              Va || (D2 === "RGBA" || D2 === "RGBE" || D2 === "RGBAARRAY" ? (Da = new Uint8Array(V2), Va = true) : D2 !== "JSON" || S2 || ra());
              la.P();
              A2.set(La);
              ca.g(0);
              V2 = null;
              if (D2 === "RGBA" || D2 === "RGBE" || D2 === "RGBAARRAY") {
                b2.viewport(0, 0, R2, T2);
                ma.l(true, true);
                b2.readPixels(0, 0, R2, T2, b2.RGBA, b2.UNSIGNED_BYTE, Da);
                if (D2 === "RGBAARRAY")
                  return { data: Da };
                I2 || (N2 = document.createElement("canvas"), z2 = N2.getContext("2d"), I2 = true);
                N2.width = R2;
                N2.height = T2;
                ka = z2.createImageData(R2, T2);
                ka.data.set(Da);
                z2.putImageData(ka, 0, 0);
                V2 = N2.toDataURL("image/png");
              } else if (D2 === "JSON")
                if (S2)
                  V2 = new Float32Array(ka), b2.viewport(0, 0, R2, T2), ma.l(true, true), b2.readPixels(0, 0, R2, T2, b2.RGBA, b2.FLOAT, V2);
                else {
                  for (V2 = 0; 4 > V2; ++V2)
                    b2.viewport(0, T2 * V2, R2, T2), A2.xc("u9", J2[V2]), ma.l(!V2, !V2);
                  ca.Rd();
                  V2 = Array(ka);
                  for (S2 = 0; S2 < ka; ++S2)
                    V2[4 * S2] = ya[0][S2], V2[4 * S2 + 1] = ya[1][S2], V2[4 * S2 + 2] = ya[2][S2], V2[4 * S2 + 3] = ya[3][S2];
                }
              return { format: D2, data: V2, width: R2, height: T2, isMirrorY: w2.isMirrorY, isFlipY: D2 === "RGBA" ? w2.isFlipY : !w2.isFlipY };
            } };
            w2.isMipmap && !Ka && Ta && !bb && (ca.Ub(), bb = true);
            if (w2.url)
              a2(ta), b2.texImage2D(b2.TEXTURE_2D, 0, b2.RGBA, 1, 1, 0, b2.RGBA, b2.UNSIGNED_BYTE, null), Ga = new Image(), Ga.jg = "Anonymous", Ga.crossOrigin = "Anonymous", Ga.src = w2.url, Ga.onload = function() {
                R2 = Ga.width;
                T2 = Ga.height;
                P2();
              };
            else if (w2.I) {
              var Db = function() {
                F2();
                R2 ? P2() : setTimeout(Db, 1);
              };
              Db();
            } else
              w2.array ? (w2.S && !w2.isFloat ? w2.array instanceof Uint16Array ? (ua = w2.array, P2()) : e2() ? (ua = d2(w2.array), P2()) : (P2(), L2.kd(b2, ta, ca.F(), ca.U(), w2.array, Aa, true)) : (ua = w2.isFloat ? w2.array instanceof Float32Array ? w2.array : new Float32Array(w2.array) : w2.array instanceof Uint8Array ? w2.array : new Uint8Array(w2.array), P2()), w2.isKeepArray || (ua && ua !== w2.array && (ua = null), delete w2.array)) : w2.Zb ? Ta = true : P2();
            ca.Ug = ca.F;
            w2.oa && Ta && (w2.oa(ca), w2.oa = null);
            p2.push(ca);
            return ca;
          }, P: function(h2) {
            h2 !== q2 && (b2.activeTexture(r2[h2]), q2 = h2);
            v2[h2] = -1;
            a2(null);
          }, Zf: function(h2) {
            C2.random.g(h2);
          }, Fc: function() {
            E2 = null;
            b2.framebufferTexture2D(la.eb(), b2.COLOR_ATTACHMENT0, b2.TEXTURE_2D, null, 0);
          }, reset: function() {
            q2 !== 0 && b2.activeTexture(r2[0]);
            for (var h2 = 0; h2 < r2.length; ++h2)
              v2[h2] = -1;
            q2 = -1;
          }, qh: function() {
            q2 = -1;
          }, Of: function() {
            for (var h2 = 0; h2 < r2.length; ++h2)
              L2.P(h2);
          }, md: function() {
            C2 && (C2.random.remove(), C2.de.remove());
          }, Fh: function(h2, F2) {
            if (h2.format === "RGBA" || h2.format === "RGBE") {
              var K2 = new Image();
              K2.src = h2.data;
              K2.onload = function() {
                L2.instance({ isMirrorY: h2.isMirrorY, isFlipY: h2.isFlipY, isFloat: false, I: K2, oa: function(P2) {
                  if (h2.format === "RGBA")
                    F2(P2);
                  else {
                    var da = h2.width, ra = h2.height, za = L2.instance({ isMirrorY: h2.isMirrorY, isFloat: true, width: da, height: ra, isFlipY: h2.isFlipY });
                    la.ha();
                    b2.viewport(0, 0, da, ra);
                    A2.set("s44");
                    za.u();
                    P2.g(0);
                    ma.l(true, true);
                    L2.P(0);
                    F2(za);
                    b2.flush();
                    setTimeout(P2.remove, 50);
                  }
                } });
              };
            } else
              h2.format === "JSON" ? F2(L2.instance({ isFloat: true, isFlipY: h2.isFlipY, width: h2.width, height: h2.height, array: new Float32Array(h2.data) })) : F2(false);
          }, ze: d2, m: function() {
            E2 && (va.ha(), L2.Fc(), va.P());
            L2.Of();
            p2.slice(0).forEach(function(h2) {
              h2.remove();
            });
            p2.splice(0);
            k2 = false;
            l2 = 0;
            typeof Ca !== "undefined" && Ca.m();
            C2 = null;
          } };
          return L2;
        }(), Ob = function() {
          return { instance: function(a2) {
            var c2 = [Ba.instance(a2), Ba.instance(a2)], d2 = [c2[1], c2[0]], e2 = d2, m2 = { Bf: function(n2) {
              e2[1].u();
              e2[0].g(n2);
              m2.Zd();
            }, uh: function(n2) {
              e2[1].da();
              e2[0].g(n2);
              m2.Zd();
            }, Zd: function() {
              e2 = e2 === c2 ? d2 : c2;
            }, refresh: function() {
              e2[0].refresh();
              e2[1].refresh();
            }, g: function(n2) {
              e2[0].g(n2);
            }, Yf: function(n2) {
              e2[1].g(n2);
            }, Og: function() {
              return e2[0];
            }, Sg: function() {
              return e2[1];
            }, remove: function() {
              e2[0].remove();
              e2[1].remove();
              e2 = null;
            } };
            return m2;
          } };
        }(), ma = function() {
          function a2(l2) {
            var v2 = { ea: null, K: null };
            v2.ea = l2.createBuffer();
            l2.bindBuffer(l2.ARRAY_BUFFER, v2.ea);
            l2.bufferData(l2.ARRAY_BUFFER, new Float32Array([-1, -1, 3, -1, -1, 3]), l2.STATIC_DRAW);
            v2.K = l2.createBuffer();
            l2.bindBuffer(l2.ELEMENT_ARRAY_BUFFER, v2.K);
            l2.bufferData(l2.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2]), l2.STATIC_DRAW);
            return v2;
          }
          var c2 = null, d2 = 0, e2 = false, m2 = [], n2 = -2, q2 = -2, r2 = { reset: function() {
            q2 = n2 = -2;
          }, A: function() {
            e2 || (c2 = a2(b2), r2.Ja(), e2 = true);
          }, instance: function(l2) {
            var v2 = d2++, C2 = l2.K ? l2.K.length : 0, E2 = typeof l2.mode === "undefined" ? b2.STATIC_DRAW : l2.mode, g2 = b2.createBuffer();
            b2.bindBuffer(b2.ARRAY_BUFFER, g2);
            b2.bufferData(b2.ARRAY_BUFFER, l2.ea instanceof Float32Array ? l2.ea : new Float32Array(l2.ea), E2);
            n2 = v2;
            var t2 = null, x2 = null, k2 = null;
            if (l2.K) {
              t2 = b2.createBuffer();
              b2.bindBuffer(b2.ELEMENT_ARRAY_BUFFER, t2);
              var p2 = null;
              65536 > l2.K.length ? (p2 = Uint16Array, x2 = b2.UNSIGNED_SHORT, k2 = 2) : (p2 = Uint32Array, x2 = b2.UNSIGNED_INT, k2 = 4);
              p2 = l2.K instanceof p2 ? l2.K : new p2(l2.K);
              b2.bufferData(b2.ELEMENT_ARRAY_BUFFER, p2, E2);
              q2 = v2;
            }
            var H2 = { se: function(I2) {
              n2 !== v2 && (b2.bindBuffer(b2.ARRAY_BUFFER, g2), n2 = v2);
              I2 && xa.yc();
            }, pe: function() {
              q2 !== v2 && (b2.bindBuffer(b2.ELEMENT_ARRAY_BUFFER, t2), q2 = v2);
            }, bind: function(I2) {
              H2.se(I2);
              H2.pe();
            }, lg: function() {
              b2.drawElements(b2.TRIANGLES, C2, x2, 0);
            }, mg: function(I2, N2) {
              b2.drawElements(b2.TRIANGLES, I2, x2, N2 * k2);
            }, remove: function() {
              b2.deleteBuffer(g2);
              l2.K && b2.deleteBuffer(t2);
              H2 = null;
            } };
            m2.push(H2);
            return H2;
          }, Ja: function() {
            n2 !== -1 && (b2.bindBuffer(b2.ARRAY_BUFFER, c2.ea), n2 = -1);
            q2 !== -1 && (b2.bindBuffer(b2.ELEMENT_ARRAY_BUFFER, c2.K), q2 = -1);
          }, l: function(l2, v2) {
            l2 && ma.Ja();
            v2 && xa.Ba();
            b2.drawElements(b2.TRIANGLES, 3, b2.UNSIGNED_SHORT, 0);
          }, ab: function(l2) {
            l2 = l2 || b2;
            var v2 = a2(l2);
            l2.bindBuffer(l2.ARRAY_BUFFER, v2.ea);
            l2.bindBuffer(l2.ELEMENT_ARRAY_BUFFER, v2.K);
            xa.zb(l2);
            l2.clear(l2.COLOR_BUFFER_BIT);
            l2.drawElements(l2.TRIANGLES, 3, l2.UNSIGNED_SHORT, 0);
            l2.flush();
            l2.bindBuffer(l2.ARRAY_BUFFER, null);
            l2.bindBuffer(l2.ELEMENT_ARRAY_BUFFER, null);
            l2.deleteBuffer(v2.ea);
            l2.deleteBuffer(v2.K);
            r2.reset();
            e2 && (r2.Ja(), xa.Ba());
          }, md: function() {
            var l2 = b2, v2 = c2;
            l2.deleteBuffer(v2.ea);
            l2.deleteBuffer(v2.K);
          }, m: function() {
            r2.md();
            m2.forEach(function(l2) {
              l2.remove();
            });
            b2.bindBuffer(b2.ARRAY_BUFFER, null);
            b2.bindBuffer(b2.ELEMENT_ARRAY_BUFFER, null);
            r2.reset();
            e2 = false;
            m2.splice(0);
            d2 = 0;
          } };
          return r2;
        }(), la = function() {
          var a2 = null, c2 = null, d2 = null, e2 = false, m2 = [], n2 = { J: -2, jd: 1 }, q2 = { nb: function() {
            return e2;
          }, A: function() {
            if (!e2) {
              a2 = b2.createFramebuffer();
              var r2 = aa.la();
              c2 = r2 && b2.DRAW_FRAMEBUFFER ? b2.DRAW_FRAMEBUFFER : b2.FRAMEBUFFER;
              d2 = r2 && b2.READ_FRAMEBUFFER ? b2.READ_FRAMEBUFFER : b2.FRAMEBUFFER;
              e2 = true;
            }
          }, Lg: function() {
            return c2;
          }, Ue: function() {
            return d2;
          }, eb: function() {
            return b2.FRAMEBUFFER;
          }, Tg: function() {
            return n2;
          }, Dg: function() {
            return a2;
          }, instance: function(r2) {
            r2.vd === void 0 && (r2.vd = false);
            var l2 = r2.N ? r2.N : null, v2 = r2.width, C2 = r2.height !== void 0 ? r2.height : r2.width, E2 = a2, g2 = null, t2 = false, x2 = false, k2 = 0;
            l2 && (v2 = v2 ? v2 : l2.F(), C2 = C2 ? C2 : l2.U());
            var p2 = { Wd: function() {
              t2 || (E2 = b2.createFramebuffer(), t2 = true, k2 = n2.jd++);
            }, je: function() {
              p2.Wd();
              p2.u();
              g2 = b2.createRenderbuffer();
              b2.bindRenderbuffer(b2.RENDERBUFFER, g2);
              b2.renderbufferStorage(b2.RENDERBUFFER, b2.DEPTH_COMPONENT16, v2, C2);
              b2.framebufferRenderbuffer(c2, b2.DEPTH_ATTACHMENT, b2.RENDERBUFFER, g2);
              b2.clearDepth(1);
            }, bind: function(H2, I2) {
              k2 !== n2.J && (b2.bindFramebuffer(c2, E2), n2.J = k2);
              l2 && l2.u();
              I2 && b2.viewport(0, 0, v2, C2);
              H2 && b2.clear(b2.COLOR_BUFFER_BIT | b2.DEPTH_BUFFER_BIT);
            }, Xf: function() {
              k2 !== n2.J && (b2.bindFramebuffer(c2, E2), n2.J = k2);
            }, clear: function() {
              b2.clear(b2.COLOR_BUFFER_BIT | b2.DEPTH_BUFFER_BIT);
            }, fg: function() {
              b2.clear(b2.COLOR_BUFFER_BIT);
            }, gg: function() {
              b2.clear(b2.DEPTH_BUFFER_BIT);
            }, Hf: function() {
              b2.viewport(0, 0, v2, C2);
            }, u: function() {
              k2 !== n2.J && (b2.bindFramebuffer(c2, E2), n2.J = k2);
            }, rtt: function(H2) {
              l2 = H2;
              n2.J !== k2 && (b2.bindFramebuffer(b2.FRAMEBUFFER, E2), n2.J = k2);
              H2.u();
            }, P: function() {
              b2.bindFramebuffer(c2, null);
              n2.J = -1;
            }, resize: function(H2, I2) {
              v2 = H2;
              C2 = I2;
              g2 && (b2.bindRenderbuffer(b2.RENDERBUFFER, g2), b2.renderbufferStorage(b2.RENDERBUFFER, b2.DEPTH_COMPONENT16, v2, C2));
            }, remove: function() {
              E2 === a2 || x2 || (b2.bindFramebuffer(c2, E2), b2.framebufferTexture2D(c2, b2.COLOR_ATTACHMENT0, b2.TEXTURE_2D, null, 0), g2 && b2.framebufferRenderbuffer(c2, b2.DEPTH_ATTACHMENT, b2.RENDERBUFFER, null), b2.bindFramebuffer(c2, null), b2.deleteFramebuffer(E2), g2 && b2.deleteRenderbuffer(g2));
              x2 = true;
            } };
            r2.vd && p2.je();
            m2.push(p2);
            return p2;
          }, P: function() {
            b2.bindFramebuffer(c2, null);
            n2.J = -1;
          }, Pf: function() {
            b2.bindFramebuffer(c2, null);
            b2.clear(b2.COLOR_BUFFER_BIT | b2.DEPTH_BUFFER_BIT);
            b2.viewport(0, 0, aa.F(), aa.U());
            n2.J = -1;
          }, reset: function() {
            n2.J = -2;
          }, ha: function() {
            n2.J !== 0 && (b2.bindFramebuffer(c2, a2), n2.J = 0);
          }, clear: function() {
            b2.viewport(0, 0, aa.F(), aa.U());
            b2.clear(b2.COLOR_BUFFER_BIT);
          }, m: function() {
            q2.P();
            m2.forEach(function(r2) {
              r2.remove();
            });
            a2 !== null && (b2.deleteFramebuffer(a2), a2 = null);
            q2.reset();
            e2 = false;
            m2.splice(0);
            n2.jd = 1;
          } };
          return q2;
        }(), aa = function() {
          function a2() {
            e2 = typeof Qa === "undefined" ? JEContext : Qa;
            m2 = true;
          }
          function c2(k2, p2) {
            for (var H2 = 0; H2 < k2.length; ++H2) {
              var I2 = p2.getExtension(k2[H2]);
              if (I2)
                return I2;
            }
            return null;
          }
          function d2() {
            g2.Cb !== null && (clearInterval(g2.Cb), g2.Cb = null);
            g2.Oa = false;
          }
          var e2 = null, m2 = false, n2 = { xd: false, Ac: null, Bc: null, Bd: false, gf: false, Cc: null, Cd: false, Dc: null, yd: false, Hb: null, bf: false, Ib: null, cf: false }, q2 = null, r2 = { ja: true, ka: true, Tb: true, Qd: false }, l2 = null, v2 = true, C2 = null, E2 = null, g2 = {
            Oa: false,
            va: null,
            ib: null,
            Yb: -1,
            X: null,
            Cb: null
          }, t2 = typeof window === "undefined" ? {} : window, x2 = {
            A: function() {
              if (m2)
                return true;
              x2.reset();
              m2 || a2();
              var k2 = b2;
              if (!q2.xd) {
                q2.Ac = x2.ed(k2);
                t2.GL_EXT_FLOAT = q2.Ac;
                q2.Bd = q2.Ac ? true : false;
                if (q2.Bd || x2.la())
                  q2.Bc = x2.fd(k2), q2.gf = q2.Bc ? true : false, t2.GL_EXT_FLOATLINEAR = q2.Bc;
                q2.xd = true;
              }
              if (!q2.yd) {
                q2.Cc = x2.Za(k2);
                q2.Cc && (q2.Cd = true, t2.GL_EXT_HALFFLOAT = q2.Cc);
                if (q2.Cd || x2.la())
                  q2.Dc = x2.gd(k2), t2.GL_EXT_HALFFLOATLINEAR = q2.Dc;
                q2.Zg = q2.Dc ? true : false;
                q2.yd = true;
              }
              q2.Hb = x2.cd(k2);
              q2.bf = q2.Hb ? true : false;
              t2.GL_EXT_COLORBUFFERFLOAT = q2.Hb;
              q2.Ib = x2.dd(k2);
              q2.cf = q2.Ib ? true : false;
              t2.GL_EXT_COLORBUFFERHALFFLOAT = q2.Ib;
              la.A();
              Ba.A();
              if (!x2.De())
                return false;
              ma.A();
              Ba.af();
              return true;
            },
            reset: function() {
              q2 = Object.assign({}, n2);
              l2 = Object.assign({}, r2);
            },
            F: function() {
              m2 || a2();
              return e2.F();
            },
            U: function() {
              m2 || a2();
              return e2.U();
            },
            la: function() {
              m2 || a2();
              return e2.la();
            },
            bd: function(k2) {
              x2.cd(k2);
              x2.dd(k2);
              x2.ed(k2);
              x2.fd(k2);
              x2.Za(k2);
              x2.gd(k2);
            },
            cd: c2.bind(null, ["EXT_color_buffer_float", "WEBGL_color_buffer_float", "OES_color_buffer_float"]),
            dd: c2.bind(null, ["EXT_color_buffer_half_float", "WEBGL_color_buffer_half_float", "OES_color_buffer_half_float"]),
            ed: c2.bind(null, ["OES_texture_float", "MOZ_OES_texture_float", "WEBKIT_OES_texture_float"]),
            fd: c2.bind(null, ["OES_texture_float_linear", "MOZ_OES_texture_float_linear", "WEBKIT_OES_texture_float_linear"]),
            Za: c2.bind(null, ["OES_texture_half_float", "MOZ_OES_texture_half_float", "WEBKIT_OES_texture_half_float"]),
            gd: c2.bind(null, ["OES_texture_half_float_linear", "MOZ_OES_texture_half_float_linear", "WEBKIT_OES_texture_half_float_linear"]),
            Vb: function(k2) {
              var p2 = x2.Za(k2);
              return p2 && p2.HALF_FLOAT_OES ? p2.HALF_FLOAT_OES : k2.HALF_FLOAT || k2.FLOAT;
            },
            Re: function() {
              return E2 || b2.RGBA32F || b2.RGBA;
            },
            Se: function() {
              return C2 || b2.RGBA16F || b2.RGBA;
            },
            Oe: function() {
              return l2;
            },
            Uc: function() {
              return l2.ja;
            },
            bg: function() {
              return l2.ka;
            },
            ag: function() {
              return l2.Tb;
            },
            ue: function() {
              return l2.Qd && v2;
            },
            be: function(k2) {
              v2 = k2;
              !k2 && g2.Oa && (b2.deleteSync(g2.ib), b2.bindBuffer(g2.X, null), g2.Oa = false);
            },
            Ab: function(k2, p2, H2) {
              function I2() {
                k2.bindTexture(k2.TEXTURE_2D, null);
                k2.bindFramebuffer(N2, null);
                k2.deleteTexture(M2);
                k2.deleteFramebuffer(J2);
              }
              var N2 = k2.FRAMEBUFFER, z2 = k2.NEAREST, J2 = k2.createFramebuffer();
              k2.bindFramebuffer(N2, J2);
              var M2 = k2.createTexture();
              k2.activeTexture(k2.TEXTURE0);
              k2.bindTexture(k2.TEXTURE_2D, M2);
              k2.pixelStorei(k2.UNPACK_FLIP_Y_WEBGL, false);
              k2.texParameteri(k2.TEXTURE_2D, k2.TEXTURE_WRAP_S, k2.CLAMP_TO_EDGE);
              k2.texParameteri(k2.TEXTURE_2D, k2.TEXTURE_WRAP_T, k2.CLAMP_TO_EDGE);
              k2.texParameteri(k2.TEXTURE_2D, k2.TEXTURE_MAG_FILTER, z2);
              k2.texParameteri(k2.TEXTURE_2D, k2.TEXTURE_MIN_FILTER, z2);
              k2.texImage2D(k2.TEXTURE_2D, 0, p2, 3, 3, 0, k2.RGBA, H2, null);
              k2.framebufferTexture2D(k2.FRAMEBUFFER, k2.COLOR_ATTACHMENT0, k2.TEXTURE_2D, M2, 0);
              if (k2.checkFramebufferStatus(k2.READ_FRAMEBUFFER || k2.FRAMEBUFFER) !== k2.FRAMEBUFFER_COMPLETE)
                return I2(), false;
              xa.wc(k2);
              k2.clearColor(0, 0, 0, 0);
              k2.viewport(0, 0, 3, 3);
              k2.disable(k2.DEPTH_TEST);
              k2.clear(k2.COLOR_BUFFER_BIT);
              ma.ab(k2);
              k2.bindFramebuffer(N2, null);
              xa.Ra(k2);
              k2.activeTexture(k2.TEXTURE0);
              k2.bindTexture(k2.TEXTURE_2D, M2);
              ma.ab(k2);
              p2 = new Uint8Array(36);
              k2.readPixels(0, 0, 3, 3, k2.RGBA, k2.UNSIGNED_BYTE, p2);
              I2();
              for (H2 = 0; 36 > H2; ++H2)
                if (H2 % 4 !== 3 && 3 < Math.abs(p2[H2] - 127))
                  return false;
              return true;
            },
            Lb: function(k2) {
              var p2 = { ja: false, ka: false };
              k2.disable(k2.BLEND);
              k2.clearColor(0, 0, 0, 0);
              k2.clear(k2.COLOR_BUFFER_BIT);
              k2.RGBA32F && x2.Ab(k2, k2.RGBA32F, k2.FLOAT) && (p2.ja = true, E2 = k2.RGBA32F);
              !p2.ja && x2.Ab(k2, k2.RGBA, k2.FLOAT) && (p2.ja = true, E2 = k2.RGBA);
              var H2 = x2.Vb(k2);
              C2 = null;
              k2.RGBA16F && x2.Ab(k2, k2.RGBA16F, H2) && (p2.ka = true, C2 = k2.RGBA16F);
              !p2.ka && x2.Ab(k2, k2.RGBA, H2) && (p2.ka = true, C2 = k2.RGBA);
              return p2;
            },
            Ee: function() {
              var k2 = la.instance({ width: 2 });
              k2.Wd();
              var p2 = Ba.instance({ width: 2, isFloat: true, sb: 3 });
              k2.u();
              p2.u();
              b2.flush();
              b2.checkFramebufferStatus(la.Ue()) !== b2.FRAMEBUFFER_COMPLETE ? (Ba.Df(), l2.Tb = false) : l2.Tb = true;
              k2.remove();
              p2.remove();
            },
            Fe: function() {
              var k2 = false;
              x2.la() && (k2 = "PIXEL_PACK_BUFFER STREAM_READ SYNC_GPU_COMMANDS_COMPLETE WAIT_FAILED fenceSync deleteSync createBuffer".split(" ").every(function(p2) {
                return typeof b2[p2] !== "undefined";
              }));
              l2.Qd = k2;
            },
            De: function() {
              var k2 = x2.Lb(b2);
              Object.assign(l2, k2);
              if (!l2.ja && !l2.ka)
                return false;
              x2.Ee();
              x2.Fe();
              return true;
            },
            xb: function(k2, p2, H2, I2, N2) {
              if (!x2.ue())
                return b2.readPixels(k2, p2, H2, I2, b2.RGBA, b2.UNSIGNED_BYTE, N2), Promise.resolve(N2);
              g2.va === null && (g2.X = b2.PIXEL_PACK_BUFFER, g2.va = b2.createBuffer(), g2.Yb = -1);
              b2.bindBuffer(g2.X, g2.va);
              N2.byteLength !== g2.Yb && (b2.bufferData(g2.X, N2.byteLength, b2.STREAM_READ), g2.Yb = N2.byteLength);
              b2.readPixels(k2, p2, H2, I2, b2.RGBA, b2.UNSIGNED_BYTE, 0);
              g2.ib = b2.fenceSync(b2.SYNC_GPU_COMMANDS_COMPLETE, 0);
              b2.flush();
              return new Promise(function(z2, J2) {
                function M2() {
                  if (!g2.Oa)
                    return d2(), J2(), false;
                  switch (b2.clientWaitSync(g2.ib, 0, 0)) {
                    case b2.TIMEOUT_EXPIRED:
                    case b2.WAIT_FAILED:
                      return false;
                    default:
                      return d2(), b2.deleteSync(g2.ib), b2.getBufferSubData(g2.X, 0, N2), b2.bindBuffer(g2.X, null), z2(N2), true;
                  }
                }
                d2();
                g2.Oa = true;
                M2() || (g2.Cb = setInterval(M2, 0));
              });
            },
            m: function() {
              d2();
              Ba.m();
              la.m();
              ma.m();
              g2.va !== null && (b2.deleteBuffer(g2.va), g2.va = null);
              xa.reset();
              m2 = false;
            }
          };
          return x2;
        }(), U2 = ma, va = la, Y2 = Ba, Ca = function() {
          function a2(J2, M2, u2, f2) {
            p2.texParameteri(p2.TEXTURE_2D, p2.TEXTURE_MIN_FILTER, f2 ? p2.NEAREST_MIPMAP_NEAREST : p2.LINEAR);
            var y2 = null;
            if (u2 !== null)
              try {
                y2 = p2.getError();
                if (y2 === "FUCKING_BIG_ERROR")
                  return false;
                p2.texImage2D(p2.TEXTURE_2D, 0, J2, 4, 4, 0, p2.RGBA, M2, u2);
                y2 = p2.getError();
                if (y2 !== p2.NO_ERROR)
                  return false;
              } catch (G2) {
                return false;
              }
            f2 && p2.generateMipmap(p2.TEXTURE_2D);
            p2.clear(p2.COLOR_BUFFER_BIT);
            U2.ab(p2);
            y2 = p2.getError();
            if (y2 === "FUCKING_BIG_ERROR")
              return false;
            p2.readPixels(0, 0, 2, 2, p2.RGBA, p2.UNSIGNED_BYTE, C2);
            y2 = p2.getError();
            y2 === p2.INVALID_OPERATION && typeof p2.PIXEL_PACK_BUFFER !== "undefined" && (p2.bindBuffer(p2.PIXEL_PACK_BUFFER, null), p2.readPixels(0, 0, 2, 2, p2.RGBA, p2.UNSIGNED_BYTE, C2), y2 = p2.getError());
            if (y2 !== p2.NO_ERROR)
              return false;
            u2 = true;
            for (f2 = 0; 16 > f2; ++f2)
              u2 = u2 && 4 > Math.abs(C2[f2] - 127);
            u2 && (l2.Nd = M2, l2.ud = J2);
            return u2;
          }
          function c2(J2, M2) {
            return H2.ja && a2(J2, p2.FLOAT, new Float32Array(E2), M2) ? (r2 = q2.Nc, true) : false;
          }
          function d2(J2, M2, u2) {
            if (!H2.ka)
              return false;
            var f2 = Ba.ze(E2), y2 = aa.Za(p2);
            if (y2 && y2.HALF_FLOAT_OES && a2(J2, y2.HALF_FLOAT_OES, f2, M2) || p2.HALF_FLOAT && a2(J2, p2.HALF_FLOAT, f2, M2))
              return r2 = q2.Ga, true;
            f2 = new Float32Array(E2);
            if (a2(J2, p2.FLOAT, f2, M2))
              return r2 = q2.Ga, true;
            p2.bindTexture(p2.TEXTURE_2D, u2);
            p2.texImage2D(p2.TEXTURE_2D, 0, p2.RGBA, 2, 2, 0, p2.RGBA, p2.UNSIGNED_BYTE, null);
            p2.bindFramebuffer(l2.Xa, z2);
            Ba.kd(p2, u2, 2, 2, f2, false, false);
            p2.bindFramebuffer(l2.Xa, null);
            p2.bindTexture(p2.TEXTURE_2D, u2);
            return a2(J2, null, null, M2) ? (r2 = q2.Ga, true) : false;
          }
          function e2(J2, M2, u2) {
            v2 = true;
            if (d2(J2, true, u2) || c2(M2, true))
              return true;
            v2 = false;
            return d2(J2, false, u2) || c2(M2, false) ? true : false;
          }
          function m2(J2) {
            if (r2 === q2.R) {
              p2 = J2 || b2;
              r2 = q2.RGBA8;
              v2 = true;
              aa.bd(p2);
              H2 || (H2 = aa.Lb(p2));
              va.reset();
              z2 = p2.createFramebuffer();
              l2.Xa = p2.DRAW_FRAMEBUFFER || p2.FRAMEBUFFER;
              p2.bindFramebuffer(l2.Xa, null);
              p2.clearColor(0, 0, 0, 0);
              p2.viewport(0, 0, 2, 2);
              A2.R();
              I2 = A2.Ra(p2);
              J2 = p2.createTexture();
              p2.activeTexture(p2.TEXTURE0);
              p2.bindTexture(p2.TEXTURE_2D, J2);
              p2.texParameteri(p2.TEXTURE_2D, p2.TEXTURE_WRAP_S, p2.REPEAT);
              p2.texParameteri(p2.TEXTURE_2D, p2.TEXTURE_WRAP_T, p2.REPEAT);
              p2.texParameteri(p2.TEXTURE_2D, p2.TEXTURE_MAG_FILTER, p2.NEAREST);
              N2 = J2;
              var M2 = J2 = p2.RGBA, u2 = p2.RGBA16F, f2 = p2.RGBA32F;
              f2 && (J2 = f2);
              u2 && (M2 = u2);
              if ((u2 || f2) && e2(M2, J2, N2))
                return n2(), true;
              J2 = M2 = p2.RGBA;
              if (e2(M2, J2, N2))
                return n2(), true;
              r2 = q2.RGBA8;
              n2();
              return false;
            }
          }
          function n2() {
            p2.deleteProgram(I2.ra);
            p2.deleteTexture(N2);
            N2 = I2 = null;
          }
          for (var q2 = { R: -1, Nc: 3, Ga: 2, RGBA8: 0 }, r2 = q2.R, l2 = { Nd: null, ud: null, Xa: null }, v2 = true, C2 = new Uint8Array(16), E2 = Array(64), g2 = 0; 4 > g2; ++g2)
            for (var t2 = 0; 4 > t2; ++t2) {
              var x2 = (t2 + g2) % 2 === 0 ? 1 : 0, k2 = 4 * g2 + t2;
              E2[4 * k2] = x2;
              E2[4 * k2 + 1] = x2;
              E2[4 * k2 + 2] = x2;
              E2[4 * k2 + 3] = x2;
            }
          var p2 = null, H2 = null, I2 = null, N2 = null, z2 = null;
          return { te: function(J2) {
            m2(J2);
            return v2;
          }, Tc: function(J2, M2) {
            r2 === q2.R && (typeof (M2 !== "undefined") && (H2 = M2), m2(J2));
            return r2 !== q2.RGBA8;
          }, bh: function(J2) {
            m2(J2);
            return r2 === q2.Nc;
          }, hf: function(J2) {
            m2(J2);
            return r2 === q2.Ga;
          }, Mg: function(J2) {
            m2(J2);
            return l2.Nd;
          }, Te: function(J2) {
            m2(J2);
            return l2.ud;
          }, m: function() {
            p2 = null;
            v2 = true;
            r2 = q2.R;
            H2 = null;
          } };
        }(), Xb = function() {
          return { instance: function(a2) {
            var c2 = Y2.instance(a2.alpha), d2 = Y2.instance(a2.beta);
            return { He: function() {
              c2.g(1);
              d2.g(2);
            } };
          } };
        }(), Gb = function() {
          return { instance: function(a2) {
            var c2 = null, d2 = false, e2 = false, m2 = null, n2 = false, q2 = false, r2 = null, l2 = typeof a2.preprocessing === "undefined" ? false : a2.preprocessing, v2 = typeof a2.preprocessingSize === "undefined" ? a2.size : a2.preprocessingSize;
            a2.mask && (d2 = true, ba && ba.oe !== void 0 && (a2.mask = ba.oe + a2.mask), c2 = Y2.instance({ isFloat: false, url: a2.mask }));
            var C2 = false;
            a2.customInputShader && (C2 = "s45", A2.Pc({ name: "_", id: C2, h: a2.customInputShader, Eh: ["uSource"], precision: "lowp" }), A2.T(C2, [{ type: "1i", name: "_", value: 0 }]));
            switch (l2) {
              case "sobel":
                r2 = "s32";
                n2 = true;
                break;
              case "meanNormalization":
                r2 = "s33";
                n2 = true;
                break;
              case "grayScale":
                r2 = "s29";
                n2 = false;
                break;
              case "grayScaleTilt":
                r2 = "s30";
                q2 = true;
                n2 = false;
                break;
              case "rgbGrayTilt":
                r2 = "s31";
                q2 = true;
                n2 = false;
                break;
              case "copy":
                r2 = C2 ? C2 : "s0";
                break;
              case "inputLightRegulation":
                r2 = C2 ? C2 : "s29";
                m2 = Yb.instance({ td: v2, Md: a2.size, Id: a2.nBlurPass, mb: false });
                e2 = true;
                break;
              case "inputMix0":
                r2 = "none";
                m2 = Zb.instance({ D: v2, ee: a2.varianceMin, Sc: a2.blurKernelSizePx, mb: false });
                e2 = true;
                break;
              case "direct":
              case "none":
                r2 = "abort";
                break;
              default:
                r2 = "s4";
            }
            q2 && A2.T(r2, [{ name: "u27", type: "1f", value: a2.tilt }]);
            d2 && (r2 += "Mask");
            var E2 = Y2.instance({ isFloat: false, isPot: false, width: a2.size }), g2 = {
              F: function() {
                return v2;
              },
              Wb: function() {
                return g2.F();
              },
              Xe: function() {
                return e2 ? m2.Xb() : E2;
              },
              V: function(t2) {
                va.ha();
                r2 !== "abort" && (r2 !== "none" && (A2.set(r2), n2 && A2.G("u28", 1 / a2.size), E2.da(), d2 && c2.g(1), U2.l(false, false), E2.g(0), t2 = E2), e2 && m2.process(t2));
              },
              m: function() {
                E2.remove();
                d2 && c2.remove();
              }
            };
            return g2;
          } };
        }(), Hb = function() {
          return { instance: function(a2) {
            function c2(h2) {
              m2.forEach(function(F2, K2) {
                n2[K2][0] = h2[0][F2];
                n2[K2][1] = h2[1][F2];
                n2[K2][2] = h2[2][F2];
                n2[K2][3] = h2[3][F2];
              });
              return n2;
            }
            typeof a2.normalize === "undefined" && (a2.normalize = false);
            var d2 = { input: null, Ua: null, bc: null, ba: null, tb: null, oc: null, pc: null }, e2 = null, m2 = [], n2 = [], q2 = false, r2 = null, l2 = true, v2 = -1, C2 = a2.isReorganize ? a2.isReorganize : false, E2 = a2.kernelsCount ? true : false, g2 = a2.dynPelu ? Xb.instance(a2.dynPelu) : false, t2 = g2 ? true : false, x2 = { isEnabled: false };
            a2.ff ? (a2.sparsity = typeof a2.sparsity !== "undefined" ? a2.sparsity : a2.vb.Wb(), l2 = false) : a2.connectivityUp === "full" && (a2.sparsity = a2.vb.Wb());
            var k2 = { elu: "s16", elu01: "s17", relu: "s15", arctan: "s19", sigmoid: "s14", copy: "s0", softplus: "s20", dynPelu: "s18" }[a2.activation], p2 = a2.sparsity * a2.sparsity, H2 = false, I2 = a2.size, N2 = "";
            if (a2.maxPooling) {
              switch (a2.maxPooling.size) {
                case 2:
                  N2 = "s34";
                  break;
                case 4:
                  N2 = "s35";
              }
              H2 = true;
              I2 /= a2.maxPooling.size;
              d2.oc = Y2.instance({ isFloat: true, isPot: false, width: I2 });
            }
            var z2 = a2.rf !== void 0 && a2.rf ? true : false, J2 = null, M2 = null, u2 = null;
            if (z2) {
              J2 = "s46" + a2.index.toString();
              A2.sd("s46", J2, [((a2.normalization.n - 1) / 2).toFixed(1)]);
              A2.T(J2, [{ type: "1i", name: "u1", value: 0 }, { type: "2f", name: "u8", value: [1 / a2.size, 1 / a2.size] }, { type: "1f", name: "u7", value: a2.normalization.alpha }, { type: "1f", name: "u10", value: a2.normalization.beta }, { type: "1f", name: "u31", value: a2.normalization.k }]);
              var f2 = { isFloat: true, isPot: true, width: a2.size };
              M2 = Y2.instance(f2);
              u2 = Y2.instance(f2);
            }
            var y2 = -1, G2 = null;
            l2 && (d2.ba = Y2.instance({ isFloat: true, isPot: false, width: a2.size }));
            d2.Ua = Y2.instance(a2.bias);
            var L2 = {
              F: function() {
                return a2.size;
              },
              Wb: function() {
                return I2;
              },
              nd: function() {
                return a2.classesCount;
              },
              qe: function(h2) {
                e2.g(h2);
              },
              uf: function() {
                a2.remap && a2.remap.isEnabled && (x2 = { isEnabled: true, kf: Y2.instance({ isFloat: false, isFlipY: false, array: new Uint8Array(a2.remap.maskTexture.data), width: a2.remap.maskTexture.width, isPot: false }), pb: a2.remap.layers.map(function(h2) {
                  return a2.parent.We(h2);
                }), depth: a2.remap.depth });
              },
              Ef: function() {
                switch (a2.connectivityUp) {
                  case "direct":
                    G2 = $b.instance(a2.connectivity);
                    break;
                  case "square":
                    G2 = ac.instance(a2.connectivity);
                    break;
                  case "squareFast":
                    G2 = bc.instance(a2.connectivity, a2.activation);
                    break;
                  case "full":
                    G2 = cc.instance(a2.connectivity);
                    break;
                  case "conv":
                    v2 = a2.kernelsCount, G2 = dc.instance(a2.connectivity), C2 && (d2.tb = Y2.instance({ width: I2, isFloat: true, isFlipY: false, isPot: false }));
                }
                if (G2.Ca) {
                  var h2 = a2.size * a2.sparsity;
                  y2 = Math.log(h2 / a2.size) / Math.log(2);
                  d2.input = Y2.instance({
                    isMipmap: true,
                    isFloat: true,
                    isPot: true,
                    width: h2,
                    ic: y2
                  });
                  d2.bc = Y2.instance({ isFloat: true, isPot: true, width: a2.size });
                }
              },
              V: function(h2, F2) {
                e2 = h2;
                G2.Ca ? (d2.input.da(), E2 && d2.Ua.g(2), G2.V(x2), d2.input.g(0), d2.input.Le(y2), d2.bc.da(), E2 ? A2.set("s0") : (A2.set("s28"), A2.G("u26", p2), d2.Ua.g(1)), d2.input.re(y2, 0), U2.l(false, false), A2.set(k2), z2 ? M2.u() : d2.ba.u(), d2.bc.g(0), t2 && g2.He(), U2.l(false, false)) : (d2.ba.da(), d2.Ua.g(1), G2.V());
                z2 && (A2.set(J2), u2.u(), M2.g(0), U2.l(false, false), A2.set("s47"), A2.G("u7", 1), d2.ba.u(), u2.g(1), U2.l(false, false));
                if (l2)
                  return H2 ? (d2.oc.da(), d2.ba.g(0), A2.set(N2), A2.sa("u8", 1 / a2.size, 1 / a2.size), U2.l(false, false), F2 = d2.oc) : F2 = d2.ba, F2.g(0), C2 && (d2.tb.u(), A2.set("s22"), A2.sa("u13", v2, I2 / v2), U2.l(false, false), F2 = d2.tb, d2.tb.g(0)), F2;
                var K2 = d2.ba;
                a2.normalize && (A2.set(q2 === "gpuRawAvg" ? "s9" : "s8"), A2.G("u4", 1 / a2.size), d2.pc.da(), d2.ba.g(0), U2.l(false, false), K2 = d2.pc);
                h2 = null;
                switch (q2) {
                  case "cpuRGBA2Float":
                    K2.Zc(false);
                    F2 ? h2 = L2.vf(K2).then(r2) : (K2 = L2.wf(K2), r2(K2));
                    break;
                  case "cpuMeanFloat":
                    K2.Zc(true);
                    F2 ? h2 = K2.yf().then(r2) : (K2 = K2.zf(), r2(K2));
                    break;
                  case "gpuRawAvg":
                  case "gpuRaw":
                    K2.g(0);
                  case "none":
                    r2 !== null && r2(K2);
                }
                F2 && h2 === null && (h2 = Promise.resolve());
                return h2;
              },
              Be: function(h2) {
                h2 && (q2 = h2.qc || "none", r2 = h2.nc || null);
                d2.ba = Y2.instance({ isFloat: true, isPot: true, isMipmap: false, width: a2.size });
                h2 = typeof a2.classesCount !== "undefined" && a2.classesCount ? a2.classesCount : a2.size * a2.size;
                for (var F2 = 0, K2 = 0, P2 = 0; F2 < h2; ++F2)
                  m2.push(K2 + (a2.size - 1 - P2) * a2.size), n2.push([-1, -1, -1, -1]), ++K2, K2 === a2.size && (K2 = 0, ++P2);
                a2.normalize && (d2.pc = Y2.instance({ isFloat: true, isPot: true, width: a2.size }));
              },
              vf: function(h2) {
                return h2.xf().then(c2);
              },
              wf: function(h2) {
                h2 = h2.Rd();
                c2(h2);
                return n2;
              },
              m: function() {
                for (var h2 in d2) {
                  var F2 = d2[h2];
                  F2 && F2.remove();
                }
                G2 && (G2.m(), G2 = null);
              }
            };
            a2.vb && L2.Ef(a2.vb);
            return L2;
          } };
        }(), $b = function() {
          return { instance: function(a2) {
            var c2 = Y2.instance(a2.weights);
            return { Ca: true, cb: function() {
              return 1;
            }, m: function() {
              c2.remove();
            }, $e: function() {
              return c2;
            }, V: function() {
              A2.set("s27");
              c2.g(1);
              U2.l(false, false);
            } };
          } };
        }(), cc = function() {
          return { instance: function(a2) {
            var c2 = a2.fromLayerSize, d2 = Y2.instance(a2.weights);
            return { Ca: true, cb: function() {
              return c2;
            }, m: function() {
              d2.remove();
            }, V: function(e2) {
              if (e2.isEnabled) {
                A2.set("s25");
                e2.kf.g(3);
                var m2, n2 = Math.min(e2.pb.length, e2.depth);
                for (m2 = 0; m2 < n2; ++m2)
                  e2.pb[m2].qe(4 + m2);
              } else
                A2.set("s24");
              A2.G("u17", a2.toLayerSize);
              d2.g(1);
              U2.l(false, false);
            } };
          } };
        }(), ac = function() {
          return { instance: function(a2) {
            for (var c2 = a2.fromLayerSize, d2 = a2.toLayerSize, e2 = a2.toSparsity, m2 = e2 * d2, n2 = m2 / c2, q2 = c2 / d2, r2 = 0, l2 = 0, v2 = 0, C2 = Array(e2 * d2 * e2 * d2 * 4), E2 = Array(e2 * d2 * e2 * d2 * 4), g2 = Array(c2 * c2), t2 = 0; t2 < g2.length; ++t2)
              g2[t2] = 0;
            t2 = Math.floor(e2 / 2);
            for (var x2 = 0.5 / d2, k2 = 0.5 / c2, p2 = 0.5 / m2, H2 = 0; H2 < d2; ++H2)
              for (var I2 = Math.round(H2 * q2), N2 = 0; N2 < d2; ++N2) {
                var z2 = Math.round(N2 * q2), J2 = H2 / d2, M2 = N2 / d2;
                J2 += x2;
                M2 += x2;
                for (var u2 = 0; u2 < e2; ++u2) {
                  var f2 = I2 + u2 - t2;
                  0 > f2 && (f2 += c2);
                  f2 >= c2 && (f2 -= c2);
                  for (var y2 = 0; y2 < e2; ++y2) {
                    var G2 = r2 / m2, L2 = l2 / m2, h2 = z2 + y2 - t2;
                    0 > h2 && (h2 += c2);
                    h2 >= c2 && (h2 -= c2);
                    var F2 = f2 / c2, K2 = h2 / c2;
                    L2 = 1 - L2 - 1 / m2;
                    F2 += k2;
                    K2 += k2;
                    G2 += p2;
                    L2 += p2;
                    var P2 = H2 * e2 + u2, da = N2 * e2 + y2;
                    da = d2 * e2 - da - 1;
                    P2 = da * d2 * e2 + P2;
                    C2[4 * P2] = G2;
                    C2[4 * P2 + 1] = L2;
                    C2[4 * P2 + 2] = F2;
                    C2[4 * P2 + 3] = K2;
                    K2 = g2[h2 * c2 + f2]++;
                    P2 = K2 % n2;
                    F2 = f2 * n2 + P2;
                    h2 = h2 * n2 + (K2 - P2) / n2;
                    h2 = c2 * n2 - 1 - h2;
                    h2 = h2 * c2 * n2 + F2;
                    E2[4 * h2] = G2;
                    E2[4 * h2 + 1] = L2;
                    E2[4 * h2 + 2] = J2;
                    E2[4 * h2 + 3] = M2;
                    ++r2 >= m2 && (r2 = 0, ++l2);
                    ++v2;
                  }
                }
              }
            g2 = null;
            var ra = Y2.instance(a2.weights);
            delete a2.weights.data;
            var za = Y2.instance({ width: m2, isFloat: true, array: new Float32Array(E2), isPot: true });
            E2 = null;
            var w2 = Y2.instance({ width: m2, isFloat: true, array: new Float32Array(C2), isPot: true });
            C2 = null;
            return { Ca: true, cb: function() {
              return n2;
            }, m: function() {
              za.remove();
              w2.remove();
              ra.remove();
            }, V: function() {
              A2.set("s23");
              ra.g(1);
              w2.g(2);
              U2.l(false, false);
            } };
          } };
        }(), dc = function() {
          return { instance: function(a2) {
            var c2 = a2.kernelsCount, d2 = a2.toSparsity, e2 = d2 * a2.toLayerSize / a2.fromLayerSize, m2 = Y2.instance(a2.weights);
            return { Ca: true, cb: function() {
              return e2;
            }, Wg: function() {
              return d2;
            }, $e: function() {
              return m2;
            }, m: function() {
              m2.remove();
            }, V: function() {
              A2.set("s26");
              A2.G("u23", c2);
              A2.G("u24", d2);
              A2.G("u17", a2.toLayerSize);
              A2.G("u25", a2.fromLayerSize);
              m2.g(1);
              U2.l(false, false);
            } };
          } };
        }(), bc = function() {
          return { instance: function(a2, c2) {
            var d2 = a2.fromLayerSize, e2 = a2.toLayerSize, m2 = a2.toSparsity, n2 = a2.stride ? a2.stride : 1, q2 = m2 * e2 / d2, r2 = e2 < d2, l2 = d2 / e2, v2 = Y2.instance(a2.weights), C2 = "s48" + [d2.toString(), e2.toString(), m2.toString(), n2.toString(), c2].join("_");
            A2.Je(C2) || (a2 = Vb.Me(c2, "gl_FragColor", "gl_FragColor"), e2 = [{ type: "1f", name: "u17", value: e2 }, { type: "1f", name: "u30", value: n2 }], r2 && e2.push({ type: "1f", name: "u25", value: d2 }), d2 = [(r2 ? q2 : m2).toFixed(1), a2], r2 && d2.push(l2.toFixed(1)), A2.sd(r2 ? "s40" : "s39", C2, d2), A2.T(C2, e2.concat([{
              type: "1i",
              name: "u15",
              value: 0
            }, { type: "1i", name: "u22", value: 1 }, { type: "1i", name: "u14", value: 3 }])));
            return { Ca: false, cb: function() {
              return q2;
            }, m: function() {
              v2.remove();
            }, V: function() {
              A2.set(C2);
              v2.g(3);
              U2.l(false, false);
            } };
          } };
        }(), Yb = function() {
          return { instance: function(a2) {
            var c2 = a2.Id ? a2.Id : 3, d2 = a2.td ? a2.td : 64, e2 = a2.Md ? a2.Md : 64, m2 = a2.mb ? true : false;
            a2 = { isFloat: false, width: d2, isPot: false, isFlipY: false };
            var n2 = Y2.instance(a2), q2 = Y2.instance(a2), r2 = Y2.instance(a2), l2 = Y2.instance(a2), v2 = Y2.instance({ isFloat: true, width: e2, isPot: false, isFlipY: false }), C2 = 1 / d2;
            return { process: function(E2) {
              A2.set("s36");
              l2.u();
              U2.l(m2, false);
              A2.set("s37");
              for (var g2 = 0; g2 < c2; ++g2)
                n2.u(), A2.sa("u8", C2, 0), U2.l(m2, false), r2.u(), l2.g(0), U2.l(m2, false), q2.u(), n2.g(0), A2.sa("u8", 0, C2), U2.l(m2, false), l2.u(), r2.g(0), U2.l(m2, false), g2 !== c2 - 1 && q2.g(0);
              A2.set("s38");
              v2.u();
              E2.g(0);
              q2.g(1);
              l2.g(2);
              U2.l(m2, false);
              v2.g(0);
            }, Xb: function() {
              return v2;
            } };
          } };
        }(), Zb = function() {
          return { instance: function(a2) {
            function c2(v2) {
              return Y2.instance({ isFloat: v2, width: d2.D, isPot: false, isFlipY: false });
            }
            var d2 = Object.assign({ ee: 0.1, Sc: 9, D: 128, mb: false }, a2), e2 = c2(false), m2 = [c2(false), c2(false), c2(false)], n2 = [c2(false), c2(false), c2(false)], q2 = c2(true), r2 = [
              e2,
              n2[0],
              n2[1]
            ];
            a2 = "uniform sampler2D u1;const float e=1.1111,g=2.2222;uniform vec2 u32;varying vec2 vv0;void main(){float b=0.,c=0.;for(float a=-e;a<=e;a+=1.){vec2 i=u32*a,j=vv0+i*g;float d=1.2*a/e,f=exp(-d*d);b+=f*texture2D(u1,j).r,c+=f;}b/=c,gl_FragColor=vec4(b,0.,0.,1.);}".replace("1.1111", Math.round((d2.Sc - 1) / 2).toFixed(2)).replace("2.2222", (1 / d2.D).toFixed(6));
            var l2 = { u1: 0 };
            A2.Qc([{
              id: "s50",
              name: "_",
              h: "uniform sampler2D u1;varying vec2 vv0;const vec3 f=vec3(.2126,.7152,.0722),g=vec3(1.,1.,1.);void main(){vec3 b=texture2D(u1,vv0).rgb;float a=dot(b,f);gl_FragColor=vec4(a,a,a,a);}",
              j: l2,
              i: ["u1"],
              precision: "lowp"
            }, { id: "s51", name: "_", h: a2, j: l2, i: ["u1", "u32"], precision: "lowp" }, { id: "s52", name: "_", h: "uniform sampler2D u33,u34,u35,u36;const float f=1.1111;const vec3 g=vec3(1.,1.,1.);varying vec2 vv0;void main(){vec3 a=texture2D(u33,vv0).rgb;float c=texture2D(u34,vv0).r,d=texture2D(u35,vv0).r,h=texture2D(u36,vv0).r,i=a.r*a.r;vec3 b=vec3(c,d,h),j=max(g*f,abs(i-b*b)),k=sqrt(j);gl_FragColor=vec4(a.r,(a-b)/k);}".replace("1.1111", d2.ee.toFixed(4)), j: { u33: 0, u34: 1, u35: 2, u36: 3 }, i: [
              "u33",
              "u34",
              "u35",
              "u36"
            ], precision: "highp" }]);
            return { process: function() {
              A2.set("s50");
              e2.da();
              U2.l(d2.mb, false);
              A2.set("s51");
              for (var v2 = 0; 3 > v2; ++v2)
                A2.sa("u32", 1, 0), m2[v2].u(), r2[v2].g(0), U2.l(false, false), A2.sa("u32", 0, 1), n2[v2].u(), m2[v2].g(0), U2.l(false, false);
              A2.set("s52");
              q2.u();
              e2.g(0);
              n2[0].g(1);
              n2[1].g(2);
              n2[2].g(3);
              U2.l(false, false);
              q2.g(0);
            }, Xb: function() {
              return q2;
            } };
          } };
        }(), W2 = {
          Ze: function() {
            return W2.Yc() ? document.createElement("video") : false;
          },
          Ma: function(a2, c2) {
            a2[c2] = true;
            a2.setAttribute(c2, "true");
          },
          xe: function() {
            var a2 = false, c2 = navigator.userAgent || navigator.vendor || window.opera;
            if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(c2) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(c2.substr(0, 4)))
              a2 = true;
            return a2;
          },
          Vc: function() {
            return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
          },
          Ne: function() {
            var a2 = navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
            return a2 && a2.length && 2 < a2.length ? [parseInt(a2[1], 10), parseInt(a2[2], 10), parseInt(a2[3] || 0, 10)] : [0, 0, 0];
          },
          Dd: function() {
            try {
              return window.matchMedia("(orientation: portrait)").matches ? true : false;
            } catch (a2) {
              return window.innerHeight > window.innerWidth;
            }
          },
          we: function() {
            return W2.Wc() || W2.Vc();
          },
          Wc: function() {
            var a2 = navigator.userAgent.toLowerCase();
            return a2.indexOf("safari") !== -1 && a2.indexOf("chrome") === -1 ? true : false;
          },
          Ag: function() {
            return W2.xe() ? W2.Dd() ? window.innerHeight / window.innerWidth * 45 : 45 : 45;
          },
          Yc: function() {
            return navigator.mediaDevices && navigator.mediaDevices.getUserMedia ? true : false;
          },
          pause: function(a2) {
            a2.pause();
          },
          rh: function(a2) {
            a2.play();
          },
          release: function(a2) {
            a2.pause();
            a2.videoStream && a2.videoStream.stop();
            a2.videoStream = null;
          },
          Xc: function(a2) {
            if (!a2)
              return a2;
            var c2 = null;
            if (a2.video) {
              var d2 = function(e2) {
                return e2 && typeof e2 === "object" ? Object.assign({}, e2) : e2;
              };
              c2 = {};
              typeof a2.video.width !== "undefined" && (c2.width = d2(a2.video.width));
              typeof a2.video.height !== "undefined" && (c2.height = d2(a2.video.height));
              typeof a2.video.facingMode !== "undefined" && (c2.facingMode = d2(a2.video.facingMode));
            }
            c2 = { audio: a2.audio, video: c2 };
            typeof a2.deviceId !== "undefined" && W2.Oc(c2, a2.deviceId);
            return c2;
          },
          Oc: function(a2, c2) {
            c2 && (a2.video = a2.video || {}, a2.video.deviceId = { exact: c2 }, a2.video.facingMode && delete a2.video.facingMode);
          },
          $d: function(a2) {
            var c2 = a2.video.width;
            a2.video.width = a2.video.height;
            a2.video.height = c2;
            return a2;
          },
          Ae: function(a2) {
            function c2(g2) {
              return [480, 576, 640, 648, 720, 768, 800, 960, 1080, 1152, 1280, 1366, 1920].sort(function(t2, x2) {
                return Math.abs(t2 - g2) - Math.abs(x2 - g2);
              });
            }
            function d2(g2) {
              var t2 = W2.Xc(a2);
              g2 = g2(t2);
              m2.push(g2);
              e2(g2);
            }
            function e2(g2) {
              if (g2.video && g2.video.facingMode && g2.video.facingMode.exact) {
                var t2 = g2.video.facingMode.exact;
                g2 = W2.Xc(g2);
                delete g2.video.facingMode.exact;
                g2.video.facingMode.ideal = t2;
                m2.push(g2);
              }
            }
            var m2 = [];
            if (!a2 || !a2.video)
              return m2;
            e2(a2);
            if (a2.video.width && a2.video.height) {
              if (a2.video.width.ideal && a2.video.height.ideal) {
                var n2 = c2(a2.video.width.ideal).slice(0, 3), q2 = c2(a2.video.height.ideal).slice(0, 3), r2 = {}, l2 = 0;
                for (r2.na = void 0; l2 < n2.length; r2 = { na: r2.na }, ++l2) {
                  r2.na = n2[l2];
                  var v2 = {}, C2 = 0;
                  for (v2.ma = void 0; C2 < q2.length; v2 = { ma: v2.ma }, ++C2)
                    if (v2.ma = q2[C2], r2.na !== a2.video.width.ideal || v2.ma !== a2.video.height.ideal) {
                      var E2 = Math.max(r2.na, v2.ma) / Math.min(r2.na, v2.ma);
                      E2 < 4 / 3 - 0.1 || E2 > 16 / 9 + 0.1 || d2(function(g2, t2) {
                        return function(x2) {
                          x2.video.width.ideal = g2.na;
                          x2.video.height.ideal = t2.ma;
                          return x2;
                        };
                      }(r2, v2));
                    }
                }
              }
              d2(function(g2) {
                return W2.$d(g2);
              });
            }
            a2.video.width && a2.video.height && (a2.video.width.ideal && a2.video.height.ideal && d2(function(g2) {
              delete g2.video.width.ideal;
              delete g2.video.height.ideal;
              return g2;
            }), d2(function(g2) {
              delete g2.video.width;
              delete g2.video.height;
              return g2;
            }));
            a2.video.facingMode && (d2(function(g2) {
              delete g2.video.facingMode;
              return g2;
            }), a2.video.width && a2.video.height && d2(function(g2) {
              W2.$d(g2);
              delete g2.video.facingMode;
              return g2;
            }));
            m2.push({ audio: a2.audio, video: true });
            return m2;
          },
          Lf: function(a2) {
            if (W2.Dd()) {
              if (!a2 || !a2.video)
                return false;
              var c2 = a2.video.width, d2 = a2.video.height;
              if (!c2 || !d2)
                return false;
              if (c2.ideal && d2.ideal && c2.ideal > d2.ideal)
                return a2.video.height = c2, a2.video.width = d2, true;
            }
            return false;
          },
          rb: function(a2) {
            a2.volume = 0;
            W2.Ma(a2, "muted");
            if (W2.Wc()) {
              if (a2.volume === 1) {
                var c2 = function() {
                  a2.volume = 0;
                  window.removeEventListener("mousemove", c2, false);
                  window.removeEventListener("touchstart", c2, false);
                };
                window.addEventListener("mousemove", c2, false);
                window.addEventListener("touchstart", c2, false);
              }
              setTimeout(function() {
                a2.volume = 0;
                W2.Ma(a2, "muted");
              }, 5);
            }
          },
          ce: function(a2, c2, d2) {
            return a2 === null ? Promise.resolve() : new Promise(function(e2, m2) {
              if (a2.srcObject && a2.srcObject.getVideoTracks) {
                var n2 = a2.srcObject.getVideoTracks();
                n2.length !== 1 ? m2("INVALID_TRACKNUMBER") : (n2 = n2[0], c2 ? W2.get(a2, e2, m2, d2) : (n2.stop(), e2()));
              } else
                m2("BAD_IMPLEMENTATION");
            });
          },
          qd: function(a2, c2, d2, e2) {
            function m2(q2) {
              n2 || (n2 = true, d2(q2));
            }
            var n2 = false;
            return navigator.mediaDevices.getUserMedia(e2).then(function(q2) {
              function r2() {
                setTimeout(function() {
                  if (a2.currentTime) {
                    var v2 = a2.videoWidth, C2 = a2.videoHeight;
                    if (v2 === 0 || C2 === 0)
                      m2("VIDEO_NULLSIZE");
                    else {
                      v2 && (a2.style.width = v2.toString() + "px");
                      C2 && (a2.style.height = C2.toString() + "px");
                      v2 = { ve: null, If: null, lf: null };
                      try {
                        var E2 = q2.getVideoTracks()[0];
                        E2 && (v2.lf = E2, v2.ve = E2.getCapabilities(), v2.If = E2.getSettings());
                      } catch (g2) {
                      }
                      W2.we() ? a2.parentNode && a2.parentNode !== null ? (n2 || c2(a2, q2, v2), setTimeout(function() {
                        a2.play();
                      }, 100)) : (document.body.appendChild(a2), W2.rb(a2), n2 || c2(a2, q2, v2), setTimeout(function() {
                        a2.style.transform = "scale(0.0001,0.0001)";
                        a2.style.position = "fixed";
                        a2.style.bottom = "0px";
                        a2.style.right = "0px";
                        W2.rb(a2);
                        setTimeout(function() {
                          a2.play();
                        }, 100);
                      }, 80)) : n2 || c2(a2, q2, v2);
                    }
                  } else
                    m2("VIDEO_NOTSTARTED");
                }, 700);
              }
              function l2() {
                a2.removeEventListener("loadeddata", l2, false);
                var v2 = a2.play();
                W2.rb(a2);
                typeof v2 === "undefined" ? r2() : v2.then(function() {
                  r2();
                }).catch(function() {
                  m2("VIDEO_PLAYPROMISEREJECTED");
                });
              }
              typeof a2.srcObject !== "undefined" ? a2.srcObject = q2 : (a2.src = window.URL.createObjectURL(q2), a2.videoStream = q2);
              W2.rb(a2);
              a2.addEventListener("loadeddata", l2, false);
            }).catch(function(q2) {
              m2(q2);
            });
          },
          get: function(a2, c2, d2, e2) {
            if (!a2)
              return d2 && d2("VIDEO_NOTPROVIDED"), false;
            if (!W2.Yc())
              return d2 && d2("MEDIASTREAMAPI_NOTFOUND"), false;
            if (e2 && e2.video) {
              if (W2.Vc()) {
                var m2 = W2.Ne();
                m2[0] !== 0 && (12 > m2[0] || m2[0] === 12 && 2 > m2[1]) && W2.Lf(e2);
              }
              e2.video.width && e2.video.width.ideal && (a2.style.width = e2.video.width.ideal + "px");
              e2.video.height && e2.video.height.ideal && (a2.style.height = e2.video.height.ideal + "px");
            }
            W2.Ma(a2, "autoplay");
            W2.Ma(a2, "playsinline");
            e2 && e2.audio ? a2.volume = 0 : W2.Ma(a2, "muted");
            W2.qd(a2, c2, function() {
              function n2(r2) {
                if (r2.length === 0)
                  d2("INVALID_FALLBACKCONSTRAINTS");
                else {
                  var l2 = r2.shift();
                  W2.qd(a2, c2, function() {
                    n2(r2);
                  }, l2);
                }
              }
              var q2 = W2.Ae(e2);
              n2(q2);
            }, e2);
          },
          Ye: function(a2) {
            if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices)
              return a2(false, "NOTSUPPORTED"), false;
            navigator.mediaDevices.enumerateDevices().then(function(c2) {
              (c2 = c2.filter(function(d2) {
                return d2.kind && d2.kind.toLowerCase().indexOf("video") !== -1 && d2.label && d2.deviceId;
              })) && c2.length && 0 < c2.length ? a2(c2, false) : a2(false, "NODEVICESFOUND");
            }).catch(function() {
              a2(false, "PROMISEREJECTED");
            });
          },
          cg: function(a2, c2, d2) {
            var e2 = {};
            e2[c2] = d2;
            c2 = [];
            c2.push(e2);
            a2.applyConstraints({ advanced: c2 }).catch(function() {
            });
          }
        }, pa = function() {
          function a2(t2, x2, k2, p2, H2, I2) {
            if (I2 === H2.length)
              p2();
            else {
              switch (H2[I2]) {
                case "D":
                  t2();
                  break;
                case "S":
                  x2().then(function() {
                    g2.ae();
                    a2(t2, x2, k2, p2, H2, ++I2);
                  }).catch(p2);
                  return;
                case "R":
                  k2();
              }
              a2(t2, x2, k2, p2, H2, ++I2);
            }
          }
          var c2 = { n: 5, kc: 1, Gd: 0, bb: [35, 49], Ya: [2, 200], k: 0.7, Qf: 200, tf: 0.05 }, d2 = -1, e2 = null, m2 = -1, n2 = -1, q2 = 0, r2 = -1, l2 = -1, v2 = 0, C2 = 0, E2 = c2.Ya[1], g2 = { od: function() {
            switch (d2) {
              case -1:
                return -1;
              case 0:
                return l2 + e2.Gd;
              case 1:
                return v2;
            }
          }, Fg: function(t2) {
            return Math.pow(Math.min(Math.max(r2, 0), e2.n - 1) / (e2.n - 1), t2 || 1);
          }, A: function(t2) {
            e2 = Object.assign({}, c2, t2);
            r2 = l2 = e2.kc;
            d2 = 0;
            g2.reset();
          }, ae: function(t2) {
            t2 = (typeof t2 === "undefined" ? Date.now() : t2) || 0;
            var x2 = Math.min(Math.max(t2 - C2, e2.Ya[0]), e2.Ya[1]);
            E2 = x2;
            C2 = t2;
            var k2 = m2 === -1 ? 0 : e2.k;
            m2 = Math.min(Math.max(1e3 / x2, 5), 120) * (1 - k2) + m2 * k2;
            t2 - n2 > e2.Qf && 5 < ++q2 && (x2 = e2.k, r2 = r2 * (1 - x2) + (m2 < e2.bb[0] ? l2 - 1 : m2 > e2.bb[1] ? l2 + 1 : l2) * x2, Math.abs(r2 - l2) > 1 - e2.tf && (x2 = Math.min(Math.max(Math.round(r2), 0), e2.n - 1), x2 !== l2 && (r2 = l2 = x2, m2 = (e2.bb[1] - e2.bb[0]) / 2)), n2 = t2);
          }, rc: function(t2, x2, k2, p2, H2) {
            a2(t2, x2, k2, p2, H2, 0);
          }, vc: function(t2) {
            v2 = t2;
            d2 = 1;
          }, Gc: function() {
            d2 = 0;
            g2.reset();
          }, reset: function() {
            E2 = c2.Ya[1];
            n2 = m2 = -1;
            q2 = 0;
          }, Qe: function() {
            return E2;
          } };
          return g2;
        }(), Ma = function() {
          function a2() {
            d2(k2 + t2.jc);
            p2.port.postMessage("DONE");
          }
          function c2() {
            var f2 = t2.ga;
            z2.isEnabled && (f2 = Math.max(f2, z2.ga));
            N2.Sa = f2 === 0 ? window.requestAnimationFrame(d2) : window.requestAnimationFrame(e2);
          }
          function d2(f2) {
            I2.ya && x2 !== null && (f2 -= k2, f2 = Math.min(Math.max(f2, t2.$c[0]), t2.$c[1]), k2 += f2, n2(), z2.isEnabled && z2.Y && I2.Z && k2 - z2.fc > t2.Lc && (v2(), z2.fc = k2), x2(k2));
          }
          function e2(f2) {
            I2.ya && (N2.timeout = window.setTimeout(d2.bind(null, f2), t2.ga));
          }
          function m2() {
            x2 = null;
            I2.ya = false;
            n2();
          }
          function n2() {
            N2.Sa && (window.cancelAnimationFrame(N2.Sa), N2.Sa = null);
            N2.timeout && (window.clearTimeout(N2.timeout), N2.timeout = null);
          }
          function q2(f2) {
            f2 && !I2.Z ? (I2.Z = true, H2 && pa.Gc(), p2.port.postMessage("STOP"), aa.be(true), c2()) : !f2 && I2.Z && (I2.Z = false, H2 && pa.vc(1), aa.be(false), p2.port.postMessage("START"));
          }
          function r2(f2) {
            f2.target.hidden ? M2() : J2();
          }
          function l2(f2, y2, G2) {
            y2 = f2.createShader(y2);
            f2.shaderSource(y2, G2);
            f2.compileShader(y2);
            return y2;
          }
          function v2() {
            z2.Y = false;
            var f2 = z2.fb, y2 = z2.gb, G2 = z2.hb, L2 = z2.X;
            f2.uniform1f(z2.rd, Math.random());
            z2.za ? y2.beginQueryEXT(L2, G2) : f2.beginQuery(L2, G2);
            f2.drawElements(f2.POINTS, 1, f2.UNSIGNED_SHORT, 0);
            z2.za ? y2.endQueryEXT(L2) : f2.endQuery(L2);
            f2.flush();
            E2().then(function(h2) {
              h2 = t2.ge * t2.Jc * 1e3 / h2;
              z2.Db = (z2.Db + 1) % t2.Ea;
              z2.hc[z2.Db] = h2;
              if (++z2.Ed > t2.Ea) {
                z2.ob.set(z2.hc);
                z2.ob.sort();
                h2 = z2.ob[Math.floor(t2.Ea / 2)];
                z2.$a = Math.max(z2.$a, h2);
                var F2;
                for (F2 = 0; F2 < z2.Ec && !(h2 > z2.$a * (1 - (t2.Kc[F2] + t2.he * (F2 >= z2.Bb ? 1 : -1)))); ++F2)
                  F2 === z2.Ec - 1 && ++F2;
                F2 !== z2.Bb && (console.log("THERMAL THROTTLING LEVEL = " + F2.toString()), z2.Bb = F2, z2.ga = F2 === 0 ? 0 : t2.fe[F2 - 1], t2.Ic && t2.Ic(F2));
              }
              z2.Y = true;
            }).catch(function() {
              z2.Y = true;
            });
          }
          function C2(f2) {
            var y2 = z2.fb, G2 = z2.gb, L2 = z2.hb;
            L2 = z2.za ? G2.Cg(L2, G2.QUERY_RESULT_AVAILABLE_EXT) : y2.getQueryParameter(L2, y2.QUERY_RESULT_AVAILABLE);
            y2 = y2.getParameter(G2.GPU_DISJOINT_EXT);
            L2 ? f2(!y2) : setTimeout(C2.bind(null, f2), 0.1);
          }
          function E2() {
            return new Promise(function(f2, y2) {
              C2(function(G2) {
                if (G2) {
                  G2 = z2.fb;
                  var L2 = z2.gb, h2 = z2.hb;
                  G2 = z2.za ? L2.getQueryObjectEXT(h2, L2.QUERY_RESULT_EXT) : G2.getQueryParameter(h2, G2.QUERY_RESULT);
                  f2(G2);
                } else
                  y2();
              });
            });
          }
          var g2 = { zd: true, $c: [1, 200], jc: 20, ga: 0, ie: false, Jc: 50, ge: 240, Lc: 3e3, Ea: 3, Kc: [0.2, 0.35, 0.5], he: 0.05, fe: [8, 20, 40], Ic: null }, t2 = null, x2 = null, k2 = 0, p2 = null, H2 = false, I2 = { qa: false, Z: true, ec: false, dc: false, cc: false, ya: false }, N2 = { Sa: null, timeout: null }, z2 = {
            isEnabled: false,
            Y: false,
            fb: null,
            gb: null,
            hb: null,
            X: null,
            rd: null,
            za: true,
            Bb: 0,
            Ec: 0,
            ga: 0,
            fc: 0,
            Ed: 0,
            hc: null,
            ob: null,
            Db: 0,
            $a: 0
          }, J2 = q2.bind(null, true), M2 = q2.bind(null, false), u2 = { A: function(f2) {
            t2 = Object.assign(g2, f2);
            Object.assign(I2, { Z: true, qa: true, ya: false });
            if (t2.ie) {
              f2 = document.createElement("canvas");
              f2.setAttribute("width", "1");
              f2.setAttribute("height", "1");
              var y2 = { antialias: false };
              f2 = f2.getContext("webgl2", y2) || f2.getContext("webgl", y2);
              if (y2 = f2.getExtension("EXT_disjoint_timer_query") || f2.getExtension("EXT_disjoint_timer_query_webgl2")) {
                z2.fb = f2;
                z2.gb = y2;
                z2.isEnabled = true;
                z2.za = y2.beginQueryEXT ? true : false;
                var G2 = l2(f2, f2.VERTEX_SHADER, "attribute vec4 a0;void main(){gl_Position=a0;}"), L2 = l2(f2, f2.FRAGMENT_SHADER, "precision lowp float;uniform float u37;void main(){vec4 a=u37*vec4(1.,2.,3.,4.);for(int b=0;b<666;b+=1)a=cos(a);gl_FragColor=a;}".replace("666", t2.Jc.toString())), h2 = f2.createProgram();
                f2.attachShader(h2, G2);
                f2.attachShader(h2, L2);
                f2.linkProgram(h2);
                G2 = f2.getAttribLocation(h2, "a0");
                z2.rd = f2.getUniformLocation(h2, "u37");
                f2.useProgram(h2);
                f2.enableVertexAttribArray(G2);
                h2 = f2.createBuffer();
                f2.bindBuffer(f2.ARRAY_BUFFER, h2);
                f2.bufferData(f2.ARRAY_BUFFER, new Float32Array([0.5, 0.5, 0, 1]), f2.STATIC_DRAW);
                f2.vertexAttribPointer(G2, 4, f2.FLOAT, false, 16, 0);
                h2 = f2.createBuffer();
                f2.bindBuffer(f2.ELEMENT_ARRAY_BUFFER, h2);
                f2.bufferData(f2.ELEMENT_ARRAY_BUFFER, new Uint16Array([0]), f2.STATIC_DRAW);
                f2.disable(f2.DEPTH_TEST);
                f2.disable(f2.DITHER);
                f2.disable(f2.STENCIL_TEST);
                f2.viewport(0, 0, 1, 1);
                h2 = z2.za ? y2.createQueryEXT() : f2.createQuery();
                z2.hb = h2;
                z2.X = y2.TIME_ELAPSED_EXT || f2.TIME_ELAPSED;
                z2.Bb = 0;
                z2.Ec = t2.Kc.length;
                z2.ga = 0;
                z2.fc = -t2.Lc;
                z2.hc = new Float32Array(t2.Ea);
                z2.ob = new Float32Array(t2.Ea);
                z2.$a = 0;
                z2.Db = 0;
                z2.Ed = 0;
                z2.Y = true;
              }
            }
            if (t2.zd) {
              f2 = false;
              try {
                if (typeof SharedWorker === "undefined") {
                  var F2 = URL.createObjectURL(new Blob(["let handler = null;\n      self.addEventListener('message', function(e){\n        if (handler !== null){\n          clearTimeout(handler);\n          handler = null;\n        }\n        switch (e.data) {\n          case 'START':\n          case 'DONE':\n            handler = setTimeout(function(){\n              self.postMessage('TICK');\n            }, " + t2.jc.toString() + ");\n            break;\n          case 'STOP':\n            break;\n        };\n      }, false);"], { type: "text/javascript" })), K2 = new Worker(F2);
                  K2.addEventListener("message", a2);
                  p2 = { Pd: K2, port: K2 };
                  I2.ec = true;
                } else {
                  var P2 = URL.createObjectURL(new Blob(["let handler = null;\n      onconnect = function(e) {\n        const port = e.ports[0];\n        port.addEventListener('message', function(e) {\n          \n          if (handler !== null){\n            clearTimeout(handler);\n            handler = null;\n          }\n          switch (e.data) {\n            case 'START':\n            case 'DONE':\n              handler = setTimeout(function(){\n                port.postMessage('TICK');\n              }, " + t2.jc.toString() + ");\n              break;\n            case 'STOP':\n              break;\n          };\n          \n        });\n        \n        port.start();\n      } // end onconnect()"], { type: "text/javascript" })), da = new SharedWorker(P2);
                  da.port.start();
                  da.port.addEventListener("message", a2);
                  p2 = { Pd: da, port: da.port };
                  I2.dc = true;
                }
                f2 = true;
              } catch (ra) {
              }
              f2 && ("onvisibilitychange" in document ? document.addEventListener("visibilitychange", r2) : (window.addEventListener("blur", M2), window.addEventListener("focus", J2)), I2.cc = true);
            }
            H2 = typeof pa !== "undefined";
          }, m: function() {
            m2();
            I2.cc && ("onvisibilitychange" in document ? document.removeEventListener("visibilitychange", r2) : (window.removeEventListener("blur", M2), window.removeEventListener("focus", J2)), I2.cc = false);
            I2.dc ? (p2.port.close(), I2.dc = false) : I2.ec && (p2.Pd.terminate(), I2.ec = false);
            Object.assign(I2, { Z: true, qa: false, ya: false });
            x2 = null;
          }, hh: function() {
            return I2.Z;
          }, update: function(f2) {
            Object.assign(t2, f2);
          }, rc: function(f2) {
            I2.qa || u2.A({});
            n2();
            I2.ya = true;
            x2 = f2;
            I2.Z && c2();
          }, stop: m2 };
          return u2;
        }(), tb = function() {
          var a2 = { Kd: 4, ub: [
            1.5,
            1.5,
            2
          ], O: [0.1, 0.1, 0.1], Td: 1, D: -1, M: -1, Kf: 2, sf: 1, Ud: true, Ie: 0.8 }, c2 = null, d2 = [], e2 = 0, m2 = [0.5, 0.5, 1];
          return { A: function(n2) {
            c2 = Object.assign({}, a2, n2);
            d2.splice(0);
            n2 = c2.ub[0] * c2.O[0];
            var q2 = c2.ub[1] * c2.O[1], r2 = 1 / (1 + c2.ub[2] * c2.O[2]), l2 = c2.Td * Math.min(c2.D, c2.M), v2 = l2 / c2.D;
            l2 /= c2.M;
            var C2 = 0.5 * c2.Ie;
            C2 *= C2;
            for (var E2 = 0; E2 < c2.Kd; ++E2) {
              var g2 = Math.pow(r2, E2), t2 = v2 * g2, x2 = l2 * g2;
              g2 = t2 * n2;
              var k2 = x2 * q2, p2 = t2 / 2;
              x2 /= 2;
              for (var H2 = 1 + (1 - p2 - p2) / g2, I2 = 1 + (1 - x2 - x2) / k2, N2 = 0; N2 < I2; ++N2)
                for (var z2 = x2 + N2 * k2, J2 = z2 - 0.5, M2 = 0; M2 < H2; ++M2) {
                  var u2 = p2 + M2 * g2, f2 = u2 - 0.5;
                  f2 * f2 + J2 * J2 > C2 || d2.push([u2, z2, t2 * c2.sf]);
                }
            }
            c2.Ud && d2.sort(function(y2, G2) {
              var L2 = y2[0] - 0.5;
              y2 = y2[1] - 0.5;
              var h2 = G2[0] - 0.5;
              G2 = G2[1] - 0.5;
              return L2 * L2 + y2 * y2 - (h2 * h2 + G2 * G2);
            });
          }, get: function() {
            var n2 = d2.length;
            if (n2 === 0)
              return m2;
            e2 >= n2 && (e2 = 0);
            var q2 = d2[Math.floor(e2)];
            e2 = (e2 + 1 / c2.Kf) % n2;
            return q2;
          } };
        }(), ba = {
          neuralNetworkPath: "NN_DEFAULT.json",
          fa: 0,
          Eb: [2, 8],
          Af: { threshold: 1, nScaleLevels: 2, scale0Factor: 0.8, overlapFactors: [2, 2, 3], scanCenterFirst: true, nDetectsPerLoop: -1, multiDetectionThresholdFactors: [0.5, 0.6], isCleanGLStateAtEachIteration: true, animateProcessOrder: "DSR" },
          Nf: 50,
          Hd: 0.3,
          mf: 8,
          pf: 0.3,
          Jf: { translationFactorRange: [15e-4, 5e-3], rotationFactorRange: [3e-3, 0.02], qualityFactorRange: [0.9, 0.98], alphaRange: [0.05, 1], followZRotAlphaFactor: 0.8 },
          Pa: [0.65, 1, 0.262],
          O: [0.092, 0.092, 0.3],
          ke: 0.2,
          me: 2,
          le: 0.1,
          qf: 8,
          Jd: 1,
          Ke: Za.qb.bind(null, 0.3, 0.7),
          Tf: 20,
          Yd: 3
        }, oa = { facingMode: "user", idealWidth: 800, idealHeight: 600, minWidth: 480, maxWidth: 1920, minHeight: 480, maxHeight: 1920, rotate: 0, flipX: false }, ia = { lc: -3, jf: -1, error: -2, ready: 1, play: 2, pause: 3 }, na = ia.lc, B2 = null, ec = { kb: false, zc: null, element: null, N: null, H: [0, 0], L: [
          0.5,
          0.5
        ], v: [0.5, 0, 0, 0.5], wb: 0, La: null, jb: false }, Q2 = null, fc = { Ka: null, Va: null, antialias: true, Mc: "./", Fa: null, ia: null, fa: ba.fa, Od: ba.fa, lb: false, ua: true }, Oa = null, ea = null, sa = null, Pa = 1, Na = { uc: -1, Mb: -1 }, Z2 = null, gc = { D: 0, M: 0, H: [0, 0], xa: null }, X2 = { Da: null, buffer: null, O: null, Pa: null, aa: ba.Jd, Na: null }, Sa = null, qa = null, O2 = { o: 1, pa: 0, W: null, Ad: false, Fd: 0, mc: 0 }, hb = [], ib = [], Eb = { VERSION: "2.1.7", init: function(a2) {
          function c2() {
            na !== ia.error && ++e2 === 2 && (Ja(), xb(), Ia(), Q2.Ka && (na = ia.ready, Q2.Ka(false, {
              GL: b2,
              canvasElement: Q2.ia,
              videoTexture: B2.N.get(),
              videoTransformMat2: B2.v,
              maxFacesDetected: O2.o,
              videoElement: B2.element
            }), fb()), eb());
          }
          if (na !== ia.lc)
            return a2.callbackReady && a2.callbackReady("ALREADY_INITIALIZED"), false;
          na = ia.jf;
          B2 = Object.assign({}, ec);
          Q2 = Object.assign({}, fc);
          Z2 = Object.assign({}, gc);
          O2.W = [0];
          X2.O = ba.O.slice(0);
          X2.Pa = ba.Pa.slice(0);
          typeof a2.antialias !== "undefined" && (Q2.antialias = a2.antialias);
          a2.callbackReady && (Q2.Ka = a2.callbackReady);
          a2.callbackTrack && (Q2.Va = a2.callbackTrack);
          a2.nExpressions && (X2.aa = a2.nExpressions);
          a2.expressionsEasings && (X2.Na = a2.expressionsEasings);
          typeof a2.animateDelay !== "undefined" && (Q2.fa = a2.animateDelay);
          typeof a2.NNCPath !== "undefined" && (Q2.Mc = a2.NNCPath);
          typeof a2.NNC !== "undefined" && (Q2.Fa = a2.NNC);
          typeof a2.maxFacesDetected !== "undefined" && (O2.o = Math.max(1, a2.maxFacesDetected));
          typeof a2.followZRot !== "undefined" && (Q2.ua = a2.followZRot ? true : false);
          if (O2.o > ba.mf)
            return Ha("MAXFACES_TOOHIGH"), false;
          if (!a2.canvasId && !a2.canvas)
            return Ha("NO_CANVASID"), false;
          Q2.ia = a2.canvas ? a2.canvas : document.getElementById(a2.canvasId);
          if (!Q2.ia)
            return Ha("INVALID_CANVASID"), false;
          Z2.D = Q2.ia.width;
          Z2.M = Q2.ia.height;
          if (!Z2.D || !Z2.M)
            return Ha("INVALID_CANVASDIMENSIONS"), false;
          for (var d2 = 0; d2 < O2.o; ++d2)
            hb.push(new Float32Array(ba.qf)), ib.push(0);
          Ma.A({ zd: a2.isKeepRunningOnWinFocusLost || false, ga: Q2.fa });
          pa.A({ kc: 0, n: ba.Eb[1] - ba.Eb[0] + 1, Gd: ba.Eb[0] });
          ea = Object.create(ba.Af);
          a2.scanSettings && (Object.assign(ea, a2.scanSettings), ea.nDetectsPerLoop !== -1 ? pa.vc(ea.nDetectsPerLoop) : pa.Gc());
          sa = Object.create(ba.Jf);
          a2.stabilizationSettings && Object.assign(sa, a2.stabilizationSettings);
          var e2 = 0;
          a2.videoSettings && a2.videoSettings.videoElement ? $a(a2.videoSettings.videoElement, c2) : (a2.videoSettings && Object.assign(oa, a2.videoSettings), zb(a2.onWebcamAsk, a2.onWebcamGet, function(m2) {
            $a(m2, c2);
          }));
          Qb(function(m2) {
            if (!Rb())
              return false;
            Oa = new Fb({ pb: m2.layers, qc: "gpuRawAvg", nc: Tb });
            A2.Qc([{ id: "s54", name: "_", ta: "attribute vec2 a0;uniform mat2 u38;varying vec2 vv0;void main(){gl_Position=vec4(a0,0.,1.),vv0=vec2(.5,.5)+u38*a0;}", Ta: ["a0"], Ha: [2], h: "uniform sampler2D u1;varying vec2 vv0;void main(){gl_FragColor=texture2D(u1,vv0);}", i: ["u1", "u38"], precision: "lowp" }, {
              id: "s55",
              name: "_",
              h: "uniform sampler2D u1;varying vec2 vv0;void main(){gl_FragColor=texture2D(u1,vv0);}",
              ta: "attribute vec2 a0;uniform sampler2D u39;uniform mat2 u38;uniform vec2 u40;uniform float u41,u42,u43;varying vec2 vv0;void main(){vec4 a=texture2D(u39,vec2(.17,u41));vec2 f=a.gb,g=a.a*u40,b=a0;b.x*=u43;float c=cos(u42),d=sin(u42);vec2 h=mat2(c,d,-d,c)*b,i=f+h*.5*g,j=i-.5;vv0=.5+2.*u38*j,gl_Position=vec4(a0,0.,1.);}",
              Ta: ["a0"],
              Ha: [2],
              i: "u1 u39 u40 u41 u42 u43 u38".split(" "),
              precision: "lowp"
            }, {
              id: "s56",
              name: "_",
              h: "uniform sampler2D u44,u39;uniform vec3 u45,u46;uniform float u47,u48,u41,u49,u42,u50;const vec4 e=vec4(.25,.25,.25,.25);void main(){vec4 d=texture2D(u44,vec2(.625,.625)),f=texture2D(u44,vec2(.875,.625)),a=texture2D(u39,vec2(.17,u41));float g=dot(d-f,e);bool h=g>u48;h?a.r=2.:a.r>u47?a.r=0.:a.r>1.9?a.r+=1.:0.,a.r*=u49;if(a.r<.9)a=vec4(1.,u45);else{a.r*=step(1.9,a.r);float i=dot(e,texture2D(u44,vec2(.875,.875))),j=dot(e,texture2D(u44,vec2(.125,.625))),k=dot(e,texture2D(u44,vec2(.375,.625))),b=cos(u42),c=sin(u42);vec2 l=mat2(b,c*u50,-c/u50,b)*vec2(i,j);a.gba+=vec3(l,k)*u46*a.a;}gl_FragColor=a;}",
              ta: "attribute vec2 a0;void main(){gl_Position=vec4(a0,0.,1.);}",
              i: "u44 u39 u45 u47 u46 u49 u42 u50 u48 u41".split(" ")
            }, {
              id: "s57",
              name: "_",
              ta: "attribute vec2 a0;void main(){gl_Position=vec4(a0,0.,1.);}",
              h: "uniform sampler2D u44;uniform float u49;const vec4 e=vec4(.25,.25,.25,.25);const vec3 f=vec3(.5,.5,.5);void main(){float a=dot(e,texture2D(u44,vec2(.125,.875))),b=dot(e,texture2D(u44,vec2(.375,.875))),c=dot(e,texture2D(u44,vec2(.625,.875))),d=dot(e,texture2D(u44,vec2(.625,.625)));vec3 g=vec3(a,b,c)*.5+f;gl_FragColor=vec4(g,d*u49);}",
              i: ["u44", "u49"]
            }, { id: "s58", name: "_", ta: "attribute vec2 a0;void main(){gl_Position=vec4(a0,0.,1.);}", h: "uniform sampler2D u44;const vec4 e=vec4(.25,.25,.25,.25);void main(){float a=dot(e,texture2D(u44,vec2(.375,.375))),b=dot(e,texture2D(u44,vec2(.625,.375))),c=dot(e,texture2D(u44,vec2(.875,.375))),d=dot(e,texture2D(u44,vec2(.125,.125)));gl_FragColor=vec4(a,b,c,d);}", i: ["u44"] }, {
              id: "s53",
              name: "_",
              h: "uniform sampler2D u39;uniform vec2 u51;uniform float u52;varying vec2 vv0;void main(){float f=step(.5,mod(gl_FragCoord.y+1.5,2.)),c=step(.33,vv0.x);vec4 a=texture2D(u39,vv0+u51);a.a=mix(a.a*u52,a.a,c);vec4 d=floor(255.*a),g=255.*(255.*a-d),b=mix(d,g,f)/255.;b.x=mix(step(a.x,1.5),b.x,c),gl_FragColor=b;}",
              i: ["u39", "u52", "u51"]
            }]);
            sb();
            Pb();
            kb();
            jb();
            c2();
          });
          return true;
        }, destroy: function() {
          Ma.m();
          return new Promise(function(a2) {
            Eb.toggle_pause(true, true).finally(function() {
              Oa && Oa.m();
              Qa.m();
              Oa = qa = Sa = null;
              hb.splice(0);
              ib.splice(0);
              Z2.xa = null;
              X2.Da = null;
              B2.N = null;
              na = ia.lc;
              a2();
            }).catch(function() {
            });
          });
        }, toggle_pause: function(a2, c2) {
          if (!Ya())
            return Promise.reject("NOT_READY");
          var d2 = null;
          d2 = B2.jb ? Promise.resolve() : c2 ? W2.ce(B2.element, !a2, B2.La) : Promise.resolve();
          a2 ? rb() : d2.then(function() {
            eb();
          });
          return d2;
        }, update_videoSettings: function(a2) {
          rb();
          return new Promise(function(c2, d2) {
            W2.ce(B2.element, false, B2.La).then(function() {
              Object.assign(oa, a2);
              zb(null, null, function(e2) {
                $a(e2, function() {
                  Ja();
                  Ia();
                  eb();
                  c2();
                });
              });
            }).catch(d2);
          });
        }, toggle_slow: function(a2) {
          Ya() && na === ia.play && (a2 && !Q2.lb ? (Q2.Od = Q2.fa, ea.nDetectsPerLoop = 1, this.set_animateDelay(ba.Vf), Q2.lb = true) : !a2 && Q2.lb && (ea.nDetectsPerLoop = -1, this.set_animateDelay(Q2.Od), Q2.lb = false));
        }, set_animateDelay: function(a2) {
          Q2.fa = a2;
          Ma.update({ ga: Q2.fa });
        }, resize: function() {
          if (!Ya())
            return false;
          var a2 = Q2.ia.width, c2 = Q2.ia.height;
          if (!lb() && a2 === Z2.D && c2 === Z2.M)
            return false;
          Z2.D = a2;
          Z2.M = c2;
          A2.R();
          kb();
          jb();
          Ja();
          Ia();
          return true;
        }, set_inputTexture: function(a2, c2, d2) {
          B2.H[0] = c2;
          B2.H[1] = d2;
          B2.N = Y2.instance({ width: c2, height: d2, Zb: a2 });
          B2.kb = true;
          Ja();
          fb();
          Ia();
        }, reset_GLState: function() {
          fb();
          Z2.xa.remove();
          X2.Da.remove();
          sb();
        }, render_video: function() {
          va.P();
          A2.set("s54");
          b2.viewport(0, 0, Z2.D, Z2.M);
          B2.N.g(0);
          U2.l(true, true);
        }, reset_inputTexture: function() {
          B2.kb = false;
          B2.N = B2.zc;
          lb();
          Ja();
          Ia();
        }, get_videoDevices: function(a2) {
          return W2.Ye(a2);
        }, set_scanSettings: function(a2) {
          Object.assign(ea, a2);
          ea.nDetectsPerLoop !== -1 ? pa.vc(ea.nDetectsPerLoop) : pa.Gc();
          kb();
          jb();
        }, set_stabilizationSettings: function(a2) {
          Object.assign(sa, a2);
        }, set_videoOrientation: function(a2, c2) {
          Ya() && (oa.flipX = c2, oa.rotate = a2, Ja(), Ia());
        }, update_videoElement: function(a2, c2) {
          $a(a2 ? a2 : B2.element, function() {
            xb();
            Ja();
            Ia();
            c2 && c2();
          });
        }, create_new: function() {
          return JEELIZFACEFILTERGEN();
        } };
        return Eb;
      };
      var JEELIZFACEFILTER2 = JEELIZFACEFILTERGEN();
      if (typeof module !== "undefined") {
        module.exports = JEELIZFACEFILTER2;
      }
    }
  });

  // node_modules/facefilter/helpers/JeelizResizer.js
  var require_JeelizResizer = __commonJS({
    "node_modules/facefilter/helpers/JeelizResizer.js"(exports, module) {
      "use strict";
      var JeelizResizer = function() {
        let _domCanvas = null, _whCanvasPx = null, _isApplyCSS = false, _resizeAttemptsCounter = 0, _overSamplingFactor = 1, _isFullScreen = false, _timerFullScreen = null, _callbackResize = null, _isInvFullscreenWH = false;
        const _cameraResolutions = [
          [640, 480],
          [768, 480],
          [800, 600],
          [960, 640],
          [960, 720],
          [1024, 768],
          [1280, 720],
          [1920, 1080]
        ];
        function add_CSStransform(domElement, CSS) {
          const CSStransform = domElement.style.transform;
          if (CSStransform.indexOf(CSS) !== -1)
            return;
          domElement.style.transform = CSS + " " + CSStransform;
        }
        function compute_overlap(whA, whB) {
          const aspectRatioA = whA[0] / whA[1];
          const aspectRatioB = whB[0] / whB[1];
          var whLandscape, whPortrait;
          if (aspectRatioA > aspectRatioB) {
            whLandscape = whA, whPortrait = whB;
          } else {
            whLandscape = whB, whPortrait = whA;
          }
          const areaOverlap = Math.min(whLandscape[0], whPortrait[0]) * Math.min(whLandscape[1], whPortrait[1]);
          var areaTotal;
          if (whLandscape[0] >= whPortrait[0] && whLandscape[1] >= whPortrait[1]) {
            areaTotal = whLandscape[0] * whLandscape[1];
          } else if (whPortrait[0] > whLandscape[0] && whPortrait[1] > whLandscape[1]) {
            areaTotal = whPortrait[0] * whPortrait[1];
          } else {
            areaTotal = whLandscape[0] * whLandscape[1];
            areaTotal += (whPortrait[1] - whLandscape[1]) * whPortrait[0];
          }
          return areaOverlap / areaTotal;
        }
        function update_sizeCanvas() {
          const domRect = _domCanvas.getBoundingClientRect();
          apply_sizeCanvas(domRect.width, domRect.height);
        }
        function apply_sizeCanvas(width2, height2) {
          _whCanvasPx = [
            Math.round(_overSamplingFactor * width2),
            Math.round(_overSamplingFactor * height2)
          ];
          _domCanvas.setAttribute("width", _whCanvasPx[0]);
          _domCanvas.setAttribute("height", _whCanvasPx[1]);
          if (_isApplyCSS) {
            _domCanvas.style.width = width2.toString() + "px";
            _domCanvas.style.height = height2.toString() + "px";
          }
        }
        function on_windowResize() {
          if (_timerFullScreen) {
            clearTimeout(_timerFullScreen);
          }
          _timerFullScreen = setTimeout(resize_fullScreen, 50);
        }
        function resize_canvasToFullScreen() {
          const wh = [window["innerWidth"], window["innerHeight"]];
          if (_isInvFullscreenWH) {
            wh.reverse();
          }
          apply_sizeCanvas(wh[0], wh[1]);
        }
        function resize_fullScreen() {
          resize_canvasToFullScreen();
          JEELIZFACEFILTER.resize();
          _timerFullScreen = null;
          if (_callbackResize) {
            _callbackResize();
          }
        }
        const that = {
          is_portrait: function() {
            try {
              if (window["matchMedia"]("(orientation: portrait)")["matches"]) {
                return true;
              } else {
                return false;
              }
            } catch (e2) {
              return window["innerHeight"] > window["innerWidth"];
            }
          },
          check_isIOS: function() {
            const isIOS = /iPad|iPhone|iPod/.test(navigator["userAgent"]) && !window["MSStream"];
            return isIOS;
          },
          get_IOSVersion: function() {
            const v2 = navigator["appVersion"].match(/OS (\d+)_(\d+)_?(\d+)?/);
            return v2.length > 2 ? [parseInt(v2[1], 10), parseInt(v2[2], 10), parseInt(v2[3] || 0, 10)] : [0, 0, 0];
          },
          check_isAndroid: function() {
            const ua = navigator["userAgent"].toLowerCase();
            return ua.indexOf("android") !== -1;
          },
          get_androidVersion: function() {
            const ua = navigator["userAgent"].toLowerCase();
            const match = ua.match(/android\s([0-9\.]*)/i);
            if (!match || match.length < 2) {
              return [0, 0, 0];
            }
            const v2 = match[1].split(".");
            return [
              parseInt(v2[0], 10),
              parseInt(v2[1], 10),
              parseInt(v2[2] || 0, 10)
            ];
          },
          require_flipVideoWHIfPortrait: function() {
            return false;
          },
          size_canvas: function(optionsArg) {
            const options = Object.assign({
              canvasId: "undefinedCanvasId",
              canvas: null,
              overSamplingFactor: window.devicePixelRatio || 1,
              isFullScreen: false,
              isInvWH: false,
              CSSFlipX: false,
              isApplyCSS: false,
              onResize: null,
              callback: function() {
              }
            }, optionsArg);
            _domCanvas = options.canvas ? options.canvas : document.getElementById(options.canvasId);
            _isFullScreen = options.isFullScreen;
            _isInvFullscreenWH = options.isInvWH;
            _isApplyCSS = options.isApplyCSS;
            _overSamplingFactor = options.overSamplingFactor;
            if (_isFullScreen) {
              _callbackResize = options.onResize;
              resize_canvasToFullScreen();
              window.addEventListener("resize", on_windowResize, false);
              window.addEventListener("orientationchange", on_windowResize, false);
            } else {
              const domRect = _domCanvas.getBoundingClientRect();
              if (domRect.width === 0 || domRect.height === 0) {
                console.log("WARNING in JeelizResize.size_canvas(): the canvas has its width or its height null, Retry a bit later...");
                if (++_resizeAttemptsCounter > 20) {
                  options.callback("CANNOT_RESIZECANVAS");
                  return;
                }
                setTimeout(that.size_canvas.bind(null, options), 50);
                return;
              }
              _resizeAttemptsCounter = 0;
              update_sizeCanvas();
            }
            if (options.CSSFlipX) {
              add_CSStransform(_domCanvas, "rotateY(180deg)");
            }
            const allResolutions = _cameraResolutions.map(function(x2) {
              return x2.slice(0);
            });
            if (that.is_portrait() && that.require_flipVideoWHIfPortrait()) {
              allResolutions.forEach(function(wh) {
                wh.reverse();
              });
            }
            allResolutions.sort(function(resA, resB) {
              return compute_overlap(resB, _whCanvasPx) - compute_overlap(resA, _whCanvasPx);
            });
            const bestCameraResolution = {
              "idealWidth": allResolutions[0][0],
              "idealHeight": allResolutions[0][1]
            };
            console.log("INFO in JeelizResizer: bestCameraResolution =", bestCameraResolution);
            setTimeout(options.callback.bind(null, false, bestCameraResolution), 1);
          },
          resize_canvas: function() {
            if (_isFullScreen) {
              resize_canvasToFullScreen();
            } else {
              update_sizeCanvas();
            }
          },
          get_canvasSize: function() {
            return _whCanvasPx;
          }
        };
        return that;
      }();
      try {
        module.exports = JeelizResizer;
      } catch (e2) {
        console.log("JeelizResizer ES6 Module not exported");
        window.JeelizResizer = JeelizResizer;
      }
    }
  });

  // lib/jeelizWeboji/dist/jeelizFaceExpressions.module.js
  var require_jeelizFaceExpressions_module = __commonJS({
    "lib/jeelizWeboji/dist/jeelizFaceExpressions.module.js"(exports, module) {
      var da = typeof Object.defineProperties == "function" ? Object.defineProperty : function(b2, d2, g2) {
        if (b2 == Array.prototype || b2 == Object.prototype)
          return b2;
        b2[d2] = g2.value;
        return b2;
      };
      function fa(b2) {
        b2 = [typeof globalThis == "object" && globalThis, b2, typeof window == "object" && window, typeof self == "object" && self, typeof global == "object" && global];
        for (var d2 = 0; d2 < b2.length; ++d2) {
          var g2 = b2[d2];
          if (g2 && g2.Math == Math)
            return g2;
        }
        throw Error("Cannot find global object");
      }
      var pa = fa(exports);
      function qa(b2, d2) {
        if (d2)
          a: {
            var g2 = pa;
            b2 = b2.split(".");
            for (var h2 = 0; h2 < b2.length - 1; h2++) {
              var t2 = b2[h2];
              if (!(t2 in g2))
                break a;
              g2 = g2[t2];
            }
            b2 = b2[b2.length - 1];
            h2 = g2[b2];
            d2 = d2(h2);
            d2 != h2 && d2 != null && da(g2, b2, { configurable: true, writable: true, value: d2 });
          }
      }
      function sa(b2) {
        var d2 = 0;
        return function() {
          return d2 < b2.length ? { done: false, value: b2[d2++] } : { done: true };
        };
      }
      function ua(b2) {
        var d2 = typeof Symbol != "undefined" && Symbol.iterator && b2[Symbol.iterator];
        return d2 ? d2.call(b2) : { next: sa(b2) };
      }
      function wa() {
        this.L = false;
        this.o = null;
        this.Ba = void 0;
        this.a = 1;
        this.Aa = 0;
        this.H = null;
      }
      function Da(b2) {
        if (b2.L)
          throw new TypeError("Generator is already running");
        b2.L = true;
      }
      wa.prototype.U = function(b2) {
        this.Ba = b2;
      };
      function Fa(b2, d2) {
        b2.H = { oe: d2, Me: true };
        b2.a = b2.Aa;
      }
      wa.prototype.return = function(b2) {
        this.H = { return: b2 };
        this.a = this.Aa;
      };
      function Ga(b2) {
        this.a = new wa();
        this.o = b2;
      }
      function Ha(b2, d2) {
        Da(b2.a);
        var g2 = b2.a.o;
        if (g2)
          return La(b2, "return" in g2 ? g2["return"] : function(h2) {
            return { value: h2, done: true };
          }, d2, b2.a.return);
        b2.a.return(d2);
        return Ma(b2);
      }
      function La(b2, d2, g2, h2) {
        try {
          var t2 = d2.call(b2.a.o, g2);
          if (!(t2 instanceof Object))
            throw new TypeError("Iterator result " + t2 + " is not an object");
          if (!t2.done)
            return b2.a.L = false, t2;
          var r2 = t2.value;
        } catch (n2) {
          return b2.a.o = null, Fa(b2.a, n2), Ma(b2);
        }
        b2.a.o = null;
        h2.call(b2.a, r2);
        return Ma(b2);
      }
      function Ma(b2) {
        for (; b2.a.a; )
          try {
            var d2 = b2.o(b2.a);
            if (d2)
              return b2.a.L = false, { value: d2.value, done: false };
          } catch (g2) {
            b2.a.Ba = void 0, Fa(b2.a, g2);
          }
        b2.a.L = false;
        if (b2.a.H) {
          d2 = b2.a.H;
          b2.a.H = null;
          if (d2.Me)
            throw d2.oe;
          return { value: d2.return, done: true };
        }
        return { value: void 0, done: true };
      }
      function Qa(b2) {
        this.next = function(d2) {
          Da(b2.a);
          b2.a.o ? d2 = La(b2, b2.a.o.next, d2, b2.a.U) : (b2.a.U(d2), d2 = Ma(b2));
          return d2;
        };
        this.throw = function(d2) {
          Da(b2.a);
          b2.a.o ? d2 = La(b2, b2.a.o["throw"], d2, b2.a.U) : (Fa(b2.a, d2), d2 = Ma(b2));
          return d2;
        };
        this.return = function(d2) {
          return Ha(b2, d2);
        };
        this[Symbol.iterator] = function() {
          return this;
        };
      }
      function Ra(b2) {
        function d2(h2) {
          return b2.next(h2);
        }
        function g2(h2) {
          return b2.throw(h2);
        }
        return new Promise(function(h2, t2) {
          function r2(n2) {
            n2.done ? h2(n2.value) : Promise.resolve(n2.value).then(d2, g2).then(r2, t2);
          }
          r2(b2.next());
        });
      }
      qa("Symbol", function(b2) {
        function d2(t2) {
          if (this instanceof d2)
            throw new TypeError("Symbol is not a constructor");
          return new g2("jscomp_symbol_" + (t2 || "") + "_" + h2++, t2);
        }
        function g2(t2, r2) {
          this.a = t2;
          da(this, "description", { configurable: true, writable: true, value: r2 });
        }
        if (b2)
          return b2;
        g2.prototype.toString = function() {
          return this.a;
        };
        var h2 = 0;
        return d2;
      });
      qa("Symbol.iterator", function(b2) {
        if (b2)
          return b2;
        b2 = Symbol("Symbol.iterator");
        for (var d2 = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "), g2 = 0; g2 < d2.length; g2++) {
          var h2 = pa[d2[g2]];
          typeof h2 === "function" && typeof h2.prototype[b2] != "function" && da(h2.prototype, b2, { configurable: true, writable: true, value: function() {
            return Sa(sa(this));
          } });
        }
        return b2;
      });
      function Sa(b2) {
        b2 = { next: b2 };
        b2[Symbol.iterator] = function() {
          return this;
        };
        return b2;
      }
      qa("Promise", function(b2) {
        function d2(n2) {
          this.o = 0;
          this.U = void 0;
          this.a = [];
          var k2 = this.H();
          try {
            n2(k2.resolve, k2.reject);
          } catch (m2) {
            k2.reject(m2);
          }
        }
        function g2() {
          this.a = null;
        }
        function h2(n2) {
          return n2 instanceof d2 ? n2 : new d2(function(k2) {
            k2(n2);
          });
        }
        if (b2)
          return b2;
        g2.prototype.o = function(n2) {
          if (this.a == null) {
            this.a = [];
            var k2 = this;
            this.H(function() {
              k2.U();
            });
          }
          this.a.push(n2);
        };
        var t2 = pa.setTimeout;
        g2.prototype.H = function(n2) {
          t2(n2, 0);
        };
        g2.prototype.U = function() {
          for (; this.a && this.a.length; ) {
            var n2 = this.a;
            this.a = [];
            for (var k2 = 0; k2 < n2.length; ++k2) {
              var m2 = n2[k2];
              n2[k2] = null;
              try {
                m2();
              } catch (p2) {
                this.L(p2);
              }
            }
          }
          this.a = null;
        };
        g2.prototype.L = function(n2) {
          this.H(function() {
            throw n2;
          });
        };
        d2.prototype.H = function() {
          function n2(p2) {
            return function(B2) {
              m2 || (m2 = true, p2.call(k2, B2));
            };
          }
          var k2 = this, m2 = false;
          return { resolve: n2(this.Ue), reject: n2(this.L) };
        };
        d2.prototype.Ue = function(n2) {
          if (n2 === this)
            this.L(new TypeError("A Promise cannot resolve to itself"));
          else if (n2 instanceof d2)
            this.$e(n2);
          else {
            a:
              switch (typeof n2) {
                case "object":
                  var k2 = n2 != null;
                  break a;
                case "function":
                  k2 = true;
                  break a;
                default:
                  k2 = false;
              }
            k2 ? this.Te(n2) : this.Aa(n2);
          }
        };
        d2.prototype.Te = function(n2) {
          var k2 = void 0;
          try {
            k2 = n2.then;
          } catch (m2) {
            this.L(m2);
            return;
          }
          typeof k2 == "function" ? this.qf(k2, n2) : this.Aa(n2);
        };
        d2.prototype.L = function(n2) {
          this.Ba(2, n2);
        };
        d2.prototype.Aa = function(n2) {
          this.Ba(1, n2);
        };
        d2.prototype.Ba = function(n2, k2) {
          if (this.o != 0)
            throw Error("Cannot settle(" + n2 + ", " + k2 + "): Promise already settled in state" + this.o);
          this.o = n2;
          this.U = k2;
          this.Se();
        };
        d2.prototype.Se = function() {
          if (this.a != null) {
            for (var n2 = 0; n2 < this.a.length; ++n2)
              r2.o(this.a[n2]);
            this.a = null;
          }
        };
        var r2 = new g2();
        d2.prototype.$e = function(n2) {
          var k2 = this.H();
          n2.Ja(k2.resolve, k2.reject);
        };
        d2.prototype.qf = function(n2, k2) {
          var m2 = this.H();
          try {
            n2.call(k2, m2.resolve, m2.reject);
          } catch (p2) {
            m2.reject(p2);
          }
        };
        d2.prototype.then = function(n2, k2) {
          function m2(q2, u2) {
            return typeof q2 == "function" ? function(D2) {
              try {
                p2(q2(D2));
              } catch (x2) {
                B2(x2);
              }
            } : u2;
          }
          var p2, B2, F2 = new d2(function(q2, u2) {
            p2 = q2;
            B2 = u2;
          });
          this.Ja(m2(n2, p2), m2(k2, B2));
          return F2;
        };
        d2.prototype.catch = function(n2) {
          return this.then(void 0, n2);
        };
        d2.prototype.Ja = function(n2, k2) {
          function m2() {
            switch (p2.o) {
              case 1:
                n2(p2.U);
                break;
              case 2:
                k2(p2.U);
                break;
              default:
                throw Error("Unexpected state: " + p2.o);
            }
          }
          var p2 = this;
          this.a == null ? r2.o(m2) : this.a.push(m2);
        };
        d2.resolve = h2;
        d2.reject = function(n2) {
          return new d2(function(k2, m2) {
            m2(n2);
          });
        };
        d2.race = function(n2) {
          return new d2(function(k2, m2) {
            for (var p2 = ua(n2), B2 = p2.next(); !B2.done; B2 = p2.next())
              h2(B2.value).Ja(k2, m2);
          });
        };
        d2.all = function(n2) {
          var k2 = ua(n2), m2 = k2.next();
          return m2.done ? h2([]) : new d2(function(p2, B2) {
            function F2(D2) {
              return function(x2) {
                q2[D2] = x2;
                u2--;
                u2 == 0 && p2(q2);
              };
            }
            var q2 = [], u2 = 0;
            do
              q2.push(void 0), u2++, h2(m2.value).Ja(F2(q2.length - 1), B2), m2 = k2.next();
            while (!m2.done);
          });
        };
        return d2;
      });
      qa("Math.log2", function(b2) {
        return b2 ? b2 : function(d2) {
          return Math.log(d2) / Math.LN2;
        };
      });
      var Ta = typeof Object.assign == "function" ? Object.assign : function(b2, d2) {
        for (var g2 = 1; g2 < arguments.length; g2++) {
          var h2 = arguments[g2];
          if (h2)
            for (var t2 in h2)
              Object.prototype.hasOwnProperty.call(h2, t2) && (b2[t2] = h2[t2]);
        }
        return b2;
      };
      qa("Object.assign", function(b2) {
        return b2 || Ta;
      });
      function Ua(b2) {
        var d2 = new XMLHttpRequest();
        d2.open("GET", c2.rc + c2.neuralNetworkPath, true);
        d2.withCredentials = false;
        d2.onreadystatechange = function() {
          d2.readyState !== 4 || d2.status !== 200 && d2.status !== 0 || b2(d2.responseText);
        };
        d2.send();
      }
      function Va(b2, d2) {
        if (d2 === 0 || typeof b2 !== "object")
          return b2;
        b2 = Object.assign({}, b2);
        d2 = d2 === void 0 || d2 === -1 ? -1 : d2 - 1;
        for (var g2 in b2)
          b2[g2] = Va(b2[g2], d2);
        return b2;
      }
      function Wa(b2, d2, g2) {
        return Math.min(Math.max((g2 - b2) / (d2 - b2), 0), 1);
      }
      function Xa(b2) {
        switch (b2) {
          case "relu":
            return "gl_FragColor=max(vec4(0.,0.,0.,0.),gl_FragColor);";
          case "elu":
            return "gl_FragColor=mix(exp(-abs(gl_FragColor))-vec4(1.,1.,1.,1.),gl_FragColor,step(0.,gl_FragColor));";
          case "elu01":
            return "gl_FragColor=mix(0.1*exp(-abs(gl_FragColor))-vec4(0.1,0.1,0.1,0.1),gl_FragColor,step(0.,gl_FragColor));";
          case "arctan":
            return "gl_FragColor=atan(3.14159265359*texture2D(u0,vUV))/3.14159265359;";
          case "copy":
            return "";
          default:
            return false;
        }
      }
      function Ya(b2, d2) {
        var g2 = d2 % 8;
        return b2[(d2 - g2) / 8] >> 7 - g2 & 1;
      }
      function $a(b2) {
        var d2 = JSON.parse(b2);
        b2 = d2.ne;
        var g2 = d2.nf, h2 = d2.n, t2 = null;
        typeof btoa === "undefined" ? t2 = Buffer.from(d2.data, "base64").toString("latin1") : t2 = atob(d2.data);
        var r2 = t2.length;
        d2 = new Uint8Array(r2);
        for (var n2 = 0; n2 < r2; ++n2)
          d2[n2] = t2.charCodeAt(n2);
        t2 = new Float32Array(h2);
        r2 = new Float32Array(g2);
        n2 = b2 + g2 + 1;
        for (var k2 = 0; k2 < h2; ++k2) {
          for (var m2 = n2 * k2, p2 = Ya(d2, m2) === 0 ? 1 : -1, B2 = m2 + 1, F2 = 1, q2 = 0, u2 = B2 + b2 - 1; u2 >= B2; --u2)
            q2 += F2 * Ya(d2, u2), F2 *= 2;
          B2 = q2;
          m2 = m2 + 1 + b2;
          F2 = r2.length;
          q2 = 0;
          for (u2 = m2; u2 < m2 + F2; ++u2)
            r2[q2] = Ya(d2, u2), ++q2;
          for (F2 = m2 = 0; F2 < g2; ++F2)
            m2 += r2[F2] * Math.pow(2, -F2 - 1);
          t2[k2] = m2 === 0 && B2 === 0 ? 0 : p2 * (1 + m2) * Math.pow(2, 1 + B2 - Math.pow(2, b2 - 1));
        }
        return t2;
      }
      var J2 = function() {
        function b2(w2, f2, A2) {
          f2 = w2.createShader(f2);
          w2.shaderSource(f2, A2);
          w2.compileShader(f2);
          return w2.getShaderParameter(f2, w2.COMPILE_STATUS) ? f2 : false;
        }
        function d2(w2, f2, A2) {
          f2 = b2(w2, w2.VERTEX_SHADER, f2);
          A2 = b2(w2, w2.FRAGMENT_SHADER, A2);
          w2 === H2 && k2.push(f2, A2);
          var L2 = w2.createProgram();
          w2.attachShader(L2, f2);
          w2.attachShader(L2, A2);
          w2.linkProgram(L2);
          return L2;
        }
        function g2(w2) {
          return ["float", "sampler2D", "int"].map(function(f2) {
            return "precision " + w2 + " " + f2 + ";\n";
          }).join("");
        }
        function h2(w2, f2) {
          f2.s = f2.s ? true : false;
          if (!f2.s) {
            f2.ua = f2.ua || "precision lowp float;attribute vec2 a0;varying vec2 vv0;void main(){gl_Position=vec4(a0,0.,1.),vv0=a0*.5+vec2(.5,.5);}";
            f2.Ha = f2.Ha || ["a0"];
            f2.xa = f2.xa || [2];
            f2.precision = f2.precision || q2;
            f2.id = B2++;
            f2.zd !== void 0 && (f2.zd.forEach(function(l2, C2) {
              f2.c = f2.c.replace(l2, f2.hb[C2]);
            }), f2.zd.splice(0));
            f2.mc = 0;
            f2.xa.forEach(function(l2) {
              f2.mc += 4 * l2;
            });
            var A2 = g2(f2.precision);
            f2.ka = d2(w2, A2 + f2.ua, A2 + f2.c);
            f2.m = {};
            f2.f.forEach(function(l2) {
              f2.m[l2] = w2.getUniformLocation(f2.ka, l2);
            });
            f2.attributes = {};
            f2.ya = [];
            f2.Ha.forEach(function(l2) {
              var C2 = w2.getAttribLocation(f2.ka, l2);
              f2.attributes[l2] = C2;
              f2.ya.push(C2);
            });
            if (f2.g) {
              w2.useProgram(f2.ka);
              p2 = f2;
              m2 = f2.id;
              for (var L2 in f2.g)
                w2.uniform1i(f2.m[L2], f2.g[L2]);
            }
            f2.ja = true;
          }
        }
        function t2(w2) {
          ab.zf(Q2);
          m2 !== w2.id && (Q2.O(), m2 = w2.id, p2 = w2, H2.useProgram(w2.ka), w2.ya.forEach(function(f2) {
            f2 !== 0 && H2.enableVertexAttribArray(f2);
          }));
        }
        function r2(w2, f2, A2) {
          h2(w2, f2, A2);
          w2.useProgram(f2.ka);
          w2.enableVertexAttribArray(0);
          m2 = -1;
          return p2 = f2;
        }
        function n2() {
          return { c: "uniform sampler2D u1;varying vec2 vv0;void main(){gl_FragColor=texture2D(u1,vv0);}", f: ["u1"], g: { u1: 0 } };
        }
        var k2 = [], m2 = -1, p2 = null, B2 = 0, F2 = false, q2 = "highp", u2 = ["u1"], D2 = ["u0"], x2 = { u1: 0 }, e2 = { u0: 0 }, G2 = { u1: 0, u2: 1 }, N2 = { u3: 0 }, K2 = {
          s0: n2(),
          s1: {
            c: "uniform sampler2D u1;varying vec2 vv0;void main(){gl_FragColor=texture2D(u1,vv0);}",
            f: u2,
            g: x2,
            precision: "lowp"
          },
          s2: { c: "uniform sampler2D u1,u2;varying vec2 vv0;void main(){vec4 a=texture2D(u2,vv0),b=texture2D(u1,vv0);gl_FragColor=a*b;}", f: ["u1", "u2"], g: G2 },
          s3: { c: "uniform sampler2D u1;uniform vec2 u4,u5;varying vec2 vv0;void main(){vec2 a=vv0*u4+u5;gl_FragColor=texture2D(u1,a);}", f: ["u1", "u4", "u5"], g: x2, s: true },
          s4: { c: "uniform sampler2D u1;varying vec2 vv0;const vec4 f=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u1,vv0);gl_FragColor=a.r*f;}", f: u2, g: x2 },
          s5: {
            c: "uniform sampler2D u1,u2;varying vec2 vv0;const vec4 f=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u2,vv0),b=texture2D(u1,vv0);gl_FragColor=a.a*b.r*f;}",
            f: ["u1", "u2"],
            g: G2
          },
          s6: { c: "uniform sampler2D u1;varying vec2 vv0;void main(){gl_FragColor=texture2D(u1,vec2(1.-vv0.x,vv0.y));}", f: u2, g: x2 },
          s7: { c: "uniform sampler2D u1;varying vec2 vv0;void main(){gl_FragColor=texture2D(u1,vec2(vv0.x,1.-vv0.y));}", f: u2, g: x2 },
          s8: { c: "uniform sampler2D u0;uniform float u4;varying vec2 vv0;void main(){vec4 a=texture2D(u0,vv0);gl_FragColor=a*u4;}", f: ["u0", "u4"], g: e2 },
          s9: {
            c: "uniform sampler2D u0;uniform float u4;varying vec2 vv0;const vec4 f=vec4(.25,.25,.25,.25),g=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u0,vv0);float b=dot(a*u4,f);gl_FragColor=b*g;}",
            f: ["u0", "u4"],
            g: e2
          },
          s10: { c: "uniform sampler2D u1;varying vec2 vv0;const vec4 e=vec4(1.,1.,1.,1.);void main(){float a=.25*dot(e,texture2D(u1,vv0));gl_FragColor=a*e;}", f: u2, g: x2 },
          s11: { c: "uniform sampler2D u1,u6;uniform float u7;const vec4 f=vec4(1.,1.,1.,1.);varying vec2 vv0;void main(){vec4 a=texture2D(u1,vv0),b=texture2D(u6,vv0);gl_FragColor=mix(b,a,u7*f);}", f: ["u1", "u6", "u7"], g: { u1: 0, u6: 1 } },
          s12: {
            c: "uniform sampler2D u1;uniform vec2 u8;varying vec2 vv0;void main(){gl_FragColor=.25*(texture2D(u1,vv0+u8)+texture2D(u1,vv0+u8*vec2(1.,-1.))+texture2D(u1,vv0+u8*vec2(-1.,-1.))+texture2D(u1,vv0+u8*vec2(-1.,1.)));}",
            f: ["u1", "u8"],
            g: x2
          },
          s13: {
            c: "uniform sampler2D u1;uniform vec4 u9;varying vec2 vv0;float g(float a,float b){a=floor(a)+.5;return floor(a/exp2(b));}float h(float a,float b){return floor(a*exp2(b)+.5);}float i(float a,float b){return mod(a,h(1.,b));}float e(float c,float a,float b){a=floor(a+.5),b=floor(b+.5);return i(g(c,a),b-a);}vec4 j(float a){if(a==0.)return vec4(0.,0.,0.,0.);float k=128.*step(a,0.);a=abs(a);float c=floor(log2(a)),l=c+127.,b=(a/exp2(c)-1.)*8388608.,d=l/2.,m=fract(d)*2.,n=floor(d),o=e(b,0.,8.),p=e(b,8.,16.),q=m*128.+e(b,16.,23.),r=k+n;return vec4(o,p,q,r)/255.;}void main(){float a=dot(texture2D(u1,vv0),u9);gl_FragColor=j(a);}",
            f: ["u1", "u9"],
            g: x2
          },
          s14: { c: "uniform sampler2D u0;varying vec2 vv0;const vec4 e=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u0,vv0),b=e/(e+exp(-a));gl_FragColor=b;}", f: D2, g: e2, s: true },
          s15: { c: "uniform sampler2D u0;varying vec2 vv0;const vec4 f=vec4(0.,0.,0.,0.);void main(){vec4 a=texture2D(u0,vv0);gl_FragColor=max(f,a);}", f: D2, g: e2 },
          s16: { c: "uniform sampler2D u0;varying vec2 vv0;const vec4 f=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u0,vv0);gl_FragColor=mix(exp(-abs(a))-f,a,step(0.,a));}", f: D2, g: e2 },
          s17: { c: "uniform sampler2D u0;varying vec2 vv0;const vec4 f=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u0,vv0),b=exp(-abs(a))-f;gl_FragColor=mix(.1*b,a,step(0.,a));}", f: D2, g: e2 },
          s18: { c: "uniform sampler2D u0,u7,u10;varying vec2 vv0;const vec4 f=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u0,vv0),c=texture2D(u7,vv0),d=texture2D(u10,vv0),b=a/d;gl_FragColor=c*mix(exp(-abs(b))-f,b,step(0.,a));}", f: ["u0", "u7", "u10"], g: { u0: 0, u7: 1, u10: 2 }, s: true },
          s19: {
            c: "uniform sampler2D u0;const float e=3.141593;varying vec2 vv0;void main(){gl_FragColor=atan(e*texture2D(u0,vv0))/e;}",
            f: D2,
            g: e2
          },
          s20: { c: "uniform sampler2D u0;varying vec2 vv0;const vec4 f=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u0,vv0),b=log(f+a);gl_FragColor=b;}", f: D2, g: e2, s: true },
          s21: { c: "uniform sampler2D u0,u11;uniform float u12;const vec2 e=vec2(.5,.5);const float f=1e-5;const vec4 g=vec4(1.,1.,1.,1.),i=vec4(0.,0.,0.,0.);varying vec2 vv0;void main(){vec4 a=texture2D(u11,e);float b=u12*u12;vec4 c=max(b*a,f*g);gl_FragColor=texture2D(u0,vv0)/c;}", f: ["u0", "u11", "u12"], g: { u0: 0, u11: 1 }, s: true },
          s22: {
            c: "uniform sampler2D u1;uniform vec2 u13;varying vec2 vv0;void main(){float a=u13.x*u13.y;vec2 b=floor(vv0*a)/a,c=fract(vv0*a),d=floor(b*u13.y),f=floor(u13.x*fract(b*u13.y)),g=(f*u13.y+d)/a;gl_FragColor=texture2D(u1,g+c/a);}",
            f: ["u1", "u13"],
            g: x2
          },
          s23: { c: "uniform sampler2D u14,u15,u16;varying vec2 vv0;void main(){vec4 a=texture2D(u16,vv0);vec2 b=a.rg,c=a.ba;vec4 d=texture2D(u14,b),f=texture2D(u15,c);gl_FragColor=d*f;}", f: ["u14", "u15", "u16"], g: { u15: 0, u14: 1, u16: 2 }, s: true },
          s24: { c: "uniform float u17;uniform sampler2D u14,u15;varying vec2 vv0;void main(){vec2 a=fract(vv0*u17);vec4 b=texture2D(u14,vv0),c=texture2D(u15,a);gl_FragColor=b*c;}", f: ["u15", "u14", "u17"], g: { u15: 0, u14: 1 } },
          s25: {
            c: "uniform float u17;uniform sampler2D u14,u15,u18,u19,u20,u21;varying vec2 vv0;const vec4 e=vec4(1.,1.,1.,1.),g=vec4(1e-3,1e-3,1e-3,1e-3);void main(){vec2 h=vv0*u17,l=floor(h),c=h-l;vec4 m=texture2D(u14,vv0),d=texture2D(u15,c),a=texture2D(u21,vv0);a=a*255.;vec4 n=texture2D(u18,c),o=texture2D(u19,c),p=texture2D(u20,c),i=step(-g,-a),b=e-i,j=b*step(-e-g,-a);b*=e-j;vec4 k=b*step(-2.*e-g,-a);b*=e-k;vec4 q=b;d=i*d+j*n+k*o+q*p,gl_FragColor=m*d;}",
            f: "u14 u15 u17 u21 u18 u19 u20".split(" "),
            g: { u15: 0, u14: 1, u21: 3, u18: 4, u19: 5, u20: 6 },
            s: true
          },
          s26: {
            c: "uniform sampler2D u14,u15,u22;uniform float u17,u23,u24,u25;varying vec2 vv0;const vec2 j=vec2(1.,1.);void main(){vec2 a=floor(u23*vv0),b=u23*vv0-a;float c=u17/u23;vec2 d=floor(b*c),f=b*c-d,g=(a+f)/u23;float k=u23*u25/u17;vec2 l=k*d,h=(l+f*u24)/u25,i=step(h,j);vec4 m=texture2D(u14,g),n=texture2D(u15,h),o=m*n*i.x*i.y,p=texture2D(u22,g);gl_FragColor=o*u24*u24+p;}",
            f: "u14 u15 u17 u23 u24 u25 u22".split(" "),
            g: { u15: 0, u14: 1, u22: 2 }
          },
          s27: { c: "uniform sampler2D u14,u15;varying vec2 vv0;void main(){vec4 a=texture2D(u14,vv0),b=texture2D(u15,vv0);gl_FragColor=a*b;}", f: ["u14", "u15"], g: { u15: 0, u14: 1 }, s: true },
          s28: { c: "uniform sampler2D u1,u22;uniform float u26;varying vec2 vv0;void main(){gl_FragColor=texture2D(u22,vv0)+u26*texture2D(u1,vv0);}", f: ["u1", "u22", "u26"], g: { u1: 0, u22: 1 } },
          s29: {
            c: "varying vec2 vv0;uniform sampler2D u1;const vec4 f=vec4(1.,1.,1.,1.),g=vec4(.299,.587,.114,0.);void main(){vec4 a=texture2D(u1,vv0);gl_FragColor=dot(a,g)*f;}",
            f: u2,
            g: x2,
            precision: "lowp"
          },
          s30: { c: "varying vec2 vv0;uniform sampler2D u1;uniform float u27;const vec3 f=vec3(.299,.587,.114);void main(){vec3 a=texture2D(u1,vv0).rgb,b=texture2D(u1,vv0+vec2(0.,u27)).rgb,c=texture2D(u1,vv0+vec2(u27,u27)).rgb,d=texture2D(u1,vv0+vec2(u27,0.)).rgb;gl_FragColor=vec4(dot(a,f),dot(b,f),dot(c,f),dot(d,f));}", f: ["u1", "u27"], g: x2, precision: "lowp" },
          s31: {
            c: "varying vec2 vv0;uniform sampler2D u1;uniform float u27;const vec3 f=vec3(.299,.587,.114);void main(){vec3 a=texture2D(u1,vv0).rgb,b=texture2D(u1,vv0+vec2(0.,u27)).rgb,c=texture2D(u1,vv0+vec2(u27,u27)).rgb,d=texture2D(u1,vv0+vec2(u27,0.)).rgb;gl_FragColor=vec4(a.r,b.g,c.b,dot(d,f));}",
            f: ["u1", "u27"],
            g: x2,
            precision: "lowp"
          },
          s32: {
            c: "varying vec2 vv0;uniform sampler2D u1,u2;uniform float u28;const vec4 f=vec4(1.,1.,1.,1.);void main(){vec4 a=vec4(0.);a-=texture2D(u1,vec2(vv0.x-u28,vv0.y-u28))*1.,a-=texture2D(u1,vec2(vv0.x-u28,vv0.y))*2.,a-=texture2D(u1,vec2(vv0.x-u28,vv0.y+u28))*1.,a+=texture2D(u1,vec2(vv0.x+u28,vv0.y-u28))*1.,a+=texture2D(u1,vec2(vv0.x+u28,vv0.y))*2.,a+=texture2D(u1,vec2(vv0.x+u28,vv0.y+u28))*1.;vec4 b=vec4(0.);b-=texture2D(u1,vec2(vv0.x-u28,vv0.y-u28))*1.,b-=texture2D(u1,vec2(vv0.x,vv0.y-u28))*2.,b-=texture2D(u1,vec2(vv0.x+u28,vv0.y-u28))*1.,b+=texture2D(u1,vec2(vv0.x-u28,vv0.y+u28))*1.,b+=texture2D(u1,vec2(vv0.x,vv0.y+u28))*2.,b+=texture2D(u1,vec2(vv0.x+u28,vv0.y+u28))*1.;vec3 c=sqrt(a.rgb*a.rgb+b.rgb*b.rgb);vec4 e=vec4(c,texture2D(u1,vv0).a),g=texture2D(u2,vv0);gl_FragColor=g.a*e.r*f;}",
            f: ["u1", "u2", "u28"],
            g: G2,
            s: true
          },
          s33: { c: "varying vec2 vv0;uniform sampler2D u1,u2;uniform float u28;const vec4 j=vec4(1.,1.,1.,1.);const vec2 k=vec2(1.,1.);void main(){float h=0.;vec2 l=k*u28,a,b;float c,d,i=0.;for(float e=-4.;e<=4.;e+=1.)for(float f=-4.;f<=4.;f+=1.)a=vec2(e,f),c=length(a)/2.,d=exp(-c*c),b=vv0+l*a,h+=d*texture2D(u1,b).r,i+=d;vec4 m=texture2D(u2,vv0);gl_FragColor=m.a*(texture2D(u1,b).r-h/i)*j;}", f: ["u1", "u2", "u28"], g: G2, s: true },
          s34: {
            c: "uniform sampler2D u3;uniform vec2 u8;varying vec2 vv0;vec4 e(vec4 a,vec4 b){vec4 c=step(a,b);return mix(a,b,c);}const vec2 g=vec2(.5,.5),h=vec2(1.,0.),i=vec2(0.,1.);void main(){vec2 a=vv0-u8*g;vec4 b=texture2D(u3,a),c=texture2D(u3,a+u8*h),d=texture2D(u3,a+u8*i),j=texture2D(u3,a+u8),k=e(b,c),l=e(d,j);gl_FragColor=e(k,l);}",
            f: ["u3", "u8"],
            g: N2
          },
          s35: { c: "uniform sampler2D u3;uniform vec2 u8;varying vec2 vv0;const vec2 k=vec2(1.,0.),l=vec2(0.,1.),m=vec2(2.,0.),n=vec2(0.,2.);vec4 e(vec4 a,vec4 b){vec4 c=step(a,b);return mix(a,b,c);}vec4 f(vec2 a){vec4 b=texture2D(u3,a),c=texture2D(u3,a+u8*k),d=texture2D(u3,a+u8*l),g=texture2D(u3,a+u8),h=e(b,c),i=e(d,g);return e(h,i);}void main(){vec2 a=vv0+u8*vec2(-.55,-1.05);vec4 b=f(a),c=f(a+u8*m),d=f(a+u8*2.),g=f(a+u8*n),h=e(b,c),i=e(d,g);gl_FragColor=e(h,i);}", f: ["u3", "u8"], g: N2, s: true },
          s36: { c: "uniform sampler2D u1;varying vec2 vv0;void main(){vec4 a=texture2D(u1,vv0);gl_FragColor=a*a;}", f: ["u1"], g: x2, precision: "lowp", s: true },
          s37: {
            c: "uniform sampler2D u1;uniform vec2 u8;varying vec2 vv0;const float e=15444.;void main(){vec4 a=1001./e*texture2D(u1,vv0-3.*u8)+2002./e*texture2D(u1,vv0-2.*u8)+3003./e*texture2D(u1,vv0-u8)+3432./e*texture2D(u1,vv0)+3003./e*texture2D(u1,vv0+u8)+2002./e*texture2D(u1,vv0+2.*u8)+1001./e*texture2D(u1,vv0+3.*u8);gl_FragColor=a;}",
            f: ["u8", "u1"],
            g: x2,
            precision: "lowp",
            s: true
          },
          s38: { c: "uniform sampler2D u1,u11,u29;varying vec2 vv0;const vec4 f=vec4(1.,1.,1.,1.);const float g=.1;void main(){vec4 a=texture2D(u11,vv0),b=texture2D(u29,vv0),c=texture2D(u1,vv0),d=max(f*g,b-a*a),h=sqrt(d);gl_FragColor=(c-a)/h;}", f: ["u1", "u11", "u29"], g: { u1: 0, u11: 1, u29: 2 }, s: true }
        }, S2 = { s39: {
          c: "uniform float u17,u30;uniform sampler2D u14,u15,u22;varying vec2 vv0;const vec2 ZERO2=vec2(0.,0.),ONE2=vec2(1.,1.),HALF2=vec2(.5,.5),EPS2=vec2(1e-5,1e-5);void main(){vec4 sum=texture2D(u22,vv0);float toSparsity=1.1111;vec2 uvFrom,uvWeight,xyPatch=ZERO2,eps2=EPS2/u17,xyTo=floor(vv0*u17+eps2);float weightSize=toSparsity*u17;vec2 halfFromSparsity=ONE2*(toSparsity-1.)/2.;for(float patch_x=0.;patch_x<1.1111;patch_x+=1.){xyPatch.x=patch_x;for(float patch_y=0.;patch_y<1.1111;patch_y+=1.)xyPatch.y=patch_y,uvFrom=(xyTo+HALF2+u30*(xyPatch-halfFromSparsity))/u17,uvFrom+=step(uvFrom,-eps2),uvFrom-=step(ONE2-eps2,uvFrom),uvWeight=(xyTo*toSparsity+xyPatch+HALF2)/weightSize,sum+=texture2D(u14,uvWeight)*texture2D(u15,uvFrom);}gl_FragColor=sum,gl_FragColor*=2.2222;}",
          f: ["u17", "u14", "u15", "u22", "u30"],
          hb: ["1.1111", "gl_FragColor\\*=2.2222;"]
        }, s40: {
          c: "uniform float u17,u30,u25;uniform sampler2D u14,u15,u22;varying vec2 vv0;const vec2 ZERO2=vec2(0.,0.),ONE2=vec2(1.,1.),HALF2=vec2(.5,.5),EPS2=vec2(1e-4,1e-4);void main(){vec4 sum=texture2D(u22,vv0);float fromSparsity=1.1111,shrinkFactor=3.3333;vec2 uvFrom,uvWeight,xyFrom,xyPatchTo,xyPatch=ZERO2,xyShrink=ZERO2,eps2=EPS2/u25,xyTo=floor(vv0*u17+eps2);float weightSize=fromSparsity*u25;vec2 halfFromSparsity=ONE2*(fromSparsity-1.)/2.;float toSparsity=weightSize/u17;vec2 xyFrom0=xyTo*shrinkFactor;for(float patch_x=0.;patch_x<1.1111;patch_x+=1.){xyPatch.x=patch_x;for(float patch_y=0.;patch_y<1.1111;patch_y+=1.){xyPatch.y=patch_y;for(float shrink_x=0.;shrink_x<3.3333;shrink_x+=1.){xyShrink.x=shrink_x;for(float shrink_y=0.;shrink_y<3.3333;shrink_y+=1.)xyShrink.y=shrink_y,xyFrom=xyFrom0+xyShrink+shrinkFactor*u30*(xyPatch-halfFromSparsity),uvFrom=(xyFrom+HALF2)/u25,uvFrom+=step(uvFrom,-eps2),uvFrom-=step(ONE2-eps2,uvFrom),xyPatchTo=xyPatch*shrinkFactor+xyShrink,uvWeight=(xyTo*toSparsity+xyPatchTo+HALF2)/weightSize,sum+=texture2D(u14,uvWeight)*texture2D(u15,uvFrom);}}}gl_FragColor=sum,gl_FragColor*=2.2222;}",
          f: "u17 u25 u14 u15 u22 u30".split(" "),
          hb: ["1.1111", "gl_FragColor\\*=2.2222;", "3.3333"]
        } }, v2 = null, P2 = null, Q2 = { $a: function() {
          return F2;
        }, j: function() {
          if (!F2) {
            v2 = Va(K2, 2);
            P2 = Va(S2, 2);
            q2 = "highp";
            H2.getShaderPrecisionFormat && (H2.getShaderPrecisionFormat(H2.FRAGMENT_SHADER, H2.MEDIUM_FLOAT), H2.getShaderPrecisionFormat(H2.FRAGMENT_SHADER, H2.LOW_FLOAT));
            for (var w2 in v2)
              h2(H2, v2[w2], w2);
            J2.set("s0");
            H2.enableVertexAttribArray(0);
            F2 = true;
          }
        }, uc: function(w2) {
          w2.forEach(function(f2) {
            Q2.tc(f2);
          });
        }, tc: function(w2) {
          v2[w2.id] = w2;
          h2(H2, w2, w2.id);
        }, Sc: function(w2, f2, A2) {
          f2 || (f2 = w2);
          v2[f2] = Object.create(P2[w2]);
          v2[f2].Oe = true;
          P2[w2].hb && P2[w2].hb.forEach(function(L2, l2) {
            v2[f2].c = v2[f2].c.replace(new RegExp(L2, "g"), A2[l2]);
          });
          h2(H2, v2[f2], f2);
        }, set: function(w2) {
          var f2 = v2[w2];
          f2.s && (f2.s = false, h2(H2, f2, w2));
          t2(f2);
        }, Da: function(w2) {
          return r2(w2, n2(), "s41");
        }, bc: function(w2) {
          return r2(w2, { c: "void main(){gl_FragColor=vec4(.5,.5,.5,.5);}", f: [], precision: q2 }, "s42");
        }, pe: function(w2) {
          return typeof v2[w2] === "undefined" ? false : v2[w2].ja;
        }, O: function() {
          m2 !== -1 && (m2 = -1, p2.ya.forEach(function(w2) {
            w2 !== 0 && H2.disableVertexAttribArray(w2);
          }));
        }, cc: function() {
          var w2 = 0;
          p2.ya.forEach(function(f2, A2) {
            A2 = p2.xa[A2];
            H2.vertexAttribPointer(f2, A2, H2.FLOAT, false, p2.mc, w2);
            w2 += 4 * A2;
          });
        }, $f: function() {
          H2.enableVertexAttribArray(0);
        }, ib: function() {
          Q2.jb(H2);
        }, jb: function(w2) {
          w2.vertexAttribPointer(p2.ya[0], 2, w2.FLOAT, false, 8, 0);
        }, Gg: function(w2, f2) {
          H2.uniform1i(p2.m[w2], f2);
        }, D: function(w2, f2) {
          H2.uniform1f(p2.m[w2], f2);
        }, la: function(w2, f2, A2) {
          H2.uniform2f(p2.m[w2], f2, A2);
        }, Hg: function(w2, f2) {
          H2.uniform2fv(p2.m[w2], f2);
        }, Af: function(w2, f2) {
          H2.uniform3fv(p2.m[w2], f2);
        }, Ig: function(w2, f2, A2, L2) {
          H2.uniform3f(p2.m[w2], f2, A2, L2);
        }, Bf: function(w2, f2, A2, L2, l2) {
          H2.uniform4f(p2.m[w2], f2, A2, L2, l2);
        }, Cd: function(w2, f2) {
          H2.uniform4fv(p2.m[w2], f2);
        }, Jg: function(w2, f2) {
          H2.uniformMatrix2fv(p2.m[w2], false, f2);
        }, Kg: function(w2, f2) {
          H2.uniformMatrix3fv(p2.m[w2], false, f2);
        }, Lg: function(w2, f2) {
          H2.uniformMatrix4fv(p2.m[w2], false, f2);
        }, F: function(w2, f2) {
          Q2.set(w2);
          f2.forEach(function(A2) {
            switch (A2.type) {
              case "4f":
                H2.uniform4fv(p2.m[A2.name], A2.value);
                break;
              case "3f":
                H2.uniform3fv(p2.m[A2.name], A2.value);
                break;
              case "2f":
                H2.uniform2fv(p2.m[A2.name], A2.value);
                break;
              case "1f":
                H2.uniform1f(p2.m[A2.name], A2.value);
                break;
              case "1i":
                H2.uniform1i(p2.m[A2.name], A2.value);
                break;
              case "mat2":
                H2.uniformMatrix2fv(p2.m[A2.name], false, A2.value);
                break;
              case "mat3":
                H2.uniformMatrix3fv(p2.m[A2.name], false, A2.value);
                break;
              case "mat4":
                H2.uniformMatrix4fv(p2.m[A2.name], false, A2.value);
            }
          });
        }, lg: function() {
          return "lowp";
        }, i: function() {
          H2.disableVertexAttribArray(0);
          Q2.O();
          for (var w2 in v2) {
            var f2 = v2[w2];
            f2.ja && (f2.ja = false, H2.deleteProgram(f2.ka));
            f2.Oe && delete v2[w2];
          }
          k2.forEach(function(A2) {
            H2.deleteShader(A2);
          });
          k2.splice(0);
          B2 = 0;
          F2 = false;
          p2 = null;
          m2 = -1;
        } };
        return Q2;
      }();
      var H2 = null;
      var eb = function() {
        function b2(q2) {
          console.log("ERROR in ContextFF: ", q2);
          return false;
        }
        function d2(q2) {
          function u2() {
            bb.i();
            cb.reset();
            x2.getExtension("WEBGL_lose_context").loseContext();
          }
          if (navigator.userAgent && navigator.userAgent.indexOf("forceWebGL1") !== -1)
            return false;
          var D2 = document.createElement("canvas");
          D2.setAttribute("width", 5);
          D2.setAttribute("height", 5);
          var x2 = null;
          try {
            x2 = D2.getContext("webgl2", q2);
          } catch (e2) {
            return false;
          }
          if (!x2)
            return false;
          g2(x2);
          cb.Cc(x2);
          q2 = cb.xb(x2);
          if (!q2.ba && !q2.da)
            return u2(), false;
          q2 = bb.yc(x2, q2);
          u2();
          return q2 ? true : false;
        }
        function g2(q2) {
          q2.clearColor(0, 0, 0, 0);
          q2.disable(q2.DEPTH_TEST);
          q2.disable(q2.BLEND);
          q2.disable(q2.DITHER);
          q2.disable(q2.STENCIL_TEST);
          q2.disable(q2.CULL_FACE);
          q2.GENERATE_MIPMAP_HINT && q2.hint(q2.GENERATE_MIPMAP_HINT, q2.FASTEST);
          q2.disable(q2.SAMPLE_ALPHA_TO_COVERAGE);
          q2.disable(q2.SAMPLE_COVERAGE);
          q2.depthFunc(q2.LEQUAL);
          q2.clearDepth(1);
        }
        var h2 = null, t2 = null, r2 = null, n2 = null, k2 = true, m2 = null, p2 = null, B2 = [], F2 = {
          u: function() {
            return h2.width;
          },
          R: function() {
            return h2.height;
          },
          Sa: function() {
            return h2;
          },
          cg: function() {
            return H2;
          },
          fa: function() {
            return k2;
          },
          flush: function() {
            H2.flush();
          },
          ve: function() {
            m2 || (m2 = new Uint8Array(h2.width * h2.height * 4));
            H2.readPixels(0, 0, h2.width, h2.height, H2.RGBA, H2.UNSIGNED_BYTE, m2);
            return m2;
          },
          fg: function() {
            return h2.toDataURL("image/jpeg");
          },
          gg: function() {
            db.N();
            t2 || (t2 = document.createElement("canvas"), r2 = t2.getContext("2d"));
            t2.width = h2.width;
            t2.height = h2.height;
            for (var q2 = F2.ve(), u2 = r2.createImageData(t2.width, t2.height), D2 = t2.width, x2 = t2.height, e2 = u2.data, G2 = 0; G2 < x2; ++G2)
              for (var N2 = x2 - G2 - 1, K2 = 0; K2 < D2; ++K2) {
                var S2 = 4 * (G2 * D2 + K2), v2 = 4 * (N2 * D2 + K2);
                e2[S2] = q2[v2];
                e2[S2 + 1] = q2[v2 + 1];
                e2[S2 + 2] = q2[v2 + 2];
                e2[S2 + 3] = q2[v2 + 3];
              }
            r2.putImageData(u2, 0, 0);
            return t2.toDataURL("image/png");
          },
          eg: function(q2) {
            !t2 && q2 && (t2 = document.createElement("canvas"), r2 = t2.getContext("2d"));
            var u2 = q2 ? t2 : document.createElement("canvas");
            u2.width = h2.width;
            u2.height = h2.height;
            (q2 ? r2 : u2.getContext("2d")).drawImage(h2, 0, 0);
            return u2;
          },
          j: function(q2) {
            q2 = Object.assign({ ca: null, Ub: null, Ka: null, Ac: null, width: 512, height: 512, premultipliedAlpha: false, Wc: true, antialias: false, debug: false, Xf: false }, q2);
            q2.ca ? (H2 = q2.ca, h2 = q2.ca.canvas) : q2.Ac && !q2.Ka ? h2 = document.getElementById(q2.Ac) : q2.Ka && (h2 = q2.Ka);
            h2 || (h2 = document.createElement("canvas"));
            h2.width = q2.width;
            h2.height = q2.height;
            if (H2)
              k2 = H2 instanceof WebGL2RenderingContext;
            else {
              k2 = true;
              var u2 = { antialias: q2.antialias, alpha: true, preserveDrawingBuffer: true, premultipliedAlpha: q2.premultipliedAlpha, stencil: false, depth: q2.Wc };
              navigator && navigator.userAgent && navigator.userAgent.indexOf("noAntialiasing") !== -1 && (u2.antialias = false);
              var D2 = d2(u2);
              !D2 && u2.antialias && (u2.antialias = false, D2 = d2(u2));
              D2 && (H2 = h2.getContext("webgl2", u2));
              H2 ? k2 = true : ((H2 = h2.getContext("webgl", u2)) || (H2 = h2.getContext("experimental-webgl", u2)), k2 = false);
            }
            if (!H2)
              return b2("WebGL1 and 2 are not enabled");
            (n2 = H2.getExtension("WEBGL_lose_context")) && q2.Ub && (p2 = q2.Ub, h2.addEventListener("webglcontextlost", p2, false));
            if (!cb.j())
              return b2("Not enough GL capabilities");
            g2(H2);
            J2.j();
            R2.j();
            if (!bb.yc(H2, cb.te()))
              return b2("Cannot filter float textures");
            B2.forEach(function(x2) {
              x2(H2);
            });
            B2.splice(0);
            return true;
          },
          Sf: function() {
            return new Promise(function(q2) {
              H2 ? q2(H2) : B2.push(q2);
            });
          },
          i: function() {
            H2 && (cb.i(), J2.i(), bb.i());
            n2 && p2 && (h2.removeEventListener("webglcontextlost", p2, false), n2 = p2 = null);
            H2 = m2 = r2 = t2 = h2 = null;
            B2.splice(0);
          }
        };
        return F2;
      }();
      var ab = function() {
        function b2() {
          d2 === null && (typeof J2 !== "undefined" ? d2 = J2 : typeof JEShaders !== "undefined" && (d2 = JEShaders));
        }
        var d2 = null;
        return { reset: function() {
          d2 = null;
        }, zf: function(g2) {
          d2 !== g2 && (d2 && d2.O(), d2 = g2);
        }, $a: function() {
          return d2.$a();
        }, ib: function() {
          return d2.ib();
        }, jb: function(g2) {
          return d2.jb(g2);
        }, cc: function() {
          return d2.cc();
        }, O: function() {
          return d2.O();
        }, set: function(g2) {
          b2();
          return d2.set(g2);
        }, Da: function(g2) {
          b2();
          return d2.Da(g2);
        }, bc: function(g2) {
          b2();
          return d2.bc(g2);
        } };
      }();
      var V2 = function() {
        function b2(l2) {
          H2.bindTexture(H2.TEXTURE_2D, l2);
        }
        function d2(l2) {
          w2[0] = l2;
          l2 = f2[0];
          var C2 = l2 >> 16 & 32768, E2 = l2 >> 12 & 2047, T2 = l2 >> 23 & 255;
          return 103 > T2 ? C2 : 142 < T2 ? C2 | 31744 | ((T2 == 255 ? 0 : 1) && l2 & 8388607) : 113 > T2 ? (E2 |= 2048, C2 | (E2 >> 114 - T2) + (E2 >> 113 - T2 & 1)) : C2 = (C2 | T2 - 112 << 10 | E2 >> 1) + (E2 & 1);
        }
        function g2(l2) {
          var C2 = new Uint16Array(l2.length);
          l2.forEach(function(E2, T2) {
            C2[T2] = d2(E2);
          });
          return C2;
        }
        function h2() {
          if (A2.Gb !== null)
            return A2.Gb;
          var l2 = r2(g2([0.5, 0.5, 0.5, 0.5]));
          return l2 === null ? true : A2.Gb = l2;
        }
        function t2() {
          if (A2.Hb !== null)
            return A2.Hb;
          var l2 = r2(new Uint8Array([127, 127, 127, 127]));
          return l2 === null ? true : A2.Hb = l2;
        }
        function r2(l2) {
          if (!ab.$a() || !x2)
            return null;
          var C2 = null, E2 = Math.sqrt(l2.length / 4);
          try {
            var T2 = H2.getError();
            if (T2 === "FUCKING_BIG_ERROR")
              return false;
            C2 = L2.instance({ isFloat: false, I: true, array: l2, width: E2 });
            T2 = H2.getError();
            if (T2 !== H2.NO_ERROR)
              return false;
          } catch (la) {
            return false;
          }
          db.N();
          H2.viewport(0, 0, E2, E2);
          H2.clearColor(0, 0, 0, 0);
          H2.clear(H2.COLOR_BUFFER_BIT);
          ab.set("s0");
          C2.wc(0);
          R2.h(true, true);
          l2 = 4 * E2 * E2;
          T2 = new Uint8Array(l2);
          H2.readPixels(0, 0, E2, E2, H2.RGBA, H2.UNSIGNED_BYTE, T2);
          E2 = true;
          for (var O2 = 0; O2 < l2; ++O2)
            E2 = E2 && 3 > Math.abs(T2[O2] - 127);
          C2.remove();
          db.aa();
          return E2;
        }
        var n2 = 0, k2 = null, m2 = 0, p2 = null, B2 = null, F2 = null, q2 = null, u2 = null, D2 = null, x2 = false, e2 = [], G2 = { isFloat: false, isPot: true, isLinear: false, isMipmap: false, isAnisotropicFiltering: false, isMirrorX: false, isMirrorY: false, isSrgb: false, isKeepArray: false, isFlipY: null, width: 0, height: 0, url: null, array: null, data: null, A: null, Oc: null, Ne: false, I: false, ia: null, cb: 4, Pb: 0 }, N2 = false, K2 = null, S2 = null, v2 = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]], P2 = false, Q2 = false, w2 = new Float32Array(1), f2 = new Int32Array(w2.buffer), A2 = { Gb: null, Hb: null }, L2 = {
          j: function() {
            x2 || (u2 = [H2.RGBA, null, H2.RGBA, H2.RGBA], D2 = [H2.RGBA, null, H2.RGBA, H2.RGBA], k2 = [
              H2.TEXTURE0,
              H2.TEXTURE1,
              H2.TEXTURE2,
              H2.TEXTURE3,
              H2.TEXTURE4,
              H2.TEXTURE5,
              H2.TEXTURE6,
              H2.TEXTURE7
            ], P2 = typeof JEContext !== "undefined", Q2 = typeof cb !== "undefined", P2 && JEContext.Ag() && k2.push(H2.TEXTURE8, H2.TEXTURE9), p2 = [-1, -1, -1, -1, -1, -1, -1, -1], q2 = [H2.UNSIGNED_BYTE, H2.FLOAT, H2.FLOAT], x2 = true);
          },
          Ie: function() {
            if (!B2) {
              for (var l2 = new Float32Array(16384), C2 = 0; 16384 > C2; ++C2)
                l2[C2] = 2 * Math.random() - 1;
              B2 = { random: L2.instance({ isFloat: true, isPot: true, array: l2, width: 64 }), Kd: L2.instance({ isFloat: false, isPot: true, width: 1, array: new Uint8Array([0, 0, 0, 0]) }) };
            }
            L2.Lf();
          },
          rg: function() {
            return B2.Kd;
          },
          Lf: function() {
            q2[1] = cb.Cb(H2);
          },
          xf: function() {
            D2 = u2 = [H2.RGBA, H2.RGBA, H2.RGBA, H2.RGBA];
          },
          td: function(l2) {
            J2.set("s1");
            db.N();
            var C2 = l2.u(), E2 = l2.R();
            H2.viewport(0, 0, C2, E2);
            l2.b(0);
            R2.h(false, false);
          },
          kf: function(l2, C2) {
            L2.td(l2);
            H2.readPixels(0, 0, l2.u(), l2.R(), H2.RGBA, H2.UNSIGNED_BYTE, C2);
          },
          lf: function(l2, C2) {
            L2.td(l2);
            return cb.ac(0, 0, l2.u(), l2.R(), C2);
          },
          Jc: function(l2, C2, E2, T2, O2, la, ha) {
            l2.activeTexture(l2.TEXTURE0);
            var oa = l2.createTexture();
            l2.bindTexture(l2.TEXTURE_2D, oa);
            O2 = O2 instanceof Float32Array ? O2 : new Float32Array(O2);
            l2.texParameteri(l2.TEXTURE_2D, l2.TEXTURE_WRAP_S, l2.CLAMP_TO_EDGE);
            l2.texParameteri(l2.TEXTURE_2D, l2.TEXTURE_WRAP_T, l2.CLAMP_TO_EDGE);
            l2.texParameteri(l2.TEXTURE_2D, l2.TEXTURE_MAG_FILTER, l2.NEAREST);
            l2.texParameteri(l2.TEXTURE_2D, l2.TEXTURE_MIN_FILTER, l2.NEAREST);
            l2.pixelStorei(l2.UNPACK_FLIP_Y_WEBGL, la);
            l2.texImage2D(l2.TEXTURE_2D, 0, l2.RGBA, E2, T2, 0, l2.RGBA, l2.FLOAT, O2);
            l2.bindTexture(l2.TEXTURE_2D, null);
            l2.pixelStorei(l2.UNPACK_FLIP_Y_WEBGL, false);
            ha && (db.aa(), J2.Da(l2));
            l2.viewport(0, 0, E2, T2);
            l2.framebufferTexture2D(l2.FRAMEBUFFER, l2.COLOR_ATTACHMENT0, l2.TEXTURE_2D, C2, 0);
            l2.bindTexture(l2.TEXTURE_2D, oa);
            ha ? R2.h(true, true) : R2.Pa(l2);
            l2.deleteTexture(oa);
            x2 && (p2[0] = -1, F2 = null, n2 = 0);
          },
          tb: function(l2) {
            l2 !== n2 && (H2.activeTexture(k2[l2]), n2 = l2);
          },
          instance: function(l2) {
            var C2;
            function E2() {
              W2 = y2.A.videoWidth !== void 0 ? y2.A.videoWidth : y2.A.width;
              Y2 = y2.A.videoHeight !== void 0 ? y2.A.videoHeight : y2.A.height;
            }
            function T2(I2) {
              var X2 = H2.getError();
              if (X2 === "FUCKING_BIG_ERROR")
                return false;
              H2.texImage2D(H2.TEXTURE_2D, 0, ma, ia, ja, I2);
              X2 = H2.getError();
              X2 !== H2.NO_ERROR && ia !== H2.RGBA && (ia = H2.RGBA, H2.texImage2D(H2.TEXTURE_2D, 0, ma, ia, ja, I2));
              return true;
            }
            function O2() {
              if (!fb) {
                b2(ka);
                va && H2.pixelStorei(H2.UNPACK_FLIP_Y_WEBGL, va);
                y2.isPot ? (H2.texParameteri(H2.TEXTURE_2D, H2.TEXTURE_WRAP_S, y2.isMirrorX ? H2.MIRRORED_REPEAT : H2.REPEAT), H2.texParameteri(H2.TEXTURE_2D, H2.TEXTURE_WRAP_T, y2.isMirrorY ? H2.MIRRORED_REPEAT : H2.REPEAT)) : (H2.texParameteri(H2.TEXTURE_2D, H2.TEXTURE_WRAP_S, H2.CLAMP_TO_EDGE), H2.texParameteri(H2.TEXTURE_2D, H2.TEXTURE_WRAP_T, H2.CLAMP_TO_EDGE));
                y2.isAnisotropicFiltering && typeof JESETTINGS !== "undefined" && H2.texParameterf(H2.TEXTURE_2D, JEContext.ig().TEXTURE_MAX_ANISOTROPY_EXT, JESETTINGS.Of);
                H2.texParameteri(H2.TEXTURE_2D, H2.TEXTURE_MAG_FILTER, y2.isLinear ? H2.LINEAR : H2.NEAREST);
                y2.isLinear ? H2.texParameteri(H2.TEXTURE_2D, H2.TEXTURE_MIN_FILTER, y2.isMipmap && !Aa ? H2.NEAREST_MIPMAP_LINEAR : H2.LINEAR) : H2.texParameteri(H2.TEXTURE_2D, H2.TEXTURE_MIN_FILTER, y2.isMipmap && !Aa ? H2.NEAREST_MIPMAP_NEAREST : H2.NEAREST);
                ia = u2[y2.cb - 1];
                ma = D2[y2.cb - 1];
                ja = q2[Ba];
                if (cb.fa()) {
                  var I2 = cb.we();
                  ia === H2.RGBA && ja === H2.FLOAT ? y2.isMipmap || y2.isLinear ? ma = bb.ye(H2) : cb.zc() ? I2 && (ma = I2) : ma = H2.RGBA16F || H2.RGBA : ia === H2.RGB && ja === H2.FLOAT && I2 && (ma = I2, ia = H2.RGBA);
                }
                if (y2.I && !y2.isFloat || y2.isFloat && y2.isMipmap && bb.Re())
                  ma = cb.xe(), ja = cb.Cb(H2);
                y2.Pb && (Na = y2.Pb);
                y2.isSrgb && y2.cb === 4 && (ia = JEContext.pg());
                if (y2.A)
                  T2(y2.A);
                else if (y2.url)
                  T2(ya);
                else if (ra) {
                  I2 = ra;
                  try {
                    H2.getError() !== "FUCKING_BIG_ERROR" && (H2.texImage2D(H2.TEXTURE_2D, 0, ma, W2, Y2, 0, ia, ja, I2), H2.getError() !== H2.NO_ERROR && (H2.texImage2D(H2.TEXTURE_2D, 0, ma, W2, Y2, 0, ia, ja, null), H2.getError() !== H2.NO_ERROR && H2.texImage2D(H2.TEXTURE_2D, 0, H2.RGBA, W2, Y2, 0, H2.RGBA, H2.UNSIGNED_BYTE, null)));
                  } catch (Tb) {
                    H2.texImage2D(H2.TEXTURE_2D, 0, ma, W2, Y2, 0, ia, ja, null);
                  }
                  y2.isKeepArray || (ra = null);
                } else
                  I2 = H2.getError(), I2 !== "FUCKING_BIG_ERROR" && (H2.texImage2D(H2.TEXTURE_2D, 0, ma, W2, Y2, 0, ia, ja, null), I2 = H2.getError(), I2 !== H2.NO_ERROR && (ia = H2.RGBA, y2.I && ja !== H2.FLOAT && (ja = H2.FLOAT, H2.texImage2D(H2.TEXTURE_2D, 0, ma, W2, Y2, 0, ia, ja, null))));
                if (y2.isMipmap) {
                  if (!Aa && ea)
                    ea.Ab(), Oa = true;
                  else if (Aa) {
                    I2 = Math.log2(Math.min(W2, Y2));
                    Ea = Array(1 + I2);
                    Ea[0] = ka;
                    for (var X2 = 1; X2 <= I2; ++X2) {
                      var na = Math.pow(2, X2), aa = W2 / na;
                      na = Y2 / na;
                      var Ca = H2.createTexture();
                      b2(Ca);
                      H2.texParameteri(H2.TEXTURE_2D, H2.TEXTURE_MIN_FILTER, H2.NEAREST);
                      H2.texParameteri(H2.TEXTURE_2D, H2.TEXTURE_MAG_FILTER, H2.NEAREST);
                      H2.texImage2D(H2.TEXTURE_2D, 0, ma, aa, na, 0, ia, ja, null);
                      b2(null);
                      Ea[X2] = Ca;
                    }
                    Oa = true;
                  }
                }
                b2(null);
                p2[n2] = -1;
                va && H2.pixelStorei(H2.UNPACK_FLIP_Y_WEBGL, false);
                Ia = true;
                y2.ia && ea && (y2.ia(ea), y2.ia = null);
              }
            }
            function la() {
              for (var I2 = W2 * Y2, X2 = 2 * I2, na = 3 * I2, aa = 0; aa < I2; ++aa)
                ta[0][aa] = Ja[aa], ta[1][aa] = Ja[aa + I2], ta[2][aa] = Ja[aa + X2], ta[3][aa] = Ja[aa + na];
            }
            function ha() {
              var I2 = W2 * Y2 * 4;
              xa = [new Uint8Array(I2), new Uint8Array(I2), new Uint8Array(I2), new Uint8Array(I2)];
              ta = [
                new Float32Array(xa[0].buffer),
                new Float32Array(xa[1].buffer),
                new Float32Array(xa[2].buffer),
                new Float32Array(xa[3].buffer)
              ];
              Pa = new Uint8Array(4 * I2);
              Ja = new Float32Array(Pa.buffer);
              Ka = true;
            }
            function oa() {
              C2 = new Uint8Array(W2 * Y2 * 4);
              gb = new Float32Array(C2.buffer);
              Za = true;
            }
            var y2 = Object.assign({}, G2, l2), ca = m2++;
            y2.isFlipY === null && (y2.isFlipY = y2.url || y2.array ? true : false);
            y2.data && (y2.array = typeof y2.data === "string" ? $a(y2.data) : y2.isFloat ? new Float32Array(y2.data) : new Uint8Array(y2.data), y2.isFlipY = false);
            var Ba = 0, za = y2.A ? true : false, z2 = null, M2 = null, ba = false, U2 = null;
            y2.I = y2.I || y2.isFloat;
            y2.I && (Ba = 1);
            !y2.Ne && y2.isFloat && Q2 && !cb.zc() && (y2.isFloat = false);
            y2.isFloat && (Ba = 2);
            y2.isAnisotropicFiltering && P2 && !JEContext.ug() && (y2.isAnisotropicFiltering = false);
            var ka = y2.Oc || H2.createTexture(), ya = null, ra = false, W2 = 0, Y2 = 0, Ia = false, fb = false, Ka = false, ta = null, xa = null, Pa = null, Ja = null, ma = null, ia = null, ja = null, va = y2.isFlipY, Cb = (l2 = y2.I && y2.isMipmap) && bb.$d(), Aa = l2 && Cb ? true : false, Ea = null, Na = -1, Oa = false;
            var Za = false;
            var gb = C2 = null;
            y2.width && (W2 = y2.width, Y2 = y2.height ? y2.height : W2);
            var ea = {
              get: function() {
                return ka;
              },
              u: function() {
                return W2;
              },
              R: function() {
                return Y2;
              },
              sg: function() {
                return y2.url;
              },
              vg: function() {
                return y2.isFloat;
              },
              xg: function() {
                return y2.I;
              },
              yg: function() {
                return y2.isLinear;
              },
              Ab: function() {
                H2.generateMipmap(H2.TEXTURE_2D);
              },
              Yd: function(I2, X2) {
                Aa ? (I2 || (I2 = ea.Mc()), L2.tb(X2), b2(Ea[I2]), p2[X2] = -1) : ea.b(X2);
              },
              Mc: function() {
                Na === -1 && (Na = Math.log(W2) / Math.log(2));
                return Na;
              },
              se: function(I2) {
                if (Aa) {
                  I2 || (I2 = ea.Mc());
                  J2.set("s12");
                  L2.tb(0);
                  for (var X2 = W2, na = Y2, aa = 1; aa <= I2; ++aa)
                    X2 /= 2, na /= 2, J2.la("u8", 0.25 / X2, 0.25 / na), H2.viewport(0, 0, X2, na), b2(Ea[aa - 1]), H2.framebufferTexture2D(db.Ua(), H2.COLOR_ATTACHMENT0, H2.TEXTURE_2D, Ea[aa], 0), R2.h(false, aa === 1);
                  p2[0] = -1;
                } else
                  ea.Ab();
              },
              Fg: function(I2) {
                (za = !(Array.isArray(I2) || I2.constructor === Float32Array || I2.constructor === Uint8Array)) ? (ra = null, y2.A = I2, E2()) : ra = I2;
              },
              b: function(I2) {
                if (!Ia)
                  return false;
                L2.tb(I2);
                if (p2[I2] === ca)
                  return false;
                b2(ka);
                p2[I2] = ca;
                return true;
              },
              wc: function(I2) {
                H2.activeTexture(k2[I2]);
                n2 = I2;
                b2(ka);
                p2[I2] = ca;
              },
              l: function() {
                F2 = ea;
                H2.framebufferTexture2D(db.Ua(), H2.COLOR_ATTACHMENT0, H2.TEXTURE_2D, ka, 0);
              },
              S: function() {
                F2 = ea;
                H2.viewport(0, 0, W2, Y2);
                H2.framebufferTexture2D(db.Ua(), H2.COLOR_ATTACHMENT0, H2.TEXTURE_2D, ka, 0);
              },
              kc: L2.kc,
              resize: function(I2, X2) {
                W2 = I2;
                Y2 = X2;
                O2();
              },
              clone: function(I2) {
                I2 = L2.instance({ width: W2, height: Y2, I: y2.I, isFloat: y2.isFloat, isLinear: y2.isLinear, isMirrorY: y2.isMirrorY, isFlipY: I2 ? !va : va, isPot: y2.isPot });
                ab.set("s0");
                db.aa();
                I2.l();
                H2.viewport(0, 0, W2, Y2);
                ea.b(0);
                R2.h(true, true);
                return I2;
              },
              Cf: function() {
                H2.viewport(0, 0, W2, Y2);
              },
              remove: function() {
                H2.deleteTexture(ka);
                fb = true;
                e2.splice(e2.indexOf(ea), 1);
                ea = null;
              },
              refresh: function() {
                ea.wc(0);
                va && H2.pixelStorei(H2.UNPACK_FLIP_Y_WEBGL, true);
                za ? H2.texImage2D(H2.TEXTURE_2D, 0, ma, ia, ja, y2.A) : H2.texImage2D(H2.TEXTURE_2D, 0, ma, W2, Y2, 0, ia, ja, ra);
                va && H2.pixelStorei(H2.UNPACK_FLIP_Y_WEBGL, false);
              },
              $b: function() {
                Ka || ha();
                H2.readPixels(0, 0, W2, 4 * Y2, H2.RGBA, H2.UNSIGNED_BYTE, Pa);
                la();
                return ta;
              },
              ff: function() {
                Ka || ha();
                return cb.ac(0, 0, W2, 4 * Y2, Pa).then(function() {
                  la();
                  return ta;
                });
              },
              hf: function() {
                Za || oa();
                H2.readPixels(0, 0, W2, Y2, H2.RGBA, H2.UNSIGNED_BYTE, C2);
                return gb;
              },
              gf: function() {
                Za || oa();
                return cb.ac(0, 0, W2, Y2, C2);
              },
              yb: function(I2) {
                db.N();
                J2.set("s13");
                ea.b(0);
                if (I2)
                  H2.viewport(0, 0, W2, Y2), J2.Bf("u9", 0.25, 0.25, 0.25, 0.25), R2.h(false, true);
                else
                  for (I2 = 0; 4 > I2; ++I2)
                    H2.viewport(0, Y2 * I2, W2, Y2), J2.Cd("u9", v2[I2]), R2.h(false, I2 === 0);
              },
              lc: function(I2) {
                var X2 = ja === q2[0] && !t2();
                b2(ka);
                va && H2.pixelStorei(H2.UNPACK_FLIP_Y_WEBGL, true);
                X2 ? (ba || (z2 = document.createElement("canvas"), z2.width = W2, z2.height = Y2, M2 = z2.getContext("2d"), U2 = M2.createImageData(W2, Y2), ba = true), U2.data.set(I2), M2.putImageData(U2, 0, 0), H2.texImage2D(H2.TEXTURE_2D, 0, ma, ia, ja, z2)) : H2.texImage2D(H2.TEXTURE_2D, 0, ma, W2, Y2, 0, ia, ja, I2);
                p2[n2] = ca;
                va && H2.pixelStorei(H2.UNPACK_FLIP_Y_WEBGL, false);
              },
              Og: function(I2, X2) {
                b2(ka);
                X2 && H2.pixelStorei(H2.UNPACK_FLIP_Y_WEBGL, true);
                H2.texImage2D(H2.TEXTURE_2D, 0, ma, ia, ja, I2);
                p2[n2] = ca;
                X2 && H2.pixelStorei(H2.UNPACK_FLIP_Y_WEBGL, false);
              },
              Eg: function(I2, X2) {
                var na = W2 * Y2, aa = 4 * na;
                I2 = y2.I ? I2 ? "RGBE" : "JSON" : "RGBA";
                X2 && (I2 = X2);
                X2 = cb.fa() && false;
                var Ca = null;
                switch (I2) {
                  case "RGBE":
                    Ca = "s43";
                    break;
                  case "JSON":
                    Ca = X2 ? "s0" : "s13";
                    break;
                  case "RGBA":
                  case "RGBAARRAY":
                    Ca = "s7";
                }
                Ka || (I2 === "RGBA" || I2 === "RGBE" || I2 === "RGBAARRAY" ? (xa = new Uint8Array(aa), Ka = true) : I2 !== "JSON" || X2 || ha());
                db.N();
                J2.set(Ca);
                ea.b(0);
                aa = null;
                if (I2 === "RGBA" || I2 === "RGBE" || I2 === "RGBAARRAY") {
                  H2.viewport(0, 0, W2, Y2);
                  R2.h(true, true);
                  H2.readPixels(0, 0, W2, Y2, H2.RGBA, H2.UNSIGNED_BYTE, xa);
                  if (I2 === "RGBAARRAY")
                    return { data: xa };
                  N2 || (K2 = document.createElement("canvas"), S2 = K2.getContext("2d"), N2 = true);
                  K2.width = W2;
                  K2.height = Y2;
                  na = S2.createImageData(W2, Y2);
                  na.data.set(xa);
                  S2.putImageData(na, 0, 0);
                  aa = K2.toDataURL("image/png");
                } else if (I2 === "JSON")
                  if (X2)
                    aa = new Float32Array(na), H2.viewport(0, 0, W2, Y2), R2.h(true, true), H2.readPixels(0, 0, W2, Y2, H2.RGBA, H2.FLOAT, aa);
                  else {
                    for (aa = 0; 4 > aa; ++aa)
                      H2.viewport(0, Y2 * aa, W2, Y2), J2.Cd("u9", v2[aa]), R2.h(!aa, !aa);
                    ea.$b();
                    aa = Array(na);
                    for (X2 = 0; X2 < na; ++X2)
                      aa[4 * X2] = ta[0][X2], aa[4 * X2 + 1] = ta[1][X2], aa[4 * X2 + 2] = ta[2][X2], aa[4 * X2 + 3] = ta[3][X2];
                  }
                return { format: I2, data: aa, width: W2, height: Y2, isMirrorY: y2.isMirrorY, isFlipY: I2 === "RGBA" ? y2.isFlipY : !y2.isFlipY };
              }
            };
            y2.isMipmap && !Aa && Ia && !Oa && (ea.Ab(), Oa = true);
            if (y2.url)
              b2(ka), H2.texImage2D(H2.TEXTURE_2D, 0, H2.RGBA, 1, 1, 0, H2.RGBA, H2.UNSIGNED_BYTE, null), ya = new Image(), ya.a = "Anonymous", ya.crossOrigin = "Anonymous", ya.src = y2.url, ya.onload = function() {
                W2 = ya.width;
                Y2 = ya.height;
                O2();
              };
            else if (y2.A) {
              var hb = function() {
                E2();
                W2 ? O2() : setTimeout(hb, 1);
              };
              hb();
            } else
              y2.array ? (y2.I && !y2.isFloat ? y2.array instanceof Uint16Array ? (ra = y2.array, O2()) : h2() ? (ra = g2(y2.array), O2()) : (O2(), L2.Jc(H2, ka, ea.u(), ea.R(), y2.array, va, true)) : (ra = y2.isFloat ? y2.array instanceof Float32Array ? y2.array : new Float32Array(y2.array) : y2.array instanceof Uint8Array ? y2.array : new Uint8Array(y2.array), O2()), y2.isKeepArray || (ra && ra !== y2.array && (ra = null), delete y2.array)) : y2.Oc ? Ia = true : O2();
            ea.og = ea.u;
            y2.ia && Ia && (y2.ia(ea), y2.ia = null);
            e2.push(ea);
            return ea;
          },
          N: function(l2) {
            l2 !== n2 && (H2.activeTexture(k2[l2]), n2 = l2);
            p2[l2] = -1;
            b2(null);
          },
          Rf: function(l2) {
            B2.random.b(l2);
          },
          kc: function() {
            F2 = null;
            H2.framebufferTexture2D(db.Ua(), H2.COLOR_ATTACHMENT0, H2.TEXTURE_2D, null, 0);
          },
          reset: function() {
            n2 !== 0 && H2.activeTexture(k2[0]);
            for (var l2 = 0; l2 < k2.length; ++l2)
              p2[l2] = -1;
            n2 = -1;
          },
          Dg: function() {
            n2 = -1;
          },
          Hf: function() {
            for (var l2 = 0; l2 < k2.length; ++l2)
              L2.N(l2);
          },
          Kc: function() {
            B2 && (B2.random.remove(), B2.Kd.remove());
          },
          Ng: function(l2, C2) {
            if (l2.format === "RGBA" || l2.format === "RGBE") {
              var E2 = new Image();
              E2.src = l2.data;
              E2.onload = function() {
                L2.instance({ isMirrorY: l2.isMirrorY, isFlipY: l2.isFlipY, isFloat: false, A: E2, ia: function(T2) {
                  if (l2.format === "RGBA")
                    C2(T2);
                  else {
                    var O2 = l2.width, la = l2.height, ha = L2.instance({ isMirrorY: l2.isMirrorY, isFloat: true, width: O2, height: la, isFlipY: l2.isFlipY });
                    db.aa();
                    H2.viewport(0, 0, O2, la);
                    J2.set("s44");
                    ha.l();
                    T2.b(0);
                    R2.h(true, true);
                    L2.N(0);
                    C2(ha);
                    cb.flush();
                    setTimeout(T2.remove, 50);
                  }
                } });
              };
            } else
              l2.format === "JSON" ? C2(L2.instance({ isFloat: true, isFlipY: l2.isFlipY, width: l2.width, height: l2.height, array: new Float32Array(l2.data) })) : C2(false);
          },
          de: g2,
          i: function() {
            F2 && (db.aa(), L2.kc(), db.N());
            L2.Hf();
            e2.slice(0).forEach(function(l2) {
              l2.remove();
            });
            e2.splice(0);
            x2 = false;
            m2 = 0;
            typeof bb !== "undefined" && bb.i();
            B2 = null;
          }
        };
        return L2;
      }();
      var ib = { instance: function(b2) {
        var d2 = [V2.instance(b2), V2.instance(b2)], g2 = [d2[1], d2[0]], h2 = g2, t2 = { Bd: function(r2) {
          h2[1].l();
          h2[0].b(r2);
          t2.Fd();
        }, uf: function(r2) {
          h2[1].S();
          h2[0].b(r2);
          t2.Fd();
        }, Fd: function() {
          h2 = h2 === d2 ? g2 : d2;
        }, refresh: function() {
          h2[0].refresh();
          h2[1].refresh();
        }, b: function(r2) {
          h2[0].b(r2);
        }, Qf: function(r2) {
          h2[1].b(r2);
        }, Be: function() {
          return h2[0];
        }, mg: function() {
          return h2[1];
        }, lc: function(r2) {
          h2[0].lc(r2);
          h2[1].lc(r2);
        }, remove: function() {
          h2[0].remove();
          h2[1].remove();
          h2 = null;
        }, sync: function() {
          t2.uf(0);
          J2.set("s0");
          R2.h(false, false);
        } };
        return t2;
      } };
      var R2 = function() {
        function b2(m2) {
          var p2 = { $: null, C: null };
          p2.$ = m2.createBuffer();
          m2.bindBuffer(m2.ARRAY_BUFFER, p2.$);
          m2.bufferData(m2.ARRAY_BUFFER, new Float32Array([-1, -1, 3, -1, -1, 3]), m2.STATIC_DRAW);
          p2.C = m2.createBuffer();
          m2.bindBuffer(m2.ELEMENT_ARRAY_BUFFER, p2.C);
          m2.bufferData(m2.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2]), m2.STATIC_DRAW);
          return p2;
        }
        var d2 = null, g2 = 0, h2 = false, t2 = [], r2 = -2, n2 = -2, k2 = { reset: function() {
          n2 = r2 = -2;
        }, j: function() {
          h2 || (d2 = b2(H2), k2.ub(), h2 = true);
        }, instance: function(m2) {
          var p2 = g2++, B2 = m2.C ? m2.C.length : 0, F2 = typeof m2.mode === "undefined" ? H2.STATIC_DRAW : m2.mode, q2 = H2.createBuffer();
          H2.bindBuffer(H2.ARRAY_BUFFER, q2);
          H2.bufferData(H2.ARRAY_BUFFER, m2.$ instanceof Float32Array ? m2.$ : new Float32Array(m2.$), F2);
          r2 = p2;
          var u2 = null, D2 = null, x2 = null;
          if (m2.C) {
            u2 = H2.createBuffer();
            H2.bindBuffer(H2.ELEMENT_ARRAY_BUFFER, u2);
            var e2 = null;
            65536 > m2.C.length ? (e2 = Uint16Array, D2 = H2.UNSIGNED_SHORT, x2 = 2) : (e2 = Uint32Array, D2 = H2.UNSIGNED_INT, x2 = 4);
            e2 = m2.C instanceof e2 ? m2.C : new e2(m2.C);
            H2.bufferData(H2.ELEMENT_ARRAY_BUFFER, e2, F2);
            n2 = p2;
          }
          var G2 = { Zd: function(N2) {
            r2 !== p2 && (H2.bindBuffer(H2.ARRAY_BUFFER, q2), r2 = p2);
            N2 && ab.cc();
          }, Wd: function() {
            n2 !== p2 && (H2.bindBuffer(H2.ELEMENT_ARRAY_BUFFER, u2), n2 = p2);
          }, bind: function(N2) {
            G2.Zd(N2);
            G2.Wd();
          }, Yf: function() {
            H2.drawElements(H2.TRIANGLES, B2, D2, 0);
          }, Zf: function(N2, K2) {
            H2.drawElements(H2.TRIANGLES, N2, D2, K2 * x2);
          }, remove: function() {
            H2.deleteBuffer(q2);
            m2.C && H2.deleteBuffer(u2);
            G2 = null;
          } };
          t2.push(G2);
          return G2;
        }, ub: function() {
          r2 !== -1 && (H2.bindBuffer(H2.ARRAY_BUFFER, d2.$), r2 = -1);
          n2 !== -1 && (H2.bindBuffer(H2.ELEMENT_ARRAY_BUFFER, d2.C), n2 = -1);
        }, h: function(m2, p2) {
          m2 && R2.ub();
          p2 && ab.ib();
          H2.drawElements(H2.TRIANGLES, 3, H2.UNSIGNED_SHORT, 0);
        }, Pa: function(m2) {
          m2 = m2 || H2;
          var p2 = b2(m2);
          m2.bindBuffer(m2.ARRAY_BUFFER, p2.$);
          m2.bindBuffer(m2.ELEMENT_ARRAY_BUFFER, p2.C);
          ab.jb(m2);
          m2.clear(m2.COLOR_BUFFER_BIT);
          m2.drawElements(m2.TRIANGLES, 3, m2.UNSIGNED_SHORT, 0);
          m2.flush();
          m2.bindBuffer(m2.ARRAY_BUFFER, null);
          m2.bindBuffer(m2.ELEMENT_ARRAY_BUFFER, null);
          m2.deleteBuffer(p2.$);
          m2.deleteBuffer(p2.C);
          k2.reset();
          h2 && (k2.ub(), ab.ib());
        }, Kc: function() {
          var m2 = H2, p2 = d2;
          m2.deleteBuffer(p2.$);
          m2.deleteBuffer(p2.C);
        }, i: function() {
          k2.Kc();
          t2.forEach(function(m2) {
            m2.remove();
          });
          H2.bindBuffer(H2.ARRAY_BUFFER, null);
          H2.bindBuffer(H2.ELEMENT_ARRAY_BUFFER, null);
          k2.reset();
          h2 = false;
          t2.splice(0);
          g2 = 0;
        } };
        return k2;
      }();
      var db = function() {
        var b2 = null, d2 = null, g2 = null, h2 = false, t2 = [], r2 = { B: -2, Ic: 1 }, n2 = { $a: function() {
          return h2;
        }, j: function() {
          if (!h2) {
            b2 = H2.createFramebuffer();
            var k2 = cb.fa();
            d2 = k2 && H2.DRAW_FRAMEBUFFER ? H2.DRAW_FRAMEBUFFER : H2.FRAMEBUFFER;
            g2 = k2 && H2.READ_FRAMEBUFFER ? H2.READ_FRAMEBUFFER : H2.FRAMEBUFFER;
            h2 = true;
          }
        }, jg: function() {
          return d2;
        }, ze: function() {
          return g2;
        }, Ua: function() {
          return H2.FRAMEBUFFER;
        }, ng: function() {
          return r2;
        }, bg: function() {
          return b2;
        }, instance: function(k2) {
          k2.Vc === void 0 && (k2.Vc = false);
          var m2 = k2.ta ? k2.ta : null, p2 = k2.width, B2 = k2.height !== void 0 ? k2.height : k2.width, F2 = b2, q2 = null, u2 = false, D2 = false, x2 = 0;
          m2 && (p2 = p2 ? p2 : m2.u(), B2 = B2 ? B2 : m2.R());
          var e2 = { Ad: function() {
            u2 || (F2 = H2.createFramebuffer(), u2 = true, x2 = r2.Ic++);
          }, Qd: function() {
            e2.Ad();
            e2.l();
            q2 = H2.createRenderbuffer();
            H2.bindRenderbuffer(H2.RENDERBUFFER, q2);
            H2.renderbufferStorage(H2.RENDERBUFFER, H2.DEPTH_COMPONENT16, p2, B2);
            H2.framebufferRenderbuffer(d2, H2.DEPTH_ATTACHMENT, H2.RENDERBUFFER, q2);
            H2.clearDepth(1);
          }, bind: function(G2, N2) {
            x2 !== r2.B && (H2.bindFramebuffer(d2, F2), r2.B = x2);
            m2 && m2.l();
            N2 && H2.viewport(0, 0, p2, B2);
            G2 && H2.clear(H2.COLOR_BUFFER_BIT | H2.DEPTH_BUFFER_BIT);
          }, Pf: function() {
            x2 !== r2.B && (H2.bindFramebuffer(d2, F2), r2.B = x2);
          }, clear: function() {
            H2.clear(H2.COLOR_BUFFER_BIT | H2.DEPTH_BUFFER_BIT);
          }, Vf: function() {
            H2.clear(H2.COLOR_BUFFER_BIT);
          }, Wf: function() {
            H2.clear(H2.DEPTH_BUFFER_BIT);
          }, Cf: function() {
            H2.viewport(0, 0, p2, B2);
          }, l: function() {
            x2 !== r2.B && (H2.bindFramebuffer(d2, F2), r2.B = x2);
          }, rtt: function(G2) {
            m2 = G2;
            r2.B !== x2 && (H2.bindFramebuffer(H2.FRAMEBUFFER, F2), r2.B = x2);
            G2.l();
          }, N: function() {
            H2.bindFramebuffer(d2, null);
            r2.B = -1;
          }, resize: function(G2, N2) {
            p2 = G2;
            B2 = N2;
            q2 && (H2.bindRenderbuffer(H2.RENDERBUFFER, q2), H2.renderbufferStorage(H2.RENDERBUFFER, H2.DEPTH_COMPONENT16, p2, B2));
          }, remove: function() {
            F2 === b2 || D2 || (H2.bindFramebuffer(d2, F2), H2.framebufferTexture2D(d2, H2.COLOR_ATTACHMENT0, H2.TEXTURE_2D, null, 0), q2 && H2.framebufferRenderbuffer(d2, H2.DEPTH_ATTACHMENT, H2.RENDERBUFFER, null), H2.bindFramebuffer(d2, null), H2.deleteFramebuffer(F2), q2 && H2.deleteRenderbuffer(q2));
            D2 = true;
          } };
          k2.Vc && e2.Qd();
          t2.push(e2);
          return e2;
        }, N: function() {
          H2.bindFramebuffer(d2, null);
          r2.B = -1;
        }, If: function() {
          H2.bindFramebuffer(d2, null);
          H2.clear(H2.COLOR_BUFFER_BIT | H2.DEPTH_BUFFER_BIT);
          cb.Dd();
          r2.B = -1;
        }, reset: function() {
          r2.B = -2;
        }, aa: function() {
          r2.B !== 0 && (H2.bindFramebuffer(d2, b2), r2.B = 0);
        }, clear: function() {
          cb.Dd();
          H2.clear(H2.COLOR_BUFFER_BIT);
        }, i: function() {
          n2.N();
          t2.forEach(function(k2) {
            k2.remove();
          });
          b2 !== null && (H2.deleteFramebuffer(b2), b2 = null);
          n2.reset();
          h2 = false;
          t2.splice(0);
          r2.Ic = 1;
        } };
        return n2;
      }();
      var cb = function() {
        function b2() {
          t2 = typeof eb === "undefined" ? JEContext : eb;
          r2 = true;
        }
        function d2(e2, G2) {
          for (var N2 = 0; N2 < e2.length; ++N2) {
            var K2 = G2.getExtension(e2[N2]);
            if (K2)
              return K2;
          }
          return null;
        }
        function g2() {
          u2.nb !== null && (clearInterval(u2.nb), u2.nb = null);
          u2.oa = false;
        }
        function h2() {
          u2.za && (H2.deleteSync(u2.za), u2.za = null);
        }
        var t2 = null, r2 = false, n2 = { Xc: false, ec: null, fc: null, $c: false, Qe: false, hc: null, ad: false, ic: null, Yc: false, vb: null, Ke: false, wb: null, Le: false }, k2 = null, m2 = { ba: true, da: true, zb: true, sd: false }, p2 = null, B2 = true, F2 = null, q2 = null, u2 = { oa: false, na: null, za: null, Fb: -1, V: null, nb: null }, D2 = typeof window === "undefined" ? {} : window, x2 = {
          j: function() {
            if (r2)
              return true;
            x2.reset();
            r2 || b2();
            var e2 = H2;
            if (!k2.Xc) {
              k2.ec = x2.Fc(e2);
              D2.GL_EXT_FLOAT = k2.ec;
              k2.$c = k2.ec ? true : false;
              if (k2.$c || x2.fa())
                k2.fc = x2.Gc(e2), k2.Qe = k2.fc ? true : false, D2.GL_EXT_FLOATLINEAR = k2.fc;
              k2.Xc = true;
            }
            if (!k2.Yc) {
              k2.hc = x2.Na(e2);
              k2.hc && (k2.ad = true, D2.GL_EXT_HALFFLOAT = k2.hc);
              if (k2.ad || x2.fa())
                k2.ic = x2.Hc(e2), D2.GL_EXT_HALFFLOATLINEAR = k2.ic;
              k2.tg = k2.ic ? true : false;
              k2.Yc = true;
            }
            k2.vb = x2.Dc(e2);
            k2.Ke = k2.vb ? true : false;
            D2.GL_EXT_COLORBUFFERFLOAT = k2.vb;
            k2.wb = x2.Ec(e2);
            k2.Le = k2.wb ? true : false;
            D2.GL_EXT_COLORBUFFERHALFFLOAT = k2.wb;
            db.j();
            V2.j();
            if (!x2.ge())
              return false;
            R2.j();
            V2.Ie();
            return true;
          },
          reset: function() {
            k2 = Object.assign({}, n2);
            p2 = Object.assign({}, m2);
          },
          u: function() {
            r2 || b2();
            return t2.u();
          },
          R: function() {
            r2 || b2();
            return t2.R();
          },
          fa: function() {
            r2 || b2();
            return t2.fa();
          },
          Cc: function(e2) {
            x2.Dc(e2);
            x2.Ec(e2);
            x2.Fc(e2);
            x2.Gc(e2);
            x2.Na(e2);
            x2.Hc(e2);
          },
          Dc: d2.bind(null, ["EXT_color_buffer_float", "WEBGL_color_buffer_float", "OES_color_buffer_float"]),
          Ec: d2.bind(null, ["EXT_color_buffer_half_float", "WEBGL_color_buffer_half_float", "OES_color_buffer_half_float"]),
          Fc: d2.bind(null, ["OES_texture_float", "MOZ_OES_texture_float", "WEBKIT_OES_texture_float"]),
          Gc: d2.bind(null, ["OES_texture_float_linear", "MOZ_OES_texture_float_linear", "WEBKIT_OES_texture_float_linear"]),
          Na: d2.bind(null, ["OES_texture_half_float", "MOZ_OES_texture_half_float", "WEBKIT_OES_texture_half_float"]),
          Hc: d2.bind(null, ["OES_texture_half_float_linear", "MOZ_OES_texture_half_float_linear", "WEBKIT_OES_texture_half_float_linear"]),
          Cb: function(e2) {
            var G2 = x2.Na(e2);
            return G2 && G2.HALF_FLOAT_OES ? G2.HALF_FLOAT_OES : e2.HALF_FLOAT || e2.FLOAT;
          },
          we: function() {
            return q2 || H2.RGBA32F || H2.RGBA;
          },
          xe: function() {
            return F2 || H2.RGBA16F || H2.RGBA;
          },
          te: function() {
            return p2;
          },
          zc: function() {
            return p2.ba;
          },
          Uf: function() {
            return p2.da;
          },
          Tf: function() {
            return p2.zb;
          },
          ae: function() {
            return p2.sd && B2;
          },
          Jd: function(e2) {
            B2 = e2;
            !e2 && u2.oa && (h2(), H2.bindBuffer(u2.V, null), u2.oa = false);
          },
          zg: function() {
            return u2.oa;
          },
          lb: function(e2, G2, N2) {
            function K2() {
              e2.bindTexture(e2.TEXTURE_2D, null);
              e2.bindFramebuffer(S2, null);
              e2.deleteTexture(Q2);
              e2.deleteFramebuffer(P2);
            }
            var S2 = e2.FRAMEBUFFER, v2 = e2.NEAREST, P2 = e2.createFramebuffer();
            e2.bindFramebuffer(S2, P2);
            var Q2 = e2.createTexture();
            e2.activeTexture(e2.TEXTURE0);
            e2.bindTexture(e2.TEXTURE_2D, Q2);
            e2.pixelStorei(e2.UNPACK_FLIP_Y_WEBGL, false);
            e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_S, e2.CLAMP_TO_EDGE);
            e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_T, e2.CLAMP_TO_EDGE);
            e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MAG_FILTER, v2);
            e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MIN_FILTER, v2);
            e2.texImage2D(e2.TEXTURE_2D, 0, G2, 3, 3, 0, e2.RGBA, N2, null);
            e2.framebufferTexture2D(e2.FRAMEBUFFER, e2.COLOR_ATTACHMENT0, e2.TEXTURE_2D, Q2, 0);
            if (e2.checkFramebufferStatus(e2.READ_FRAMEBUFFER || e2.FRAMEBUFFER) !== e2.FRAMEBUFFER_COMPLETE)
              return K2(), false;
            ab.bc(e2);
            e2.clearColor(0, 0, 0, 0);
            e2.viewport(0, 0, 3, 3);
            e2.disable(e2.DEPTH_TEST);
            e2.clear(e2.COLOR_BUFFER_BIT);
            R2.Pa(e2);
            e2.bindFramebuffer(S2, null);
            ab.Da(e2);
            e2.activeTexture(e2.TEXTURE0);
            e2.bindTexture(e2.TEXTURE_2D, Q2);
            R2.Pa(e2);
            G2 = new Uint8Array(36);
            e2.readPixels(0, 0, 3, 3, e2.RGBA, e2.UNSIGNED_BYTE, G2);
            K2();
            for (N2 = 0; 36 > N2; ++N2)
              if (N2 % 4 !== 3 && 3 < Math.abs(G2[N2] - 127))
                return false;
            return true;
          },
          xb: function(e2) {
            var G2 = { ba: false, da: false };
            e2.disable(e2.BLEND);
            e2.clearColor(0, 0, 0, 0);
            e2.clear(e2.COLOR_BUFFER_BIT);
            e2.RGBA32F && x2.lb(e2, e2.RGBA32F, e2.FLOAT) && (G2.ba = true, q2 = e2.RGBA32F);
            !G2.ba && x2.lb(e2, e2.RGBA, e2.FLOAT) && (G2.ba = true, q2 = e2.RGBA);
            var N2 = x2.Cb(e2);
            F2 = null;
            e2.RGBA16F && x2.lb(e2, e2.RGBA16F, N2) && (G2.da = true, F2 = e2.RGBA16F);
            !G2.da && x2.lb(e2, e2.RGBA, N2) && (G2.da = true, F2 = e2.RGBA);
            return G2;
          },
          he: function() {
            var e2 = db.instance({ width: 2 });
            e2.Ad();
            var G2 = V2.instance({ width: 2, isFloat: true, cb: 3 });
            e2.l();
            G2.l();
            x2.flush();
            H2.checkFramebufferStatus(db.ze()) !== H2.FRAMEBUFFER_COMPLETE ? (V2.xf(), p2.zb = false) : p2.zb = true;
            e2.remove();
            G2.remove();
          },
          ie: function() {
            var e2 = false;
            x2.fa() && (e2 = "PIXEL_PACK_BUFFER STREAM_READ SYNC_GPU_COMMANDS_COMPLETE WAIT_FAILED fenceSync deleteSync createBuffer".split(" ").every(function(G2) {
              return typeof H2[G2] !== "undefined";
            }));
            p2.sd = e2;
          },
          ge: function() {
            var e2 = x2.xb(H2);
            Object.assign(p2, e2);
            if (!p2.ba && !p2.da)
              return false;
            x2.he();
            x2.ie();
            return true;
          },
          jf: function(e2, G2, N2, K2, S2) {
            H2.readPixels(e2, G2, N2, K2, H2.RGBA, H2.UNSIGNED_BYTE, S2);
            return Promise.resolve(S2, false);
          },
          ac: function(e2, G2, N2, K2, S2, v2) {
            if (!x2.ae())
              return x2.jf(e2, G2, N2, K2, S2);
            u2.na === null && (u2.V = H2.PIXEL_PACK_BUFFER, u2.na = H2.createBuffer(), u2.Fb = -1);
            H2.bindBuffer(u2.V, u2.na);
            S2.byteLength !== u2.Fb && (H2.bufferData(u2.V, S2.byteLength, H2.STREAM_READ), u2.Fb = S2.byteLength);
            H2.readPixels(e2, G2, N2, K2, H2.RGBA, H2.UNSIGNED_BYTE, 0);
            u2.za = H2.fenceSync(H2.SYNC_GPU_COMMANDS_COMPLETE, 0);
            x2.flush();
            var P2 = false;
            return new Promise(function(Q2, w2) {
              function f2() {
                if (!u2.oa)
                  return g2(), w2(), false;
                switch (H2.clientWaitSync(u2.za, 0, 0)) {
                  case H2.TIMEOUT_EXPIRED:
                  case H2.WAIT_FAILED:
                    return false;
                  default:
                    return g2(), h2(), H2.getBufferSubData(u2.V, 0, S2), H2.bindBuffer(u2.V, null), Q2(S2, P2), true;
                }
              }
              g2();
              u2.oa = true;
              f2() || (v2 && !P2 && (P2 = true, v2()), u2.nb = setInterval(f2, 0));
            });
          },
          Dd: function() {
            H2.viewport(0, 0, x2.u(), x2.R());
          },
          flush: function() {
            H2.flush();
          },
          i: function() {
            g2();
            h2();
            V2.i();
            db.i();
            R2.i();
            u2.na !== null && (H2.deleteBuffer(u2.na), u2.na = null);
            ab.reset();
            r2 = false;
          }
        };
        return x2;
      }();
      var bb = function() {
        function b2(v2, P2, Q2, w2) {
          e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MIN_FILTER, w2 ? e2.NEAREST_MIPMAP_NEAREST : e2.LINEAR);
          var f2 = null;
          if (Q2 !== null)
            try {
              f2 = e2.getError();
              if (f2 === "FUCKING_BIG_ERROR")
                return false;
              e2.texImage2D(e2.TEXTURE_2D, 0, v2, 4, 4, 0, e2.RGBA, P2, Q2);
              f2 = e2.getError();
              if (f2 !== e2.NO_ERROR)
                return false;
            } catch (A2) {
              return false;
            }
          w2 && e2.generateMipmap(e2.TEXTURE_2D);
          e2.clear(e2.COLOR_BUFFER_BIT);
          R2.Pa(e2);
          f2 = e2.getError();
          if (f2 === "FUCKING_BIG_ERROR")
            return false;
          e2.readPixels(0, 0, 2, 2, e2.RGBA, e2.UNSIGNED_BYTE, B2);
          f2 = e2.getError();
          f2 === e2.INVALID_OPERATION && typeof e2.PIXEL_PACK_BUFFER !== "undefined" && (e2.bindBuffer(e2.PIXEL_PACK_BUFFER, null), e2.readPixels(0, 0, 2, 2, e2.RGBA, e2.UNSIGNED_BYTE, B2), f2 = e2.getError());
          if (f2 !== e2.NO_ERROR)
            return false;
          Q2 = true;
          for (w2 = 0; 16 > w2; ++w2)
            Q2 = Q2 && 4 > Math.abs(B2[w2] - 127);
          Q2 && (m2.ld = P2, m2.Uc = v2);
          return Q2;
        }
        function d2(v2, P2) {
          return G2.ba && b2(v2, e2.FLOAT, new Float32Array(F2), P2) ? (k2 = n2.sc, true) : false;
        }
        function g2(v2, P2, Q2) {
          if (!G2.da)
            return false;
          var w2 = V2.de(F2), f2 = cb.Na(e2);
          if (f2 && f2.HALF_FLOAT_OES && b2(v2, f2.HALF_FLOAT_OES, w2, P2) || e2.HALF_FLOAT && b2(v2, e2.HALF_FLOAT, w2, P2))
            return k2 = n2.wa, true;
          w2 = new Float32Array(F2);
          if (b2(v2, e2.FLOAT, w2, P2))
            return k2 = n2.wa, true;
          e2.bindTexture(e2.TEXTURE_2D, Q2);
          e2.texImage2D(e2.TEXTURE_2D, 0, e2.RGBA, 2, 2, 0, e2.RGBA, e2.UNSIGNED_BYTE, null);
          e2.bindFramebuffer(m2.La, S2);
          V2.Jc(e2, Q2, 2, 2, w2, false, false);
          e2.bindFramebuffer(m2.La, null);
          e2.bindTexture(e2.TEXTURE_2D, Q2);
          return b2(v2, null, null, P2) ? (k2 = n2.wa, true) : false;
        }
        function h2(v2, P2, Q2) {
          p2 = true;
          if (g2(v2, true, Q2) || d2(P2, true))
            return true;
          p2 = false;
          return g2(v2, false, Q2) || d2(P2, false) ? true : false;
        }
        function t2(v2) {
          if (k2 === n2.O) {
            e2 = v2 || H2;
            k2 = n2.RGBA8;
            p2 = true;
            cb.Cc(e2);
            G2 || (G2 = cb.xb(e2));
            db.reset();
            S2 = e2.createFramebuffer();
            m2.La = e2.DRAW_FRAMEBUFFER || e2.FRAMEBUFFER;
            e2.bindFramebuffer(m2.La, null);
            e2.clearColor(0, 0, 0, 0);
            e2.viewport(0, 0, 2, 2);
            J2.O();
            N2 = J2.Da(e2);
            v2 = e2.createTexture();
            e2.activeTexture(e2.TEXTURE0);
            e2.bindTexture(e2.TEXTURE_2D, v2);
            e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_S, e2.REPEAT);
            e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_T, e2.REPEAT);
            e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MAG_FILTER, e2.NEAREST);
            K2 = v2;
            var P2 = v2 = e2.RGBA, Q2 = e2.RGBA16F, w2 = e2.RGBA32F;
            w2 && (v2 = w2);
            Q2 && (P2 = Q2);
            if ((Q2 || w2) && h2(P2, v2, K2))
              return r2(), true;
            v2 = P2 = e2.RGBA;
            if (h2(P2, v2, K2))
              return r2(), true;
            k2 = n2.RGBA8;
            r2();
            return false;
          }
        }
        function r2() {
          e2.deleteProgram(N2.ka);
          e2.deleteTexture(K2);
          K2 = N2 = null;
        }
        for (var n2 = { O: -1, sc: 3, wa: 2, RGBA8: 0 }, k2 = n2.O, m2 = { ld: null, Uc: null, La: null }, p2 = true, B2 = new Uint8Array(16), F2 = Array(64), q2 = 0; 4 > q2; ++q2)
          for (var u2 = 0; 4 > u2; ++u2) {
            var D2 = (u2 + q2) % 2 === 0 ? 1 : 0, x2 = 4 * q2 + u2;
            F2[4 * x2] = D2;
            F2[4 * x2 + 1] = D2;
            F2[4 * x2 + 2] = D2;
            F2[4 * x2 + 3] = D2;
          }
        var e2 = null, G2 = null, N2 = null, K2 = null, S2 = null;
        return { $d: function(v2) {
          t2(v2);
          return p2;
        }, yc: function(v2, P2) {
          k2 === n2.O && (typeof (P2 !== "undefined") && (G2 = P2), t2(v2));
          return k2 !== n2.RGBA8;
        }, wg: function(v2) {
          t2(v2);
          return k2 === n2.sc;
        }, Re: function(v2) {
          t2(v2);
          return k2 === n2.wa;
        }, kg: function(v2) {
          t2(v2);
          return m2.ld;
        }, ye: function(v2) {
          t2(v2);
          return m2.Uc;
        }, i: function() {
          e2 = null;
          p2 = true;
          k2 = n2.O;
          G2 = null;
        } };
      }();
      var jb = { instance: function(b2) {
        var d2 = V2.instance(b2.alpha), g2 = V2.instance(b2.beta);
        return { ke: function() {
          d2.b(1);
          g2.b(2);
        } };
      } };
      var mb = { instance: function(b2) {
        var d2 = null, g2 = false, h2 = false, t2 = null, r2 = false, n2 = false, k2 = null, m2 = typeof b2.preprocessing === "undefined" ? false : b2.preprocessing, p2 = typeof b2.preprocessingSize === "undefined" ? b2.size : b2.preprocessingSize;
        b2.mask && (g2 = true, c2 && c2.Vd !== void 0 && (b2.mask = c2.Vd + b2.mask), d2 = V2.instance({ isFloat: false, url: b2.mask }));
        var B2 = false;
        b2.customInputShader && (B2 = "s45", J2.tc({ name: "_", id: B2, c: b2.customInputShader, Mg: ["uSource"], precision: "lowp" }), J2.F(B2, [{ type: "1i", name: "_", value: 0 }]));
        switch (m2) {
          case "sobel":
            k2 = "s32";
            r2 = true;
            break;
          case "meanNormalization":
            k2 = "s33";
            r2 = true;
            break;
          case "grayScale":
            k2 = "s29";
            r2 = false;
            break;
          case "grayScaleTilt":
            k2 = "s30";
            n2 = true;
            r2 = false;
            break;
          case "rgbGrayTilt":
            k2 = "s31";
            n2 = true;
            r2 = false;
            break;
          case "copy":
            k2 = B2 ? B2 : "s0";
            break;
          case "inputLightRegulation":
            k2 = B2 ? B2 : "s29";
            t2 = kb.instance({
              Tc: p2,
              kd: b2.size,
              hd: b2.nBlurPass,
              Za: false
            });
            h2 = true;
            break;
          case "inputMix0":
            k2 = "none";
            t2 = lb.instance({ K: p2, Ld: b2.varianceMin, xc: b2.blurKernelSizePx, Za: false });
            h2 = true;
            break;
          case "direct":
          case "none":
            k2 = "abort";
            break;
          default:
            k2 = "s4";
        }
        n2 && J2.F(k2, [{ name: "u27", type: "1f", value: b2.tilt }]);
        g2 && (k2 += "Mask");
        var F2 = V2.instance({ isFloat: false, isPot: false, width: b2.size }), q2 = { u: function() {
          return p2;
        }, Db: function() {
          return q2.u();
        }, Fe: function() {
          return h2 ? t2.Eb() : F2;
        }, M: function(u2) {
          db.aa();
          k2 !== "abort" && (k2 !== "none" && (J2.set(k2), r2 && J2.D("u28", 1 / b2.size), F2.S(), g2 && d2.b(1), R2.h(false, false), F2.b(0), u2 = F2), h2 && t2.process(u2));
        }, i: function() {
          F2.remove();
          g2 && d2.remove();
        } };
        return q2;
      } };
      var sb = { instance: function(b2) {
        function d2(l2) {
          t2.forEach(function(C2, E2) {
            r2[E2][0] = l2[0][C2];
            r2[E2][1] = l2[1][C2];
            r2[E2][2] = l2[2][C2];
            r2[E2][3] = l2[3][C2];
          });
          return r2;
        }
        b2.normalize = b2.normalize || false;
        var g2 = { input: null, Ia: null, Ib: null, Y: null, eb: null, Xb: null, Yb: null }, h2 = null, t2 = [], r2 = [], n2 = false, k2 = null, m2 = true, p2 = -1, B2 = b2.isReorganize ? b2.isReorganize : false, F2 = b2.kernelsCount ? true : false, q2 = b2.dynPelu ? jb.instance(b2.dynPelu) : false, u2 = q2 ? true : false, D2 = { isEnabled: false };
        b2.Pe ? (b2.sparsity = typeof b2.sparsity !== "undefined" ? b2.sparsity : b2.gb.Db(), m2 = false) : b2.connectivityUp === "full" && (b2.sparsity = b2.gb.Db());
        var x2 = { elu: "s16", elu01: "s17", relu: "s15", arctan: "s19", sigmoid: "s14", copy: "s0", softplus: "s20", dynPelu: "s18" }[b2.activation], e2 = b2.sparsity * b2.sparsity, G2 = false, N2 = b2.size, K2 = "";
        if (b2.maxPooling) {
          switch (b2.maxPooling.size) {
            case 2:
              K2 = "s34";
              break;
            case 4:
              K2 = "s35";
          }
          G2 = true;
          N2 /= b2.maxPooling.size;
          g2.Xb = V2.instance({ isFloat: true, isPot: false, width: N2 });
        }
        var S2 = b2.normalization ? true : false, v2 = null, P2 = null, Q2 = null;
        if (S2) {
          v2 = "s46" + b2.index.toString();
          J2.Sc("s46", v2, [((b2.normalization.n - 1) / 2).toFixed(1)]);
          J2.F(v2, [{ type: "1i", name: "u1", value: 0 }, { type: "2f", name: "u8", value: [1 / b2.size, 1 / b2.size] }, { type: "1f", name: "u7", value: b2.normalization.alpha }, { type: "1f", name: "u10", value: b2.normalization.beta }, { type: "1f", name: "u31", value: b2.normalization.k }]);
          var w2 = { isFloat: true, isPot: true, width: b2.size };
          P2 = V2.instance(w2);
          Q2 = V2.instance(w2);
        }
        var f2 = -1, A2 = null;
        m2 && (g2.Y = V2.instance({ isFloat: true, isPot: false, width: b2.size }));
        g2.Ia = V2.instance(b2.bias);
        var L2 = {
          u: function() {
            return b2.size;
          },
          Db: function() {
            return N2;
          },
          Lc: function() {
            return b2.classesCount;
          },
          Xd: function(l2) {
            h2.b(l2);
          },
          cf: function() {
            b2.remap && b2.remap.isEnabled && (D2 = { isEnabled: true, Ve: V2.instance({ isFloat: false, isFlipY: false, array: new Uint8Array(b2.remap.maskTexture.data), width: b2.remap.maskTexture.width, isPot: false }), bb: b2.remap.layers.map(function(l2) {
              return b2.parent.Ce(l2);
            }), depth: b2.remap.depth });
          },
          yf: function() {
            switch (b2.connectivityUp) {
              case "direct":
                A2 = nb.instance(b2.connectivity);
                break;
              case "square":
                A2 = ob.instance(b2.connectivity);
                break;
              case "squareFast":
                A2 = pb.instance(b2.connectivity, b2.activation);
                break;
              case "full":
                A2 = qb.instance(b2.connectivity);
                break;
              case "conv":
                p2 = b2.kernelsCount, A2 = rb.instance(b2.connectivity), B2 && (g2.eb = V2.instance({ width: N2, isFloat: true, isFlipY: false, isPot: false }));
            }
            if (A2.sa) {
              var l2 = b2.size * b2.sparsity;
              f2 = Math.log(l2 / b2.size) / Math.log(2);
              g2.input = V2.instance({ isMipmap: true, isFloat: true, isPot: true, width: l2, Pb: f2 });
              g2.Ib = V2.instance({ isFloat: true, isPot: true, width: b2.size });
            }
          },
          M: function(l2, C2) {
            h2 = l2;
            A2.sa ? (g2.input.S(), F2 && g2.Ia.b(2), A2.M(D2), g2.input.b(0), g2.input.se(f2), g2.Ib.S(), F2 ? J2.set("s0") : (J2.set("s28"), J2.D("u26", e2), g2.Ia.b(1)), g2.input.Yd(f2, 0), R2.h(false, false), J2.set(x2), S2 ? P2.l() : g2.Y.l(), g2.Ib.b(0), u2 && q2.ke(), R2.h(false, false)) : (g2.Y.S(), g2.Ia.b(1), A2.M());
            S2 && (J2.set(v2), Q2.l(), P2.b(0), R2.h(false, false), J2.set("s47"), J2.D("u7", 1), g2.Y.l(), Q2.b(1), R2.h(false, false));
            if (m2)
              return G2 ? (g2.Xb.S(), g2.Y.b(0), J2.set(K2), J2.la("u8", 1 / b2.size, 1 / b2.size), R2.h(false, false), C2 = g2.Xb) : C2 = g2.Y, C2.b(0), B2 && (g2.eb.l(), J2.set("s22"), J2.la("u13", p2, N2 / p2), R2.h(false, false), C2 = g2.eb, g2.eb.b(0)), C2;
            var E2 = g2.Y;
            b2.normalize && (J2.set(n2 === "gpuRawAvg" ? "s9" : "s8"), J2.D("u4", 1 / b2.size), g2.Yb.S(), g2.Y.b(0), R2.h(false, false), E2 = g2.Yb);
            l2 = null;
            switch (n2) {
              case "cpuRGBA2Float":
                E2.yb(false);
                C2 ? l2 = L2.df(E2).then(k2) : (E2 = L2.ef(E2), k2(E2));
                break;
              case "cpuMeanFloat":
                E2.yb(true);
                if (C2)
                  l2 = E2.gf().then(k2);
                else {
                  E2 = E2.hf();
                  for (var T2 = 0; T2 < E2.length; ++T2)
                    ;
                  k2(E2);
                }
                break;
              case "gpuRawAvg":
              case "gpuRaw":
                E2.b(0);
              case "none":
                k2 !== null && k2(E2);
            }
            C2 && l2 === null && (l2 = Promise.resolve());
            return l2;
          },
          ee: function(l2) {
            l2 && (n2 = l2.Zb || "none", k2 = l2.Wb || null);
            g2.Y = V2.instance({ isFloat: true, isPot: true, isMipmap: false, width: b2.size });
            l2 = typeof b2.classesCount !== "undefined" && b2.classesCount ? b2.classesCount : b2.size * b2.size;
            for (var C2 = 0, E2 = 0, T2 = 0; C2 < l2; ++C2)
              t2.push(E2 + (b2.size - 1 - T2) * b2.size), r2.push([-1, -1, -1, -1]), ++E2, E2 === b2.size && (E2 = 0, ++T2);
            b2.normalize && (g2.Yb = V2.instance({ isFloat: true, isPot: true, width: b2.size }));
          },
          df: function(l2) {
            return l2.ff().then(d2);
          },
          ef: function(l2) {
            l2 = l2.$b();
            d2(l2);
            return r2;
          },
          i: function() {
            for (var l2 in g2) {
              var C2 = g2[l2];
              C2 && C2.remove();
            }
            A2 && (A2.i(), A2 = null);
          }
        };
        b2.gb && L2.yf(b2.gb);
        return L2;
      } };
      function tb(b2) {
        var d2 = null, g2 = null, h2 = null, t2 = 0;
        this.j = function(r2) {
          this.wf(r2.bb);
          h2.ee({ Zb: r2.Zb, Wb: r2.Wb });
        };
        this.Ce = function(r2) {
          return d2[r2];
        };
        this.wf = function(r2) {
          var n2 = null;
          t2 = r2.length;
          d2 = r2.map(function(k2, m2) {
            k2 = Object.assign({}, k2, { index: m2, parent: this, gb: n2, Pe: m2 === t2 - 1 });
            return n2 = m2 = m2 === 0 ? mb.instance(k2) : sb.instance(k2);
          });
          g2 = d2[0];
          h2 = d2[t2 - 1];
          d2.forEach(function(k2, m2) {
            m2 !== 0 && k2.cf();
          });
        };
        this.M = function(r2) {
          var n2 = r2;
          d2.forEach(function(k2) {
            n2 = k2.M(n2, false);
          });
          return n2;
        };
        this.Ae = function() {
          return g2.u();
        };
        this.Ge = function() {
          return h2.u();
        };
        this.Eb = function() {
          return h2.Fe();
        };
        this.Lc = function() {
          return h2.Lc();
        };
        this.i = function() {
          d2 && (d2.forEach(function(r2) {
            r2.i();
          }), h2 = g2 = d2 = null, t2 = 0);
        };
        typeof b2 !== "undefined" && this.j(b2);
      }
      var nb = { instance: function(b2) {
        var d2 = V2.instance(b2.weights);
        return { sa: true, Ta: function() {
          return 1;
        }, i: function() {
          d2.remove();
        }, He: function() {
          return d2;
        }, M: function() {
          J2.set("s27");
          d2.b(1);
          R2.h(false, false);
        } };
      } };
      var qb = { instance: function(b2) {
        var d2 = b2.fromLayerSize, g2 = V2.instance(b2.weights);
        return { sa: true, Ta: function() {
          return d2;
        }, i: function() {
          g2.remove();
        }, M: function(h2) {
          if (h2.isEnabled) {
            J2.set("s25");
            h2.Ve.b(3);
            var t2, r2 = Math.min(h2.bb.length, h2.depth);
            for (t2 = 0; t2 < r2; ++t2)
              h2.bb[t2].Xd(4 + t2);
          } else
            J2.set("s24");
          J2.D("u17", b2.toLayerSize);
          g2.b(1);
          R2.h(false, false);
        } };
      } };
      var ob = { instance: function(b2) {
        for (var d2 = b2.fromLayerSize, g2 = b2.toLayerSize, h2 = b2.toSparsity, t2 = h2 * g2, r2 = t2 / d2, n2 = d2 / g2, k2 = 0, m2 = 0, p2 = 0, B2 = Array(h2 * g2 * h2 * g2 * 4), F2 = Array(h2 * g2 * h2 * g2 * 4), q2 = Array(d2 * d2), u2 = 0; u2 < q2.length; ++u2)
          q2[u2] = 0;
        u2 = Math.floor(h2 / 2);
        for (var D2 = 0.5 / g2, x2 = 0.5 / d2, e2 = 0.5 / t2, G2 = 0; G2 < g2; ++G2)
          for (var N2 = Math.round(G2 * n2), K2 = 0; K2 < g2; ++K2) {
            var S2 = Math.round(K2 * n2), v2 = G2 / g2, P2 = K2 / g2;
            v2 += D2;
            P2 += D2;
            for (var Q2 = 0; Q2 < h2; ++Q2) {
              var w2 = N2 + Q2 - u2;
              0 > w2 && (w2 += d2);
              w2 >= d2 && (w2 -= d2);
              for (var f2 = 0; f2 < h2; ++f2) {
                var A2 = k2 / t2, L2 = m2 / t2, l2 = S2 + f2 - u2;
                0 > l2 && (l2 += d2);
                l2 >= d2 && (l2 -= d2);
                var C2 = w2 / d2, E2 = l2 / d2;
                L2 = 1 - L2 - 1 / t2;
                C2 += x2;
                E2 += x2;
                A2 += e2;
                L2 += e2;
                var T2 = G2 * h2 + Q2, O2 = K2 * h2 + f2;
                O2 = g2 * h2 - O2 - 1;
                T2 = O2 * g2 * h2 + T2;
                B2[4 * T2] = A2;
                B2[4 * T2 + 1] = L2;
                B2[4 * T2 + 2] = C2;
                B2[4 * T2 + 3] = E2;
                E2 = q2[l2 * d2 + w2]++;
                T2 = E2 % r2;
                C2 = w2 * r2 + T2;
                l2 = l2 * r2 + (E2 - T2) / r2;
                l2 = d2 * r2 - 1 - l2;
                l2 = l2 * d2 * r2 + C2;
                F2[4 * l2] = A2;
                F2[4 * l2 + 1] = L2;
                F2[4 * l2 + 2] = v2;
                F2[4 * l2 + 3] = P2;
                ++k2 >= t2 && (k2 = 0, ++m2);
                ++p2;
              }
            }
          }
        q2 = null;
        var la = V2.instance(b2.weights);
        delete b2.weights.data;
        var ha = V2.instance({ width: t2, isFloat: true, array: new Float32Array(F2), isPot: true });
        F2 = null;
        var oa = V2.instance({ width: t2, isFloat: true, array: new Float32Array(B2), isPot: true });
        B2 = null;
        return { sa: true, Ta: function() {
          return r2;
        }, i: function() {
          ha.remove();
          oa.remove();
          la.remove();
        }, M: function() {
          J2.set("s23");
          la.b(1);
          oa.b(2);
          R2.h(false, false);
        } };
      } };
      var rb = { instance: function(b2) {
        var d2 = b2.kernelsCount, g2 = b2.toSparsity, h2 = g2 * b2.toLayerSize / b2.fromLayerSize, t2 = V2.instance(b2.weights);
        return { sa: true, Ta: function() {
          return h2;
        }, qg: function() {
          return g2;
        }, He: function() {
          return t2;
        }, i: function() {
          t2.remove();
        }, M: function() {
          J2.set("s26");
          J2.D("u23", d2);
          J2.D("u24", g2);
          J2.D("u17", b2.toLayerSize);
          J2.D("u25", b2.fromLayerSize);
          t2.b(1);
          R2.h(false, false);
        } };
      } };
      var pb = { instance: function(b2, d2) {
        var g2 = b2.fromLayerSize, h2 = b2.toLayerSize, t2 = b2.toSparsity, r2 = b2.stride ? b2.stride : 1, n2 = t2 * h2 / g2, k2 = h2 < g2, m2 = g2 / h2, p2 = V2.instance(b2.weights), B2 = "s48" + [g2.toString(), h2.toString(), t2.toString(), r2.toString(), d2].join("_");
        J2.pe(B2) || (b2 = Xa(d2), h2 = [{ type: "1f", name: "u17", value: h2 }, { type: "1f", name: "u30", value: r2 }], k2 && h2.push({ type: "1f", name: "u25", value: g2 }), g2 = [(k2 ? n2 : t2).toFixed(1), b2], k2 && g2.push(m2.toFixed(1)), J2.Sc(k2 ? "s40" : "s39", B2, g2), J2.F(B2, h2.concat([{ type: "1i", name: "u15", value: 0 }, { type: "1i", name: "u22", value: 1 }, { type: "1i", name: "u14", value: 3 }])));
        return {
          sa: false,
          Ta: function() {
            return n2;
          },
          i: function() {
            p2.remove();
          },
          M: function() {
            J2.set(B2);
            p2.b(3);
            R2.h(false, false);
          }
        };
      } };
      var kb = { instance: function(b2) {
        var d2 = b2.hd ? b2.hd : 3, g2 = b2.Tc ? b2.Tc : 64, h2 = b2.kd ? b2.kd : 64, t2 = b2.Za ? true : false;
        b2 = { isFloat: false, width: g2, isPot: false, isFlipY: false };
        var r2 = V2.instance(b2), n2 = V2.instance(b2), k2 = V2.instance(b2), m2 = V2.instance(b2), p2 = V2.instance({ isFloat: true, width: h2, isPot: false, isFlipY: false }), B2 = 1 / g2;
        return { process: function(F2) {
          J2.set("s36");
          m2.l();
          R2.h(t2, false);
          J2.set("s37");
          for (var q2 = 0; q2 < d2; ++q2)
            r2.l(), J2.la("u8", B2, 0), R2.h(t2, false), k2.l(), m2.b(0), R2.h(t2, false), n2.l(), r2.b(0), J2.la("u8", 0, B2), R2.h(t2, false), m2.l(), k2.b(0), R2.h(t2, false), q2 !== d2 - 1 && n2.b(0);
          J2.set("s38");
          p2.l();
          F2.b(0);
          n2.b(1);
          m2.b(2);
          R2.h(t2, false);
          p2.b(0);
        }, Eb: function() {
          return p2;
        } };
      } };
      var lb = { instance: function(b2) {
        function d2(m2) {
          return V2.instance({ isFloat: m2, width: g2.K, isPot: false, isFlipY: false });
        }
        var g2 = Object.assign({ Ld: 0.1, xc: 9, K: 128, Za: false }, b2), h2 = d2(false), t2 = [d2(false), d2(false), d2(false)], r2 = [d2(false), d2(false), d2(false)], n2 = d2(true), k2 = [h2, r2[0], r2[1]];
        b2 = { u1: 0 };
        J2.uc([{
          id: "s50",
          name: "_",
          c: "uniform sampler2D u1;varying vec2 vv0;const vec3 f=vec3(.2126,.7152,.0722),g=vec3(1.,1.,1.);void main(){vec3 b=texture2D(u1,vv0).rgb;float a=dot(b,f);gl_FragColor=vec4(a,a,a,a);}",
          g: b2,
          f: ["u1"],
          precision: "lowp"
        }, { id: "s51", name: "_", c: "uniform sampler2D u1;const float e=1.1111,g=2.2222;uniform vec2 u32;varying vec2 vv0;void main(){float b=0.,c=0.;for(float a=-e;a<=e;a+=1.){vec2 i=u32*a,j=vv0+i*g;float d=1.2*a/e,f=exp(-d*d);b+=f*texture2D(u1,j).r,c+=f;}b/=c,gl_FragColor=vec4(b,0.,0.,1.);}".replace("1.1111", Math.round((g2.xc - 1) / 2).toFixed(2)).replace("2.2222", (1 / g2.K).toFixed(6)), g: b2, f: ["u1", "u32"], precision: "lowp" }, { id: "s52", name: "_", c: "uniform sampler2D u33,u34,u35,u36;const float f=1.1111;const vec3 g=vec3(1.,1.,1.);varying vec2 vv0;void main(){vec3 a=texture2D(u33,vv0).rgb;float c=texture2D(u34,vv0).r,d=texture2D(u35,vv0).r,h=texture2D(u36,vv0).r,i=a.r*a.r;vec3 b=vec3(c,d,h),j=max(g*f,abs(i-b*b)),k=sqrt(j);gl_FragColor=vec4(a.r,(a-b)/k);}".replace("1.1111", g2.Ld.toFixed(4)), g: { u33: 0, u34: 1, u35: 2, u36: 3 }, f: ["u33", "u34", "u35", "u36"], precision: "highp" }]);
        return { process: function() {
          J2.set("s50");
          h2.S();
          R2.h(g2.Za, false);
          J2.set("s51");
          for (var m2 = 0; 3 > m2; ++m2)
            J2.la("u32", 1, 0), t2[m2].l(), k2[m2].b(0), R2.h(false, false), J2.la("u32", 0, 1), r2[m2].l(), t2[m2].b(0), R2.h(false, false);
          J2.set("s52");
          n2.l();
          h2.b(0);
          r2[0].b(1);
          r2[1].b(2);
          r2[2].b(3);
          R2.h(false, false);
          n2.b(0);
        }, Eb: function() {
          return n2;
        } };
      } };
      function ub(b2, d2) {
        b2[d2] = true;
        b2.setAttribute(d2, "true");
      }
      function vb() {
        return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
      }
      function wb() {
        var b2 = navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
        return b2 && b2.length && 2 < b2.length ? [parseInt(b2[1], 10), parseInt(b2[2], 10), parseInt(b2[3] || 0, 10)] : [0, 0, 0];
      }
      function xb() {
        var b2 = navigator.userAgent.toLowerCase();
        return b2.indexOf("safari") !== -1 && b2.indexOf("chrome") === -1 ? true : false;
      }
      function yb() {
        return navigator.mediaDevices && navigator.mediaDevices.getUserMedia ? true : false;
      }
      function zb(b2) {
        if (!b2)
          return b2;
        var d2 = null;
        if (b2.video) {
          var g2 = function(h2) {
            return h2 && typeof h2 === "object" ? Object.assign({}, h2) : h2;
          };
          d2 = {};
          typeof b2.video.width !== "undefined" && (d2.width = g2(b2.video.width));
          typeof b2.video.height !== "undefined" && (d2.height = g2(b2.video.height));
          typeof b2.video.facingMode !== "undefined" && (d2.facingMode = g2(b2.video.facingMode));
        }
        d2 = { audio: b2.audio, video: d2 };
        typeof b2.deviceId !== "undefined" && Ab(d2, b2.deviceId);
        return d2;
      }
      function Ab(b2, d2) {
        d2 && (b2.video = b2.video || {}, b2.video.deviceId = { exact: d2 }, b2.video.facingMode && delete b2.video.facingMode);
      }
      function Bb(b2) {
        var d2 = b2.video.width;
        b2.video.width = b2.video.height;
        b2.video.height = d2;
        return b2;
      }
      function Db(b2) {
        function d2(q2) {
          return [480, 576, 640, 648, 720, 768, 800, 960, 1080, 1152, 1280, 1366, 1920].sort(function(u2, D2) {
            return Math.abs(u2 - q2) - Math.abs(D2 - q2);
          });
        }
        function g2(q2) {
          var u2 = zb(b2);
          q2 = q2(u2);
          t2.push(q2);
          h2(q2);
        }
        function h2(q2) {
          if (q2.video && q2.video.facingMode && q2.video.facingMode.exact) {
            var u2 = q2.video.facingMode.exact;
            q2 = zb(q2);
            delete q2.video.facingMode.exact;
            q2.video.facingMode.ideal = u2;
            t2.push(q2);
          }
        }
        var t2 = [];
        if (!b2 || !b2.video)
          return t2;
        h2(b2);
        if (b2.video.width && b2.video.height) {
          if (b2.video.width.ideal && b2.video.height.ideal) {
            var r2 = d2(b2.video.width.ideal).slice(0, 3), n2 = d2(b2.video.height.ideal).slice(0, 3), k2 = {}, m2 = 0;
            for (k2.ha = void 0; m2 < r2.length; k2 = { ha: k2.ha }, ++m2) {
              k2.ha = r2[m2];
              var p2 = {}, B2 = 0;
              for (p2.ga = void 0; B2 < n2.length; p2 = { ga: p2.ga }, ++B2)
                if (p2.ga = n2[B2], k2.ha !== b2.video.width.ideal || p2.ga !== b2.video.height.ideal) {
                  var F2 = Math.max(k2.ha, p2.ga) / Math.min(k2.ha, p2.ga);
                  F2 < 4 / 3 - 0.1 || F2 > 16 / 9 + 0.1 || g2(function(q2, u2) {
                    return function(D2) {
                      D2.video.width.ideal = q2.ha;
                      D2.video.height.ideal = u2.ga;
                      return D2;
                    };
                  }(k2, p2));
                }
            }
          }
          g2(function(q2) {
            return Bb(q2);
          });
        }
        b2.video.width && b2.video.height && (b2.video.width.ideal && b2.video.height.ideal && g2(function(q2) {
          delete q2.video.width.ideal;
          delete q2.video.height.ideal;
          return q2;
        }), g2(function(q2) {
          delete q2.video.width;
          delete q2.video.height;
          return q2;
        }));
        b2.video.facingMode && (g2(function(q2) {
          delete q2.video.facingMode;
          return q2;
        }), b2.video.width && b2.video.height && g2(function(q2) {
          Bb(q2);
          delete q2.video.facingMode;
          return q2;
        }));
        t2.push({ audio: b2.audio, video: true });
        return t2;
      }
      function Eb(b2) {
        try {
          var d2 = window.matchMedia("(orientation: portrait)").matches ? true : false;
        } catch (h2) {
          d2 = window.innerHeight > window.innerWidth;
        }
        if (d2 && b2 && b2.video) {
          d2 = b2.video.width;
          var g2 = b2.video.height;
          d2 && g2 && d2.ideal && g2.ideal && d2.ideal > g2.ideal && (b2.video.height = d2, b2.video.width = g2);
        }
      }
      function Fb(b2) {
        b2.volume = 0;
        ub(b2, "muted");
        if (xb()) {
          if (b2.volume === 1) {
            var d2 = function() {
              b2.volume = 0;
              window.removeEventListener("mousemove", d2, false);
              window.removeEventListener("touchstart", d2, false);
            };
            window.addEventListener("mousemove", d2, false);
            window.addEventListener("touchstart", d2, false);
          }
          setTimeout(function() {
            b2.volume = 0;
            ub(b2, "muted");
          }, 5);
        }
      }
      function Gb(b2, d2, g2, h2) {
        function t2(n2) {
          r2 || (r2 = true, g2(n2));
        }
        var r2 = false;
        navigator.mediaDevices.getUserMedia(h2).then(function(n2) {
          function k2() {
            setTimeout(function() {
              if (b2.currentTime) {
                var p2 = b2.videoWidth, B2 = b2.videoHeight;
                if (p2 === 0 || B2 === 0)
                  t2("VIDEO_NULLSIZE");
                else {
                  p2 && (b2.style.width = p2.toString() + "px");
                  B2 && (b2.style.height = B2.toString() + "px");
                  p2 = { be: null, Df: null, We: null };
                  try {
                    var F2 = n2.getVideoTracks()[0];
                    F2 && (p2.We = F2, p2.be = F2.getCapabilities(), p2.Df = F2.getSettings());
                  } catch (q2) {
                  }
                  xb() || vb() ? b2.parentNode && b2.parentNode !== null ? (r2 || d2(b2, n2, p2), setTimeout(function() {
                    b2.play();
                  }, 100)) : (document.body.appendChild(b2), Fb(b2), r2 || d2(b2, n2, p2), setTimeout(function() {
                    b2.style.transform = "scale(0.0001,0.0001)";
                    b2.style.position = "fixed";
                    b2.style.bottom = "0px";
                    b2.style.right = "0px";
                    Fb(b2);
                    setTimeout(function() {
                      b2.play();
                    }, 100);
                  }, 80)) : r2 || d2(b2, n2, p2);
                }
              } else
                t2("VIDEO_NOTSTARTED");
            }, 700);
          }
          function m2() {
            b2.removeEventListener("loadeddata", m2, false);
            var p2 = b2.play();
            Fb(b2);
            typeof p2 === "undefined" ? k2() : p2.then(function() {
              k2();
            }).catch(function() {
              t2("VIDEO_PLAYPROMISEREJECTED");
            });
          }
          typeof b2.srcObject !== "undefined" ? b2.srcObject = n2 : (b2.src = window.URL.createObjectURL(n2), b2.videoStream = n2);
          Fb(b2);
          b2.addEventListener("loadeddata", m2, false);
        }).catch(function(n2) {
          t2(n2);
        });
      }
      function Hb(b2, d2, g2) {
        var h2 = yb() ? document.createElement("video") : false;
        if (h2)
          if (yb()) {
            if (g2 && g2.video) {
              if (vb()) {
                var t2 = wb();
                t2[0] !== 0 && (12 > t2[0] || t2[0] === 12 && 2 > t2[1]) && Eb(g2);
              }
              g2.video.width && g2.video.width.ideal && (h2.style.width = g2.video.width.ideal + "px");
              g2.video.height && g2.video.height.ideal && (h2.style.height = g2.video.height.ideal + "px");
            }
            ub(h2, "autoplay");
            ub(h2, "playsinline");
            g2 && g2.audio ? h2.volume = 0 : ub(h2, "muted");
            Gb(h2, b2, function() {
              function r2(k2) {
                if (k2.length === 0)
                  d2("INVALID_FALLBACKCONSTRAINTS");
                else {
                  var m2 = k2.shift();
                  Gb(h2, b2, function() {
                    r2(k2);
                  }, m2);
                }
              }
              var n2 = Db(g2);
              r2(n2);
            }, g2);
          } else
            d2 && d2("MEDIASTREAMAPI_NOTFOUND");
        else
          d2 && d2("VIDEO_NOTPROVIDED");
      }
      var Ib = function() {
        function b2(D2, x2, e2, G2, N2, K2, S2) {
          if (!q2)
            if (S2 === K2.length)
              N2();
            else {
              switch (K2[S2]) {
                case "A":
                  e2();
                  break;
                case "D":
                  D2();
                  break;
                case "S":
                  x2().then(function(v2, P2) {
                    u2.Id();
                    b2(D2, x2, e2, P2 ? null : G2, N2, K2, ++S2);
                  }).catch(function(v2) {
                    N2();
                    throw v2;
                  });
                  return;
                case "R":
                  G2 && G2();
              }
              b2(D2, x2, e2, G2, N2, K2, ++S2);
            }
        }
        var d2 = { n: 5, Rb: 1, fd: 0, Ra: [35, 49], Ma: [2, 200], k: 0.7, Kf: 200, bf: 0.05 }, g2 = -1, h2 = null, t2 = -1, r2 = -1, n2 = 0, k2 = -1, m2 = -1, p2 = 0, B2 = 0, F2 = d2.Ma[1], q2 = true, u2 = { De: function() {
          switch (g2) {
            case -1:
              return -1;
            case 0:
              return m2 + h2.fd;
            case 1:
              return p2;
          }
        }, ue: function(D2) {
          return Math.pow(Math.min(Math.max(k2, 0), h2.n - 1) / (h2.n - 1), D2 || 1);
        }, j: function(D2) {
          h2 = Object.assign({}, d2, D2);
          k2 = m2 = h2.Rb;
          g2 = 0;
          u2.reset();
        }, Id: function(D2) {
          D2 = (typeof D2 === "undefined" ? Date.now() : D2) || 0;
          var x2 = Math.min(Math.max(D2 - B2, h2.Ma[0]), h2.Ma[1]);
          F2 = x2;
          B2 = D2;
          var e2 = t2 === -1 ? 0 : h2.k;
          t2 = Math.min(Math.max(1e3 / x2, 5), 120) * (1 - e2) + t2 * e2;
          D2 - r2 > h2.Kf && 5 < ++n2 && (x2 = h2.k, k2 = k2 * (1 - x2) + (t2 < h2.Ra[0] ? m2 - 1 : t2 > h2.Ra[1] ? m2 + 1 : m2) * x2, Math.abs(k2 - m2) > 1 - h2.bf && (x2 = Math.min(Math.max(Math.round(k2), 0), h2.n - 1), x2 !== m2 && (k2 = m2 = x2, t2 = (h2.Ra[1] - h2.Ra[0]) / 2)), r2 = D2);
        }, ud: function(D2, x2, e2, G2, N2, K2) {
          q2 = false;
          b2(D2, x2, e2, G2, N2, K2, 0);
        }, stop: function() {
          q2 = true;
        }, vf: function(D2) {
          p2 = D2;
          g2 = 1;
        }, Jf: function() {
          g2 = 0;
          u2.reset();
        }, reset: function() {
          F2 = d2.Ma[1];
          r2 = t2 = -1;
          n2 = 0;
        }, hg: function() {
          return F2;
        } };
        return u2;
      }();
      var Jb = function() {
        function b2() {
          g2(x2 + u2.Qb);
          e2.port.postMessage("DONE");
        }
        function d2() {
          var f2 = u2.P;
          v2.isEnabled && (f2 = Math.max(f2, v2.P));
          S2.Ga = f2 === 0 ? N2(g2) : N2(h2);
        }
        function g2(f2) {
          K2.pa && D2 !== null && (f2 -= x2, f2 = Math.min(Math.max(f2, u2.Bc[0]), u2.Bc[1]), x2 += f2, r2(), v2.isEnabled && v2.Ca && K2.X && x2 - v2.Mb > u2.qc && (p2(), v2.Mb = x2), D2(x2));
        }
        function h2(f2) {
          K2.pa && (S2.timeout = window.setTimeout(g2.bind(null, f2), u2.P));
        }
        function t2() {
          D2 = null;
          K2.pa = false;
          r2();
        }
        function r2() {
          S2.Ga && (window.cancelAnimationFrame(S2.Ga), S2.Ga = null);
          S2.timeout && (window.clearTimeout(S2.timeout), S2.timeout = null);
        }
        function n2(f2) {
          f2 && !K2.X ? (K2.X = true, G2 && Ib.Jf(), e2.port.postMessage("STOP"), cb.Jd(true), d2()) : !f2 && K2.X && (K2.X = false, G2 && Ib.vf(1), cb.Jd(false), e2.port.postMessage("START"));
        }
        function k2(f2) {
          f2.target.hidden ? Q2() : P2();
        }
        function m2(f2, A2, L2) {
          A2 = f2.createShader(A2);
          f2.shaderSource(A2, L2);
          f2.compileShader(A2);
          return A2;
        }
        function p2() {
          v2.Ca = false;
          var f2 = v2.ca, A2 = v2.Va, L2 = v2.Wa, l2 = v2.V;
          f2.uniform1f(v2.Pc, Math.random());
          v2.qa ? A2.beginQueryEXT(l2, L2) : f2.beginQuery(l2, L2);
          f2.drawElements(f2.POINTS, 1, f2.UNSIGNED_SHORT, 0);
          v2.qa ? A2.endQueryEXT(l2) : f2.endQuery(l2);
          cb.flush();
          F2().then(function(C2) {
            C2 = u2.Nd * u2.oc * 1e3 / C2;
            v2.ob = (v2.ob + 1) % u2.va;
            v2.Ob[v2.ob] = C2;
            if (++v2.bd > u2.va) {
              v2.ab.set(v2.Ob);
              v2.ab.sort(function(T2, O2) {
                return T2 - O2;
              });
              C2 = v2.ab[Math.floor(u2.va / 2)];
              v2.Oa = Math.max(v2.Oa, C2);
              var E2 = 0;
              for (E2 = 0; E2 < v2.jc && !(C2 > v2.Oa * (1 - (u2.pc[E2] + u2.Od * (E2 >= v2.mb ? 1 : -1)))); ++E2)
                E2 === v2.jc - 1 && ++E2;
              E2 !== v2.mb && (console.log("THERMAL THROTTLING LEVEL = " + E2.toString()), v2.mb = E2, v2.P = E2 === 0 ? 0 : u2.Md[E2 - 1], u2.nc && u2.nc(E2));
            }
            v2.Ca = true;
          }).catch(function() {
            v2.Ca = true;
          });
        }
        function B2(f2) {
          var A2 = v2.ca, L2 = v2.Va, l2 = v2.Wa, C2 = false;
          v2.qa ? C2 = L2.ag(l2, L2.QUERY_RESULT_AVAILABLE_EXT) : C2 = A2.getQueryParameter(l2, A2.QUERY_RESULT_AVAILABLE);
          A2 = A2.getParameter(L2.GPU_DISJOINT_EXT);
          C2 ? f2(!A2) : setTimeout(B2.bind(null, f2), 0.1);
        }
        function F2() {
          return new Promise(function(f2, A2) {
            B2(function(L2) {
              if (L2) {
                L2 = v2.ca;
                var l2 = v2.Va, C2 = v2.Wa;
                L2 = v2.qa ? l2.getQueryObjectEXT(C2, l2.QUERY_RESULT_EXT) : L2.getQueryParameter(C2, L2.QUERY_RESULT);
                f2(L2);
              } else
                A2();
            });
          });
        }
        var q2 = {
          Zc: true,
          Bc: [1, 200],
          Qb: 20,
          P: 0,
          Pd: false,
          oc: 50,
          Nd: 240,
          qc: 3e3,
          va: 3,
          pc: [0.2, 0.35, 0.5],
          Od: 0.05,
          Md: [8, 20, 40],
          nc: null
        }, u2 = null, D2 = null, x2 = 0, e2 = null, G2 = false, N2 = null, K2 = { ja: false, X: true, Lb: false, Kb: false, Jb: false, pa: false }, S2 = { Ga: null, timeout: null }, v2 = { isEnabled: false, Ca: false, ca: null, Va: null, Wa: null, V: null, Pc: null, qa: true, mb: 0, jc: 0, P: 0, Mb: 0, bd: 0, Ob: null, ab: null, ob: 0, Oa: 0 }, P2 = n2.bind(null, true), Q2 = n2.bind(null, false), w2 = { j: function(f2) {
          u2 = Object.assign(q2, f2);
          Object.assign(K2, { X: true, ja: true, pa: false });
          N2 = window.requestPostAnimationFrame || window.requestAnimationFrame;
          if (u2.Pd) {
            f2 = document.createElement("canvas");
            f2.setAttribute("width", "1");
            f2.setAttribute("height", "1");
            var A2 = { antialias: false };
            f2 = f2.getContext("webgl2", A2) || f2.getContext("webgl", A2);
            if (A2 = f2.getExtension("EXT_disjoint_timer_query") || f2.getExtension("EXT_disjoint_timer_query_webgl2")) {
              v2.ca = f2;
              v2.Va = A2;
              v2.isEnabled = true;
              v2.qa = A2.beginQueryEXT ? true : false;
              var L2 = m2(f2, f2.VERTEX_SHADER, "attribute vec4 a0;void main(){gl_Position=a0;}"), l2 = m2(f2, f2.FRAGMENT_SHADER, "precision lowp float;uniform float u37;void main(){vec4 a=u37*vec4(1.,2.,3.,4.);for(int b=0;b<666;b+=1)a=cos(a);gl_FragColor=a;}".replace("666", u2.oc.toString())), C2 = f2.createProgram();
              f2.attachShader(C2, L2);
              f2.attachShader(C2, l2);
              f2.linkProgram(C2);
              L2 = f2.getAttribLocation(C2, "a0");
              v2.Pc = f2.getUniformLocation(C2, "u37");
              f2.useProgram(C2);
              f2.enableVertexAttribArray(L2);
              C2 = f2.createBuffer();
              f2.bindBuffer(f2.ARRAY_BUFFER, C2);
              f2.bufferData(f2.ARRAY_BUFFER, new Float32Array([0.5, 0.5, 0, 1]), f2.STATIC_DRAW);
              f2.vertexAttribPointer(L2, 4, f2.FLOAT, false, 16, 0);
              C2 = f2.createBuffer();
              f2.bindBuffer(f2.ELEMENT_ARRAY_BUFFER, C2);
              f2.bufferData(f2.ELEMENT_ARRAY_BUFFER, new Uint16Array([0]), f2.STATIC_DRAW);
              f2.disable(f2.DEPTH_TEST);
              f2.disable(f2.DITHER);
              f2.disable(f2.STENCIL_TEST);
              f2.viewport(0, 0, 1, 1);
              C2 = v2.qa ? A2.createQueryEXT() : f2.createQuery();
              v2.Wa = C2;
              v2.V = A2.TIME_ELAPSED_EXT || f2.TIME_ELAPSED;
              v2.mb = 0;
              v2.jc = u2.pc.length;
              v2.P = 0;
              v2.Mb = -u2.qc;
              v2.Ob = new Float32Array(u2.va);
              v2.ab = new Float32Array(u2.va);
              v2.Oa = 0;
              v2.ob = 0;
              v2.bd = 0;
              v2.Ca = true;
            }
          }
          if (u2.Zc) {
            f2 = false;
            try {
              if (typeof SharedWorker === "undefined") {
                var E2 = URL.createObjectURL(new Blob(["let handler = null;\n      self.addEventListener('message', function(e){\n        if (handler !== null){\n          clearTimeout(handler);\n          handler = null;\n        }\n        switch (e.data) {\n          case 'START':\n          case 'DONE':\n            handler = setTimeout(function(){\n              self.postMessage('TICK');\n            }, " + u2.Qb.toString() + ");\n            break;\n          case 'STOP':\n            break;\n        };\n      }, false);"], { type: "text/javascript" })), T2 = new Worker(E2);
                T2.addEventListener("message", b2);
                e2 = { md: T2, port: T2 };
                K2.Lb = true;
              } else {
                var O2 = URL.createObjectURL(new Blob(["let handler = null;\n      onconnect = function(e) {\n        const port = e.ports[0];\n        port.addEventListener('message', function(e) {\n          \n          if (handler !== null){\n            clearTimeout(handler);\n            handler = null;\n          }\n          switch (e.data) {\n            case 'START':\n            case 'DONE':\n              handler = setTimeout(function(){\n                port.postMessage('TICK');\n              }, " + u2.Qb.toString() + ");\n              break;\n            case 'STOP':\n              break;\n          };\n          \n        });\n        \n        port.start();\n      } // end onconnect()"], { type: "text/javascript" })), la = new SharedWorker(O2);
                la.port.start();
                la.port.addEventListener("message", b2);
                e2 = { md: la, port: la.port };
                K2.Kb = true;
              }
              f2 = true;
            } catch (ha) {
            }
            f2 && ("onvisibilitychange" in document ? document.addEventListener("visibilitychange", k2) : (window.addEventListener("blur", Q2), window.addEventListener("focus", P2)), K2.Jb = true);
          }
          G2 = typeof Ib !== "undefined";
        }, i: function() {
          t2();
          K2.Jb && ("onvisibilitychange" in document ? document.removeEventListener("visibilitychange", k2) : (window.removeEventListener("blur", Q2), window.removeEventListener("focus", P2)), K2.Jb = false);
          K2.Kb ? (e2.port.close(), K2.Kb = false) : K2.Lb && (e2.md.terminate(), K2.Lb = false);
          Object.assign(K2, { X: true, ja: false, pa: false });
          D2 = null;
        }, Bg: function() {
          return K2.X;
        }, update: function(f2) {
          Object.assign(u2, f2);
        }, ud: function(f2) {
          K2.ja || w2.j({});
          r2();
          K2.pa = true;
          D2 = f2;
          K2.X && d2();
        }, stop: t2 };
        return w2;
      }();
      var Kb = function() {
        var b2 = { jd: 4, fb: [
          1.5,
          1.5,
          2
        ], Z: [0.1, 0.1, 0.1], wd: 1, K: -1, ea: -1, Ff: 2, af: 1, yd: true, me: 0.8 }, d2 = null, g2 = [], h2 = [0], t2 = [0.5, 0.5, 1];
        return { j: function(r2) {
          d2 = Object.assign({}, b2, r2);
          g2.splice(0);
          r2 = d2.fb[0] * d2.Z[0];
          var n2 = d2.fb[1] * d2.Z[1], k2 = 1 / (1 + d2.fb[2] * d2.Z[2]), m2 = d2.wd * Math.min(d2.K, d2.ea), p2 = m2 / d2.K;
          m2 /= d2.ea;
          var B2 = 0.5 * d2.me;
          B2 *= B2;
          for (var F2 = 0; F2 < d2.jd; ++F2) {
            var q2 = Math.pow(k2, F2), u2 = p2 * q2, D2 = m2 * q2;
            q2 = u2 * d2.af;
            var x2 = u2 * r2, e2 = D2 * n2;
            u2 /= 2;
            D2 /= 2;
            for (var G2 = 1 + (1 - u2 - u2) / x2, N2 = 1 + (1 - D2 - D2) / e2, K2 = 0; K2 < N2; ++K2)
              for (var S2 = D2 + K2 * e2, v2 = S2 - 0.5, P2 = 0; P2 < G2; ++P2) {
                var Q2 = u2 + P2 * x2, w2 = Q2 - 0.5;
                w2 * w2 + v2 * v2 > B2 || g2.push([Q2, S2, q2]);
              }
          }
          d2.yd && g2.sort(function(f2, A2) {
            var L2 = f2[0] - 0.5;
            f2 = f2[1] - 0.5;
            var l2 = A2[0] - 0.5;
            A2 = A2[1] - 0.5;
            return L2 * L2 + f2 * f2 - (l2 * l2 + A2 * A2);
          });
        }, get: function(r2) {
          var n2 = g2.length;
          if (n2 === 0)
            return t2;
          for (; r2 >= h2.length; )
            h2.push(0);
          h2[r2] >= n2 && (h2[r2] = 0);
          var k2 = g2[Math.floor(h2[r2])];
          h2[r2] = (h2[r2] + 1 / d2.Ff) % n2;
          return k2;
        }, reset: function() {
          for (var r2 = g2.length / h2.length, n2 = 0; n2 < h2.length; ++n2)
            h2[n2] = Math.floor(n2 * r2);
        } };
      }();
      var Lb = { Bb: function() {
        return Date.now();
      }, dg: function() {
        return performance.now();
      } };
      var Mb = function() {
        var b2 = 0, d2 = null, g2 = null, h2 = null, t2 = null;
        return { j: function(r2, n2) {
          b2 = r2.length;
          d2 = n2;
          g2 = r2;
          h2 = new Float32Array(b2);
          t2 = new Float32Array(b2);
        }, Ee: function() {
          return t2;
        }, Ef: function(r2, n2, k2) {
          r2.forEach(function(m2, p2) {
            var B2 = Math.min(1, g2[p2] * k2 * (n2 + 0.33 * (1 - n2)));
            m2 = B2 * m2 + (1 - B2) * h2[p2];
            h2[p2] = m2;
            m2 = d2[p2](m2);
            m2 = Math.min(Math.max(m2, 0), 1);
            t2[p2] = m2;
          });
        } };
      }();
      var Z2 = { VERSION: "1.3.3", ma: [], rb: false, sb: false, qb: false, Fa: true, Ea: false, ready: false, initialized: false };
      var Nb = { facingMode: "user", idealWidth: 800, idealHeight: 600, minWidth: 240, maxWidth: 1280, minHeight: 240, maxHeight: 1280, rotate: 0, isAudio: true, disableRendering: false };
      var c2 = {
        neuralNetworkPath: "jeelizFaceExpressionsNNC.json",
        rc: "../../",
        P: 0,
        width: 512,
        height: 512,
        Gf: 40,
        xd: [0.6, 5.8],
        Z: [0.11, 0.11, 0.3],
        tf: 0.7,
        rf: 2,
        sf: [2, 2, 2],
        Qa: true,
        re: 0.1,
        threshold: 0.8,
        Gd: 0.7,
        Hd: 0.03,
        le: 0.06,
        qe: 0.02,
        Sd: [1, 0.05],
        Nf: 10,
        Je: false,
        pb: [2, 7],
        J: { Qc: [3, 7], quality: [0, 6], position: [0, 7], rotation: [5, 7] },
        Tb: 11,
        gd: 1,
        Xe: 1,
        Td: [0.1, 0.01],
        mf: [0.4, -0.7, -0.4],
        pf: [0.3, 0, 0],
        je: false,
        Ud: 1e-3,
        vc: [Math.PI / 10, Math.PI / 6],
        od: [0.1, 0.4],
        pd: [9e-3, 0.02],
        qd: [0.1, 0.2],
        Sb: 5,
        Rc: 0.1,
        Rd: [0.2, 0.2, 0.15, 0.15, 0.15, 0.15, 0.5, 0.2, 0.3, 0.3, 0.2],
        Ye: [
          Wa.bind(null, 0.1, 0.7),
          Wa.bind(null, 0.1, 0.7),
          Wa.bind(null, 0.05, 0.4),
          Wa.bind(null, 0.05, 0.4),
          Wa.bind(null, 0.05, 0.6),
          Wa.bind(null, 0.05, 0.6),
          Wa.bind(null, 0.1, 0.5),
          Wa.bind(null, 0.3, 0.7),
          Wa.bind(null, 0.7, 0.8),
          Wa.bind(null, 0.7, 0.8),
          Wa.bind(null, 0.15, 0.6)
        ]
      };
      Z2.get_nMorphs = function() {
        return c2.Tb;
      };
      var Ob = null;
      var Pb = null;
      var Qb = null;
      var Rb = [];
      function Sb() {
        function b2() {
          ++la === 1 && (Mb.j(c2.Rd, c2.Ye), d2(), Z2.ready = true, Z2.ma.forEach(function(z2) {
            z2();
          }), Z2.ma.splice(0, Z2.ma.length), g2(), la = 0);
        }
        function d2() {
          K2 = new Float32Array(c2.Tb);
          S2 = new Float32Array(c2.Tb);
          v2 = new Uint8Array(e2 * e2 * 4);
          Z2.get_morphTargetInfluences = function() {
            return K2;
          };
          Z2.get_morphTargetInfluencesStabilized = function() {
            return Mb.Ee();
          };
          Z2.set_morphUpdateCallback = function(z2) {
            P2 = z2;
          };
          Z2.get_rotation = function() {
            return f2;
          };
          Z2.get_positionScale = function() {
            var z2 = G2.Ed.Be();
            z2.yb(false);
            z2 = z2.$b();
            l2[0] = 1 - z2[1][0];
            l2[1] = z2[2][0];
            l2[2] = z2[3][0] * E2.G[0];
            return l2;
          };
          Z2.get_rotationStabilized = function() {
            return L2;
          };
          Z2.switch_sleep = function(z2) {
            oa !== ha.dc || z2 ? oa = z2 ? ha.dc : ha.play : g2();
          };
          Z2.on_detect = function(z2) {
            z2(y2.W);
            y2.Vb.push(z2);
          };
          Z2.is_detected = function() {
            return y2.W;
          };
          Z2.set_animateDelay = function(z2) {
            D2 = z2;
            Jb.update({ P: D2 });
          };
        }
        function g2() {
          oa !== ha.play && (oa = ha.play, Jb.stop(), h2());
        }
        function h2() {
          var z2, M2;
          return Ra(new Qa(new Ga(function(ba) {
            switch (ba.a) {
              case 1:
                a: {
                  if (O2.element.nodeName === "VIDEO") {
                    var U2 = O2.element.currentTime - Ba;
                    0 > U2 && (Ba = O2.element.currentTime);
                    if (1e3 * U2 < c2.Nf)
                      break a;
                    Ba += U2;
                  }
                  O2.ta.refresh();
                  U2 = za.Nc();
                  U2[0] === O2.G[0] && U2[1] === O2.G[1] || p2();
                }
                z2 = Ib.De();
                M2 = 0;
              case 2:
                if (!(M2 < z2)) {
                  ba.a = 4;
                  break;
                }
                U2 = G2;
                var ka = x2;
                J2.set("s54");
                db.aa();
                U2.Xa.S();
                O2.ta.b(0);
                U2.kb.b(1);
                c2.Qa && J2.D("u38", C2);
                R2.h(false, false);
                U2.Xa.b(0);
                ka.M(U2.Xa);
                c2.Je ? U2 = V2.lf(Q2, v2).then(t2) : (V2.kf(Q2, v2), t2(), U2 = Promise.resolve());
                ba.a = 3;
                return { value: U2 };
              case 3:
                ++M2;
                ba.a = 2;
                break;
              case 4:
                Nb.disableRendering || (U2 = G2, db.aa(), N2.S(), J2.set("s57"), c2.Qa && J2.D("u38", C2), U2.kb.b(0), R2.h(false, false)), U2 = Ib.ue(), T2 = 3 * (1 - U2) + 1 * U2, Ib.Id(), Z2.Fa && (db.If(), J2.set("s53"), O2.ta.b(0), R2.h(false, false), H2.enable(H2.BLEND), H2.blendFunc(H2.SRC_ALPHA, H2.ONE), N2.b(0), R2.h(false, false), H2.disable(H2.BLEND)), H2.flush(), oa !== ha.dc && Jb.ud(h2), ba.a = 0;
            }
          })));
        }
        function t2() {
          k2();
          if (!c2.je && y2.W) {
            for (var z2 = 0, M2 = 0; 3 > M2; ++M2)
              z2 = n2(M2 + c2.J.rotation[0], c2.J.rotation[1]), z2 = (2 * z2 - 1) * c2.mf[M2], z2 += c2.pf[M2], w2[M2] = z2;
            c2.Qa && (M2 = c2.re, C2 = C2 * (1 - M2) + (-z2 + C2) * M2);
          }
          r2();
          z2 = Lb.Bb();
          M2 = z2 - ca.dd;
          var ba = n2(c2.J.quality[0], c2.J.quality[1]);
          ca.nd = Wa(c2.od[0], c2.od[1], ba);
          ba = n2(c2.J.position[0], c2.J.position[1]);
          var U2 = n2(c2.J.position[0] + 1, c2.J.position[1]), ka = n2(c2.J.position[0] + 2, c2.J.position[1]);
          ca.vd = 1 - Wa(c2.qd[0], c2.qd[1], Math.sqrt(ba * ba + U2 * U2 + ka * ka) / M2);
          ba = ca.ra[0] - w2[0];
          U2 = ca.ra[1] - w2[1];
          ka = ca.ra[2] - w2[2];
          M2 = Math.sqrt(ba * ba + U2 * U2 + ka * ka) / M2;
          ca.ra[0] = w2[0];
          ca.ra[1] = w2[1];
          ca.ra[2] = w2[2];
          ca.rd = 1 - Wa(c2.pd[0], c2.pd[1], M2);
          ca.T = ca.nd * ca.vd * ca.rd;
          ca.dd = z2;
          ca.cd[ca.Nb] = ca.T;
          ca.Nb = (ca.Nb + 1) % c2.Sb;
          for (z2 = 0; z2 < c2.Sb; ++z2)
            ca.T = Math.min(ca.cd[z2], ca.T);
          Mb.Ef(K2, ca.T, T2, S2);
          P2 && P2(ca.T, T2);
          if (y2.W) {
            z2 = ca.T;
            M2 = c2.Td;
            z2 = T2 * (M2[0] * (1 - z2) + M2[1] * z2);
            for (M2 = 0; 3 > M2; ++M2)
              f2[M2] = z2 * w2[M2] + (1 - z2) * f2[M2], L2[M2] = f2[M2];
            L2[2] -= C2;
          } else
            z2 = Lb.Bb() * c2.Ud, A2[0] = c2.vc[0] * Math.sin(z2), A2[1] = c2.vc[1] * Math.cos(z2), L2[0] = A2[0], L2[1] = A2[1], L2[2] = A2[2];
        }
        function r2() {
          var z2 = n2(c2.J.Qc[0], c2.J.Qc[1]);
          y2.Ya = c2.Rc * z2 + (1 - c2.Rc) * y2.Ya;
          y2.Ya > c2.Gd + c2.Hd && !y2.W ? (y2.Vb.forEach(function(M2) {
            M2(true);
          }), y2.W = true) : y2.Ya < c2.Gd - c2.Hd && y2.W && (y2.Vb.forEach(function(M2) {
            M2(false);
          }), y2.W = false, C2 = 0);
        }
        function n2(z2, M2) {
          z2 += e2 * M2;
          return (v2[4 * z2] + v2[4 * z2 + 1] + v2[4 * z2 + 2] + v2[4 * z2 + 3]) / 1020;
        }
        function k2() {
          K2.forEach(function(z2, M2) {
            if (y2.W) {
              var ba = (c2.gd + M2) % e2, U2 = c2.Xe + Math.floor((c2.gd + M2) / e2);
              U2 = e2 - 1 - U2;
              ba += e2 * U2;
              U2 = v2.slice(4 * ba, 4 * ba + 4);
              ba = (U2[0] + U2[1] + U2[2] + U2[3]) / 1020;
              U2 = c2.qe * Math.sqrt((U2[0] * U2[0] + U2[1] * U2[1] + U2[2] * U2[2] + U2[3] * U2[3]) / 1020 - ba * ba);
              K2[M2] = z2 > ba - U2 && z2 < ba + U2 ? z2 : ba;
            } else
              K2[M2] = 0;
          });
        }
        function m2(z2) {
          x2 = new tb({ bb: z2.layers, Zb: "gpuRaw", Wb: function(M2) {
            var ba = G2;
            ba.kb.Bd(1);
            H2.viewport(0, 0, 1, 1);
            J2.set("s55");
            c2.Qa && J2.D("u38", C2);
            J2.D("u39", ca.T);
            J2.Af("u40", Kb.get(0));
            R2.h(false, false);
            ba.Ed.Bd(1);
            J2.set("s56");
            J2.D("u39", ca.T);
            ba.kb.b(0);
            R2.h(false, false);
            Q2 = M2;
          } });
          z2 = x2.Ae();
          z2 !== u2 && (u2 = z2, B2(), G2.Xa.resize(u2, u2), F2());
          e2 = x2.Ge();
          b2();
        }
        function p2() {
          var z2 = za.Nc();
          O2.G[0] = z2[0];
          O2.G[1] = z2[1];
          eb.Sa().width = z2[0];
          eb.Sa().height = z2[1];
          c2.width = z2[0];
          c2.height = z2[1];
          z2 = O2.Mf;
          var M2 = O2.G[1] / O2.G[0], ba = eb.R() / eb.u();
          M2 > ba ? 1 >= M2 ? z2[0] *= M2 : z2[1] /= M2 : (z2[0] *= M2, M2 = 1 / ba, z2[0] *= M2, z2[1] *= M2);
          z2[1] *= ba;
          J2.F("s57", [{ name: "u41", type: "1f", value: ba }]);
          O2.v[0] = 0;
          O2.v[1] = 0;
          O2.v[2] = 0;
          O2.v[3] = 0;
          switch (Nb.rotate) {
            case 0:
              O2.v[0] = z2[0];
              O2.v[3] = z2[1];
              break;
            case 180:
              O2.v[0] = -z2[0];
              O2.v[3] = -z2[1];
              break;
            case 90:
              O2.v[1] = z2[0];
              O2.v[2] = -z2[1];
              break;
            case -90:
              O2.v[1] = -z2[0], O2.v[2] = z2[1];
          }
          z2 = [{ type: "mat2", name: "u42", value: O2.v }];
          J2.F("s54", z2);
          J2.F("s53", z2);
          J2.F("s57", [{
            type: "mat2",
            name: "u42",
            value: Math.abs(Nb.rotate) === 90 ? [0, -O2.v[1], -O2.v[2], 0] : O2.v
          }]);
        }
        function B2() {
          E2.K = c2.width;
          E2.ea = c2.height;
          Kb.j({ fb: c2.sf, jd: c2.rf, K: E2.K, ea: E2.ea, wd: c2.tf, Z: c2.Z, yd: true });
          E2.G = [1, E2.K / E2.ea];
        }
        function F2() {
          J2.F("s53", [{ type: "1i", name: "u1", value: 0 }]);
          J2.F("s54", [{ type: "1i", name: "u1", value: 0 }, { type: "1i", name: "u43", value: 1 }, { type: "1f", name: "u38", value: 0 }, { type: "2f", name: "u44", value: E2.G }]);
          J2.F("s57", [{ type: "1i", name: "u43", value: 0 }, { type: "2f", name: "u44", value: E2.G }, { type: "1f", name: "u38", value: 0 }, {
            type: "3f",
            name: "u45",
            value: [0, 0.5, 1]
          }]);
          J2.F("s55", [{ type: "1i", name: "u46", value: 0 }, { type: "1i", name: "u43", value: 1 }, { type: "1f", name: "u47", value: c2.xd[0] }, { type: "1f", name: "u48", value: c2.xd[1] }, { type: "1f", name: "u49", value: c2.Gf }, { type: "1f", name: "u50", value: c2.threshold }, { type: "1f", name: "u51", value: c2.le }, { type: "1f", name: "u38", value: 0 }, { type: "3f", name: "u52", value: [c2.Z[0] * E2.G[0], c2.Z[1] * E2.G[1], c2.Z[2]] }]);
          J2.F("s56", [{ type: "1i", name: "u1", value: 0 }, { type: "1i", name: "u6", value: 1 }, { type: "2f", name: "u53", value: c2.Sd }]);
        }
        function q2(z2) {
          var M2 = new Float32Array([
            0,
            0.5,
            0.5,
            0
          ]);
          z2.Xa = V2.instance({ isPot: true, isFloat: false, width: u2 });
          M2 = { width: 1, height: 1, isFloat: true, isPot: false, array: M2 };
          z2.kb = ib.instance(M2);
          z2.Ed = ib.instance(M2);
        }
        var u2 = 64, D2 = c2.P, x2 = null, e2 = 0, G2 = {}, N2 = null, K2 = null, S2 = null, v2 = null, P2 = null, Q2 = null, w2 = [0, 0, 0], f2 = [0, 0, 0], A2 = [0, 0, 0], L2 = [0, 0, 0], l2 = [0, 0, 0], C2 = 0, E2 = { G: null, K: -1, ea: -1 }, T2 = 1, O2 = { Mf: [0.5, 0.5], v: [0.5, 0, 0, 0.5], element: null, ta: null, G: [-1, -1] }, la = 0, ha = { fe: -4, Ze: -3, Cg: -2, dc: -1, play: 0 }, oa = ha.Ze, y2 = { Ya: 0, W: false, Vb: [] }, ca = { T: 1, vd: 1, nd: 1, rd: 1, ra: [0, 0, 0], dd: Lb.Bb(), cd: new Float32Array(c2.Sb), Nb: 0 }, Ba = 0, za = { j: function() {
          O2.ta = V2.instance({ A: O2.element, isPot: false, isFloat: false, isFlipY: true });
          N2 = V2.instance({ isPot: false, isFloat: false, width: E2.K, height: E2.ea });
          q2(G2);
          Jb.j({ Zc: false, P: D2 });
          Ib.j({ Rb: 0, n: c2.pb[1] - c2.pb[0] + 1, fd: c2.pb[0] });
          Qb ? m2(Qb) : Ua(function(z2) {
            z2 = JSON.parse(z2);
            m2(z2);
          });
        }, i: function() {
          Jb.stop();
          x2 && (x2.i(), x2 = null);
          oa = ha.fe;
        }, ce: function(z2) {
          Z2.rb && Z2.rb();
          var M2 = {
            video: { facingMode: { ideal: Nb.facingMode }, width: { min: Nb.minWidth, max: Nb.maxWidth, ideal: Nb.idealWidth }, height: { min: Nb.minHeight, max: Nb.maxHeight, ideal: Nb.idealHeight } },
            audio: Nb.isAudio
          };
          Ab(M2, Nb.deviceId);
          Hb(function(ba, U2) {
            Ob = U2;
            Z2.sb && Z2.sb();
            z2(ba);
          }, function() {
            window.a && window.a("WEBCAM_UNAVAILABLE");
          }, M2);
        }, ed: function(z2, M2) {
          J2.uc([{ id: "s53", name: "_", ua: "attribute vec2 a0;uniform mat2 u42;varying vec2 vv0;const vec2 f=vec2(.5,.5);void main(){gl_Position=vec4(a0,0.,1.),vv0=f+u42*a0;}", Ha: ["a0"], xa: [2], c: "uniform sampler2D u1;varying vec2 vv0;void main(){gl_FragColor=texture2D(u1,vv0);}", f: ["u1", "u42"], precision: "lowp" }, {
            id: "s54",
            name: "_",
            c: "uniform sampler2D u1;varying vec2 vv0;void main(){gl_FragColor=texture2D(u1,vv0);}",
            ua: "attribute vec2 a0;uniform sampler2D u43;uniform mat2 u42;uniform vec2 u44;uniform float u38;const vec2 e=vec2(.25,.5),f=vec2(.5,.5);varying vec2 vv0;void main(){vec4 a=texture2D(u43,e);vec2 d=a.gb,h=a.a*u44;float b=cos(u38),c=sin(u38);vec2 i=mat2(b,c,-c,b)*a0,j=d+i*.5*h,k=j-.5;vv0=f+2.*u42*k,gl_Position=vec4(a0,0.,1.);}",
            Ha: ["a0"],
            xa: [2],
            f: ["u1", "u43", "u44", "u42", "u38"],
            precision: "lowp"
          }, {
            id: "s55",
            name: "_",
            ua: "attribute vec2 a0;void main(){gl_Position=vec4(a0,0.,1.);}",
            c: "uniform sampler2D u46,u43;uniform vec3 u40,u52;uniform float u47,u48,u49,u50,u39,u51,u38;varying vec2 vv0;const vec4 e=vec4(.25,.25,.25,.25);void main(){vec4 h=texture2D(u46,vec2(.4375,.9375)),i=texture2D(u46,vec2(.5625,.9375));float j=dot(h-i,e);bool k=j>u50;vec4 a=texture2D(u43,vec2(.5,.5));k?a.r=2.:a.r>u49?a.r=0.:a.r>1.9&&(a.a>u48||a.a<u47)?a.r=0.:a.r>1.9?a.r+=1.:0.;if(a.r<.9)a.gba=u40,a.r=1.;else{float l=dot(e,texture2D(u46,vec2(.0625,.9375))),m=dot(e,texture2D(u46,vec2(.1875,.9375))),d=dot(e,texture2D(u46,vec2(.3125,.9375))),f=cos(u38),g=sin(u38);vec2 c=mat2(f,g,-g,f)*vec2(l,m);float b;a.r>1.9?(b=1.-u39,b*=1.-step(abs(c.x),u51)*step(abs(c.y),u51)*step(abs(d),u51)):(b=1.,a.r=0.),a.gba+=vec3(c,d)*u52*a.a*b;}gl_FragColor=a;}",
            f: "u46 u43 u40 u47 u48 u49 u50 u52 u39 u51 u38".split(" ")
          }, {
            id: "s57",
            name: "_",
            ua: "attribute vec2 a0;uniform mat2 u42;varying vec2 vv0;const vec2 f=vec2(.5,.5);void main(){gl_Position=vec4(a0,0.,1.),vv0=f+u42*a0;}",
            c: "uniform sampler2D u43;uniform vec3 u45;uniform vec2 u44;uniform float u38,u41;varying vec2 vv0;const vec2 l=vec2(1.,1.),e=vec2(.5,.5),m=vec2(.25,.5);void main(){float f=cos(u38),g=-sin(u38);mat2 h=mat2(f,g/u41,-g*u41,f);vec2 b=h*(vv0-e);vec4 i=texture2D(u43,m);vec2 c=h*(i.gb-e);float n=i.a;vec2 d=.5*n*u44,o=c+d,p=c-d,j=step(p,b)*step(b,o);float q=j.x*j.y;vec2 a=abs(c-b)/d;a=pow(a,3.*l),gl_FragColor=vec4(q*u45*max(a.x,a.y),1.);}",
            f: "u43 u44 u45 u42 u38 u41".split(" "),
            precision: "lowp"
          }, { id: "s56", name: "_", c: "uniform sampler2D u1,u6;uniform vec2 u53;uniform float u39;const vec4 f=vec4(1.,1.,1.,1.);varying vec2 vv0;void main(){vec4 a=texture2D(u1,vv0),b=texture2D(u6,vv0);float c=mix(u53.x,u53.y,u39);gl_FragColor=mix(b,a,c*f);}", f: ["u1", "u6", "u53", "u39"] }]);
          O2.element = z2;
          Pb = O2.element;
          p2();
          B2();
          F2();
          za.j();
          M2 && M2();
        }, Nc: function() {
          var z2 = [-1, -1], M2 = O2.element;
          M2.nodeName === "VIDEO" ? (z2[0] = M2.videoWidth, z2[1] = M2.videoHeight) : (z2[0] = M2.width, z2[1] = M2.height);
          Math.abs(Nb.rotate) === 90 && z2.reverse();
          return z2;
        } };
        Rb.push(za);
        return za;
      }
      Z2.onLoad = function(b2) {
        Z2.ready ? b2() : Z2.ma.push(b2);
      };
      Z2.switch_displayVideo = function(b2) {
        Z2.Fa = b2;
        Z2.Ea && (Z2.Ea.style.display = Z2.Fa ? "block" : "none");
      };
      Z2.onWebcamAsk = function(b2) {
        Z2.rb = b2;
      };
      Z2.onContextLost = function(b2) {
        Z2.qb = b2;
      };
      Z2.onWebcamGet = function(b2) {
        Z2.sb = b2;
      };
      Z2.destroy = function() {
        Jb.i();
        Pb && Pb.srcObject && Pb.srcObject.getTracks().forEach(function(b2) {
          b2.stop();
        });
        Rb.forEach(function(b2) {
          b2.i();
        });
        Rb.splice(0);
        eb.i();
        Z2.switch_displayVideo(false);
        Z2.initialized = false;
        Z2.ma.splice(0);
      };
      Z2.set_size = function(b2, d2) {
        c2.width = b2;
        c2.height = d2;
      };
      Z2.get_size = function() {
        return { width: c2.width, height: c2.height };
      };
      Z2.get_videoStream = function() {
        return Ob;
      };
      Z2.get_video = function() {
        return Pb;
      };
      Z2.get_cv = function() {
        return eb.Sa();
      };
      Z2.set_color = function(b2) {
        J2.F("s57", [{ type: "3f", name: "u45", value: b2 }]);
      };
      Z2.init = function(b2) {
        var d2 = Sb(), g2 = b2.callbackReady || function(r2) {
          console.log("ERR:", r2);
        }, h2 = b2.callbackReady ? b2.callbackReady.bind(null, false) : null;
        if (b2.canvasId || b2.canvas) {
          var t2 = b2.canvas ? b2.canvas : document.getElementById(b2.canvasId);
          if (t2)
            if (Z2.initialized)
              g2("ALREADY_INITIALIZED");
            else {
              Z2.initialized = true;
              window.a = g2 ? function(r2) {
                g2(r2);
                window.a = false;
              } : false;
              b2.NNCPath && (c2.rc = b2.NNCPath);
              typeof b2.NNC !== "undefined" && (Qb = typeof b2.NNC === "string" ? JSON.parse(b2.NNC) : b2.NNC);
              h2 && Z2.ma.push(h2);
              if (!eb.j({
                Ka: t2,
                width: c2.width,
                height: c2.height,
                debug: false,
                Wc: false,
                Ub: function() {
                  Z2.qb && Z2.qb();
                },
                premultipliedAlpha: false
              }))
                return g2("GL_INCOMPATIBLE"), false;
              Z2.Ea = eb.Sa();
              Z2.Fa || (Z2.Ea.style.display = "none");
              b2.videoSettings && b2.videoSettings.videoElement ? d2.ed(b2.videoSettings.videoElement, false) : (b2.videoSettings && Object.assign(Nb, b2.videoSettings), d2.ce(function(r2) {
                d2.ed(r2, false);
              }));
              return true;
            }
          else
            g2("INVALID_CANVAS");
        } else
          g2("NO_CANVASID");
      };
      var JEELIZFACEEXPRESSIONS = Z2;
      if (typeof module !== "undefined") {
        module.exports = JEELIZFACEEXPRESSIONS;
      }
    }
  });

  // node_modules/three/build/three.module.js
  var REVISION = "133";
  var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
  var TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
  var CullFaceNone = 0;
  var CullFaceBack = 1;
  var CullFaceFront = 2;
  var PCFShadowMap = 1;
  var PCFSoftShadowMap = 2;
  var VSMShadowMap = 3;
  var FrontSide = 0;
  var BackSide = 1;
  var DoubleSide = 2;
  var FlatShading = 1;
  var NoBlending = 0;
  var NormalBlending = 1;
  var AdditiveBlending = 2;
  var SubtractiveBlending = 3;
  var MultiplyBlending = 4;
  var CustomBlending = 5;
  var AddEquation = 100;
  var SubtractEquation = 101;
  var ReverseSubtractEquation = 102;
  var MinEquation = 103;
  var MaxEquation = 104;
  var ZeroFactor = 200;
  var OneFactor = 201;
  var SrcColorFactor = 202;
  var OneMinusSrcColorFactor = 203;
  var SrcAlphaFactor = 204;
  var OneMinusSrcAlphaFactor = 205;
  var DstAlphaFactor = 206;
  var OneMinusDstAlphaFactor = 207;
  var DstColorFactor = 208;
  var OneMinusDstColorFactor = 209;
  var SrcAlphaSaturateFactor = 210;
  var NeverDepth = 0;
  var AlwaysDepth = 1;
  var LessDepth = 2;
  var LessEqualDepth = 3;
  var EqualDepth = 4;
  var GreaterEqualDepth = 5;
  var GreaterDepth = 6;
  var NotEqualDepth = 7;
  var MultiplyOperation = 0;
  var MixOperation = 1;
  var AddOperation = 2;
  var NoToneMapping = 0;
  var LinearToneMapping = 1;
  var ReinhardToneMapping = 2;
  var CineonToneMapping = 3;
  var ACESFilmicToneMapping = 4;
  var CustomToneMapping = 5;
  var UVMapping = 300;
  var CubeReflectionMapping = 301;
  var CubeRefractionMapping = 302;
  var EquirectangularReflectionMapping = 303;
  var EquirectangularRefractionMapping = 304;
  var CubeUVReflectionMapping = 306;
  var CubeUVRefractionMapping = 307;
  var RepeatWrapping = 1e3;
  var ClampToEdgeWrapping = 1001;
  var MirroredRepeatWrapping = 1002;
  var NearestFilter = 1003;
  var NearestMipmapNearestFilter = 1004;
  var NearestMipmapLinearFilter = 1005;
  var LinearFilter = 1006;
  var LinearMipmapNearestFilter = 1007;
  var LinearMipmapLinearFilter = 1008;
  var UnsignedByteType = 1009;
  var ByteType = 1010;
  var ShortType = 1011;
  var UnsignedShortType = 1012;
  var IntType = 1013;
  var UnsignedIntType = 1014;
  var FloatType = 1015;
  var HalfFloatType = 1016;
  var UnsignedShort4444Type = 1017;
  var UnsignedShort5551Type = 1018;
  var UnsignedShort565Type = 1019;
  var UnsignedInt248Type = 1020;
  var AlphaFormat = 1021;
  var RGBFormat = 1022;
  var RGBAFormat = 1023;
  var LuminanceFormat = 1024;
  var LuminanceAlphaFormat = 1025;
  var RGBEFormat = RGBAFormat;
  var DepthFormat = 1026;
  var DepthStencilFormat = 1027;
  var RedFormat = 1028;
  var RedIntegerFormat = 1029;
  var RGFormat = 1030;
  var RGIntegerFormat = 1031;
  var RGBIntegerFormat = 1032;
  var RGBAIntegerFormat = 1033;
  var RGB_S3TC_DXT1_Format = 33776;
  var RGBA_S3TC_DXT1_Format = 33777;
  var RGBA_S3TC_DXT3_Format = 33778;
  var RGBA_S3TC_DXT5_Format = 33779;
  var RGB_PVRTC_4BPPV1_Format = 35840;
  var RGB_PVRTC_2BPPV1_Format = 35841;
  var RGBA_PVRTC_4BPPV1_Format = 35842;
  var RGBA_PVRTC_2BPPV1_Format = 35843;
  var RGB_ETC1_Format = 36196;
  var RGB_ETC2_Format = 37492;
  var RGBA_ETC2_EAC_Format = 37496;
  var RGBA_ASTC_4x4_Format = 37808;
  var RGBA_ASTC_5x4_Format = 37809;
  var RGBA_ASTC_5x5_Format = 37810;
  var RGBA_ASTC_6x5_Format = 37811;
  var RGBA_ASTC_6x6_Format = 37812;
  var RGBA_ASTC_8x5_Format = 37813;
  var RGBA_ASTC_8x6_Format = 37814;
  var RGBA_ASTC_8x8_Format = 37815;
  var RGBA_ASTC_10x5_Format = 37816;
  var RGBA_ASTC_10x6_Format = 37817;
  var RGBA_ASTC_10x8_Format = 37818;
  var RGBA_ASTC_10x10_Format = 37819;
  var RGBA_ASTC_12x10_Format = 37820;
  var RGBA_ASTC_12x12_Format = 37821;
  var RGBA_BPTC_Format = 36492;
  var SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
  var SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
  var SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
  var SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
  var SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
  var SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
  var SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
  var SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
  var SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
  var SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
  var SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
  var SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
  var SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
  var SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
  var LoopOnce = 2200;
  var LoopRepeat = 2201;
  var LoopPingPong = 2202;
  var InterpolateDiscrete = 2300;
  var InterpolateLinear = 2301;
  var InterpolateSmooth = 2302;
  var ZeroCurvatureEnding = 2400;
  var ZeroSlopeEnding = 2401;
  var WrapAroundEnding = 2402;
  var NormalAnimationBlendMode = 2500;
  var AdditiveAnimationBlendMode = 2501;
  var TrianglesDrawMode = 0;
  var TriangleStripDrawMode = 1;
  var TriangleFanDrawMode = 2;
  var LinearEncoding = 3e3;
  var sRGBEncoding = 3001;
  var GammaEncoding = 3007;
  var RGBEEncoding = 3002;
  var LogLuvEncoding = 3003;
  var RGBM7Encoding = 3004;
  var RGBM16Encoding = 3005;
  var RGBDEncoding = 3006;
  var BasicDepthPacking = 3200;
  var RGBADepthPacking = 3201;
  var TangentSpaceNormalMap = 0;
  var ObjectSpaceNormalMap = 1;
  var KeepStencilOp = 7680;
  var AlwaysStencilFunc = 519;
  var StaticDrawUsage = 35044;
  var DynamicDrawUsage = 35048;
  var GLSL3 = "300 es";
  var EventDispatcher = class {
    addEventListener(type, listener) {
      if (this._listeners === void 0)
        this._listeners = {};
      const listeners = this._listeners;
      if (listeners[type] === void 0) {
        listeners[type] = [];
      }
      if (listeners[type].indexOf(listener) === -1) {
        listeners[type].push(listener);
      }
    }
    hasEventListener(type, listener) {
      if (this._listeners === void 0)
        return false;
      const listeners = this._listeners;
      return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
    }
    removeEventListener(type, listener) {
      if (this._listeners === void 0)
        return;
      const listeners = this._listeners;
      const listenerArray = listeners[type];
      if (listenerArray !== void 0) {
        const index = listenerArray.indexOf(listener);
        if (index !== -1) {
          listenerArray.splice(index, 1);
        }
      }
    }
    dispatchEvent(event) {
      if (this._listeners === void 0)
        return;
      const listeners = this._listeners;
      const listenerArray = listeners[event.type];
      if (listenerArray !== void 0) {
        event.target = this;
        const array = listenerArray.slice(0);
        for (let i2 = 0, l2 = array.length; i2 < l2; i2++) {
          array[i2].call(this, event);
        }
        event.target = null;
      }
    }
  };
  var _seed = 1234567;
  var DEG2RAD = Math.PI / 180;
  var RAD2DEG = 180 / Math.PI;
  var _lut = [];
  for (let i2 = 0; i2 < 256; i2++) {
    _lut[i2] = (i2 < 16 ? "0" : "") + i2.toString(16);
  }
  var hasRandomUUID = typeof crypto !== "undefined" && "randomUUID" in crypto;
  function generateUUID() {
    if (hasRandomUUID) {
      return crypto.randomUUID().toUpperCase();
    }
    const d0 = Math.random() * 4294967295 | 0;
    const d1 = Math.random() * 4294967295 | 0;
    const d2 = Math.random() * 4294967295 | 0;
    const d3 = Math.random() * 4294967295 | 0;
    const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
    return uuid.toUpperCase();
  }
  function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
  }
  function euclideanModulo(n2, m2) {
    return (n2 % m2 + m2) % m2;
  }
  function mapLinear(x2, a1, a2, b1, b2) {
    return b1 + (x2 - a1) * (b2 - b1) / (a2 - a1);
  }
  function inverseLerp(x2, y2, value) {
    if (x2 !== y2) {
      return (value - x2) / (y2 - x2);
    } else {
      return 0;
    }
  }
  function lerp(x2, y2, t2) {
    return (1 - t2) * x2 + t2 * y2;
  }
  function damp(x2, y2, lambda, dt) {
    return lerp(x2, y2, 1 - Math.exp(-lambda * dt));
  }
  function pingpong(x2, length = 1) {
    return length - Math.abs(euclideanModulo(x2, length * 2) - length);
  }
  function smoothstep(x2, min, max) {
    if (x2 <= min)
      return 0;
    if (x2 >= max)
      return 1;
    x2 = (x2 - min) / (max - min);
    return x2 * x2 * (3 - 2 * x2);
  }
  function smootherstep(x2, min, max) {
    if (x2 <= min)
      return 0;
    if (x2 >= max)
      return 1;
    x2 = (x2 - min) / (max - min);
    return x2 * x2 * x2 * (x2 * (x2 * 6 - 15) + 10);
  }
  function randInt(low, high) {
    return low + Math.floor(Math.random() * (high - low + 1));
  }
  function randFloat(low, high) {
    return low + Math.random() * (high - low);
  }
  function randFloatSpread(range) {
    return range * (0.5 - Math.random());
  }
  function seededRandom(s2) {
    if (s2 !== void 0)
      _seed = s2 % 2147483647;
    _seed = _seed * 16807 % 2147483647;
    return (_seed - 1) / 2147483646;
  }
  function degToRad(degrees) {
    return degrees * DEG2RAD;
  }
  function radToDeg(radians) {
    return radians * RAD2DEG;
  }
  function isPowerOfTwo(value) {
    return (value & value - 1) === 0 && value !== 0;
  }
  function ceilPowerOfTwo(value) {
    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
  }
  function floorPowerOfTwo(value) {
    return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
  }
  function setQuaternionFromProperEuler(q2, a2, b2, c2, order) {
    const cos = Math.cos;
    const sin = Math.sin;
    const c22 = cos(b2 / 2);
    const s2 = sin(b2 / 2);
    const c13 = cos((a2 + c2) / 2);
    const s13 = sin((a2 + c2) / 2);
    const c1_3 = cos((a2 - c2) / 2);
    const s1_3 = sin((a2 - c2) / 2);
    const c3_1 = cos((c2 - a2) / 2);
    const s3_1 = sin((c2 - a2) / 2);
    switch (order) {
      case "XYX":
        q2.set(c22 * s13, s2 * c1_3, s2 * s1_3, c22 * c13);
        break;
      case "YZY":
        q2.set(s2 * s1_3, c22 * s13, s2 * c1_3, c22 * c13);
        break;
      case "ZXZ":
        q2.set(s2 * c1_3, s2 * s1_3, c22 * s13, c22 * c13);
        break;
      case "XZX":
        q2.set(c22 * s13, s2 * s3_1, s2 * c3_1, c22 * c13);
        break;
      case "YXY":
        q2.set(s2 * c3_1, c22 * s13, s2 * s3_1, c22 * c13);
        break;
      case "ZYZ":
        q2.set(s2 * s3_1, s2 * c3_1, c22 * s13, c22 * c13);
        break;
      default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
    }
  }
  var MathUtils = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    DEG2RAD,
    RAD2DEG,
    generateUUID,
    clamp,
    euclideanModulo,
    mapLinear,
    inverseLerp,
    lerp,
    damp,
    pingpong,
    smoothstep,
    smootherstep,
    randInt,
    randFloat,
    randFloatSpread,
    seededRandom,
    degToRad,
    radToDeg,
    isPowerOfTwo,
    ceilPowerOfTwo,
    floorPowerOfTwo,
    setQuaternionFromProperEuler
  });
  var Vector2 = class {
    constructor(x2 = 0, y2 = 0) {
      this.x = x2;
      this.y = y2;
    }
    get width() {
      return this.x;
    }
    set width(value) {
      this.x = value;
    }
    get height() {
      return this.y;
    }
    set height(value) {
      this.y = value;
    }
    set(x2, y2) {
      this.x = x2;
      this.y = y2;
      return this;
    }
    setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      return this;
    }
    setX(x2) {
      this.x = x2;
      return this;
    }
    setY(y2) {
      this.y = y2;
      return this;
    }
    setComponent(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        default:
          throw new Error("index is out of range: " + index);
      }
      return this;
    }
    getComponent(index) {
      switch (index) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + index);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y);
    }
    copy(v2) {
      this.x = v2.x;
      this.y = v2.y;
      return this;
    }
    add(v2, w2) {
      if (w2 !== void 0) {
        console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
        return this.addVectors(v2, w2);
      }
      this.x += v2.x;
      this.y += v2.y;
      return this;
    }
    addScalar(s2) {
      this.x += s2;
      this.y += s2;
      return this;
    }
    addVectors(a2, b2) {
      this.x = a2.x + b2.x;
      this.y = a2.y + b2.y;
      return this;
    }
    addScaledVector(v2, s2) {
      this.x += v2.x * s2;
      this.y += v2.y * s2;
      return this;
    }
    sub(v2, w2) {
      if (w2 !== void 0) {
        console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
        return this.subVectors(v2, w2);
      }
      this.x -= v2.x;
      this.y -= v2.y;
      return this;
    }
    subScalar(s2) {
      this.x -= s2;
      this.y -= s2;
      return this;
    }
    subVectors(a2, b2) {
      this.x = a2.x - b2.x;
      this.y = a2.y - b2.y;
      return this;
    }
    multiply(v2) {
      this.x *= v2.x;
      this.y *= v2.y;
      return this;
    }
    multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      return this;
    }
    divide(v2) {
      this.x /= v2.x;
      this.y /= v2.y;
      return this;
    }
    divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
    applyMatrix3(m2) {
      const x2 = this.x, y2 = this.y;
      const e2 = m2.elements;
      this.x = e2[0] * x2 + e2[3] * y2 + e2[6];
      this.y = e2[1] * x2 + e2[4] * y2 + e2[7];
      return this;
    }
    min(v2) {
      this.x = Math.min(this.x, v2.x);
      this.y = Math.min(this.y, v2.y);
      return this;
    }
    max(v2) {
      this.x = Math.max(this.x, v2.x);
      this.y = Math.max(this.y, v2.y);
      return this;
    }
    clamp(min, max) {
      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      return this;
    }
    clampScalar(minVal, maxVal) {
      this.x = Math.max(minVal, Math.min(maxVal, this.x));
      this.y = Math.max(minVal, Math.min(maxVal, this.y));
      return this;
    }
    clampLength(min, max) {
      const length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      return this;
    }
    ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      return this;
    }
    round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      return this;
    }
    roundToZero() {
      this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
      this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
      return this;
    }
    negate() {
      this.x = -this.x;
      this.y = -this.y;
      return this;
    }
    dot(v2) {
      return this.x * v2.x + this.y * v2.y;
    }
    cross(v2) {
      return this.x * v2.y - this.y * v2.x;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    angle() {
      const angle = Math.atan2(-this.y, -this.x) + Math.PI;
      return angle;
    }
    distanceTo(v2) {
      return Math.sqrt(this.distanceToSquared(v2));
    }
    distanceToSquared(v2) {
      const dx = this.x - v2.x, dy = this.y - v2.y;
      return dx * dx + dy * dy;
    }
    manhattanDistanceTo(v2) {
      return Math.abs(this.x - v2.x) + Math.abs(this.y - v2.y);
    }
    setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
    lerp(v2, alpha) {
      this.x += (v2.x - this.x) * alpha;
      this.y += (v2.y - this.y) * alpha;
      return this;
    }
    lerpVectors(v1, v2, alpha) {
      this.x = v1.x + (v2.x - v1.x) * alpha;
      this.y = v1.y + (v2.y - v1.y) * alpha;
      return this;
    }
    equals(v2) {
      return v2.x === this.x && v2.y === this.y;
    }
    fromArray(array, offset = 0) {
      this.x = array[offset];
      this.y = array[offset + 1];
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this.x;
      array[offset + 1] = this.y;
      return array;
    }
    fromBufferAttribute(attribute, index, offset) {
      if (offset !== void 0) {
        console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
      }
      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      return this;
    }
    rotateAround(center, angle) {
      const c2 = Math.cos(angle), s2 = Math.sin(angle);
      const x2 = this.x - center.x;
      const y2 = this.y - center.y;
      this.x = x2 * c2 - y2 * s2 + center.x;
      this.y = x2 * s2 + y2 * c2 + center.y;
      return this;
    }
    random() {
      this.x = Math.random();
      this.y = Math.random();
      return this;
    }
    *[Symbol.iterator]() {
      yield this.x;
      yield this.y;
    }
  };
  Vector2.prototype.isVector2 = true;
  var Matrix3 = class {
    constructor() {
      this.elements = [
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ];
      if (arguments.length > 0) {
        console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
      }
    }
    set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
      const te2 = this.elements;
      te2[0] = n11;
      te2[1] = n21;
      te2[2] = n31;
      te2[3] = n12;
      te2[4] = n22;
      te2[5] = n32;
      te2[6] = n13;
      te2[7] = n23;
      te2[8] = n33;
      return this;
    }
    identity() {
      this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
      return this;
    }
    copy(m2) {
      const te2 = this.elements;
      const me2 = m2.elements;
      te2[0] = me2[0];
      te2[1] = me2[1];
      te2[2] = me2[2];
      te2[3] = me2[3];
      te2[4] = me2[4];
      te2[5] = me2[5];
      te2[6] = me2[6];
      te2[7] = me2[7];
      te2[8] = me2[8];
      return this;
    }
    extractBasis(xAxis, yAxis, zAxis) {
      xAxis.setFromMatrix3Column(this, 0);
      yAxis.setFromMatrix3Column(this, 1);
      zAxis.setFromMatrix3Column(this, 2);
      return this;
    }
    setFromMatrix4(m2) {
      const me2 = m2.elements;
      this.set(me2[0], me2[4], me2[8], me2[1], me2[5], me2[9], me2[2], me2[6], me2[10]);
      return this;
    }
    multiply(m2) {
      return this.multiplyMatrices(this, m2);
    }
    premultiply(m2) {
      return this.multiplyMatrices(m2, this);
    }
    multiplyMatrices(a2, b2) {
      const ae2 = a2.elements;
      const be = b2.elements;
      const te2 = this.elements;
      const a11 = ae2[0], a12 = ae2[3], a13 = ae2[6];
      const a21 = ae2[1], a22 = ae2[4], a23 = ae2[7];
      const a31 = ae2[2], a32 = ae2[5], a33 = ae2[8];
      const b11 = be[0], b12 = be[3], b13 = be[6];
      const b21 = be[1], b22 = be[4], b23 = be[7];
      const b31 = be[2], b32 = be[5], b33 = be[8];
      te2[0] = a11 * b11 + a12 * b21 + a13 * b31;
      te2[3] = a11 * b12 + a12 * b22 + a13 * b32;
      te2[6] = a11 * b13 + a12 * b23 + a13 * b33;
      te2[1] = a21 * b11 + a22 * b21 + a23 * b31;
      te2[4] = a21 * b12 + a22 * b22 + a23 * b32;
      te2[7] = a21 * b13 + a22 * b23 + a23 * b33;
      te2[2] = a31 * b11 + a32 * b21 + a33 * b31;
      te2[5] = a31 * b12 + a32 * b22 + a33 * b32;
      te2[8] = a31 * b13 + a32 * b23 + a33 * b33;
      return this;
    }
    multiplyScalar(s2) {
      const te2 = this.elements;
      te2[0] *= s2;
      te2[3] *= s2;
      te2[6] *= s2;
      te2[1] *= s2;
      te2[4] *= s2;
      te2[7] *= s2;
      te2[2] *= s2;
      te2[5] *= s2;
      te2[8] *= s2;
      return this;
    }
    determinant() {
      const te2 = this.elements;
      const a2 = te2[0], b2 = te2[1], c2 = te2[2], d2 = te2[3], e2 = te2[4], f2 = te2[5], g2 = te2[6], h2 = te2[7], i2 = te2[8];
      return a2 * e2 * i2 - a2 * f2 * h2 - b2 * d2 * i2 + b2 * f2 * g2 + c2 * d2 * h2 - c2 * e2 * g2;
    }
    invert() {
      const te2 = this.elements, n11 = te2[0], n21 = te2[1], n31 = te2[2], n12 = te2[3], n22 = te2[4], n32 = te2[5], n13 = te2[6], n23 = te2[7], n33 = te2[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
      if (det === 0)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      const detInv = 1 / det;
      te2[0] = t11 * detInv;
      te2[1] = (n31 * n23 - n33 * n21) * detInv;
      te2[2] = (n32 * n21 - n31 * n22) * detInv;
      te2[3] = t12 * detInv;
      te2[4] = (n33 * n11 - n31 * n13) * detInv;
      te2[5] = (n31 * n12 - n32 * n11) * detInv;
      te2[6] = t13 * detInv;
      te2[7] = (n21 * n13 - n23 * n11) * detInv;
      te2[8] = (n22 * n11 - n21 * n12) * detInv;
      return this;
    }
    transpose() {
      let tmp2;
      const m2 = this.elements;
      tmp2 = m2[1];
      m2[1] = m2[3];
      m2[3] = tmp2;
      tmp2 = m2[2];
      m2[2] = m2[6];
      m2[6] = tmp2;
      tmp2 = m2[5];
      m2[5] = m2[7];
      m2[7] = tmp2;
      return this;
    }
    getNormalMatrix(matrix4) {
      return this.setFromMatrix4(matrix4).invert().transpose();
    }
    transposeIntoArray(r2) {
      const m2 = this.elements;
      r2[0] = m2[0];
      r2[1] = m2[3];
      r2[2] = m2[6];
      r2[3] = m2[1];
      r2[4] = m2[4];
      r2[5] = m2[7];
      r2[6] = m2[2];
      r2[7] = m2[5];
      r2[8] = m2[8];
      return this;
    }
    setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
      const c2 = Math.cos(rotation);
      const s2 = Math.sin(rotation);
      this.set(sx * c2, sx * s2, -sx * (c2 * cx + s2 * cy) + cx + tx, -sy * s2, sy * c2, -sy * (-s2 * cx + c2 * cy) + cy + ty, 0, 0, 1);
      return this;
    }
    scale(sx, sy) {
      const te2 = this.elements;
      te2[0] *= sx;
      te2[3] *= sx;
      te2[6] *= sx;
      te2[1] *= sy;
      te2[4] *= sy;
      te2[7] *= sy;
      return this;
    }
    rotate(theta) {
      const c2 = Math.cos(theta);
      const s2 = Math.sin(theta);
      const te2 = this.elements;
      const a11 = te2[0], a12 = te2[3], a13 = te2[6];
      const a21 = te2[1], a22 = te2[4], a23 = te2[7];
      te2[0] = c2 * a11 + s2 * a21;
      te2[3] = c2 * a12 + s2 * a22;
      te2[6] = c2 * a13 + s2 * a23;
      te2[1] = -s2 * a11 + c2 * a21;
      te2[4] = -s2 * a12 + c2 * a22;
      te2[7] = -s2 * a13 + c2 * a23;
      return this;
    }
    translate(tx, ty) {
      const te2 = this.elements;
      te2[0] += tx * te2[2];
      te2[3] += tx * te2[5];
      te2[6] += tx * te2[8];
      te2[1] += ty * te2[2];
      te2[4] += ty * te2[5];
      te2[7] += ty * te2[8];
      return this;
    }
    equals(matrix) {
      const te2 = this.elements;
      const me2 = matrix.elements;
      for (let i2 = 0; i2 < 9; i2++) {
        if (te2[i2] !== me2[i2])
          return false;
      }
      return true;
    }
    fromArray(array, offset = 0) {
      for (let i2 = 0; i2 < 9; i2++) {
        this.elements[i2] = array[i2 + offset];
      }
      return this;
    }
    toArray(array = [], offset = 0) {
      const te2 = this.elements;
      array[offset] = te2[0];
      array[offset + 1] = te2[1];
      array[offset + 2] = te2[2];
      array[offset + 3] = te2[3];
      array[offset + 4] = te2[4];
      array[offset + 5] = te2[5];
      array[offset + 6] = te2[6];
      array[offset + 7] = te2[7];
      array[offset + 8] = te2[8];
      return array;
    }
    clone() {
      return new this.constructor().fromArray(this.elements);
    }
  };
  Matrix3.prototype.isMatrix3 = true;
  function arrayMax(array) {
    if (array.length === 0)
      return -Infinity;
    let max = array[0];
    for (let i2 = 1, l2 = array.length; i2 < l2; ++i2) {
      if (array[i2] > max)
        max = array[i2];
    }
    return max;
  }
  function createElementNS(name) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", name);
  }
  var _canvas;
  var ImageUtils = class {
    static getDataURL(image) {
      if (/^data:/i.test(image.src)) {
        return image.src;
      }
      if (typeof HTMLCanvasElement == "undefined") {
        return image.src;
      }
      let canvas;
      if (image instanceof HTMLCanvasElement) {
        canvas = image;
      } else {
        if (_canvas === void 0)
          _canvas = createElementNS("canvas");
        _canvas.width = image.width;
        _canvas.height = image.height;
        const context = _canvas.getContext("2d");
        if (image instanceof ImageData) {
          context.putImageData(image, 0, 0);
        } else {
          context.drawImage(image, 0, 0, image.width, image.height);
        }
        canvas = _canvas;
      }
      if (canvas.width > 2048 || canvas.height > 2048) {
        console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);
        return canvas.toDataURL("image/jpeg", 0.6);
      } else {
        return canvas.toDataURL("image/png");
      }
    }
  };
  var textureId = 0;
  var Texture = class extends EventDispatcher {
    constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {
      super();
      Object.defineProperty(this, "id", { value: textureId++ });
      this.uuid = generateUUID();
      this.name = "";
      this.image = image;
      this.mipmaps = [];
      this.mapping = mapping;
      this.wrapS = wrapS;
      this.wrapT = wrapT;
      this.magFilter = magFilter;
      this.minFilter = minFilter;
      this.anisotropy = anisotropy;
      this.format = format;
      this.internalFormat = null;
      this.type = type;
      this.offset = new Vector2(0, 0);
      this.repeat = new Vector2(1, 1);
      this.center = new Vector2(0, 0);
      this.rotation = 0;
      this.matrixAutoUpdate = true;
      this.matrix = new Matrix3();
      this.generateMipmaps = true;
      this.premultiplyAlpha = false;
      this.flipY = true;
      this.unpackAlignment = 4;
      this.encoding = encoding;
      this.version = 0;
      this.onUpdate = null;
      this.isRenderTargetTexture = false;
    }
    updateMatrix() {
      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(source) {
      this.name = source.name;
      this.image = source.image;
      this.mipmaps = source.mipmaps.slice(0);
      this.mapping = source.mapping;
      this.wrapS = source.wrapS;
      this.wrapT = source.wrapT;
      this.magFilter = source.magFilter;
      this.minFilter = source.minFilter;
      this.anisotropy = source.anisotropy;
      this.format = source.format;
      this.internalFormat = source.internalFormat;
      this.type = source.type;
      this.offset.copy(source.offset);
      this.repeat.copy(source.repeat);
      this.center.copy(source.center);
      this.rotation = source.rotation;
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      this.matrix.copy(source.matrix);
      this.generateMipmaps = source.generateMipmaps;
      this.premultiplyAlpha = source.premultiplyAlpha;
      this.flipY = source.flipY;
      this.unpackAlignment = source.unpackAlignment;
      this.encoding = source.encoding;
      return this;
    }
    toJSON(meta) {
      const isRootObject = meta === void 0 || typeof meta === "string";
      if (!isRootObject && meta.textures[this.uuid] !== void 0) {
        return meta.textures[this.uuid];
      }
      const output = {
        metadata: {
          version: 4.5,
          type: "Texture",
          generator: "Texture.toJSON"
        },
        uuid: this.uuid,
        name: this.name,
        mapping: this.mapping,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        type: this.type,
        encoding: this.encoding,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment
      };
      if (this.image !== void 0) {
        const image = this.image;
        if (image.uuid === void 0) {
          image.uuid = generateUUID();
        }
        if (!isRootObject && meta.images[image.uuid] === void 0) {
          let url;
          if (Array.isArray(image)) {
            url = [];
            for (let i2 = 0, l2 = image.length; i2 < l2; i2++) {
              if (image[i2].isDataTexture) {
                url.push(serializeImage(image[i2].image));
              } else {
                url.push(serializeImage(image[i2]));
              }
            }
          } else {
            url = serializeImage(image);
          }
          meta.images[image.uuid] = {
            uuid: image.uuid,
            url
          };
        }
        output.image = image.uuid;
      }
      if (!isRootObject) {
        meta.textures[this.uuid] = output;
      }
      return output;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    transformUv(uv) {
      if (this.mapping !== UVMapping)
        return uv;
      uv.applyMatrix3(this.matrix);
      if (uv.x < 0 || uv.x > 1) {
        switch (this.wrapS) {
          case RepeatWrapping:
            uv.x = uv.x - Math.floor(uv.x);
            break;
          case ClampToEdgeWrapping:
            uv.x = uv.x < 0 ? 0 : 1;
            break;
          case MirroredRepeatWrapping:
            if (Math.abs(Math.floor(uv.x) % 2) === 1) {
              uv.x = Math.ceil(uv.x) - uv.x;
            } else {
              uv.x = uv.x - Math.floor(uv.x);
            }
            break;
        }
      }
      if (uv.y < 0 || uv.y > 1) {
        switch (this.wrapT) {
          case RepeatWrapping:
            uv.y = uv.y - Math.floor(uv.y);
            break;
          case ClampToEdgeWrapping:
            uv.y = uv.y < 0 ? 0 : 1;
            break;
          case MirroredRepeatWrapping:
            if (Math.abs(Math.floor(uv.y) % 2) === 1) {
              uv.y = Math.ceil(uv.y) - uv.y;
            } else {
              uv.y = uv.y - Math.floor(uv.y);
            }
            break;
        }
      }
      if (this.flipY) {
        uv.y = 1 - uv.y;
      }
      return uv;
    }
    set needsUpdate(value) {
      if (value === true)
        this.version++;
    }
  };
  Texture.DEFAULT_IMAGE = void 0;
  Texture.DEFAULT_MAPPING = UVMapping;
  Texture.prototype.isTexture = true;
  function serializeImage(image) {
    if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
      return ImageUtils.getDataURL(image);
    } else {
      if (image.data) {
        return {
          data: Array.prototype.slice.call(image.data),
          width: image.width,
          height: image.height,
          type: image.data.constructor.name
        };
      } else {
        console.warn("THREE.Texture: Unable to serialize Texture.");
        return {};
      }
    }
  }
  var Vector4 = class {
    constructor(x2 = 0, y2 = 0, z2 = 0, w2 = 1) {
      this.x = x2;
      this.y = y2;
      this.z = z2;
      this.w = w2;
    }
    get width() {
      return this.z;
    }
    set width(value) {
      this.z = value;
    }
    get height() {
      return this.w;
    }
    set height(value) {
      this.w = value;
    }
    set(x2, y2, z2, w2) {
      this.x = x2;
      this.y = y2;
      this.z = z2;
      this.w = w2;
      return this;
    }
    setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      this.z = scalar;
      this.w = scalar;
      return this;
    }
    setX(x2) {
      this.x = x2;
      return this;
    }
    setY(y2) {
      this.y = y2;
      return this;
    }
    setZ(z2) {
      this.z = z2;
      return this;
    }
    setW(w2) {
      this.w = w2;
      return this;
    }
    setComponent(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        case 2:
          this.z = value;
          break;
        case 3:
          this.w = value;
          break;
        default:
          throw new Error("index is out of range: " + index);
      }
      return this;
    }
    getComponent(index) {
      switch (index) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw new Error("index is out of range: " + index);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(v2) {
      this.x = v2.x;
      this.y = v2.y;
      this.z = v2.z;
      this.w = v2.w !== void 0 ? v2.w : 1;
      return this;
    }
    add(v2, w2) {
      if (w2 !== void 0) {
        console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
        return this.addVectors(v2, w2);
      }
      this.x += v2.x;
      this.y += v2.y;
      this.z += v2.z;
      this.w += v2.w;
      return this;
    }
    addScalar(s2) {
      this.x += s2;
      this.y += s2;
      this.z += s2;
      this.w += s2;
      return this;
    }
    addVectors(a2, b2) {
      this.x = a2.x + b2.x;
      this.y = a2.y + b2.y;
      this.z = a2.z + b2.z;
      this.w = a2.w + b2.w;
      return this;
    }
    addScaledVector(v2, s2) {
      this.x += v2.x * s2;
      this.y += v2.y * s2;
      this.z += v2.z * s2;
      this.w += v2.w * s2;
      return this;
    }
    sub(v2, w2) {
      if (w2 !== void 0) {
        console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
        return this.subVectors(v2, w2);
      }
      this.x -= v2.x;
      this.y -= v2.y;
      this.z -= v2.z;
      this.w -= v2.w;
      return this;
    }
    subScalar(s2) {
      this.x -= s2;
      this.y -= s2;
      this.z -= s2;
      this.w -= s2;
      return this;
    }
    subVectors(a2, b2) {
      this.x = a2.x - b2.x;
      this.y = a2.y - b2.y;
      this.z = a2.z - b2.z;
      this.w = a2.w - b2.w;
      return this;
    }
    multiply(v2) {
      this.x *= v2.x;
      this.y *= v2.y;
      this.z *= v2.z;
      this.w *= v2.w;
      return this;
    }
    multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
      this.w *= scalar;
      return this;
    }
    applyMatrix4(m2) {
      const x2 = this.x, y2 = this.y, z2 = this.z, w2 = this.w;
      const e2 = m2.elements;
      this.x = e2[0] * x2 + e2[4] * y2 + e2[8] * z2 + e2[12] * w2;
      this.y = e2[1] * x2 + e2[5] * y2 + e2[9] * z2 + e2[13] * w2;
      this.z = e2[2] * x2 + e2[6] * y2 + e2[10] * z2 + e2[14] * w2;
      this.w = e2[3] * x2 + e2[7] * y2 + e2[11] * z2 + e2[15] * w2;
      return this;
    }
    divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
    setAxisAngleFromQuaternion(q2) {
      this.w = 2 * Math.acos(q2.w);
      const s2 = Math.sqrt(1 - q2.w * q2.w);
      if (s2 < 1e-4) {
        this.x = 1;
        this.y = 0;
        this.z = 0;
      } else {
        this.x = q2.x / s2;
        this.y = q2.y / s2;
        this.z = q2.z / s2;
      }
      return this;
    }
    setAxisAngleFromRotationMatrix(m2) {
      let angle, x2, y2, z2;
      const epsilon = 0.01, epsilon2 = 0.1, te2 = m2.elements, m11 = te2[0], m12 = te2[4], m13 = te2[8], m21 = te2[1], m22 = te2[5], m23 = te2[9], m31 = te2[2], m32 = te2[6], m33 = te2[10];
      if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
        if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
          this.set(1, 0, 0, 0);
          return this;
        }
        angle = Math.PI;
        const xx = (m11 + 1) / 2;
        const yy = (m22 + 1) / 2;
        const zz = (m33 + 1) / 2;
        const xy = (m12 + m21) / 4;
        const xz = (m13 + m31) / 4;
        const yz = (m23 + m32) / 4;
        if (xx > yy && xx > zz) {
          if (xx < epsilon) {
            x2 = 0;
            y2 = 0.707106781;
            z2 = 0.707106781;
          } else {
            x2 = Math.sqrt(xx);
            y2 = xy / x2;
            z2 = xz / x2;
          }
        } else if (yy > zz) {
          if (yy < epsilon) {
            x2 = 0.707106781;
            y2 = 0;
            z2 = 0.707106781;
          } else {
            y2 = Math.sqrt(yy);
            x2 = xy / y2;
            z2 = yz / y2;
          }
        } else {
          if (zz < epsilon) {
            x2 = 0.707106781;
            y2 = 0.707106781;
            z2 = 0;
          } else {
            z2 = Math.sqrt(zz);
            x2 = xz / z2;
            y2 = yz / z2;
          }
        }
        this.set(x2, y2, z2, angle);
        return this;
      }
      let s2 = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
      if (Math.abs(s2) < 1e-3)
        s2 = 1;
      this.x = (m32 - m23) / s2;
      this.y = (m13 - m31) / s2;
      this.z = (m21 - m12) / s2;
      this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
      return this;
    }
    min(v2) {
      this.x = Math.min(this.x, v2.x);
      this.y = Math.min(this.y, v2.y);
      this.z = Math.min(this.z, v2.z);
      this.w = Math.min(this.w, v2.w);
      return this;
    }
    max(v2) {
      this.x = Math.max(this.x, v2.x);
      this.y = Math.max(this.y, v2.y);
      this.z = Math.max(this.z, v2.z);
      this.w = Math.max(this.w, v2.w);
      return this;
    }
    clamp(min, max) {
      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      this.z = Math.max(min.z, Math.min(max.z, this.z));
      this.w = Math.max(min.w, Math.min(max.w, this.w));
      return this;
    }
    clampScalar(minVal, maxVal) {
      this.x = Math.max(minVal, Math.min(maxVal, this.x));
      this.y = Math.max(minVal, Math.min(maxVal, this.y));
      this.z = Math.max(minVal, Math.min(maxVal, this.z));
      this.w = Math.max(minVal, Math.min(maxVal, this.w));
      return this;
    }
    clampLength(min, max) {
      const length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      this.z = Math.floor(this.z);
      this.w = Math.floor(this.w);
      return this;
    }
    ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      this.z = Math.ceil(this.z);
      this.w = Math.ceil(this.w);
      return this;
    }
    round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      this.z = Math.round(this.z);
      this.w = Math.round(this.w);
      return this;
    }
    roundToZero() {
      this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
      this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
      this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
      this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
      return this;
    }
    negate() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      this.w = -this.w;
      return this;
    }
    dot(v2) {
      return this.x * v2.x + this.y * v2.y + this.z * v2.z + this.w * v2.w;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
    lerp(v2, alpha) {
      this.x += (v2.x - this.x) * alpha;
      this.y += (v2.y - this.y) * alpha;
      this.z += (v2.z - this.z) * alpha;
      this.w += (v2.w - this.w) * alpha;
      return this;
    }
    lerpVectors(v1, v2, alpha) {
      this.x = v1.x + (v2.x - v1.x) * alpha;
      this.y = v1.y + (v2.y - v1.y) * alpha;
      this.z = v1.z + (v2.z - v1.z) * alpha;
      this.w = v1.w + (v2.w - v1.w) * alpha;
      return this;
    }
    equals(v2) {
      return v2.x === this.x && v2.y === this.y && v2.z === this.z && v2.w === this.w;
    }
    fromArray(array, offset = 0) {
      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      this.w = array[offset + 3];
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this.x;
      array[offset + 1] = this.y;
      array[offset + 2] = this.z;
      array[offset + 3] = this.w;
      return array;
    }
    fromBufferAttribute(attribute, index, offset) {
      if (offset !== void 0) {
        console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
      }
      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      this.z = attribute.getZ(index);
      this.w = attribute.getW(index);
      return this;
    }
    random() {
      this.x = Math.random();
      this.y = Math.random();
      this.z = Math.random();
      this.w = Math.random();
      return this;
    }
    *[Symbol.iterator]() {
      yield this.x;
      yield this.y;
      yield this.z;
      yield this.w;
    }
  };
  Vector4.prototype.isVector4 = true;
  var WebGLRenderTarget = class extends EventDispatcher {
    constructor(width2, height2, options = {}) {
      super();
      this.width = width2;
      this.height = height2;
      this.depth = 1;
      this.scissor = new Vector4(0, 0, width2, height2);
      this.scissorTest = false;
      this.viewport = new Vector4(0, 0, width2, height2);
      this.texture = new Texture(void 0, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
      this.texture.isRenderTargetTexture = true;
      this.texture.image = { width: width2, height: height2, depth: 1 };
      this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
      this.texture.internalFormat = options.internalFormat !== void 0 ? options.internalFormat : null;
      this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
      this.depthBuffer = options.depthBuffer !== void 0 ? options.depthBuffer : true;
      this.stencilBuffer = options.stencilBuffer !== void 0 ? options.stencilBuffer : false;
      this.depthTexture = options.depthTexture !== void 0 ? options.depthTexture : null;
    }
    setTexture(texture) {
      texture.image = {
        width: this.width,
        height: this.height,
        depth: this.depth
      };
      this.texture = texture;
    }
    setSize(width2, height2, depth = 1) {
      if (this.width !== width2 || this.height !== height2 || this.depth !== depth) {
        this.width = width2;
        this.height = height2;
        this.depth = depth;
        this.texture.image.width = width2;
        this.texture.image.height = height2;
        this.texture.image.depth = depth;
        this.dispose();
      }
      this.viewport.set(0, 0, width2, height2);
      this.scissor.set(0, 0, width2, height2);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(source) {
      this.width = source.width;
      this.height = source.height;
      this.depth = source.depth;
      this.viewport.copy(source.viewport);
      this.texture = source.texture.clone();
      this.texture.image = { ...this.texture.image };
      this.depthBuffer = source.depthBuffer;
      this.stencilBuffer = source.stencilBuffer;
      this.depthTexture = source.depthTexture;
      return this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  };
  WebGLRenderTarget.prototype.isWebGLRenderTarget = true;
  var WebGLMultipleRenderTargets = class extends WebGLRenderTarget {
    constructor(width2, height2, count) {
      super(width2, height2);
      const texture = this.texture;
      this.texture = [];
      for (let i2 = 0; i2 < count; i2++) {
        this.texture[i2] = texture.clone();
      }
    }
    setSize(width2, height2, depth = 1) {
      if (this.width !== width2 || this.height !== height2 || this.depth !== depth) {
        this.width = width2;
        this.height = height2;
        this.depth = depth;
        for (let i2 = 0, il = this.texture.length; i2 < il; i2++) {
          this.texture[i2].image.width = width2;
          this.texture[i2].image.height = height2;
          this.texture[i2].image.depth = depth;
        }
        this.dispose();
      }
      this.viewport.set(0, 0, width2, height2);
      this.scissor.set(0, 0, width2, height2);
      return this;
    }
    copy(source) {
      this.dispose();
      this.width = source.width;
      this.height = source.height;
      this.depth = source.depth;
      this.viewport.set(0, 0, this.width, this.height);
      this.scissor.set(0, 0, this.width, this.height);
      this.depthBuffer = source.depthBuffer;
      this.stencilBuffer = source.stencilBuffer;
      this.depthTexture = source.depthTexture;
      this.texture.length = 0;
      for (let i2 = 0, il = source.texture.length; i2 < il; i2++) {
        this.texture[i2] = source.texture[i2].clone();
      }
      return this;
    }
  };
  WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true;
  var WebGLMultisampleRenderTarget = class extends WebGLRenderTarget {
    constructor(width2, height2, options) {
      super(width2, height2, options);
      this.samples = 4;
    }
    copy(source) {
      super.copy.call(this, source);
      this.samples = source.samples;
      return this;
    }
  };
  WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;
  var Quaternion = class {
    constructor(x2 = 0, y2 = 0, z2 = 0, w2 = 1) {
      this._x = x2;
      this._y = y2;
      this._z = z2;
      this._w = w2;
    }
    static slerp(qa, qb, qm, t2) {
      console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.");
      return qm.slerpQuaternions(qa, qb, t2);
    }
    static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t2) {
      let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
      const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
      if (t2 === 0) {
        dst[dstOffset + 0] = x0;
        dst[dstOffset + 1] = y0;
        dst[dstOffset + 2] = z0;
        dst[dstOffset + 3] = w0;
        return;
      }
      if (t2 === 1) {
        dst[dstOffset + 0] = x1;
        dst[dstOffset + 1] = y1;
        dst[dstOffset + 2] = z1;
        dst[dstOffset + 3] = w1;
        return;
      }
      if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
        let s2 = 1 - t2;
        const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
        if (sqrSin > Number.EPSILON) {
          const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
          s2 = Math.sin(s2 * len) / sin;
          t2 = Math.sin(t2 * len) / sin;
        }
        const tDir = t2 * dir;
        x0 = x0 * s2 + x1 * tDir;
        y0 = y0 * s2 + y1 * tDir;
        z0 = z0 * s2 + z1 * tDir;
        w0 = w0 * s2 + w1 * tDir;
        if (s2 === 1 - t2) {
          const f2 = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
          x0 *= f2;
          y0 *= f2;
          z0 *= f2;
          w0 *= f2;
        }
      }
      dst[dstOffset] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
    }
    static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
      const x0 = src0[srcOffset0];
      const y0 = src0[srcOffset0 + 1];
      const z0 = src0[srcOffset0 + 2];
      const w0 = src0[srcOffset0 + 3];
      const x1 = src1[srcOffset1];
      const y1 = src1[srcOffset1 + 1];
      const z1 = src1[srcOffset1 + 2];
      const w1 = src1[srcOffset1 + 3];
      dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
      dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
      dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
      dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
      return dst;
    }
    get x() {
      return this._x;
    }
    set x(value) {
      this._x = value;
      this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(value) {
      this._y = value;
      this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(value) {
      this._z = value;
      this._onChangeCallback();
    }
    get w() {
      return this._w;
    }
    set w(value) {
      this._w = value;
      this._onChangeCallback();
    }
    set(x2, y2, z2, w2) {
      this._x = x2;
      this._y = y2;
      this._z = z2;
      this._w = w2;
      this._onChangeCallback();
      return this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(quaternion) {
      this._x = quaternion.x;
      this._y = quaternion.y;
      this._z = quaternion.z;
      this._w = quaternion.w;
      this._onChangeCallback();
      return this;
    }
    setFromEuler(euler, update2) {
      if (!(euler && euler.isEuler)) {
        throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
      }
      const x2 = euler._x, y2 = euler._y, z2 = euler._z, order = euler._order;
      const cos = Math.cos;
      const sin = Math.sin;
      const c1 = cos(x2 / 2);
      const c2 = cos(y2 / 2);
      const c3 = cos(z2 / 2);
      const s1 = sin(x2 / 2);
      const s2 = sin(y2 / 2);
      const s3 = sin(z2 / 2);
      switch (order) {
        case "XYZ":
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
          break;
        case "YXZ":
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
          break;
        case "ZXY":
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
          break;
        case "ZYX":
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
          break;
        case "YZX":
          this._x = s1 * c2 * c3 + c1 * s2 * s3;
          this._y = c1 * s2 * c3 + s1 * c2 * s3;
          this._z = c1 * c2 * s3 - s1 * s2 * c3;
          this._w = c1 * c2 * c3 - s1 * s2 * s3;
          break;
        case "XZY":
          this._x = s1 * c2 * c3 - c1 * s2 * s3;
          this._y = c1 * s2 * c3 - s1 * c2 * s3;
          this._z = c1 * c2 * s3 + s1 * s2 * c3;
          this._w = c1 * c2 * c3 + s1 * s2 * s3;
          break;
        default:
          console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
      }
      if (update2 !== false)
        this._onChangeCallback();
      return this;
    }
    setFromAxisAngle(axis, angle) {
      const halfAngle = angle / 2, s2 = Math.sin(halfAngle);
      this._x = axis.x * s2;
      this._y = axis.y * s2;
      this._z = axis.z * s2;
      this._w = Math.cos(halfAngle);
      this._onChangeCallback();
      return this;
    }
    setFromRotationMatrix(m2) {
      const te2 = m2.elements, m11 = te2[0], m12 = te2[4], m13 = te2[8], m21 = te2[1], m22 = te2[5], m23 = te2[9], m31 = te2[2], m32 = te2[6], m33 = te2[10], trace = m11 + m22 + m33;
      if (trace > 0) {
        const s2 = 0.5 / Math.sqrt(trace + 1);
        this._w = 0.25 / s2;
        this._x = (m32 - m23) * s2;
        this._y = (m13 - m31) * s2;
        this._z = (m21 - m12) * s2;
      } else if (m11 > m22 && m11 > m33) {
        const s2 = 2 * Math.sqrt(1 + m11 - m22 - m33);
        this._w = (m32 - m23) / s2;
        this._x = 0.25 * s2;
        this._y = (m12 + m21) / s2;
        this._z = (m13 + m31) / s2;
      } else if (m22 > m33) {
        const s2 = 2 * Math.sqrt(1 + m22 - m11 - m33);
        this._w = (m13 - m31) / s2;
        this._x = (m12 + m21) / s2;
        this._y = 0.25 * s2;
        this._z = (m23 + m32) / s2;
      } else {
        const s2 = 2 * Math.sqrt(1 + m33 - m11 - m22);
        this._w = (m21 - m12) / s2;
        this._x = (m13 + m31) / s2;
        this._y = (m23 + m32) / s2;
        this._z = 0.25 * s2;
      }
      this._onChangeCallback();
      return this;
    }
    setFromUnitVectors(vFrom, vTo) {
      let r2 = vFrom.dot(vTo) + 1;
      if (r2 < Number.EPSILON) {
        r2 = 0;
        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
          this._x = -vFrom.y;
          this._y = vFrom.x;
          this._z = 0;
          this._w = r2;
        } else {
          this._x = 0;
          this._y = -vFrom.z;
          this._z = vFrom.y;
          this._w = r2;
        }
      } else {
        this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
        this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
        this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
        this._w = r2;
      }
      return this.normalize();
    }
    angleTo(q2) {
      return 2 * Math.acos(Math.abs(clamp(this.dot(q2), -1, 1)));
    }
    rotateTowards(q2, step) {
      const angle = this.angleTo(q2);
      if (angle === 0)
        return this;
      const t2 = Math.min(1, step / angle);
      this.slerp(q2, t2);
      return this;
    }
    identity() {
      return this.set(0, 0, 0, 1);
    }
    invert() {
      return this.conjugate();
    }
    conjugate() {
      this._x *= -1;
      this._y *= -1;
      this._z *= -1;
      this._onChangeCallback();
      return this;
    }
    dot(v2) {
      return this._x * v2._x + this._y * v2._y + this._z * v2._z + this._w * v2._w;
    }
    lengthSq() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
    length() {
      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }
    normalize() {
      let l2 = this.length();
      if (l2 === 0) {
        this._x = 0;
        this._y = 0;
        this._z = 0;
        this._w = 1;
      } else {
        l2 = 1 / l2;
        this._x = this._x * l2;
        this._y = this._y * l2;
        this._z = this._z * l2;
        this._w = this._w * l2;
      }
      this._onChangeCallback();
      return this;
    }
    multiply(q2, p2) {
      if (p2 !== void 0) {
        console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
        return this.multiplyQuaternions(q2, p2);
      }
      return this.multiplyQuaternions(this, q2);
    }
    premultiply(q2) {
      return this.multiplyQuaternions(q2, this);
    }
    multiplyQuaternions(a2, b2) {
      const qax = a2._x, qay = a2._y, qaz = a2._z, qaw = a2._w;
      const qbx = b2._x, qby = b2._y, qbz = b2._z, qbw = b2._w;
      this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
      this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
      this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
      this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
      this._onChangeCallback();
      return this;
    }
    slerp(qb, t2) {
      if (t2 === 0)
        return this;
      if (t2 === 1)
        return this.copy(qb);
      const x2 = this._x, y2 = this._y, z2 = this._z, w2 = this._w;
      let cosHalfTheta = w2 * qb._w + x2 * qb._x + y2 * qb._y + z2 * qb._z;
      if (cosHalfTheta < 0) {
        this._w = -qb._w;
        this._x = -qb._x;
        this._y = -qb._y;
        this._z = -qb._z;
        cosHalfTheta = -cosHalfTheta;
      } else {
        this.copy(qb);
      }
      if (cosHalfTheta >= 1) {
        this._w = w2;
        this._x = x2;
        this._y = y2;
        this._z = z2;
        return this;
      }
      const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
      if (sqrSinHalfTheta <= Number.EPSILON) {
        const s2 = 1 - t2;
        this._w = s2 * w2 + t2 * this._w;
        this._x = s2 * x2 + t2 * this._x;
        this._y = s2 * y2 + t2 * this._y;
        this._z = s2 * z2 + t2 * this._z;
        this.normalize();
        this._onChangeCallback();
        return this;
      }
      const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
      const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
      const ratioA = Math.sin((1 - t2) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t2 * halfTheta) / sinHalfTheta;
      this._w = w2 * ratioA + this._w * ratioB;
      this._x = x2 * ratioA + this._x * ratioB;
      this._y = y2 * ratioA + this._y * ratioB;
      this._z = z2 * ratioA + this._z * ratioB;
      this._onChangeCallback();
      return this;
    }
    slerpQuaternions(qa, qb, t2) {
      this.copy(qa).slerp(qb, t2);
    }
    random() {
      const u1 = Math.random();
      const sqrt1u1 = Math.sqrt(1 - u1);
      const sqrtu1 = Math.sqrt(u1);
      const u2 = 2 * Math.PI * Math.random();
      const u3 = 2 * Math.PI * Math.random();
      return this.set(sqrt1u1 * Math.cos(u2), sqrtu1 * Math.sin(u3), sqrtu1 * Math.cos(u3), sqrt1u1 * Math.sin(u2));
    }
    equals(quaternion) {
      return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
    }
    fromArray(array, offset = 0) {
      this._x = array[offset];
      this._y = array[offset + 1];
      this._z = array[offset + 2];
      this._w = array[offset + 3];
      this._onChangeCallback();
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this._x;
      array[offset + 1] = this._y;
      array[offset + 2] = this._z;
      array[offset + 3] = this._w;
      return array;
    }
    fromBufferAttribute(attribute, index) {
      this._x = attribute.getX(index);
      this._y = attribute.getY(index);
      this._z = attribute.getZ(index);
      this._w = attribute.getW(index);
      return this;
    }
    _onChange(callback) {
      this._onChangeCallback = callback;
      return this;
    }
    _onChangeCallback() {
    }
  };
  Quaternion.prototype.isQuaternion = true;
  var Vector3 = class {
    constructor(x2 = 0, y2 = 0, z2 = 0) {
      this.x = x2;
      this.y = y2;
      this.z = z2;
    }
    set(x2, y2, z2) {
      if (z2 === void 0)
        z2 = this.z;
      this.x = x2;
      this.y = y2;
      this.z = z2;
      return this;
    }
    setScalar(scalar) {
      this.x = scalar;
      this.y = scalar;
      this.z = scalar;
      return this;
    }
    setX(x2) {
      this.x = x2;
      return this;
    }
    setY(y2) {
      this.y = y2;
      return this;
    }
    setZ(z2) {
      this.z = z2;
      return this;
    }
    setComponent(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        case 2:
          this.z = value;
          break;
        default:
          throw new Error("index is out of range: " + index);
      }
      return this;
    }
    getComponent(index) {
      switch (index) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error("index is out of range: " + index);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z);
    }
    copy(v2) {
      this.x = v2.x;
      this.y = v2.y;
      this.z = v2.z;
      return this;
    }
    add(v2, w2) {
      if (w2 !== void 0) {
        console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
        return this.addVectors(v2, w2);
      }
      this.x += v2.x;
      this.y += v2.y;
      this.z += v2.z;
      return this;
    }
    addScalar(s2) {
      this.x += s2;
      this.y += s2;
      this.z += s2;
      return this;
    }
    addVectors(a2, b2) {
      this.x = a2.x + b2.x;
      this.y = a2.y + b2.y;
      this.z = a2.z + b2.z;
      return this;
    }
    addScaledVector(v2, s2) {
      this.x += v2.x * s2;
      this.y += v2.y * s2;
      this.z += v2.z * s2;
      return this;
    }
    sub(v2, w2) {
      if (w2 !== void 0) {
        console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
        return this.subVectors(v2, w2);
      }
      this.x -= v2.x;
      this.y -= v2.y;
      this.z -= v2.z;
      return this;
    }
    subScalar(s2) {
      this.x -= s2;
      this.y -= s2;
      this.z -= s2;
      return this;
    }
    subVectors(a2, b2) {
      this.x = a2.x - b2.x;
      this.y = a2.y - b2.y;
      this.z = a2.z - b2.z;
      return this;
    }
    multiply(v2, w2) {
      if (w2 !== void 0) {
        console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
        return this.multiplyVectors(v2, w2);
      }
      this.x *= v2.x;
      this.y *= v2.y;
      this.z *= v2.z;
      return this;
    }
    multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
      return this;
    }
    multiplyVectors(a2, b2) {
      this.x = a2.x * b2.x;
      this.y = a2.y * b2.y;
      this.z = a2.z * b2.z;
      return this;
    }
    applyEuler(euler) {
      if (!(euler && euler.isEuler)) {
        console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
      }
      return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
    }
    applyAxisAngle(axis, angle) {
      return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
    }
    applyMatrix3(m2) {
      const x2 = this.x, y2 = this.y, z2 = this.z;
      const e2 = m2.elements;
      this.x = e2[0] * x2 + e2[3] * y2 + e2[6] * z2;
      this.y = e2[1] * x2 + e2[4] * y2 + e2[7] * z2;
      this.z = e2[2] * x2 + e2[5] * y2 + e2[8] * z2;
      return this;
    }
    applyNormalMatrix(m2) {
      return this.applyMatrix3(m2).normalize();
    }
    applyMatrix4(m2) {
      const x2 = this.x, y2 = this.y, z2 = this.z;
      const e2 = m2.elements;
      const w2 = 1 / (e2[3] * x2 + e2[7] * y2 + e2[11] * z2 + e2[15]);
      this.x = (e2[0] * x2 + e2[4] * y2 + e2[8] * z2 + e2[12]) * w2;
      this.y = (e2[1] * x2 + e2[5] * y2 + e2[9] * z2 + e2[13]) * w2;
      this.z = (e2[2] * x2 + e2[6] * y2 + e2[10] * z2 + e2[14]) * w2;
      return this;
    }
    applyQuaternion(q2) {
      const x2 = this.x, y2 = this.y, z2 = this.z;
      const qx = q2.x, qy = q2.y, qz = q2.z, qw = q2.w;
      const ix = qw * x2 + qy * z2 - qz * y2;
      const iy = qw * y2 + qz * x2 - qx * z2;
      const iz = qw * z2 + qx * y2 - qy * x2;
      const iw = -qx * x2 - qy * y2 - qz * z2;
      this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
      this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
      this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
      return this;
    }
    project(camera2) {
      return this.applyMatrix4(camera2.matrixWorldInverse).applyMatrix4(camera2.projectionMatrix);
    }
    unproject(camera2) {
      return this.applyMatrix4(camera2.projectionMatrixInverse).applyMatrix4(camera2.matrixWorld);
    }
    transformDirection(m2) {
      const x2 = this.x, y2 = this.y, z2 = this.z;
      const e2 = m2.elements;
      this.x = e2[0] * x2 + e2[4] * y2 + e2[8] * z2;
      this.y = e2[1] * x2 + e2[5] * y2 + e2[9] * z2;
      this.z = e2[2] * x2 + e2[6] * y2 + e2[10] * z2;
      return this.normalize();
    }
    divide(v2) {
      this.x /= v2.x;
      this.y /= v2.y;
      this.z /= v2.z;
      return this;
    }
    divideScalar(scalar) {
      return this.multiplyScalar(1 / scalar);
    }
    min(v2) {
      this.x = Math.min(this.x, v2.x);
      this.y = Math.min(this.y, v2.y);
      this.z = Math.min(this.z, v2.z);
      return this;
    }
    max(v2) {
      this.x = Math.max(this.x, v2.x);
      this.y = Math.max(this.y, v2.y);
      this.z = Math.max(this.z, v2.z);
      return this;
    }
    clamp(min, max) {
      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      this.z = Math.max(min.z, Math.min(max.z, this.z));
      return this;
    }
    clampScalar(minVal, maxVal) {
      this.x = Math.max(minVal, Math.min(maxVal, this.x));
      this.y = Math.max(minVal, Math.min(maxVal, this.y));
      this.z = Math.max(minVal, Math.min(maxVal, this.z));
      return this;
    }
    clampLength(min, max) {
      const length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    }
    floor() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      this.z = Math.floor(this.z);
      return this;
    }
    ceil() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      this.z = Math.ceil(this.z);
      return this;
    }
    round() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      this.z = Math.round(this.z);
      return this;
    }
    roundToZero() {
      this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
      this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
      this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
      return this;
    }
    negate() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      return this;
    }
    dot(v2) {
      return this.x * v2.x + this.y * v2.y + this.z * v2.z;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(length) {
      return this.normalize().multiplyScalar(length);
    }
    lerp(v2, alpha) {
      this.x += (v2.x - this.x) * alpha;
      this.y += (v2.y - this.y) * alpha;
      this.z += (v2.z - this.z) * alpha;
      return this;
    }
    lerpVectors(v1, v2, alpha) {
      this.x = v1.x + (v2.x - v1.x) * alpha;
      this.y = v1.y + (v2.y - v1.y) * alpha;
      this.z = v1.z + (v2.z - v1.z) * alpha;
      return this;
    }
    cross(v2, w2) {
      if (w2 !== void 0) {
        console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
        return this.crossVectors(v2, w2);
      }
      return this.crossVectors(this, v2);
    }
    crossVectors(a2, b2) {
      const ax = a2.x, ay = a2.y, az = a2.z;
      const bx = b2.x, by = b2.y, bz = b2.z;
      this.x = ay * bz - az * by;
      this.y = az * bx - ax * bz;
      this.z = ax * by - ay * bx;
      return this;
    }
    projectOnVector(v2) {
      const denominator = v2.lengthSq();
      if (denominator === 0)
        return this.set(0, 0, 0);
      const scalar = v2.dot(this) / denominator;
      return this.copy(v2).multiplyScalar(scalar);
    }
    projectOnPlane(planeNormal) {
      _vector$c.copy(this).projectOnVector(planeNormal);
      return this.sub(_vector$c);
    }
    reflect(normal) {
      return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
    }
    angleTo(v2) {
      const denominator = Math.sqrt(this.lengthSq() * v2.lengthSq());
      if (denominator === 0)
        return Math.PI / 2;
      const theta = this.dot(v2) / denominator;
      return Math.acos(clamp(theta, -1, 1));
    }
    distanceTo(v2) {
      return Math.sqrt(this.distanceToSquared(v2));
    }
    distanceToSquared(v2) {
      const dx = this.x - v2.x, dy = this.y - v2.y, dz = this.z - v2.z;
      return dx * dx + dy * dy + dz * dz;
    }
    manhattanDistanceTo(v2) {
      return Math.abs(this.x - v2.x) + Math.abs(this.y - v2.y) + Math.abs(this.z - v2.z);
    }
    setFromSpherical(s2) {
      return this.setFromSphericalCoords(s2.radius, s2.phi, s2.theta);
    }
    setFromSphericalCoords(radius, phi, theta) {
      const sinPhiRadius = Math.sin(phi) * radius;
      this.x = sinPhiRadius * Math.sin(theta);
      this.y = Math.cos(phi) * radius;
      this.z = sinPhiRadius * Math.cos(theta);
      return this;
    }
    setFromCylindrical(c2) {
      return this.setFromCylindricalCoords(c2.radius, c2.theta, c2.y);
    }
    setFromCylindricalCoords(radius, theta, y2) {
      this.x = radius * Math.sin(theta);
      this.y = y2;
      this.z = radius * Math.cos(theta);
      return this;
    }
    setFromMatrixPosition(m2) {
      const e2 = m2.elements;
      this.x = e2[12];
      this.y = e2[13];
      this.z = e2[14];
      return this;
    }
    setFromMatrixScale(m2) {
      const sx = this.setFromMatrixColumn(m2, 0).length();
      const sy = this.setFromMatrixColumn(m2, 1).length();
      const sz = this.setFromMatrixColumn(m2, 2).length();
      this.x = sx;
      this.y = sy;
      this.z = sz;
      return this;
    }
    setFromMatrixColumn(m2, index) {
      return this.fromArray(m2.elements, index * 4);
    }
    setFromMatrix3Column(m2, index) {
      return this.fromArray(m2.elements, index * 3);
    }
    equals(v2) {
      return v2.x === this.x && v2.y === this.y && v2.z === this.z;
    }
    fromArray(array, offset = 0) {
      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this.x;
      array[offset + 1] = this.y;
      array[offset + 2] = this.z;
      return array;
    }
    fromBufferAttribute(attribute, index, offset) {
      if (offset !== void 0) {
        console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
      }
      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      this.z = attribute.getZ(index);
      return this;
    }
    random() {
      this.x = Math.random();
      this.y = Math.random();
      this.z = Math.random();
      return this;
    }
    randomDirection() {
      const u2 = (Math.random() - 0.5) * 2;
      const t2 = Math.random() * Math.PI * 2;
      const f2 = Math.sqrt(1 - u2 ** 2);
      this.x = f2 * Math.cos(t2);
      this.y = f2 * Math.sin(t2);
      this.z = u2;
      return this;
    }
    *[Symbol.iterator]() {
      yield this.x;
      yield this.y;
      yield this.z;
    }
  };
  Vector3.prototype.isVector3 = true;
  var _vector$c = /* @__PURE__ */ new Vector3();
  var _quaternion$4 = /* @__PURE__ */ new Quaternion();
  var Box3 = class {
    constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
      this.min = min;
      this.max = max;
    }
    set(min, max) {
      this.min.copy(min);
      this.max.copy(max);
      return this;
    }
    setFromArray(array) {
      let minX = Infinity;
      let minY = Infinity;
      let minZ = Infinity;
      let maxX = -Infinity;
      let maxY = -Infinity;
      let maxZ = -Infinity;
      for (let i2 = 0, l2 = array.length; i2 < l2; i2 += 3) {
        const x2 = array[i2];
        const y2 = array[i2 + 1];
        const z2 = array[i2 + 2];
        if (x2 < minX)
          minX = x2;
        if (y2 < minY)
          minY = y2;
        if (z2 < minZ)
          minZ = z2;
        if (x2 > maxX)
          maxX = x2;
        if (y2 > maxY)
          maxY = y2;
        if (z2 > maxZ)
          maxZ = z2;
      }
      this.min.set(minX, minY, minZ);
      this.max.set(maxX, maxY, maxZ);
      return this;
    }
    setFromBufferAttribute(attribute) {
      let minX = Infinity;
      let minY = Infinity;
      let minZ = Infinity;
      let maxX = -Infinity;
      let maxY = -Infinity;
      let maxZ = -Infinity;
      for (let i2 = 0, l2 = attribute.count; i2 < l2; i2++) {
        const x2 = attribute.getX(i2);
        const y2 = attribute.getY(i2);
        const z2 = attribute.getZ(i2);
        if (x2 < minX)
          minX = x2;
        if (y2 < minY)
          minY = y2;
        if (z2 < minZ)
          minZ = z2;
        if (x2 > maxX)
          maxX = x2;
        if (y2 > maxY)
          maxY = y2;
        if (z2 > maxZ)
          maxZ = z2;
      }
      this.min.set(minX, minY, minZ);
      this.max.set(maxX, maxY, maxZ);
      return this;
    }
    setFromPoints(points) {
      this.makeEmpty();
      for (let i2 = 0, il = points.length; i2 < il; i2++) {
        this.expandByPoint(points[i2]);
      }
      return this;
    }
    setFromCenterAndSize(center, size) {
      const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    }
    setFromObject(object) {
      this.makeEmpty();
      return this.expandByObject(object);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(box) {
      this.min.copy(box.min);
      this.max.copy(box.max);
      return this;
    }
    makeEmpty() {
      this.min.x = this.min.y = this.min.z = Infinity;
      this.max.x = this.max.y = this.max.z = -Infinity;
      return this;
    }
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }
    getCenter(target) {
      return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(target) {
      return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
    }
    expandByPoint(point) {
      this.min.min(point);
      this.max.max(point);
      return this;
    }
    expandByVector(vector) {
      this.min.sub(vector);
      this.max.add(vector);
      return this;
    }
    expandByScalar(scalar) {
      this.min.addScalar(-scalar);
      this.max.addScalar(scalar);
      return this;
    }
    expandByObject(object) {
      object.updateWorldMatrix(false, false);
      const geometry = object.geometry;
      if (geometry !== void 0) {
        if (geometry.boundingBox === null) {
          geometry.computeBoundingBox();
        }
        _box$3.copy(geometry.boundingBox);
        _box$3.applyMatrix4(object.matrixWorld);
        this.union(_box$3);
      }
      const children = object.children;
      for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
        this.expandByObject(children[i2]);
      }
      return this;
    }
    containsPoint(point) {
      return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
    }
    containsBox(box) {
      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
    }
    getParameter(point, target) {
      return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
    }
    intersectsBox(box) {
      return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
    }
    intersectsSphere(sphere) {
      this.clampPoint(sphere.center, _vector$b);
      return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
    }
    intersectsPlane(plane) {
      let min, max;
      if (plane.normal.x > 0) {
        min = plane.normal.x * this.min.x;
        max = plane.normal.x * this.max.x;
      } else {
        min = plane.normal.x * this.max.x;
        max = plane.normal.x * this.min.x;
      }
      if (plane.normal.y > 0) {
        min += plane.normal.y * this.min.y;
        max += plane.normal.y * this.max.y;
      } else {
        min += plane.normal.y * this.max.y;
        max += plane.normal.y * this.min.y;
      }
      if (plane.normal.z > 0) {
        min += plane.normal.z * this.min.z;
        max += plane.normal.z * this.max.z;
      } else {
        min += plane.normal.z * this.max.z;
        max += plane.normal.z * this.min.z;
      }
      return min <= -plane.constant && max >= -plane.constant;
    }
    intersectsTriangle(triangle) {
      if (this.isEmpty()) {
        return false;
      }
      this.getCenter(_center);
      _extents.subVectors(this.max, _center);
      _v0$2.subVectors(triangle.a, _center);
      _v1$7.subVectors(triangle.b, _center);
      _v2$3.subVectors(triangle.c, _center);
      _f0.subVectors(_v1$7, _v0$2);
      _f1.subVectors(_v2$3, _v1$7);
      _f2.subVectors(_v0$2, _v2$3);
      let axes = [
        0,
        -_f0.z,
        _f0.y,
        0,
        -_f1.z,
        _f1.y,
        0,
        -_f2.z,
        _f2.y,
        _f0.z,
        0,
        -_f0.x,
        _f1.z,
        0,
        -_f1.x,
        _f2.z,
        0,
        -_f2.x,
        -_f0.y,
        _f0.x,
        0,
        -_f1.y,
        _f1.x,
        0,
        -_f2.y,
        _f2.x,
        0
      ];
      if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
        return false;
      }
      axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
        return false;
      }
      _triangleNormal.crossVectors(_f0, _f1);
      axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
      return satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents);
    }
    clampPoint(point, target) {
      return target.copy(point).clamp(this.min, this.max);
    }
    distanceToPoint(point) {
      const clampedPoint = _vector$b.copy(point).clamp(this.min, this.max);
      return clampedPoint.sub(point).length();
    }
    getBoundingSphere(target) {
      this.getCenter(target.center);
      target.radius = this.getSize(_vector$b).length() * 0.5;
      return target;
    }
    intersect(box) {
      this.min.max(box.min);
      this.max.min(box.max);
      if (this.isEmpty())
        this.makeEmpty();
      return this;
    }
    union(box) {
      this.min.min(box.min);
      this.max.max(box.max);
      return this;
    }
    applyMatrix4(matrix) {
      if (this.isEmpty())
        return this;
      _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
      _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
      _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
      _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
      _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
      _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
      _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
      _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
      this.setFromPoints(_points);
      return this;
    }
    translate(offset) {
      this.min.add(offset);
      this.max.add(offset);
      return this;
    }
    equals(box) {
      return box.min.equals(this.min) && box.max.equals(this.max);
    }
  };
  Box3.prototype.isBox3 = true;
  var _points = [
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3(),
    /* @__PURE__ */ new Vector3()
  ];
  var _vector$b = /* @__PURE__ */ new Vector3();
  var _box$3 = /* @__PURE__ */ new Box3();
  var _v0$2 = /* @__PURE__ */ new Vector3();
  var _v1$7 = /* @__PURE__ */ new Vector3();
  var _v2$3 = /* @__PURE__ */ new Vector3();
  var _f0 = /* @__PURE__ */ new Vector3();
  var _f1 = /* @__PURE__ */ new Vector3();
  var _f2 = /* @__PURE__ */ new Vector3();
  var _center = /* @__PURE__ */ new Vector3();
  var _extents = /* @__PURE__ */ new Vector3();
  var _triangleNormal = /* @__PURE__ */ new Vector3();
  var _testAxis = /* @__PURE__ */ new Vector3();
  function satForAxes(axes, v0, v1, v2, extents) {
    for (let i2 = 0, j2 = axes.length - 3; i2 <= j2; i2 += 3) {
      _testAxis.fromArray(axes, i2);
      const r2 = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
      const p0 = v0.dot(_testAxis);
      const p1 = v1.dot(_testAxis);
      const p2 = v2.dot(_testAxis);
      if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r2) {
        return false;
      }
    }
    return true;
  }
  var _box$2 = /* @__PURE__ */ new Box3();
  var _v1$6 = /* @__PURE__ */ new Vector3();
  var _toFarthestPoint = /* @__PURE__ */ new Vector3();
  var _toPoint = /* @__PURE__ */ new Vector3();
  var Sphere = class {
    constructor(center = new Vector3(), radius = -1) {
      this.center = center;
      this.radius = radius;
    }
    set(center, radius) {
      this.center.copy(center);
      this.radius = radius;
      return this;
    }
    setFromPoints(points, optionalCenter) {
      const center = this.center;
      if (optionalCenter !== void 0) {
        center.copy(optionalCenter);
      } else {
        _box$2.setFromPoints(points).getCenter(center);
      }
      let maxRadiusSq = 0;
      for (let i2 = 0, il = points.length; i2 < il; i2++) {
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i2]));
      }
      this.radius = Math.sqrt(maxRadiusSq);
      return this;
    }
    copy(sphere) {
      this.center.copy(sphere.center);
      this.radius = sphere.radius;
      return this;
    }
    isEmpty() {
      return this.radius < 0;
    }
    makeEmpty() {
      this.center.set(0, 0, 0);
      this.radius = -1;
      return this;
    }
    containsPoint(point) {
      return point.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(point) {
      return point.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(sphere) {
      const radiusSum = this.radius + sphere.radius;
      return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
    }
    intersectsBox(box) {
      return box.intersectsSphere(this);
    }
    intersectsPlane(plane) {
      return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(point, target) {
      const deltaLengthSq = this.center.distanceToSquared(point);
      target.copy(point);
      if (deltaLengthSq > this.radius * this.radius) {
        target.sub(this.center).normalize();
        target.multiplyScalar(this.radius).add(this.center);
      }
      return target;
    }
    getBoundingBox(target) {
      if (this.isEmpty()) {
        target.makeEmpty();
        return target;
      }
      target.set(this.center, this.center);
      target.expandByScalar(this.radius);
      return target;
    }
    applyMatrix4(matrix) {
      this.center.applyMatrix4(matrix);
      this.radius = this.radius * matrix.getMaxScaleOnAxis();
      return this;
    }
    translate(offset) {
      this.center.add(offset);
      return this;
    }
    expandByPoint(point) {
      _toPoint.subVectors(point, this.center);
      const lengthSq = _toPoint.lengthSq();
      if (lengthSq > this.radius * this.radius) {
        const length = Math.sqrt(lengthSq);
        const missingRadiusHalf = (length - this.radius) * 0.5;
        this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));
        this.radius += missingRadiusHalf;
      }
      return this;
    }
    union(sphere) {
      _toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);
      this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));
      this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));
      return this;
    }
    equals(sphere) {
      return sphere.center.equals(this.center) && sphere.radius === this.radius;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  var _vector$a = /* @__PURE__ */ new Vector3();
  var _segCenter = /* @__PURE__ */ new Vector3();
  var _segDir = /* @__PURE__ */ new Vector3();
  var _diff = /* @__PURE__ */ new Vector3();
  var _edge1 = /* @__PURE__ */ new Vector3();
  var _edge2 = /* @__PURE__ */ new Vector3();
  var _normal$1 = /* @__PURE__ */ new Vector3();
  var Ray = class {
    constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
      this.origin = origin;
      this.direction = direction;
    }
    set(origin, direction) {
      this.origin.copy(origin);
      this.direction.copy(direction);
      return this;
    }
    copy(ray) {
      this.origin.copy(ray.origin);
      this.direction.copy(ray.direction);
      return this;
    }
    at(t2, target) {
      return target.copy(this.direction).multiplyScalar(t2).add(this.origin);
    }
    lookAt(v2) {
      this.direction.copy(v2).sub(this.origin).normalize();
      return this;
    }
    recast(t2) {
      this.origin.copy(this.at(t2, _vector$a));
      return this;
    }
    closestPointToPoint(point, target) {
      target.subVectors(point, this.origin);
      const directionDistance = target.dot(this.direction);
      if (directionDistance < 0) {
        return target.copy(this.origin);
      }
      return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    }
    distanceToPoint(point) {
      return Math.sqrt(this.distanceSqToPoint(point));
    }
    distanceSqToPoint(point) {
      const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
      if (directionDistance < 0) {
        return this.origin.distanceToSquared(point);
      }
      _vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
      return _vector$a.distanceToSquared(point);
    }
    distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
      _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
      _segDir.copy(v1).sub(v0).normalize();
      _diff.copy(this.origin).sub(_segCenter);
      const segExtent = v0.distanceTo(v1) * 0.5;
      const a01 = -this.direction.dot(_segDir);
      const b0 = _diff.dot(this.direction);
      const b1 = -_diff.dot(_segDir);
      const c2 = _diff.lengthSq();
      const det = Math.abs(1 - a01 * a01);
      let s0, s1, sqrDist, extDet;
      if (det > 0) {
        s0 = a01 * b1 - b0;
        s1 = a01 * b0 - b1;
        extDet = segExtent * det;
        if (s0 >= 0) {
          if (s1 >= -extDet) {
            if (s1 <= extDet) {
              const invDet = 1 / det;
              s0 *= invDet;
              s1 *= invDet;
              sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c2;
            } else {
              s1 = segExtent;
              s0 = Math.max(0, -(a01 * s1 + b0));
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
            }
          } else {
            s1 = -segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
          }
        } else {
          if (s1 <= -extDet) {
            s0 = Math.max(0, -(-a01 * segExtent + b0));
            s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
          } else if (s1 <= extDet) {
            s0 = 0;
            s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = s1 * (s1 + 2 * b1) + c2;
          } else {
            s0 = Math.max(0, -(a01 * segExtent + b0));
            s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
          }
        }
      } else {
        s1 = a01 > 0 ? -segExtent : segExtent;
        s0 = Math.max(0, -(a01 * s1 + b0));
        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
      }
      if (optionalPointOnRay) {
        optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
      }
      if (optionalPointOnSegment) {
        optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
      }
      return sqrDist;
    }
    intersectSphere(sphere, target) {
      _vector$a.subVectors(sphere.center, this.origin);
      const tca = _vector$a.dot(this.direction);
      const d2 = _vector$a.dot(_vector$a) - tca * tca;
      const radius2 = sphere.radius * sphere.radius;
      if (d2 > radius2)
        return null;
      const thc = Math.sqrt(radius2 - d2);
      const t0 = tca - thc;
      const t1 = tca + thc;
      if (t0 < 0 && t1 < 0)
        return null;
      if (t0 < 0)
        return this.at(t1, target);
      return this.at(t0, target);
    }
    intersectsSphere(sphere) {
      return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
    }
    distanceToPlane(plane) {
      const denominator = plane.normal.dot(this.direction);
      if (denominator === 0) {
        if (plane.distanceToPoint(this.origin) === 0) {
          return 0;
        }
        return null;
      }
      const t2 = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
      return t2 >= 0 ? t2 : null;
    }
    intersectPlane(plane, target) {
      const t2 = this.distanceToPlane(plane);
      if (t2 === null) {
        return null;
      }
      return this.at(t2, target);
    }
    intersectsPlane(plane) {
      const distToPoint = plane.distanceToPoint(this.origin);
      if (distToPoint === 0) {
        return true;
      }
      const denominator = plane.normal.dot(this.direction);
      if (denominator * distToPoint < 0) {
        return true;
      }
      return false;
    }
    intersectBox(box, target) {
      let tmin, tmax, tymin, tymax, tzmin, tzmax;
      const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
      const origin = this.origin;
      if (invdirx >= 0) {
        tmin = (box.min.x - origin.x) * invdirx;
        tmax = (box.max.x - origin.x) * invdirx;
      } else {
        tmin = (box.max.x - origin.x) * invdirx;
        tmax = (box.min.x - origin.x) * invdirx;
      }
      if (invdiry >= 0) {
        tymin = (box.min.y - origin.y) * invdiry;
        tymax = (box.max.y - origin.y) * invdiry;
      } else {
        tymin = (box.max.y - origin.y) * invdiry;
        tymax = (box.min.y - origin.y) * invdiry;
      }
      if (tmin > tymax || tymin > tmax)
        return null;
      if (tymin > tmin || tmin !== tmin)
        tmin = tymin;
      if (tymax < tmax || tmax !== tmax)
        tmax = tymax;
      if (invdirz >= 0) {
        tzmin = (box.min.z - origin.z) * invdirz;
        tzmax = (box.max.z - origin.z) * invdirz;
      } else {
        tzmin = (box.max.z - origin.z) * invdirz;
        tzmax = (box.min.z - origin.z) * invdirz;
      }
      if (tmin > tzmax || tzmin > tmax)
        return null;
      if (tzmin > tmin || tmin !== tmin)
        tmin = tzmin;
      if (tzmax < tmax || tmax !== tmax)
        tmax = tzmax;
      if (tmax < 0)
        return null;
      return this.at(tmin >= 0 ? tmin : tmax, target);
    }
    intersectsBox(box) {
      return this.intersectBox(box, _vector$a) !== null;
    }
    intersectTriangle(a2, b2, c2, backfaceCulling, target) {
      _edge1.subVectors(b2, a2);
      _edge2.subVectors(c2, a2);
      _normal$1.crossVectors(_edge1, _edge2);
      let DdN = this.direction.dot(_normal$1);
      let sign2;
      if (DdN > 0) {
        if (backfaceCulling)
          return null;
        sign2 = 1;
      } else if (DdN < 0) {
        sign2 = -1;
        DdN = -DdN;
      } else {
        return null;
      }
      _diff.subVectors(this.origin, a2);
      const DdQxE2 = sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
      if (DdQxE2 < 0) {
        return null;
      }
      const DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff));
      if (DdE1xQ < 0) {
        return null;
      }
      if (DdQxE2 + DdE1xQ > DdN) {
        return null;
      }
      const QdN = -sign2 * _diff.dot(_normal$1);
      if (QdN < 0) {
        return null;
      }
      return this.at(QdN / DdN, target);
    }
    applyMatrix4(matrix4) {
      this.origin.applyMatrix4(matrix4);
      this.direction.transformDirection(matrix4);
      return this;
    }
    equals(ray) {
      return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  var Matrix4 = class {
    constructor() {
      this.elements = [
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ];
      if (arguments.length > 0) {
        console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
      }
    }
    set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
      const te2 = this.elements;
      te2[0] = n11;
      te2[4] = n12;
      te2[8] = n13;
      te2[12] = n14;
      te2[1] = n21;
      te2[5] = n22;
      te2[9] = n23;
      te2[13] = n24;
      te2[2] = n31;
      te2[6] = n32;
      te2[10] = n33;
      te2[14] = n34;
      te2[3] = n41;
      te2[7] = n42;
      te2[11] = n43;
      te2[15] = n44;
      return this;
    }
    identity() {
      this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      return this;
    }
    clone() {
      return new Matrix4().fromArray(this.elements);
    }
    copy(m2) {
      const te2 = this.elements;
      const me2 = m2.elements;
      te2[0] = me2[0];
      te2[1] = me2[1];
      te2[2] = me2[2];
      te2[3] = me2[3];
      te2[4] = me2[4];
      te2[5] = me2[5];
      te2[6] = me2[6];
      te2[7] = me2[7];
      te2[8] = me2[8];
      te2[9] = me2[9];
      te2[10] = me2[10];
      te2[11] = me2[11];
      te2[12] = me2[12];
      te2[13] = me2[13];
      te2[14] = me2[14];
      te2[15] = me2[15];
      return this;
    }
    copyPosition(m2) {
      const te2 = this.elements, me2 = m2.elements;
      te2[12] = me2[12];
      te2[13] = me2[13];
      te2[14] = me2[14];
      return this;
    }
    setFromMatrix3(m2) {
      const me2 = m2.elements;
      this.set(me2[0], me2[3], me2[6], 0, me2[1], me2[4], me2[7], 0, me2[2], me2[5], me2[8], 0, 0, 0, 0, 1);
      return this;
    }
    extractBasis(xAxis, yAxis, zAxis) {
      xAxis.setFromMatrixColumn(this, 0);
      yAxis.setFromMatrixColumn(this, 1);
      zAxis.setFromMatrixColumn(this, 2);
      return this;
    }
    makeBasis(xAxis, yAxis, zAxis) {
      this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
      return this;
    }
    extractRotation(m2) {
      const te2 = this.elements;
      const me2 = m2.elements;
      const scaleX = 1 / _v1$5.setFromMatrixColumn(m2, 0).length();
      const scaleY = 1 / _v1$5.setFromMatrixColumn(m2, 1).length();
      const scaleZ = 1 / _v1$5.setFromMatrixColumn(m2, 2).length();
      te2[0] = me2[0] * scaleX;
      te2[1] = me2[1] * scaleX;
      te2[2] = me2[2] * scaleX;
      te2[3] = 0;
      te2[4] = me2[4] * scaleY;
      te2[5] = me2[5] * scaleY;
      te2[6] = me2[6] * scaleY;
      te2[7] = 0;
      te2[8] = me2[8] * scaleZ;
      te2[9] = me2[9] * scaleZ;
      te2[10] = me2[10] * scaleZ;
      te2[11] = 0;
      te2[12] = 0;
      te2[13] = 0;
      te2[14] = 0;
      te2[15] = 1;
      return this;
    }
    makeRotationFromEuler(euler) {
      if (!(euler && euler.isEuler)) {
        console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
      }
      const te2 = this.elements;
      const x2 = euler.x, y2 = euler.y, z2 = euler.z;
      const a2 = Math.cos(x2), b2 = Math.sin(x2);
      const c2 = Math.cos(y2), d2 = Math.sin(y2);
      const e2 = Math.cos(z2), f2 = Math.sin(z2);
      if (euler.order === "XYZ") {
        const ae2 = a2 * e2, af = a2 * f2, be = b2 * e2, bf = b2 * f2;
        te2[0] = c2 * e2;
        te2[4] = -c2 * f2;
        te2[8] = d2;
        te2[1] = af + be * d2;
        te2[5] = ae2 - bf * d2;
        te2[9] = -b2 * c2;
        te2[2] = bf - ae2 * d2;
        te2[6] = be + af * d2;
        te2[10] = a2 * c2;
      } else if (euler.order === "YXZ") {
        const ce2 = c2 * e2, cf = c2 * f2, de2 = d2 * e2, df = d2 * f2;
        te2[0] = ce2 + df * b2;
        te2[4] = de2 * b2 - cf;
        te2[8] = a2 * d2;
        te2[1] = a2 * f2;
        te2[5] = a2 * e2;
        te2[9] = -b2;
        te2[2] = cf * b2 - de2;
        te2[6] = df + ce2 * b2;
        te2[10] = a2 * c2;
      } else if (euler.order === "ZXY") {
        const ce2 = c2 * e2, cf = c2 * f2, de2 = d2 * e2, df = d2 * f2;
        te2[0] = ce2 - df * b2;
        te2[4] = -a2 * f2;
        te2[8] = de2 + cf * b2;
        te2[1] = cf + de2 * b2;
        te2[5] = a2 * e2;
        te2[9] = df - ce2 * b2;
        te2[2] = -a2 * d2;
        te2[6] = b2;
        te2[10] = a2 * c2;
      } else if (euler.order === "ZYX") {
        const ae2 = a2 * e2, af = a2 * f2, be = b2 * e2, bf = b2 * f2;
        te2[0] = c2 * e2;
        te2[4] = be * d2 - af;
        te2[8] = ae2 * d2 + bf;
        te2[1] = c2 * f2;
        te2[5] = bf * d2 + ae2;
        te2[9] = af * d2 - be;
        te2[2] = -d2;
        te2[6] = b2 * c2;
        te2[10] = a2 * c2;
      } else if (euler.order === "YZX") {
        const ac = a2 * c2, ad = a2 * d2, bc = b2 * c2, bd = b2 * d2;
        te2[0] = c2 * e2;
        te2[4] = bd - ac * f2;
        te2[8] = bc * f2 + ad;
        te2[1] = f2;
        te2[5] = a2 * e2;
        te2[9] = -b2 * e2;
        te2[2] = -d2 * e2;
        te2[6] = ad * f2 + bc;
        te2[10] = ac - bd * f2;
      } else if (euler.order === "XZY") {
        const ac = a2 * c2, ad = a2 * d2, bc = b2 * c2, bd = b2 * d2;
        te2[0] = c2 * e2;
        te2[4] = -f2;
        te2[8] = d2 * e2;
        te2[1] = ac * f2 + bd;
        te2[5] = a2 * e2;
        te2[9] = ad * f2 - bc;
        te2[2] = bc * f2 - ad;
        te2[6] = b2 * e2;
        te2[10] = bd * f2 + ac;
      }
      te2[3] = 0;
      te2[7] = 0;
      te2[11] = 0;
      te2[12] = 0;
      te2[13] = 0;
      te2[14] = 0;
      te2[15] = 1;
      return this;
    }
    makeRotationFromQuaternion(q2) {
      return this.compose(_zero, q2, _one);
    }
    lookAt(eye, target, up) {
      const te2 = this.elements;
      _z.subVectors(eye, target);
      if (_z.lengthSq() === 0) {
        _z.z = 1;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
      if (_x.lengthSq() === 0) {
        if (Math.abs(up.z) === 1) {
          _z.x += 1e-4;
        } else {
          _z.z += 1e-4;
        }
        _z.normalize();
        _x.crossVectors(up, _z);
      }
      _x.normalize();
      _y.crossVectors(_z, _x);
      te2[0] = _x.x;
      te2[4] = _y.x;
      te2[8] = _z.x;
      te2[1] = _x.y;
      te2[5] = _y.y;
      te2[9] = _z.y;
      te2[2] = _x.z;
      te2[6] = _y.z;
      te2[10] = _z.z;
      return this;
    }
    multiply(m2, n2) {
      if (n2 !== void 0) {
        console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
        return this.multiplyMatrices(m2, n2);
      }
      return this.multiplyMatrices(this, m2);
    }
    premultiply(m2) {
      return this.multiplyMatrices(m2, this);
    }
    multiplyMatrices(a2, b2) {
      const ae2 = a2.elements;
      const be = b2.elements;
      const te2 = this.elements;
      const a11 = ae2[0], a12 = ae2[4], a13 = ae2[8], a14 = ae2[12];
      const a21 = ae2[1], a22 = ae2[5], a23 = ae2[9], a24 = ae2[13];
      const a31 = ae2[2], a32 = ae2[6], a33 = ae2[10], a34 = ae2[14];
      const a41 = ae2[3], a42 = ae2[7], a43 = ae2[11], a44 = ae2[15];
      const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
      const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
      const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
      const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
      te2[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
      te2[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
      te2[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
      te2[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
      te2[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
      te2[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
      te2[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
      te2[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
      te2[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
      te2[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
      te2[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
      te2[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
      te2[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
      te2[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
      te2[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
      te2[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
      return this;
    }
    multiplyScalar(s2) {
      const te2 = this.elements;
      te2[0] *= s2;
      te2[4] *= s2;
      te2[8] *= s2;
      te2[12] *= s2;
      te2[1] *= s2;
      te2[5] *= s2;
      te2[9] *= s2;
      te2[13] *= s2;
      te2[2] *= s2;
      te2[6] *= s2;
      te2[10] *= s2;
      te2[14] *= s2;
      te2[3] *= s2;
      te2[7] *= s2;
      te2[11] *= s2;
      te2[15] *= s2;
      return this;
    }
    determinant() {
      const te2 = this.elements;
      const n11 = te2[0], n12 = te2[4], n13 = te2[8], n14 = te2[12];
      const n21 = te2[1], n22 = te2[5], n23 = te2[9], n24 = te2[13];
      const n31 = te2[2], n32 = te2[6], n33 = te2[10], n34 = te2[14];
      const n41 = te2[3], n42 = te2[7], n43 = te2[11], n44 = te2[15];
      return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
    }
    transpose() {
      const te2 = this.elements;
      let tmp2;
      tmp2 = te2[1];
      te2[1] = te2[4];
      te2[4] = tmp2;
      tmp2 = te2[2];
      te2[2] = te2[8];
      te2[8] = tmp2;
      tmp2 = te2[6];
      te2[6] = te2[9];
      te2[9] = tmp2;
      tmp2 = te2[3];
      te2[3] = te2[12];
      te2[12] = tmp2;
      tmp2 = te2[7];
      te2[7] = te2[13];
      te2[13] = tmp2;
      tmp2 = te2[11];
      te2[11] = te2[14];
      te2[14] = tmp2;
      return this;
    }
    setPosition(x2, y2, z2) {
      const te2 = this.elements;
      if (x2.isVector3) {
        te2[12] = x2.x;
        te2[13] = x2.y;
        te2[14] = x2.z;
      } else {
        te2[12] = x2;
        te2[13] = y2;
        te2[14] = z2;
      }
      return this;
    }
    invert() {
      const te2 = this.elements, n11 = te2[0], n21 = te2[1], n31 = te2[2], n41 = te2[3], n12 = te2[4], n22 = te2[5], n32 = te2[6], n42 = te2[7], n13 = te2[8], n23 = te2[9], n33 = te2[10], n43 = te2[11], n14 = te2[12], n24 = te2[13], n34 = te2[14], n44 = te2[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
      const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
      if (det === 0)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      const detInv = 1 / det;
      te2[0] = t11 * detInv;
      te2[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
      te2[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
      te2[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
      te2[4] = t12 * detInv;
      te2[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
      te2[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
      te2[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
      te2[8] = t13 * detInv;
      te2[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
      te2[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
      te2[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
      te2[12] = t14 * detInv;
      te2[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
      te2[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
      te2[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
      return this;
    }
    scale(v2) {
      const te2 = this.elements;
      const x2 = v2.x, y2 = v2.y, z2 = v2.z;
      te2[0] *= x2;
      te2[4] *= y2;
      te2[8] *= z2;
      te2[1] *= x2;
      te2[5] *= y2;
      te2[9] *= z2;
      te2[2] *= x2;
      te2[6] *= y2;
      te2[10] *= z2;
      te2[3] *= x2;
      te2[7] *= y2;
      te2[11] *= z2;
      return this;
    }
    getMaxScaleOnAxis() {
      const te2 = this.elements;
      const scaleXSq = te2[0] * te2[0] + te2[1] * te2[1] + te2[2] * te2[2];
      const scaleYSq = te2[4] * te2[4] + te2[5] * te2[5] + te2[6] * te2[6];
      const scaleZSq = te2[8] * te2[8] + te2[9] * te2[9] + te2[10] * te2[10];
      return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
    }
    makeTranslation(x2, y2, z2) {
      this.set(1, 0, 0, x2, 0, 1, 0, y2, 0, 0, 1, z2, 0, 0, 0, 1);
      return this;
    }
    makeRotationX(theta) {
      const c2 = Math.cos(theta), s2 = Math.sin(theta);
      this.set(1, 0, 0, 0, 0, c2, -s2, 0, 0, s2, c2, 0, 0, 0, 0, 1);
      return this;
    }
    makeRotationY(theta) {
      const c2 = Math.cos(theta), s2 = Math.sin(theta);
      this.set(c2, 0, s2, 0, 0, 1, 0, 0, -s2, 0, c2, 0, 0, 0, 0, 1);
      return this;
    }
    makeRotationZ(theta) {
      const c2 = Math.cos(theta), s2 = Math.sin(theta);
      this.set(c2, -s2, 0, 0, s2, c2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      return this;
    }
    makeRotationAxis(axis, angle) {
      const c2 = Math.cos(angle);
      const s2 = Math.sin(angle);
      const t2 = 1 - c2;
      const x2 = axis.x, y2 = axis.y, z2 = axis.z;
      const tx = t2 * x2, ty = t2 * y2;
      this.set(tx * x2 + c2, tx * y2 - s2 * z2, tx * z2 + s2 * y2, 0, tx * y2 + s2 * z2, ty * y2 + c2, ty * z2 - s2 * x2, 0, tx * z2 - s2 * y2, ty * z2 + s2 * x2, t2 * z2 * z2 + c2, 0, 0, 0, 0, 1);
      return this;
    }
    makeScale(x2, y2, z2) {
      this.set(x2, 0, 0, 0, 0, y2, 0, 0, 0, 0, z2, 0, 0, 0, 0, 1);
      return this;
    }
    makeShear(xy, xz, yx, yz, zx, zy) {
      this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
      return this;
    }
    compose(position, quaternion, scale) {
      const te2 = this.elements;
      const x2 = quaternion._x, y2 = quaternion._y, z2 = quaternion._z, w2 = quaternion._w;
      const x22 = x2 + x2, y22 = y2 + y2, z22 = z2 + z2;
      const xx = x2 * x22, xy = x2 * y22, xz = x2 * z22;
      const yy = y2 * y22, yz = y2 * z22, zz = z2 * z22;
      const wx = w2 * x22, wy = w2 * y22, wz = w2 * z22;
      const sx = scale.x, sy = scale.y, sz = scale.z;
      te2[0] = (1 - (yy + zz)) * sx;
      te2[1] = (xy + wz) * sx;
      te2[2] = (xz - wy) * sx;
      te2[3] = 0;
      te2[4] = (xy - wz) * sy;
      te2[5] = (1 - (xx + zz)) * sy;
      te2[6] = (yz + wx) * sy;
      te2[7] = 0;
      te2[8] = (xz + wy) * sz;
      te2[9] = (yz - wx) * sz;
      te2[10] = (1 - (xx + yy)) * sz;
      te2[11] = 0;
      te2[12] = position.x;
      te2[13] = position.y;
      te2[14] = position.z;
      te2[15] = 1;
      return this;
    }
    decompose(position, quaternion, scale) {
      const te2 = this.elements;
      let sx = _v1$5.set(te2[0], te2[1], te2[2]).length();
      const sy = _v1$5.set(te2[4], te2[5], te2[6]).length();
      const sz = _v1$5.set(te2[8], te2[9], te2[10]).length();
      const det = this.determinant();
      if (det < 0)
        sx = -sx;
      position.x = te2[12];
      position.y = te2[13];
      position.z = te2[14];
      _m1$2.copy(this);
      const invSX = 1 / sx;
      const invSY = 1 / sy;
      const invSZ = 1 / sz;
      _m1$2.elements[0] *= invSX;
      _m1$2.elements[1] *= invSX;
      _m1$2.elements[2] *= invSX;
      _m1$2.elements[4] *= invSY;
      _m1$2.elements[5] *= invSY;
      _m1$2.elements[6] *= invSY;
      _m1$2.elements[8] *= invSZ;
      _m1$2.elements[9] *= invSZ;
      _m1$2.elements[10] *= invSZ;
      quaternion.setFromRotationMatrix(_m1$2);
      scale.x = sx;
      scale.y = sy;
      scale.z = sz;
      return this;
    }
    makePerspective(left, right, top, bottom, near, far) {
      if (far === void 0) {
        console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
      }
      const te2 = this.elements;
      const x2 = 2 * near / (right - left);
      const y2 = 2 * near / (top - bottom);
      const a2 = (right + left) / (right - left);
      const b2 = (top + bottom) / (top - bottom);
      const c2 = -(far + near) / (far - near);
      const d2 = -2 * far * near / (far - near);
      te2[0] = x2;
      te2[4] = 0;
      te2[8] = a2;
      te2[12] = 0;
      te2[1] = 0;
      te2[5] = y2;
      te2[9] = b2;
      te2[13] = 0;
      te2[2] = 0;
      te2[6] = 0;
      te2[10] = c2;
      te2[14] = d2;
      te2[3] = 0;
      te2[7] = 0;
      te2[11] = -1;
      te2[15] = 0;
      return this;
    }
    makeOrthographic(left, right, top, bottom, near, far) {
      const te2 = this.elements;
      const w2 = 1 / (right - left);
      const h2 = 1 / (top - bottom);
      const p2 = 1 / (far - near);
      const x2 = (right + left) * w2;
      const y2 = (top + bottom) * h2;
      const z2 = (far + near) * p2;
      te2[0] = 2 * w2;
      te2[4] = 0;
      te2[8] = 0;
      te2[12] = -x2;
      te2[1] = 0;
      te2[5] = 2 * h2;
      te2[9] = 0;
      te2[13] = -y2;
      te2[2] = 0;
      te2[6] = 0;
      te2[10] = -2 * p2;
      te2[14] = -z2;
      te2[3] = 0;
      te2[7] = 0;
      te2[11] = 0;
      te2[15] = 1;
      return this;
    }
    equals(matrix) {
      const te2 = this.elements;
      const me2 = matrix.elements;
      for (let i2 = 0; i2 < 16; i2++) {
        if (te2[i2] !== me2[i2])
          return false;
      }
      return true;
    }
    fromArray(array, offset = 0) {
      for (let i2 = 0; i2 < 16; i2++) {
        this.elements[i2] = array[i2 + offset];
      }
      return this;
    }
    toArray(array = [], offset = 0) {
      const te2 = this.elements;
      array[offset] = te2[0];
      array[offset + 1] = te2[1];
      array[offset + 2] = te2[2];
      array[offset + 3] = te2[3];
      array[offset + 4] = te2[4];
      array[offset + 5] = te2[5];
      array[offset + 6] = te2[6];
      array[offset + 7] = te2[7];
      array[offset + 8] = te2[8];
      array[offset + 9] = te2[9];
      array[offset + 10] = te2[10];
      array[offset + 11] = te2[11];
      array[offset + 12] = te2[12];
      array[offset + 13] = te2[13];
      array[offset + 14] = te2[14];
      array[offset + 15] = te2[15];
      return array;
    }
  };
  Matrix4.prototype.isMatrix4 = true;
  var _v1$5 = /* @__PURE__ */ new Vector3();
  var _m1$2 = /* @__PURE__ */ new Matrix4();
  var _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
  var _one = /* @__PURE__ */ new Vector3(1, 1, 1);
  var _x = /* @__PURE__ */ new Vector3();
  var _y = /* @__PURE__ */ new Vector3();
  var _z = /* @__PURE__ */ new Vector3();
  var _matrix$1 = /* @__PURE__ */ new Matrix4();
  var _quaternion$3 = /* @__PURE__ */ new Quaternion();
  var Euler = class {
    constructor(x2 = 0, y2 = 0, z2 = 0, order = Euler.DefaultOrder) {
      this._x = x2;
      this._y = y2;
      this._z = z2;
      this._order = order;
    }
    get x() {
      return this._x;
    }
    set x(value) {
      this._x = value;
      this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(value) {
      this._y = value;
      this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(value) {
      this._z = value;
      this._onChangeCallback();
    }
    get order() {
      return this._order;
    }
    set order(value) {
      this._order = value;
      this._onChangeCallback();
    }
    set(x2, y2, z2, order = this._order) {
      this._x = x2;
      this._y = y2;
      this._z = z2;
      this._order = order;
      this._onChangeCallback();
      return this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(euler) {
      this._x = euler._x;
      this._y = euler._y;
      this._z = euler._z;
      this._order = euler._order;
      this._onChangeCallback();
      return this;
    }
    setFromRotationMatrix(m2, order = this._order, update2 = true) {
      const te2 = m2.elements;
      const m11 = te2[0], m12 = te2[4], m13 = te2[8];
      const m21 = te2[1], m22 = te2[5], m23 = te2[9];
      const m31 = te2[2], m32 = te2[6], m33 = te2[10];
      switch (order) {
        case "XYZ":
          this._y = Math.asin(clamp(m13, -1, 1));
          if (Math.abs(m13) < 0.9999999) {
            this._x = Math.atan2(-m23, m33);
            this._z = Math.atan2(-m12, m11);
          } else {
            this._x = Math.atan2(m32, m22);
            this._z = 0;
          }
          break;
        case "YXZ":
          this._x = Math.asin(-clamp(m23, -1, 1));
          if (Math.abs(m23) < 0.9999999) {
            this._y = Math.atan2(m13, m33);
            this._z = Math.atan2(m21, m22);
          } else {
            this._y = Math.atan2(-m31, m11);
            this._z = 0;
          }
          break;
        case "ZXY":
          this._x = Math.asin(clamp(m32, -1, 1));
          if (Math.abs(m32) < 0.9999999) {
            this._y = Math.atan2(-m31, m33);
            this._z = Math.atan2(-m12, m22);
          } else {
            this._y = 0;
            this._z = Math.atan2(m21, m11);
          }
          break;
        case "ZYX":
          this._y = Math.asin(-clamp(m31, -1, 1));
          if (Math.abs(m31) < 0.9999999) {
            this._x = Math.atan2(m32, m33);
            this._z = Math.atan2(m21, m11);
          } else {
            this._x = 0;
            this._z = Math.atan2(-m12, m22);
          }
          break;
        case "YZX":
          this._z = Math.asin(clamp(m21, -1, 1));
          if (Math.abs(m21) < 0.9999999) {
            this._x = Math.atan2(-m23, m22);
            this._y = Math.atan2(-m31, m11);
          } else {
            this._x = 0;
            this._y = Math.atan2(m13, m33);
          }
          break;
        case "XZY":
          this._z = Math.asin(-clamp(m12, -1, 1));
          if (Math.abs(m12) < 0.9999999) {
            this._x = Math.atan2(m32, m22);
            this._y = Math.atan2(m13, m11);
          } else {
            this._x = Math.atan2(-m23, m33);
            this._y = 0;
          }
          break;
        default:
          console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
      }
      this._order = order;
      if (update2 === true)
        this._onChangeCallback();
      return this;
    }
    setFromQuaternion(q2, order, update2) {
      _matrix$1.makeRotationFromQuaternion(q2);
      return this.setFromRotationMatrix(_matrix$1, order, update2);
    }
    setFromVector3(v2, order = this._order) {
      return this.set(v2.x, v2.y, v2.z, order);
    }
    reorder(newOrder) {
      _quaternion$3.setFromEuler(this);
      return this.setFromQuaternion(_quaternion$3, newOrder);
    }
    equals(euler) {
      return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
    }
    fromArray(array) {
      this._x = array[0];
      this._y = array[1];
      this._z = array[2];
      if (array[3] !== void 0)
        this._order = array[3];
      this._onChangeCallback();
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this._x;
      array[offset + 1] = this._y;
      array[offset + 2] = this._z;
      array[offset + 3] = this._order;
      return array;
    }
    toVector3(optionalResult) {
      if (optionalResult) {
        return optionalResult.set(this._x, this._y, this._z);
      } else {
        return new Vector3(this._x, this._y, this._z);
      }
    }
    _onChange(callback) {
      this._onChangeCallback = callback;
      return this;
    }
    _onChangeCallback() {
    }
  };
  Euler.prototype.isEuler = true;
  Euler.DefaultOrder = "XYZ";
  Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
  var Layers = class {
    constructor() {
      this.mask = 1 | 0;
    }
    set(channel) {
      this.mask = 1 << channel | 0;
    }
    enable(channel) {
      this.mask |= 1 << channel | 0;
    }
    enableAll() {
      this.mask = 4294967295 | 0;
    }
    toggle(channel) {
      this.mask ^= 1 << channel | 0;
    }
    disable(channel) {
      this.mask &= ~(1 << channel | 0);
    }
    disableAll() {
      this.mask = 0;
    }
    test(layers2) {
      return (this.mask & layers2.mask) !== 0;
    }
  };
  var _object3DId = 0;
  var _v1$4 = /* @__PURE__ */ new Vector3();
  var _q1 = /* @__PURE__ */ new Quaternion();
  var _m1$1 = /* @__PURE__ */ new Matrix4();
  var _target = /* @__PURE__ */ new Vector3();
  var _position$3 = /* @__PURE__ */ new Vector3();
  var _scale$2 = /* @__PURE__ */ new Vector3();
  var _quaternion$2 = /* @__PURE__ */ new Quaternion();
  var _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);
  var _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);
  var _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);
  var _addedEvent = { type: "added" };
  var _removedEvent = { type: "removed" };
  var Object3D = class extends EventDispatcher {
    constructor() {
      super();
      Object.defineProperty(this, "id", { value: _object3DId++ });
      this.uuid = generateUUID();
      this.name = "";
      this.type = "Object3D";
      this.parent = null;
      this.children = [];
      this.up = Object3D.DefaultUp.clone();
      const position = new Vector3();
      const rotation = new Euler();
      const quaternion = new Quaternion();
      const scale = new Vector3(1, 1, 1);
      function onRotationChange() {
        quaternion.setFromEuler(rotation, false);
      }
      function onQuaternionChange() {
        rotation.setFromQuaternion(quaternion, void 0, false);
      }
      rotation._onChange(onRotationChange);
      quaternion._onChange(onQuaternionChange);
      Object.defineProperties(this, {
        position: {
          configurable: true,
          enumerable: true,
          value: position
        },
        rotation: {
          configurable: true,
          enumerable: true,
          value: rotation
        },
        quaternion: {
          configurable: true,
          enumerable: true,
          value: quaternion
        },
        scale: {
          configurable: true,
          enumerable: true,
          value: scale
        },
        modelViewMatrix: {
          value: new Matrix4()
        },
        normalMatrix: {
          value: new Matrix3()
        }
      });
      this.matrix = new Matrix4();
      this.matrixWorld = new Matrix4();
      this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
      this.matrixWorldNeedsUpdate = false;
      this.layers = new Layers();
      this.visible = true;
      this.castShadow = false;
      this.receiveShadow = false;
      this.frustumCulled = true;
      this.renderOrder = 0;
      this.animations = [];
      this.userData = {};
    }
    onBeforeRender() {
    }
    onAfterRender() {
    }
    applyMatrix4(matrix) {
      if (this.matrixAutoUpdate)
        this.updateMatrix();
      this.matrix.premultiply(matrix);
      this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    applyQuaternion(q2) {
      this.quaternion.premultiply(q2);
      return this;
    }
    setRotationFromAxisAngle(axis, angle) {
      this.quaternion.setFromAxisAngle(axis, angle);
    }
    setRotationFromEuler(euler) {
      this.quaternion.setFromEuler(euler, true);
    }
    setRotationFromMatrix(m2) {
      this.quaternion.setFromRotationMatrix(m2);
    }
    setRotationFromQuaternion(q2) {
      this.quaternion.copy(q2);
    }
    rotateOnAxis(axis, angle) {
      _q1.setFromAxisAngle(axis, angle);
      this.quaternion.multiply(_q1);
      return this;
    }
    rotateOnWorldAxis(axis, angle) {
      _q1.setFromAxisAngle(axis, angle);
      this.quaternion.premultiply(_q1);
      return this;
    }
    rotateX(angle) {
      return this.rotateOnAxis(_xAxis, angle);
    }
    rotateY(angle) {
      return this.rotateOnAxis(_yAxis, angle);
    }
    rotateZ(angle) {
      return this.rotateOnAxis(_zAxis, angle);
    }
    translateOnAxis(axis, distance) {
      _v1$4.copy(axis).applyQuaternion(this.quaternion);
      this.position.add(_v1$4.multiplyScalar(distance));
      return this;
    }
    translateX(distance) {
      return this.translateOnAxis(_xAxis, distance);
    }
    translateY(distance) {
      return this.translateOnAxis(_yAxis, distance);
    }
    translateZ(distance) {
      return this.translateOnAxis(_zAxis, distance);
    }
    localToWorld(vector) {
      return vector.applyMatrix4(this.matrixWorld);
    }
    worldToLocal(vector) {
      return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
    }
    lookAt(x2, y2, z2) {
      if (x2.isVector3) {
        _target.copy(x2);
      } else {
        _target.set(x2, y2, z2);
      }
      const parent = this.parent;
      this.updateWorldMatrix(true, false);
      _position$3.setFromMatrixPosition(this.matrixWorld);
      if (this.isCamera || this.isLight) {
        _m1$1.lookAt(_position$3, _target, this.up);
      } else {
        _m1$1.lookAt(_target, _position$3, this.up);
      }
      this.quaternion.setFromRotationMatrix(_m1$1);
      if (parent) {
        _m1$1.extractRotation(parent.matrixWorld);
        _q1.setFromRotationMatrix(_m1$1);
        this.quaternion.premultiply(_q1.invert());
      }
    }
    add(object) {
      if (arguments.length > 1) {
        for (let i2 = 0; i2 < arguments.length; i2++) {
          this.add(arguments[i2]);
        }
        return this;
      }
      if (object === this) {
        console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
        return this;
      }
      if (object && object.isObject3D) {
        if (object.parent !== null) {
          object.parent.remove(object);
        }
        object.parent = this;
        this.children.push(object);
        object.dispatchEvent(_addedEvent);
      } else {
        console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
      }
      return this;
    }
    remove(object) {
      if (arguments.length > 1) {
        for (let i2 = 0; i2 < arguments.length; i2++) {
          this.remove(arguments[i2]);
        }
        return this;
      }
      const index = this.children.indexOf(object);
      if (index !== -1) {
        object.parent = null;
        this.children.splice(index, 1);
        object.dispatchEvent(_removedEvent);
      }
      return this;
    }
    removeFromParent() {
      const parent = this.parent;
      if (parent !== null) {
        parent.remove(this);
      }
      return this;
    }
    clear() {
      for (let i2 = 0; i2 < this.children.length; i2++) {
        const object = this.children[i2];
        object.parent = null;
        object.dispatchEvent(_removedEvent);
      }
      this.children.length = 0;
      return this;
    }
    attach(object) {
      this.updateWorldMatrix(true, false);
      _m1$1.copy(this.matrixWorld).invert();
      if (object.parent !== null) {
        object.parent.updateWorldMatrix(true, false);
        _m1$1.multiply(object.parent.matrixWorld);
      }
      object.applyMatrix4(_m1$1);
      this.add(object);
      object.updateWorldMatrix(false, true);
      return this;
    }
    getObjectById(id) {
      return this.getObjectByProperty("id", id);
    }
    getObjectByName(name) {
      return this.getObjectByProperty("name", name);
    }
    getObjectByProperty(name, value) {
      if (this[name] === value)
        return this;
      for (let i2 = 0, l2 = this.children.length; i2 < l2; i2++) {
        const child = this.children[i2];
        const object = child.getObjectByProperty(name, value);
        if (object !== void 0) {
          return object;
        }
      }
      return void 0;
    }
    getWorldPosition(target) {
      this.updateWorldMatrix(true, false);
      return target.setFromMatrixPosition(this.matrixWorld);
    }
    getWorldQuaternion(target) {
      this.updateWorldMatrix(true, false);
      this.matrixWorld.decompose(_position$3, target, _scale$2);
      return target;
    }
    getWorldScale(target) {
      this.updateWorldMatrix(true, false);
      this.matrixWorld.decompose(_position$3, _quaternion$2, target);
      return target;
    }
    getWorldDirection(target) {
      this.updateWorldMatrix(true, false);
      const e2 = this.matrixWorld.elements;
      return target.set(e2[8], e2[9], e2[10]).normalize();
    }
    raycast() {
    }
    traverse(callback) {
      callback(this);
      const children = this.children;
      for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
        children[i2].traverse(callback);
      }
    }
    traverseVisible(callback) {
      if (this.visible === false)
        return;
      callback(this);
      const children = this.children;
      for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
        children[i2].traverseVisible(callback);
      }
    }
    traverseAncestors(callback) {
      const parent = this.parent;
      if (parent !== null) {
        callback(parent);
        parent.traverseAncestors(callback);
      }
    }
    updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale);
      this.matrixWorldNeedsUpdate = true;
    }
    updateMatrixWorld(force) {
      if (this.matrixAutoUpdate)
        this.updateMatrix();
      if (this.matrixWorldNeedsUpdate || force) {
        if (this.parent === null) {
          this.matrixWorld.copy(this.matrix);
        } else {
          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        }
        this.matrixWorldNeedsUpdate = false;
        force = true;
      }
      const children = this.children;
      for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
        children[i2].updateMatrixWorld(force);
      }
    }
    updateWorldMatrix(updateParents, updateChildren) {
      const parent = this.parent;
      if (updateParents === true && parent !== null) {
        parent.updateWorldMatrix(true, false);
      }
      if (this.matrixAutoUpdate)
        this.updateMatrix();
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      if (updateChildren === true) {
        const children = this.children;
        for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
          children[i2].updateWorldMatrix(false, true);
        }
      }
    }
    toJSON(meta) {
      const isRootObject = meta === void 0 || typeof meta === "string";
      const output = {};
      if (isRootObject) {
        meta = {
          geometries: {},
          materials: {},
          textures: {},
          images: {},
          shapes: {},
          skeletons: {},
          animations: {}
        };
        output.metadata = {
          version: 4.5,
          type: "Object",
          generator: "Object3D.toJSON"
        };
      }
      const object = {};
      object.uuid = this.uuid;
      object.type = this.type;
      if (this.name !== "")
        object.name = this.name;
      if (this.castShadow === true)
        object.castShadow = true;
      if (this.receiveShadow === true)
        object.receiveShadow = true;
      if (this.visible === false)
        object.visible = false;
      if (this.frustumCulled === false)
        object.frustumCulled = false;
      if (this.renderOrder !== 0)
        object.renderOrder = this.renderOrder;
      if (JSON.stringify(this.userData) !== "{}")
        object.userData = this.userData;
      object.layers = this.layers.mask;
      object.matrix = this.matrix.toArray();
      if (this.matrixAutoUpdate === false)
        object.matrixAutoUpdate = false;
      if (this.isInstancedMesh) {
        object.type = "InstancedMesh";
        object.count = this.count;
        object.instanceMatrix = this.instanceMatrix.toJSON();
        if (this.instanceColor !== null)
          object.instanceColor = this.instanceColor.toJSON();
      }
      function serialize(library, element) {
        if (library[element.uuid] === void 0) {
          library[element.uuid] = element.toJSON(meta);
        }
        return element.uuid;
      }
      if (this.isScene) {
        if (this.background) {
          if (this.background.isColor) {
            object.background = this.background.toJSON();
          } else if (this.background.isTexture) {
            object.background = this.background.toJSON(meta).uuid;
          }
        }
        if (this.environment && this.environment.isTexture) {
          object.environment = this.environment.toJSON(meta).uuid;
        }
      } else if (this.isMesh || this.isLine || this.isPoints) {
        object.geometry = serialize(meta.geometries, this.geometry);
        const parameters = this.geometry.parameters;
        if (parameters !== void 0 && parameters.shapes !== void 0) {
          const shapes = parameters.shapes;
          if (Array.isArray(shapes)) {
            for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
              const shape = shapes[i2];
              serialize(meta.shapes, shape);
            }
          } else {
            serialize(meta.shapes, shapes);
          }
        }
      }
      if (this.isSkinnedMesh) {
        object.bindMode = this.bindMode;
        object.bindMatrix = this.bindMatrix.toArray();
        if (this.skeleton !== void 0) {
          serialize(meta.skeletons, this.skeleton);
          object.skeleton = this.skeleton.uuid;
        }
      }
      if (this.material !== void 0) {
        if (Array.isArray(this.material)) {
          const uuids = [];
          for (let i2 = 0, l2 = this.material.length; i2 < l2; i2++) {
            uuids.push(serialize(meta.materials, this.material[i2]));
          }
          object.material = uuids;
        } else {
          object.material = serialize(meta.materials, this.material);
        }
      }
      if (this.children.length > 0) {
        object.children = [];
        for (let i2 = 0; i2 < this.children.length; i2++) {
          object.children.push(this.children[i2].toJSON(meta).object);
        }
      }
      if (this.animations.length > 0) {
        object.animations = [];
        for (let i2 = 0; i2 < this.animations.length; i2++) {
          const animation = this.animations[i2];
          object.animations.push(serialize(meta.animations, animation));
        }
      }
      if (isRootObject) {
        const geometries = extractFromCache(meta.geometries);
        const materials = extractFromCache(meta.materials);
        const textures = extractFromCache(meta.textures);
        const images = extractFromCache(meta.images);
        const shapes = extractFromCache(meta.shapes);
        const skeletons = extractFromCache(meta.skeletons);
        const animations = extractFromCache(meta.animations);
        if (geometries.length > 0)
          output.geometries = geometries;
        if (materials.length > 0)
          output.materials = materials;
        if (textures.length > 0)
          output.textures = textures;
        if (images.length > 0)
          output.images = images;
        if (shapes.length > 0)
          output.shapes = shapes;
        if (skeletons.length > 0)
          output.skeletons = skeletons;
        if (animations.length > 0)
          output.animations = animations;
      }
      output.object = object;
      return output;
      function extractFromCache(cache) {
        const values = [];
        for (const key in cache) {
          const data = cache[key];
          delete data.metadata;
          values.push(data);
        }
        return values;
      }
    }
    clone(recursive) {
      return new this.constructor().copy(this, recursive);
    }
    copy(source, recursive = true) {
      this.name = source.name;
      this.up.copy(source.up);
      this.position.copy(source.position);
      this.rotation.order = source.rotation.order;
      this.quaternion.copy(source.quaternion);
      this.scale.copy(source.scale);
      this.matrix.copy(source.matrix);
      this.matrixWorld.copy(source.matrixWorld);
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
      this.layers.mask = source.layers.mask;
      this.visible = source.visible;
      this.castShadow = source.castShadow;
      this.receiveShadow = source.receiveShadow;
      this.frustumCulled = source.frustumCulled;
      this.renderOrder = source.renderOrder;
      this.userData = JSON.parse(JSON.stringify(source.userData));
      if (recursive === true) {
        for (let i2 = 0; i2 < source.children.length; i2++) {
          const child = source.children[i2];
          this.add(child.clone());
        }
      }
      return this;
    }
  };
  Object3D.DefaultUp = new Vector3(0, 1, 0);
  Object3D.DefaultMatrixAutoUpdate = true;
  Object3D.prototype.isObject3D = true;
  var _v0$1 = /* @__PURE__ */ new Vector3();
  var _v1$3 = /* @__PURE__ */ new Vector3();
  var _v2$2 = /* @__PURE__ */ new Vector3();
  var _v3$1 = /* @__PURE__ */ new Vector3();
  var _vab = /* @__PURE__ */ new Vector3();
  var _vac = /* @__PURE__ */ new Vector3();
  var _vbc = /* @__PURE__ */ new Vector3();
  var _vap = /* @__PURE__ */ new Vector3();
  var _vbp = /* @__PURE__ */ new Vector3();
  var _vcp = /* @__PURE__ */ new Vector3();
  var Triangle = class {
    constructor(a2 = new Vector3(), b2 = new Vector3(), c2 = new Vector3()) {
      this.a = a2;
      this.b = b2;
      this.c = c2;
    }
    static getNormal(a2, b2, c2, target) {
      target.subVectors(c2, b2);
      _v0$1.subVectors(a2, b2);
      target.cross(_v0$1);
      const targetLengthSq = target.lengthSq();
      if (targetLengthSq > 0) {
        return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
      }
      return target.set(0, 0, 0);
    }
    static getBarycoord(point, a2, b2, c2, target) {
      _v0$1.subVectors(c2, a2);
      _v1$3.subVectors(b2, a2);
      _v2$2.subVectors(point, a2);
      const dot00 = _v0$1.dot(_v0$1);
      const dot01 = _v0$1.dot(_v1$3);
      const dot02 = _v0$1.dot(_v2$2);
      const dot11 = _v1$3.dot(_v1$3);
      const dot12 = _v1$3.dot(_v2$2);
      const denom = dot00 * dot11 - dot01 * dot01;
      if (denom === 0) {
        return target.set(-2, -1, -1);
      }
      const invDenom = 1 / denom;
      const u2 = (dot11 * dot02 - dot01 * dot12) * invDenom;
      const v2 = (dot00 * dot12 - dot01 * dot02) * invDenom;
      return target.set(1 - u2 - v2, v2, u2);
    }
    static containsPoint(point, a2, b2, c2) {
      this.getBarycoord(point, a2, b2, c2, _v3$1);
      return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
    }
    static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
      this.getBarycoord(point, p1, p2, p3, _v3$1);
      target.set(0, 0);
      target.addScaledVector(uv1, _v3$1.x);
      target.addScaledVector(uv2, _v3$1.y);
      target.addScaledVector(uv3, _v3$1.z);
      return target;
    }
    static isFrontFacing(a2, b2, c2, direction) {
      _v0$1.subVectors(c2, b2);
      _v1$3.subVectors(a2, b2);
      return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
    }
    set(a2, b2, c2) {
      this.a.copy(a2);
      this.b.copy(b2);
      this.c.copy(c2);
      return this;
    }
    setFromPointsAndIndices(points, i0, i1, i2) {
      this.a.copy(points[i0]);
      this.b.copy(points[i1]);
      this.c.copy(points[i2]);
      return this;
    }
    setFromAttributeAndIndices(attribute, i0, i1, i2) {
      this.a.fromBufferAttribute(attribute, i0);
      this.b.fromBufferAttribute(attribute, i1);
      this.c.fromBufferAttribute(attribute, i2);
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(triangle) {
      this.a.copy(triangle.a);
      this.b.copy(triangle.b);
      this.c.copy(triangle.c);
      return this;
    }
    getArea() {
      _v0$1.subVectors(this.c, this.b);
      _v1$3.subVectors(this.a, this.b);
      return _v0$1.cross(_v1$3).length() * 0.5;
    }
    getMidpoint(target) {
      return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    }
    getNormal(target) {
      return Triangle.getNormal(this.a, this.b, this.c, target);
    }
    getPlane(target) {
      return target.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(point, target) {
      return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
    }
    getUV(point, uv1, uv2, uv3, target) {
      return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
    }
    containsPoint(point) {
      return Triangle.containsPoint(point, this.a, this.b, this.c);
    }
    isFrontFacing(direction) {
      return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
    }
    intersectsBox(box) {
      return box.intersectsTriangle(this);
    }
    closestPointToPoint(p2, target) {
      const a2 = this.a, b2 = this.b, c2 = this.c;
      let v2, w2;
      _vab.subVectors(b2, a2);
      _vac.subVectors(c2, a2);
      _vap.subVectors(p2, a2);
      const d1 = _vab.dot(_vap);
      const d2 = _vac.dot(_vap);
      if (d1 <= 0 && d2 <= 0) {
        return target.copy(a2);
      }
      _vbp.subVectors(p2, b2);
      const d3 = _vab.dot(_vbp);
      const d4 = _vac.dot(_vbp);
      if (d3 >= 0 && d4 <= d3) {
        return target.copy(b2);
      }
      const vc = d1 * d4 - d3 * d2;
      if (vc <= 0 && d1 >= 0 && d3 <= 0) {
        v2 = d1 / (d1 - d3);
        return target.copy(a2).addScaledVector(_vab, v2);
      }
      _vcp.subVectors(p2, c2);
      const d5 = _vab.dot(_vcp);
      const d6 = _vac.dot(_vcp);
      if (d6 >= 0 && d5 <= d6) {
        return target.copy(c2);
      }
      const vb = d5 * d2 - d1 * d6;
      if (vb <= 0 && d2 >= 0 && d6 <= 0) {
        w2 = d2 / (d2 - d6);
        return target.copy(a2).addScaledVector(_vac, w2);
      }
      const va = d3 * d6 - d5 * d4;
      if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
        _vbc.subVectors(c2, b2);
        w2 = (d4 - d3) / (d4 - d3 + (d5 - d6));
        return target.copy(b2).addScaledVector(_vbc, w2);
      }
      const denom = 1 / (va + vb + vc);
      v2 = vb * denom;
      w2 = vc * denom;
      return target.copy(a2).addScaledVector(_vab, v2).addScaledVector(_vac, w2);
    }
    equals(triangle) {
      return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
    }
  };
  var materialId = 0;
  var Material = class extends EventDispatcher {
    constructor() {
      super();
      Object.defineProperty(this, "id", { value: materialId++ });
      this.uuid = generateUUID();
      this.name = "";
      this.type = "Material";
      this.fog = true;
      this.blending = NormalBlending;
      this.side = FrontSide;
      this.vertexColors = false;
      this.opacity = 1;
      this.format = RGBAFormat;
      this.transparent = false;
      this.blendSrc = SrcAlphaFactor;
      this.blendDst = OneMinusSrcAlphaFactor;
      this.blendEquation = AddEquation;
      this.blendSrcAlpha = null;
      this.blendDstAlpha = null;
      this.blendEquationAlpha = null;
      this.depthFunc = LessEqualDepth;
      this.depthTest = true;
      this.depthWrite = true;
      this.stencilWriteMask = 255;
      this.stencilFunc = AlwaysStencilFunc;
      this.stencilRef = 0;
      this.stencilFuncMask = 255;
      this.stencilFail = KeepStencilOp;
      this.stencilZFail = KeepStencilOp;
      this.stencilZPass = KeepStencilOp;
      this.stencilWrite = false;
      this.clippingPlanes = null;
      this.clipIntersection = false;
      this.clipShadows = false;
      this.shadowSide = null;
      this.colorWrite = true;
      this.precision = null;
      this.polygonOffset = false;
      this.polygonOffsetFactor = 0;
      this.polygonOffsetUnits = 0;
      this.dithering = false;
      this.alphaToCoverage = false;
      this.premultipliedAlpha = false;
      this.visible = true;
      this.toneMapped = true;
      this.userData = {};
      this.version = 0;
      this._alphaTest = 0;
    }
    get alphaTest() {
      return this._alphaTest;
    }
    set alphaTest(value) {
      if (this._alphaTest > 0 !== value > 0) {
        this.version++;
      }
      this._alphaTest = value;
    }
    onBuild() {
    }
    onBeforeRender() {
    }
    onBeforeCompile() {
    }
    customProgramCacheKey() {
      return this.onBeforeCompile.toString();
    }
    setValues(values) {
      if (values === void 0)
        return;
      for (const key in values) {
        const newValue = values[key];
        if (newValue === void 0) {
          console.warn("THREE.Material: '" + key + "' parameter is undefined.");
          continue;
        }
        if (key === "shading") {
          console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
          this.flatShading = newValue === FlatShading ? true : false;
          continue;
        }
        const currentValue = this[key];
        if (currentValue === void 0) {
          console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
          continue;
        }
        if (currentValue && currentValue.isColor) {
          currentValue.set(newValue);
        } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
          currentValue.copy(newValue);
        } else {
          this[key] = newValue;
        }
      }
    }
    toJSON(meta) {
      const isRoot = meta === void 0 || typeof meta === "string";
      if (isRoot) {
        meta = {
          textures: {},
          images: {}
        };
      }
      const data = {
        metadata: {
          version: 4.5,
          type: "Material",
          generator: "Material.toJSON"
        }
      };
      data.uuid = this.uuid;
      data.type = this.type;
      if (this.name !== "")
        data.name = this.name;
      if (this.color && this.color.isColor)
        data.color = this.color.getHex();
      if (this.roughness !== void 0)
        data.roughness = this.roughness;
      if (this.metalness !== void 0)
        data.metalness = this.metalness;
      if (this.sheen !== void 0)
        data.sheen = this.sheen;
      if (this.sheenTint && this.sheenTint.isColor)
        data.sheenTint = this.sheenTint.getHex();
      if (this.sheenRoughness !== void 0)
        data.sheenRoughness = this.sheenRoughness;
      if (this.emissive && this.emissive.isColor)
        data.emissive = this.emissive.getHex();
      if (this.emissiveIntensity && this.emissiveIntensity !== 1)
        data.emissiveIntensity = this.emissiveIntensity;
      if (this.specular && this.specular.isColor)
        data.specular = this.specular.getHex();
      if (this.specularIntensity !== void 0)
        data.specularIntensity = this.specularIntensity;
      if (this.specularTint && this.specularTint.isColor)
        data.specularTint = this.specularTint.getHex();
      if (this.shininess !== void 0)
        data.shininess = this.shininess;
      if (this.clearcoat !== void 0)
        data.clearcoat = this.clearcoat;
      if (this.clearcoatRoughness !== void 0)
        data.clearcoatRoughness = this.clearcoatRoughness;
      if (this.clearcoatMap && this.clearcoatMap.isTexture) {
        data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
      }
      if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
        data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
      }
      if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
        data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
        data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
      }
      if (this.map && this.map.isTexture)
        data.map = this.map.toJSON(meta).uuid;
      if (this.matcap && this.matcap.isTexture)
        data.matcap = this.matcap.toJSON(meta).uuid;
      if (this.alphaMap && this.alphaMap.isTexture)
        data.alphaMap = this.alphaMap.toJSON(meta).uuid;
      if (this.lightMap && this.lightMap.isTexture) {
        data.lightMap = this.lightMap.toJSON(meta).uuid;
        data.lightMapIntensity = this.lightMapIntensity;
      }
      if (this.aoMap && this.aoMap.isTexture) {
        data.aoMap = this.aoMap.toJSON(meta).uuid;
        data.aoMapIntensity = this.aoMapIntensity;
      }
      if (this.bumpMap && this.bumpMap.isTexture) {
        data.bumpMap = this.bumpMap.toJSON(meta).uuid;
        data.bumpScale = this.bumpScale;
      }
      if (this.normalMap && this.normalMap.isTexture) {
        data.normalMap = this.normalMap.toJSON(meta).uuid;
        data.normalMapType = this.normalMapType;
        data.normalScale = this.normalScale.toArray();
      }
      if (this.displacementMap && this.displacementMap.isTexture) {
        data.displacementMap = this.displacementMap.toJSON(meta).uuid;
        data.displacementScale = this.displacementScale;
        data.displacementBias = this.displacementBias;
      }
      if (this.roughnessMap && this.roughnessMap.isTexture)
        data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
      if (this.metalnessMap && this.metalnessMap.isTexture)
        data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
      if (this.emissiveMap && this.emissiveMap.isTexture)
        data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
      if (this.specularMap && this.specularMap.isTexture)
        data.specularMap = this.specularMap.toJSON(meta).uuid;
      if (this.specularIntensityMap && this.specularIntensityMap.isTexture)
        data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
      if (this.specularTintMap && this.specularTintMap.isTexture)
        data.specularTintMap = this.specularTintMap.toJSON(meta).uuid;
      if (this.envMap && this.envMap.isTexture) {
        data.envMap = this.envMap.toJSON(meta).uuid;
        if (this.combine !== void 0)
          data.combine = this.combine;
      }
      if (this.envMapIntensity !== void 0)
        data.envMapIntensity = this.envMapIntensity;
      if (this.reflectivity !== void 0)
        data.reflectivity = this.reflectivity;
      if (this.refractionRatio !== void 0)
        data.refractionRatio = this.refractionRatio;
      if (this.gradientMap && this.gradientMap.isTexture) {
        data.gradientMap = this.gradientMap.toJSON(meta).uuid;
      }
      if (this.transmission !== void 0)
        data.transmission = this.transmission;
      if (this.transmissionMap && this.transmissionMap.isTexture)
        data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
      if (this.thickness !== void 0)
        data.thickness = this.thickness;
      if (this.thicknessMap && this.thicknessMap.isTexture)
        data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
      if (this.attenuationDistance !== void 0)
        data.attenuationDistance = this.attenuationDistance;
      if (this.attenuationTint !== void 0)
        data.attenuationTint = this.attenuationTint.getHex();
      if (this.size !== void 0)
        data.size = this.size;
      if (this.shadowSide !== null)
        data.shadowSide = this.shadowSide;
      if (this.sizeAttenuation !== void 0)
        data.sizeAttenuation = this.sizeAttenuation;
      if (this.blending !== NormalBlending)
        data.blending = this.blending;
      if (this.side !== FrontSide)
        data.side = this.side;
      if (this.vertexColors)
        data.vertexColors = true;
      if (this.opacity < 1)
        data.opacity = this.opacity;
      if (this.format !== RGBAFormat)
        data.format = this.format;
      if (this.transparent === true)
        data.transparent = this.transparent;
      data.depthFunc = this.depthFunc;
      data.depthTest = this.depthTest;
      data.depthWrite = this.depthWrite;
      data.colorWrite = this.colorWrite;
      data.stencilWrite = this.stencilWrite;
      data.stencilWriteMask = this.stencilWriteMask;
      data.stencilFunc = this.stencilFunc;
      data.stencilRef = this.stencilRef;
      data.stencilFuncMask = this.stencilFuncMask;
      data.stencilFail = this.stencilFail;
      data.stencilZFail = this.stencilZFail;
      data.stencilZPass = this.stencilZPass;
      if (this.rotation && this.rotation !== 0)
        data.rotation = this.rotation;
      if (this.polygonOffset === true)
        data.polygonOffset = true;
      if (this.polygonOffsetFactor !== 0)
        data.polygonOffsetFactor = this.polygonOffsetFactor;
      if (this.polygonOffsetUnits !== 0)
        data.polygonOffsetUnits = this.polygonOffsetUnits;
      if (this.linewidth && this.linewidth !== 1)
        data.linewidth = this.linewidth;
      if (this.dashSize !== void 0)
        data.dashSize = this.dashSize;
      if (this.gapSize !== void 0)
        data.gapSize = this.gapSize;
      if (this.scale !== void 0)
        data.scale = this.scale;
      if (this.dithering === true)
        data.dithering = true;
      if (this.alphaTest > 0)
        data.alphaTest = this.alphaTest;
      if (this.alphaToCoverage === true)
        data.alphaToCoverage = this.alphaToCoverage;
      if (this.premultipliedAlpha === true)
        data.premultipliedAlpha = this.premultipliedAlpha;
      if (this.wireframe === true)
        data.wireframe = this.wireframe;
      if (this.wireframeLinewidth > 1)
        data.wireframeLinewidth = this.wireframeLinewidth;
      if (this.wireframeLinecap !== "round")
        data.wireframeLinecap = this.wireframeLinecap;
      if (this.wireframeLinejoin !== "round")
        data.wireframeLinejoin = this.wireframeLinejoin;
      if (this.flatShading === true)
        data.flatShading = this.flatShading;
      if (this.visible === false)
        data.visible = false;
      if (this.toneMapped === false)
        data.toneMapped = false;
      if (JSON.stringify(this.userData) !== "{}")
        data.userData = this.userData;
      function extractFromCache(cache) {
        const values = [];
        for (const key in cache) {
          const data2 = cache[key];
          delete data2.metadata;
          values.push(data2);
        }
        return values;
      }
      if (isRoot) {
        const textures = extractFromCache(meta.textures);
        const images = extractFromCache(meta.images);
        if (textures.length > 0)
          data.textures = textures;
        if (images.length > 0)
          data.images = images;
      }
      return data;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(source) {
      this.name = source.name;
      this.fog = source.fog;
      this.blending = source.blending;
      this.side = source.side;
      this.vertexColors = source.vertexColors;
      this.opacity = source.opacity;
      this.format = source.format;
      this.transparent = source.transparent;
      this.blendSrc = source.blendSrc;
      this.blendDst = source.blendDst;
      this.blendEquation = source.blendEquation;
      this.blendSrcAlpha = source.blendSrcAlpha;
      this.blendDstAlpha = source.blendDstAlpha;
      this.blendEquationAlpha = source.blendEquationAlpha;
      this.depthFunc = source.depthFunc;
      this.depthTest = source.depthTest;
      this.depthWrite = source.depthWrite;
      this.stencilWriteMask = source.stencilWriteMask;
      this.stencilFunc = source.stencilFunc;
      this.stencilRef = source.stencilRef;
      this.stencilFuncMask = source.stencilFuncMask;
      this.stencilFail = source.stencilFail;
      this.stencilZFail = source.stencilZFail;
      this.stencilZPass = source.stencilZPass;
      this.stencilWrite = source.stencilWrite;
      const srcPlanes = source.clippingPlanes;
      let dstPlanes = null;
      if (srcPlanes !== null) {
        const n2 = srcPlanes.length;
        dstPlanes = new Array(n2);
        for (let i2 = 0; i2 !== n2; ++i2) {
          dstPlanes[i2] = srcPlanes[i2].clone();
        }
      }
      this.clippingPlanes = dstPlanes;
      this.clipIntersection = source.clipIntersection;
      this.clipShadows = source.clipShadows;
      this.shadowSide = source.shadowSide;
      this.colorWrite = source.colorWrite;
      this.precision = source.precision;
      this.polygonOffset = source.polygonOffset;
      this.polygonOffsetFactor = source.polygonOffsetFactor;
      this.polygonOffsetUnits = source.polygonOffsetUnits;
      this.dithering = source.dithering;
      this.alphaTest = source.alphaTest;
      this.alphaToCoverage = source.alphaToCoverage;
      this.premultipliedAlpha = source.premultipliedAlpha;
      this.visible = source.visible;
      this.toneMapped = source.toneMapped;
      this.userData = JSON.parse(JSON.stringify(source.userData));
      return this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    set needsUpdate(value) {
      if (value === true)
        this.version++;
    }
  };
  Material.prototype.isMaterial = true;
  var _colorKeywords = {
    "aliceblue": 15792383,
    "antiquewhite": 16444375,
    "aqua": 65535,
    "aquamarine": 8388564,
    "azure": 15794175,
    "beige": 16119260,
    "bisque": 16770244,
    "black": 0,
    "blanchedalmond": 16772045,
    "blue": 255,
    "blueviolet": 9055202,
    "brown": 10824234,
    "burlywood": 14596231,
    "cadetblue": 6266528,
    "chartreuse": 8388352,
    "chocolate": 13789470,
    "coral": 16744272,
    "cornflowerblue": 6591981,
    "cornsilk": 16775388,
    "crimson": 14423100,
    "cyan": 65535,
    "darkblue": 139,
    "darkcyan": 35723,
    "darkgoldenrod": 12092939,
    "darkgray": 11119017,
    "darkgreen": 25600,
    "darkgrey": 11119017,
    "darkkhaki": 12433259,
    "darkmagenta": 9109643,
    "darkolivegreen": 5597999,
    "darkorange": 16747520,
    "darkorchid": 10040012,
    "darkred": 9109504,
    "darksalmon": 15308410,
    "darkseagreen": 9419919,
    "darkslateblue": 4734347,
    "darkslategray": 3100495,
    "darkslategrey": 3100495,
    "darkturquoise": 52945,
    "darkviolet": 9699539,
    "deeppink": 16716947,
    "deepskyblue": 49151,
    "dimgray": 6908265,
    "dimgrey": 6908265,
    "dodgerblue": 2003199,
    "firebrick": 11674146,
    "floralwhite": 16775920,
    "forestgreen": 2263842,
    "fuchsia": 16711935,
    "gainsboro": 14474460,
    "ghostwhite": 16316671,
    "gold": 16766720,
    "goldenrod": 14329120,
    "gray": 8421504,
    "green": 32768,
    "greenyellow": 11403055,
    "grey": 8421504,
    "honeydew": 15794160,
    "hotpink": 16738740,
    "indianred": 13458524,
    "indigo": 4915330,
    "ivory": 16777200,
    "khaki": 15787660,
    "lavender": 15132410,
    "lavenderblush": 16773365,
    "lawngreen": 8190976,
    "lemonchiffon": 16775885,
    "lightblue": 11393254,
    "lightcoral": 15761536,
    "lightcyan": 14745599,
    "lightgoldenrodyellow": 16448210,
    "lightgray": 13882323,
    "lightgreen": 9498256,
    "lightgrey": 13882323,
    "lightpink": 16758465,
    "lightsalmon": 16752762,
    "lightseagreen": 2142890,
    "lightskyblue": 8900346,
    "lightslategray": 7833753,
    "lightslategrey": 7833753,
    "lightsteelblue": 11584734,
    "lightyellow": 16777184,
    "lime": 65280,
    "limegreen": 3329330,
    "linen": 16445670,
    "magenta": 16711935,
    "maroon": 8388608,
    "mediumaquamarine": 6737322,
    "mediumblue": 205,
    "mediumorchid": 12211667,
    "mediumpurple": 9662683,
    "mediumseagreen": 3978097,
    "mediumslateblue": 8087790,
    "mediumspringgreen": 64154,
    "mediumturquoise": 4772300,
    "mediumvioletred": 13047173,
    "midnightblue": 1644912,
    "mintcream": 16121850,
    "mistyrose": 16770273,
    "moccasin": 16770229,
    "navajowhite": 16768685,
    "navy": 128,
    "oldlace": 16643558,
    "olive": 8421376,
    "olivedrab": 7048739,
    "orange": 16753920,
    "orangered": 16729344,
    "orchid": 14315734,
    "palegoldenrod": 15657130,
    "palegreen": 10025880,
    "paleturquoise": 11529966,
    "palevioletred": 14381203,
    "papayawhip": 16773077,
    "peachpuff": 16767673,
    "peru": 13468991,
    "pink": 16761035,
    "plum": 14524637,
    "powderblue": 11591910,
    "purple": 8388736,
    "rebeccapurple": 6697881,
    "red": 16711680,
    "rosybrown": 12357519,
    "royalblue": 4286945,
    "saddlebrown": 9127187,
    "salmon": 16416882,
    "sandybrown": 16032864,
    "seagreen": 3050327,
    "seashell": 16774638,
    "sienna": 10506797,
    "silver": 12632256,
    "skyblue": 8900331,
    "slateblue": 6970061,
    "slategray": 7372944,
    "slategrey": 7372944,
    "snow": 16775930,
    "springgreen": 65407,
    "steelblue": 4620980,
    "tan": 13808780,
    "teal": 32896,
    "thistle": 14204888,
    "tomato": 16737095,
    "turquoise": 4251856,
    "violet": 15631086,
    "wheat": 16113331,
    "white": 16777215,
    "whitesmoke": 16119285,
    "yellow": 16776960,
    "yellowgreen": 10145074
  };
  var _hslA = { h: 0, s: 0, l: 0 };
  var _hslB = { h: 0, s: 0, l: 0 };
  function hue2rgb(p2, q2, t2) {
    if (t2 < 0)
      t2 += 1;
    if (t2 > 1)
      t2 -= 1;
    if (t2 < 1 / 6)
      return p2 + (q2 - p2) * 6 * t2;
    if (t2 < 1 / 2)
      return q2;
    if (t2 < 2 / 3)
      return p2 + (q2 - p2) * 6 * (2 / 3 - t2);
    return p2;
  }
  function SRGBToLinear(c2) {
    return c2 < 0.04045 ? c2 * 0.0773993808 : Math.pow(c2 * 0.9478672986 + 0.0521327014, 2.4);
  }
  function LinearToSRGB(c2) {
    return c2 < 31308e-7 ? c2 * 12.92 : 1.055 * Math.pow(c2, 0.41666) - 0.055;
  }
  var Color = class {
    constructor(r2, g2, b2) {
      if (g2 === void 0 && b2 === void 0) {
        return this.set(r2);
      }
      return this.setRGB(r2, g2, b2);
    }
    set(value) {
      if (value && value.isColor) {
        this.copy(value);
      } else if (typeof value === "number") {
        this.setHex(value);
      } else if (typeof value === "string") {
        this.setStyle(value);
      }
      return this;
    }
    setScalar(scalar) {
      this.r = scalar;
      this.g = scalar;
      this.b = scalar;
      return this;
    }
    setHex(hex) {
      hex = Math.floor(hex);
      this.r = (hex >> 16 & 255) / 255;
      this.g = (hex >> 8 & 255) / 255;
      this.b = (hex & 255) / 255;
      return this;
    }
    setRGB(r2, g2, b2) {
      this.r = r2;
      this.g = g2;
      this.b = b2;
      return this;
    }
    setHSL(h2, s2, l2) {
      h2 = euclideanModulo(h2, 1);
      s2 = clamp(s2, 0, 1);
      l2 = clamp(l2, 0, 1);
      if (s2 === 0) {
        this.r = this.g = this.b = l2;
      } else {
        const p2 = l2 <= 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
        const q2 = 2 * l2 - p2;
        this.r = hue2rgb(q2, p2, h2 + 1 / 3);
        this.g = hue2rgb(q2, p2, h2);
        this.b = hue2rgb(q2, p2, h2 - 1 / 3);
      }
      return this;
    }
    setStyle(style) {
      function handleAlpha(string) {
        if (string === void 0)
          return;
        if (parseFloat(string) < 1) {
          console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
        }
      }
      let m2;
      if (m2 = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
        let color;
        const name = m2[1];
        const components = m2[2];
        switch (name) {
          case "rgb":
          case "rgba":
            if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
              this.r = Math.min(255, parseInt(color[1], 10)) / 255;
              this.g = Math.min(255, parseInt(color[2], 10)) / 255;
              this.b = Math.min(255, parseInt(color[3], 10)) / 255;
              handleAlpha(color[4]);
              return this;
            }
            if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
              this.r = Math.min(100, parseInt(color[1], 10)) / 100;
              this.g = Math.min(100, parseInt(color[2], 10)) / 100;
              this.b = Math.min(100, parseInt(color[3], 10)) / 100;
              handleAlpha(color[4]);
              return this;
            }
            break;
          case "hsl":
          case "hsla":
            if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
              const h2 = parseFloat(color[1]) / 360;
              const s2 = parseInt(color[2], 10) / 100;
              const l2 = parseInt(color[3], 10) / 100;
              handleAlpha(color[4]);
              return this.setHSL(h2, s2, l2);
            }
            break;
        }
      } else if (m2 = /^\#([A-Fa-f\d]+)$/.exec(style)) {
        const hex = m2[1];
        const size = hex.length;
        if (size === 3) {
          this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
          this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
          this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
          return this;
        } else if (size === 6) {
          this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
          this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
          this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
          return this;
        }
      }
      if (style && style.length > 0) {
        return this.setColorName(style);
      }
      return this;
    }
    setColorName(style) {
      const hex = _colorKeywords[style.toLowerCase()];
      if (hex !== void 0) {
        this.setHex(hex);
      } else {
        console.warn("THREE.Color: Unknown color " + style);
      }
      return this;
    }
    clone() {
      return new this.constructor(this.r, this.g, this.b);
    }
    copy(color) {
      this.r = color.r;
      this.g = color.g;
      this.b = color.b;
      return this;
    }
    copyGammaToLinear(color, gammaFactor = 2) {
      this.r = Math.pow(color.r, gammaFactor);
      this.g = Math.pow(color.g, gammaFactor);
      this.b = Math.pow(color.b, gammaFactor);
      return this;
    }
    copyLinearToGamma(color, gammaFactor = 2) {
      const safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
      this.r = Math.pow(color.r, safeInverse);
      this.g = Math.pow(color.g, safeInverse);
      this.b = Math.pow(color.b, safeInverse);
      return this;
    }
    convertGammaToLinear(gammaFactor) {
      this.copyGammaToLinear(this, gammaFactor);
      return this;
    }
    convertLinearToGamma(gammaFactor) {
      this.copyLinearToGamma(this, gammaFactor);
      return this;
    }
    copySRGBToLinear(color) {
      this.r = SRGBToLinear(color.r);
      this.g = SRGBToLinear(color.g);
      this.b = SRGBToLinear(color.b);
      return this;
    }
    copyLinearToSRGB(color) {
      this.r = LinearToSRGB(color.r);
      this.g = LinearToSRGB(color.g);
      this.b = LinearToSRGB(color.b);
      return this;
    }
    convertSRGBToLinear() {
      this.copySRGBToLinear(this);
      return this;
    }
    convertLinearToSRGB() {
      this.copyLinearToSRGB(this);
      return this;
    }
    getHex() {
      return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
    }
    getHexString() {
      return ("000000" + this.getHex().toString(16)).slice(-6);
    }
    getHSL(target) {
      const r2 = this.r, g2 = this.g, b2 = this.b;
      const max = Math.max(r2, g2, b2);
      const min = Math.min(r2, g2, b2);
      let hue, saturation;
      const lightness = (min + max) / 2;
      if (min === max) {
        hue = 0;
        saturation = 0;
      } else {
        const delta = max - min;
        saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
        switch (max) {
          case r2:
            hue = (g2 - b2) / delta + (g2 < b2 ? 6 : 0);
            break;
          case g2:
            hue = (b2 - r2) / delta + 2;
            break;
          case b2:
            hue = (r2 - g2) / delta + 4;
            break;
        }
        hue /= 6;
      }
      target.h = hue;
      target.s = saturation;
      target.l = lightness;
      return target;
    }
    getStyle() {
      return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
    }
    offsetHSL(h2, s2, l2) {
      this.getHSL(_hslA);
      _hslA.h += h2;
      _hslA.s += s2;
      _hslA.l += l2;
      this.setHSL(_hslA.h, _hslA.s, _hslA.l);
      return this;
    }
    add(color) {
      this.r += color.r;
      this.g += color.g;
      this.b += color.b;
      return this;
    }
    addColors(color1, color2) {
      this.r = color1.r + color2.r;
      this.g = color1.g + color2.g;
      this.b = color1.b + color2.b;
      return this;
    }
    addScalar(s2) {
      this.r += s2;
      this.g += s2;
      this.b += s2;
      return this;
    }
    sub(color) {
      this.r = Math.max(0, this.r - color.r);
      this.g = Math.max(0, this.g - color.g);
      this.b = Math.max(0, this.b - color.b);
      return this;
    }
    multiply(color) {
      this.r *= color.r;
      this.g *= color.g;
      this.b *= color.b;
      return this;
    }
    multiplyScalar(s2) {
      this.r *= s2;
      this.g *= s2;
      this.b *= s2;
      return this;
    }
    lerp(color, alpha) {
      this.r += (color.r - this.r) * alpha;
      this.g += (color.g - this.g) * alpha;
      this.b += (color.b - this.b) * alpha;
      return this;
    }
    lerpColors(color1, color2, alpha) {
      this.r = color1.r + (color2.r - color1.r) * alpha;
      this.g = color1.g + (color2.g - color1.g) * alpha;
      this.b = color1.b + (color2.b - color1.b) * alpha;
      return this;
    }
    lerpHSL(color, alpha) {
      this.getHSL(_hslA);
      color.getHSL(_hslB);
      const h2 = lerp(_hslA.h, _hslB.h, alpha);
      const s2 = lerp(_hslA.s, _hslB.s, alpha);
      const l2 = lerp(_hslA.l, _hslB.l, alpha);
      this.setHSL(h2, s2, l2);
      return this;
    }
    equals(c2) {
      return c2.r === this.r && c2.g === this.g && c2.b === this.b;
    }
    fromArray(array, offset = 0) {
      this.r = array[offset];
      this.g = array[offset + 1];
      this.b = array[offset + 2];
      return this;
    }
    toArray(array = [], offset = 0) {
      array[offset] = this.r;
      array[offset + 1] = this.g;
      array[offset + 2] = this.b;
      return array;
    }
    fromBufferAttribute(attribute, index) {
      this.r = attribute.getX(index);
      this.g = attribute.getY(index);
      this.b = attribute.getZ(index);
      if (attribute.normalized === true) {
        this.r /= 255;
        this.g /= 255;
        this.b /= 255;
      }
      return this;
    }
    toJSON() {
      return this.getHex();
    }
  };
  Color.NAMES = _colorKeywords;
  Color.prototype.isColor = true;
  Color.prototype.r = 1;
  Color.prototype.g = 1;
  Color.prototype.b = 1;
  var MeshBasicMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.type = "MeshBasicMaterial";
      this.color = new Color(16777215);
      this.map = null;
      this.lightMap = null;
      this.lightMapIntensity = 1;
      this.aoMap = null;
      this.aoMapIntensity = 1;
      this.specularMap = null;
      this.alphaMap = null;
      this.envMap = null;
      this.combine = MultiplyOperation;
      this.reflectivity = 1;
      this.refractionRatio = 0.98;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = "round";
      this.wireframeLinejoin = "round";
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.specularMap = source.specularMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      return this;
    }
  };
  MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
  var _vector$9 = /* @__PURE__ */ new Vector3();
  var _vector2$1 = /* @__PURE__ */ new Vector2();
  var BufferAttribute = class {
    constructor(array, itemSize, normalized) {
      if (Array.isArray(array)) {
        throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
      }
      this.name = "";
      this.array = array;
      this.itemSize = itemSize;
      this.count = array !== void 0 ? array.length / itemSize : 0;
      this.normalized = normalized === true;
      this.usage = StaticDrawUsage;
      this.updateRange = { offset: 0, count: -1 };
      this.version = 0;
    }
    onUploadCallback() {
    }
    set needsUpdate(value) {
      if (value === true)
        this.version++;
    }
    setUsage(value) {
      this.usage = value;
      return this;
    }
    copy(source) {
      this.name = source.name;
      this.array = new source.array.constructor(source.array);
      this.itemSize = source.itemSize;
      this.count = source.count;
      this.normalized = source.normalized;
      this.usage = source.usage;
      return this;
    }
    copyAt(index1, attribute, index2) {
      index1 *= this.itemSize;
      index2 *= attribute.itemSize;
      for (let i2 = 0, l2 = this.itemSize; i2 < l2; i2++) {
        this.array[index1 + i2] = attribute.array[index2 + i2];
      }
      return this;
    }
    copyArray(array) {
      this.array.set(array);
      return this;
    }
    copyColorsArray(colors) {
      const array = this.array;
      let offset = 0;
      for (let i2 = 0, l2 = colors.length; i2 < l2; i2++) {
        let color = colors[i2];
        if (color === void 0) {
          console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i2);
          color = new Color();
        }
        array[offset++] = color.r;
        array[offset++] = color.g;
        array[offset++] = color.b;
      }
      return this;
    }
    copyVector2sArray(vectors) {
      const array = this.array;
      let offset = 0;
      for (let i2 = 0, l2 = vectors.length; i2 < l2; i2++) {
        let vector = vectors[i2];
        if (vector === void 0) {
          console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i2);
          vector = new Vector2();
        }
        array[offset++] = vector.x;
        array[offset++] = vector.y;
      }
      return this;
    }
    copyVector3sArray(vectors) {
      const array = this.array;
      let offset = 0;
      for (let i2 = 0, l2 = vectors.length; i2 < l2; i2++) {
        let vector = vectors[i2];
        if (vector === void 0) {
          console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i2);
          vector = new Vector3();
        }
        array[offset++] = vector.x;
        array[offset++] = vector.y;
        array[offset++] = vector.z;
      }
      return this;
    }
    copyVector4sArray(vectors) {
      const array = this.array;
      let offset = 0;
      for (let i2 = 0, l2 = vectors.length; i2 < l2; i2++) {
        let vector = vectors[i2];
        if (vector === void 0) {
          console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i2);
          vector = new Vector4();
        }
        array[offset++] = vector.x;
        array[offset++] = vector.y;
        array[offset++] = vector.z;
        array[offset++] = vector.w;
      }
      return this;
    }
    applyMatrix3(m2) {
      if (this.itemSize === 2) {
        for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
          _vector2$1.fromBufferAttribute(this, i2);
          _vector2$1.applyMatrix3(m2);
          this.setXY(i2, _vector2$1.x, _vector2$1.y);
        }
      } else if (this.itemSize === 3) {
        for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
          _vector$9.fromBufferAttribute(this, i2);
          _vector$9.applyMatrix3(m2);
          this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
        }
      }
      return this;
    }
    applyMatrix4(m2) {
      for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
        _vector$9.x = this.getX(i2);
        _vector$9.y = this.getY(i2);
        _vector$9.z = this.getZ(i2);
        _vector$9.applyMatrix4(m2);
        this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
      }
      return this;
    }
    applyNormalMatrix(m2) {
      for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
        _vector$9.x = this.getX(i2);
        _vector$9.y = this.getY(i2);
        _vector$9.z = this.getZ(i2);
        _vector$9.applyNormalMatrix(m2);
        this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
      }
      return this;
    }
    transformDirection(m2) {
      for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
        _vector$9.x = this.getX(i2);
        _vector$9.y = this.getY(i2);
        _vector$9.z = this.getZ(i2);
        _vector$9.transformDirection(m2);
        this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
      }
      return this;
    }
    set(value, offset = 0) {
      this.array.set(value, offset);
      return this;
    }
    getX(index) {
      return this.array[index * this.itemSize];
    }
    setX(index, x2) {
      this.array[index * this.itemSize] = x2;
      return this;
    }
    getY(index) {
      return this.array[index * this.itemSize + 1];
    }
    setY(index, y2) {
      this.array[index * this.itemSize + 1] = y2;
      return this;
    }
    getZ(index) {
      return this.array[index * this.itemSize + 2];
    }
    setZ(index, z2) {
      this.array[index * this.itemSize + 2] = z2;
      return this;
    }
    getW(index) {
      return this.array[index * this.itemSize + 3];
    }
    setW(index, w2) {
      this.array[index * this.itemSize + 3] = w2;
      return this;
    }
    setXY(index, x2, y2) {
      index *= this.itemSize;
      this.array[index + 0] = x2;
      this.array[index + 1] = y2;
      return this;
    }
    setXYZ(index, x2, y2, z2) {
      index *= this.itemSize;
      this.array[index + 0] = x2;
      this.array[index + 1] = y2;
      this.array[index + 2] = z2;
      return this;
    }
    setXYZW(index, x2, y2, z2, w2) {
      index *= this.itemSize;
      this.array[index + 0] = x2;
      this.array[index + 1] = y2;
      this.array[index + 2] = z2;
      this.array[index + 3] = w2;
      return this;
    }
    onUpload(callback) {
      this.onUploadCallback = callback;
      return this;
    }
    clone() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    }
    toJSON() {
      const data = {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: Array.prototype.slice.call(this.array),
        normalized: this.normalized
      };
      if (this.name !== "")
        data.name = this.name;
      if (this.usage !== StaticDrawUsage)
        data.usage = this.usage;
      if (this.updateRange.offset !== 0 || this.updateRange.count !== -1)
        data.updateRange = this.updateRange;
      return data;
    }
  };
  BufferAttribute.prototype.isBufferAttribute = true;
  var Uint16BufferAttribute = class extends BufferAttribute {
    constructor(array, itemSize, normalized) {
      super(new Uint16Array(array), itemSize, normalized);
    }
  };
  var Uint32BufferAttribute = class extends BufferAttribute {
    constructor(array, itemSize, normalized) {
      super(new Uint32Array(array), itemSize, normalized);
    }
  };
  var Float16BufferAttribute = class extends BufferAttribute {
    constructor(array, itemSize, normalized) {
      super(new Uint16Array(array), itemSize, normalized);
    }
  };
  Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;
  var Float32BufferAttribute = class extends BufferAttribute {
    constructor(array, itemSize, normalized) {
      super(new Float32Array(array), itemSize, normalized);
    }
  };
  var _id = 0;
  var _m1 = /* @__PURE__ */ new Matrix4();
  var _obj = /* @__PURE__ */ new Object3D();
  var _offset = /* @__PURE__ */ new Vector3();
  var _box$1 = /* @__PURE__ */ new Box3();
  var _boxMorphTargets = /* @__PURE__ */ new Box3();
  var _vector$8 = /* @__PURE__ */ new Vector3();
  var BufferGeometry = class extends EventDispatcher {
    constructor() {
      super();
      Object.defineProperty(this, "id", { value: _id++ });
      this.uuid = generateUUID();
      this.name = "";
      this.type = "BufferGeometry";
      this.index = null;
      this.attributes = {};
      this.morphAttributes = {};
      this.morphTargetsRelative = false;
      this.groups = [];
      this.boundingBox = null;
      this.boundingSphere = null;
      this.drawRange = { start: 0, count: Infinity };
      this.userData = {};
    }
    getIndex() {
      return this.index;
    }
    setIndex(index) {
      if (Array.isArray(index)) {
        this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
      } else {
        this.index = index;
      }
      return this;
    }
    getAttribute(name) {
      return this.attributes[name];
    }
    setAttribute(name, attribute) {
      this.attributes[name] = attribute;
      return this;
    }
    deleteAttribute(name) {
      delete this.attributes[name];
      return this;
    }
    hasAttribute(name) {
      return this.attributes[name] !== void 0;
    }
    addGroup(start, count, materialIndex = 0) {
      this.groups.push({
        start,
        count,
        materialIndex
      });
    }
    clearGroups() {
      this.groups = [];
    }
    setDrawRange(start, count) {
      this.drawRange.start = start;
      this.drawRange.count = count;
    }
    applyMatrix4(matrix) {
      const position = this.attributes.position;
      if (position !== void 0) {
        position.applyMatrix4(matrix);
        position.needsUpdate = true;
      }
      const normal = this.attributes.normal;
      if (normal !== void 0) {
        const normalMatrix = new Matrix3().getNormalMatrix(matrix);
        normal.applyNormalMatrix(normalMatrix);
        normal.needsUpdate = true;
      }
      const tangent = this.attributes.tangent;
      if (tangent !== void 0) {
        tangent.transformDirection(matrix);
        tangent.needsUpdate = true;
      }
      if (this.boundingBox !== null) {
        this.computeBoundingBox();
      }
      if (this.boundingSphere !== null) {
        this.computeBoundingSphere();
      }
      return this;
    }
    applyQuaternion(q2) {
      _m1.makeRotationFromQuaternion(q2);
      this.applyMatrix4(_m1);
      return this;
    }
    rotateX(angle) {
      _m1.makeRotationX(angle);
      this.applyMatrix4(_m1);
      return this;
    }
    rotateY(angle) {
      _m1.makeRotationY(angle);
      this.applyMatrix4(_m1);
      return this;
    }
    rotateZ(angle) {
      _m1.makeRotationZ(angle);
      this.applyMatrix4(_m1);
      return this;
    }
    translate(x2, y2, z2) {
      _m1.makeTranslation(x2, y2, z2);
      this.applyMatrix4(_m1);
      return this;
    }
    scale(x2, y2, z2) {
      _m1.makeScale(x2, y2, z2);
      this.applyMatrix4(_m1);
      return this;
    }
    lookAt(vector) {
      _obj.lookAt(vector);
      _obj.updateMatrix();
      this.applyMatrix4(_obj.matrix);
      return this;
    }
    center() {
      this.computeBoundingBox();
      this.boundingBox.getCenter(_offset).negate();
      this.translate(_offset.x, _offset.y, _offset.z);
      return this;
    }
    setFromPoints(points) {
      const position = [];
      for (let i2 = 0, l2 = points.length; i2 < l2; i2++) {
        const point = points[i2];
        position.push(point.x, point.y, point.z || 0);
      }
      this.setAttribute("position", new Float32BufferAttribute(position, 3));
      return this;
    }
    computeBoundingBox() {
      if (this.boundingBox === null) {
        this.boundingBox = new Box3();
      }
      const position = this.attributes.position;
      const morphAttributesPosition = this.morphAttributes.position;
      if (position && position.isGLBufferAttribute) {
        console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
        this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(Infinity, Infinity, Infinity));
        return;
      }
      if (position !== void 0) {
        this.boundingBox.setFromBufferAttribute(position);
        if (morphAttributesPosition) {
          for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
            const morphAttribute = morphAttributesPosition[i2];
            _box$1.setFromBufferAttribute(morphAttribute);
            if (this.morphTargetsRelative) {
              _vector$8.addVectors(this.boundingBox.min, _box$1.min);
              this.boundingBox.expandByPoint(_vector$8);
              _vector$8.addVectors(this.boundingBox.max, _box$1.max);
              this.boundingBox.expandByPoint(_vector$8);
            } else {
              this.boundingBox.expandByPoint(_box$1.min);
              this.boundingBox.expandByPoint(_box$1.max);
            }
          }
        }
      } else {
        this.boundingBox.makeEmpty();
      }
      if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
        console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
      }
    }
    computeBoundingSphere() {
      if (this.boundingSphere === null) {
        this.boundingSphere = new Sphere();
      }
      const position = this.attributes.position;
      const morphAttributesPosition = this.morphAttributes.position;
      if (position && position.isGLBufferAttribute) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
        this.boundingSphere.set(new Vector3(), Infinity);
        return;
      }
      if (position) {
        const center = this.boundingSphere.center;
        _box$1.setFromBufferAttribute(position);
        if (morphAttributesPosition) {
          for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
            const morphAttribute = morphAttributesPosition[i2];
            _boxMorphTargets.setFromBufferAttribute(morphAttribute);
            if (this.morphTargetsRelative) {
              _vector$8.addVectors(_box$1.min, _boxMorphTargets.min);
              _box$1.expandByPoint(_vector$8);
              _vector$8.addVectors(_box$1.max, _boxMorphTargets.max);
              _box$1.expandByPoint(_vector$8);
            } else {
              _box$1.expandByPoint(_boxMorphTargets.min);
              _box$1.expandByPoint(_boxMorphTargets.max);
            }
          }
        }
        _box$1.getCenter(center);
        let maxRadiusSq = 0;
        for (let i2 = 0, il = position.count; i2 < il; i2++) {
          _vector$8.fromBufferAttribute(position, i2);
          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
        }
        if (morphAttributesPosition) {
          for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
            const morphAttribute = morphAttributesPosition[i2];
            const morphTargetsRelative = this.morphTargetsRelative;
            for (let j2 = 0, jl = morphAttribute.count; j2 < jl; j2++) {
              _vector$8.fromBufferAttribute(morphAttribute, j2);
              if (morphTargetsRelative) {
                _offset.fromBufferAttribute(position, j2);
                _vector$8.add(_offset);
              }
              maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
            }
          }
        }
        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
        if (isNaN(this.boundingSphere.radius)) {
          console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
        }
      }
    }
    computeTangents() {
      const index = this.index;
      const attributes = this.attributes;
      if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
        console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
        return;
      }
      const indices = index.array;
      const positions = attributes.position.array;
      const normals = attributes.normal.array;
      const uvs = attributes.uv.array;
      const nVertices = positions.length / 3;
      if (attributes.tangent === void 0) {
        this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * nVertices), 4));
      }
      const tangents = attributes.tangent.array;
      const tan1 = [], tan2 = [];
      for (let i2 = 0; i2 < nVertices; i2++) {
        tan1[i2] = new Vector3();
        tan2[i2] = new Vector3();
      }
      const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
      function handleTriangle(a2, b2, c2) {
        vA.fromArray(positions, a2 * 3);
        vB.fromArray(positions, b2 * 3);
        vC.fromArray(positions, c2 * 3);
        uvA.fromArray(uvs, a2 * 2);
        uvB.fromArray(uvs, b2 * 2);
        uvC.fromArray(uvs, c2 * 2);
        vB.sub(vA);
        vC.sub(vA);
        uvB.sub(uvA);
        uvC.sub(uvA);
        const r2 = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
        if (!isFinite(r2))
          return;
        sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r2);
        tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r2);
        tan1[a2].add(sdir);
        tan1[b2].add(sdir);
        tan1[c2].add(sdir);
        tan2[a2].add(tdir);
        tan2[b2].add(tdir);
        tan2[c2].add(tdir);
      }
      let groups = this.groups;
      if (groups.length === 0) {
        groups = [{
          start: 0,
          count: indices.length
        }];
      }
      for (let i2 = 0, il = groups.length; i2 < il; ++i2) {
        const group = groups[i2];
        const start = group.start;
        const count = group.count;
        for (let j2 = start, jl = start + count; j2 < jl; j2 += 3) {
          handleTriangle(indices[j2 + 0], indices[j2 + 1], indices[j2 + 2]);
        }
      }
      const tmp2 = new Vector3(), tmp22 = new Vector3();
      const n2 = new Vector3(), n22 = new Vector3();
      function handleVertex(v2) {
        n2.fromArray(normals, v2 * 3);
        n22.copy(n2);
        const t2 = tan1[v2];
        tmp2.copy(t2);
        tmp2.sub(n2.multiplyScalar(n2.dot(t2))).normalize();
        tmp22.crossVectors(n22, t2);
        const test = tmp22.dot(tan2[v2]);
        const w2 = test < 0 ? -1 : 1;
        tangents[v2 * 4] = tmp2.x;
        tangents[v2 * 4 + 1] = tmp2.y;
        tangents[v2 * 4 + 2] = tmp2.z;
        tangents[v2 * 4 + 3] = w2;
      }
      for (let i2 = 0, il = groups.length; i2 < il; ++i2) {
        const group = groups[i2];
        const start = group.start;
        const count = group.count;
        for (let j2 = start, jl = start + count; j2 < jl; j2 += 3) {
          handleVertex(indices[j2 + 0]);
          handleVertex(indices[j2 + 1]);
          handleVertex(indices[j2 + 2]);
        }
      }
    }
    computeVertexNormals() {
      const index = this.index;
      const positionAttribute = this.getAttribute("position");
      if (positionAttribute !== void 0) {
        let normalAttribute = this.getAttribute("normal");
        if (normalAttribute === void 0) {
          normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
          this.setAttribute("normal", normalAttribute);
        } else {
          for (let i2 = 0, il = normalAttribute.count; i2 < il; i2++) {
            normalAttribute.setXYZ(i2, 0, 0, 0);
          }
        }
        const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
        const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
        const cb = new Vector3(), ab = new Vector3();
        if (index) {
          for (let i2 = 0, il = index.count; i2 < il; i2 += 3) {
            const vA = index.getX(i2 + 0);
            const vB = index.getX(i2 + 1);
            const vC = index.getX(i2 + 2);
            pA.fromBufferAttribute(positionAttribute, vA);
            pB.fromBufferAttribute(positionAttribute, vB);
            pC.fromBufferAttribute(positionAttribute, vC);
            cb.subVectors(pC, pB);
            ab.subVectors(pA, pB);
            cb.cross(ab);
            nA.fromBufferAttribute(normalAttribute, vA);
            nB.fromBufferAttribute(normalAttribute, vB);
            nC.fromBufferAttribute(normalAttribute, vC);
            nA.add(cb);
            nB.add(cb);
            nC.add(cb);
            normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
            normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
            normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
          }
        } else {
          for (let i2 = 0, il = positionAttribute.count; i2 < il; i2 += 3) {
            pA.fromBufferAttribute(positionAttribute, i2 + 0);
            pB.fromBufferAttribute(positionAttribute, i2 + 1);
            pC.fromBufferAttribute(positionAttribute, i2 + 2);
            cb.subVectors(pC, pB);
            ab.subVectors(pA, pB);
            cb.cross(ab);
            normalAttribute.setXYZ(i2 + 0, cb.x, cb.y, cb.z);
            normalAttribute.setXYZ(i2 + 1, cb.x, cb.y, cb.z);
            normalAttribute.setXYZ(i2 + 2, cb.x, cb.y, cb.z);
          }
        }
        this.normalizeNormals();
        normalAttribute.needsUpdate = true;
      }
    }
    merge(geometry, offset) {
      if (!(geometry && geometry.isBufferGeometry)) {
        console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
        return;
      }
      if (offset === void 0) {
        offset = 0;
        console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
      }
      const attributes = this.attributes;
      for (const key in attributes) {
        if (geometry.attributes[key] === void 0)
          continue;
        const attribute1 = attributes[key];
        const attributeArray1 = attribute1.array;
        const attribute2 = geometry.attributes[key];
        const attributeArray2 = attribute2.array;
        const attributeOffset = attribute2.itemSize * offset;
        const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
        for (let i2 = 0, j2 = attributeOffset; i2 < length; i2++, j2++) {
          attributeArray1[j2] = attributeArray2[i2];
        }
      }
      return this;
    }
    normalizeNormals() {
      const normals = this.attributes.normal;
      for (let i2 = 0, il = normals.count; i2 < il; i2++) {
        _vector$8.fromBufferAttribute(normals, i2);
        _vector$8.normalize();
        normals.setXYZ(i2, _vector$8.x, _vector$8.y, _vector$8.z);
      }
    }
    toNonIndexed() {
      function convertBufferAttribute(attribute, indices2) {
        const array = attribute.array;
        const itemSize = attribute.itemSize;
        const normalized = attribute.normalized;
        const array2 = new array.constructor(indices2.length * itemSize);
        let index = 0, index2 = 0;
        for (let i2 = 0, l2 = indices2.length; i2 < l2; i2++) {
          if (attribute.isInterleavedBufferAttribute) {
            index = indices2[i2] * attribute.data.stride + attribute.offset;
          } else {
            index = indices2[i2] * itemSize;
          }
          for (let j2 = 0; j2 < itemSize; j2++) {
            array2[index2++] = array[index++];
          }
        }
        return new BufferAttribute(array2, itemSize, normalized);
      }
      if (this.index === null) {
        console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
        return this;
      }
      const geometry2 = new BufferGeometry();
      const indices = this.index.array;
      const attributes = this.attributes;
      for (const name in attributes) {
        const attribute = attributes[name];
        const newAttribute = convertBufferAttribute(attribute, indices);
        geometry2.setAttribute(name, newAttribute);
      }
      const morphAttributes = this.morphAttributes;
      for (const name in morphAttributes) {
        const morphArray = [];
        const morphAttribute = morphAttributes[name];
        for (let i2 = 0, il = morphAttribute.length; i2 < il; i2++) {
          const attribute = morphAttribute[i2];
          const newAttribute = convertBufferAttribute(attribute, indices);
          morphArray.push(newAttribute);
        }
        geometry2.morphAttributes[name] = morphArray;
      }
      geometry2.morphTargetsRelative = this.morphTargetsRelative;
      const groups = this.groups;
      for (let i2 = 0, l2 = groups.length; i2 < l2; i2++) {
        const group = groups[i2];
        geometry2.addGroup(group.start, group.count, group.materialIndex);
      }
      return geometry2;
    }
    toJSON() {
      const data = {
        metadata: {
          version: 4.5,
          type: "BufferGeometry",
          generator: "BufferGeometry.toJSON"
        }
      };
      data.uuid = this.uuid;
      data.type = this.type;
      if (this.name !== "")
        data.name = this.name;
      if (Object.keys(this.userData).length > 0)
        data.userData = this.userData;
      if (this.parameters !== void 0) {
        const parameters = this.parameters;
        for (const key in parameters) {
          if (parameters[key] !== void 0)
            data[key] = parameters[key];
        }
        return data;
      }
      data.data = { attributes: {} };
      const index = this.index;
      if (index !== null) {
        data.data.index = {
          type: index.array.constructor.name,
          array: Array.prototype.slice.call(index.array)
        };
      }
      const attributes = this.attributes;
      for (const key in attributes) {
        const attribute = attributes[key];
        data.data.attributes[key] = attribute.toJSON(data.data);
      }
      const morphAttributes = {};
      let hasMorphAttributes = false;
      for (const key in this.morphAttributes) {
        const attributeArray = this.morphAttributes[key];
        const array = [];
        for (let i2 = 0, il = attributeArray.length; i2 < il; i2++) {
          const attribute = attributeArray[i2];
          array.push(attribute.toJSON(data.data));
        }
        if (array.length > 0) {
          morphAttributes[key] = array;
          hasMorphAttributes = true;
        }
      }
      if (hasMorphAttributes) {
        data.data.morphAttributes = morphAttributes;
        data.data.morphTargetsRelative = this.morphTargetsRelative;
      }
      const groups = this.groups;
      if (groups.length > 0) {
        data.data.groups = JSON.parse(JSON.stringify(groups));
      }
      const boundingSphere = this.boundingSphere;
      if (boundingSphere !== null) {
        data.data.boundingSphere = {
          center: boundingSphere.center.toArray(),
          radius: boundingSphere.radius
        };
      }
      return data;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(source) {
      this.index = null;
      this.attributes = {};
      this.morphAttributes = {};
      this.groups = [];
      this.boundingBox = null;
      this.boundingSphere = null;
      const data = {};
      this.name = source.name;
      const index = source.index;
      if (index !== null) {
        this.setIndex(index.clone(data));
      }
      const attributes = source.attributes;
      for (const name in attributes) {
        const attribute = attributes[name];
        this.setAttribute(name, attribute.clone(data));
      }
      const morphAttributes = source.morphAttributes;
      for (const name in morphAttributes) {
        const array = [];
        const morphAttribute = morphAttributes[name];
        for (let i2 = 0, l2 = morphAttribute.length; i2 < l2; i2++) {
          array.push(morphAttribute[i2].clone(data));
        }
        this.morphAttributes[name] = array;
      }
      this.morphTargetsRelative = source.morphTargetsRelative;
      const groups = source.groups;
      for (let i2 = 0, l2 = groups.length; i2 < l2; i2++) {
        const group = groups[i2];
        this.addGroup(group.start, group.count, group.materialIndex);
      }
      const boundingBox = source.boundingBox;
      if (boundingBox !== null) {
        this.boundingBox = boundingBox.clone();
      }
      const boundingSphere = source.boundingSphere;
      if (boundingSphere !== null) {
        this.boundingSphere = boundingSphere.clone();
      }
      this.drawRange.start = source.drawRange.start;
      this.drawRange.count = source.drawRange.count;
      this.userData = source.userData;
      if (source.parameters !== void 0)
        this.parameters = Object.assign({}, source.parameters);
      return this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  };
  BufferGeometry.prototype.isBufferGeometry = true;
  var _inverseMatrix$2 = /* @__PURE__ */ new Matrix4();
  var _ray$2 = /* @__PURE__ */ new Ray();
  var _sphere$3 = /* @__PURE__ */ new Sphere();
  var _vA$1 = /* @__PURE__ */ new Vector3();
  var _vB$1 = /* @__PURE__ */ new Vector3();
  var _vC$1 = /* @__PURE__ */ new Vector3();
  var _tempA = /* @__PURE__ */ new Vector3();
  var _tempB = /* @__PURE__ */ new Vector3();
  var _tempC = /* @__PURE__ */ new Vector3();
  var _morphA = /* @__PURE__ */ new Vector3();
  var _morphB = /* @__PURE__ */ new Vector3();
  var _morphC = /* @__PURE__ */ new Vector3();
  var _uvA$1 = /* @__PURE__ */ new Vector2();
  var _uvB$1 = /* @__PURE__ */ new Vector2();
  var _uvC$1 = /* @__PURE__ */ new Vector2();
  var _intersectionPoint = /* @__PURE__ */ new Vector3();
  var _intersectionPointWorld = /* @__PURE__ */ new Vector3();
  var Mesh = class extends Object3D {
    constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
      super();
      this.type = "Mesh";
      this.geometry = geometry;
      this.material = material;
      this.updateMorphTargets();
    }
    copy(source) {
      super.copy(source);
      if (source.morphTargetInfluences !== void 0) {
        this.morphTargetInfluences = source.morphTargetInfluences.slice();
      }
      if (source.morphTargetDictionary !== void 0) {
        this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
      }
      this.material = source.material;
      this.geometry = source.geometry;
      return this;
    }
    updateMorphTargets() {
      const geometry = this.geometry;
      if (geometry.isBufferGeometry) {
        const morphAttributes = geometry.morphAttributes;
        const keys = Object.keys(morphAttributes);
        if (keys.length > 0) {
          const morphAttribute = morphAttributes[keys[0]];
          if (morphAttribute !== void 0) {
            this.morphTargetInfluences = [];
            this.morphTargetDictionary = {};
            for (let m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
              const name = morphAttribute[m2].name || String(m2);
              this.morphTargetInfluences.push(0);
              this.morphTargetDictionary[name] = m2;
            }
          }
        }
      } else {
        const morphTargets = geometry.morphTargets;
        if (morphTargets !== void 0 && morphTargets.length > 0) {
          console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
      }
    }
    raycast(raycaster, intersects2) {
      const geometry = this.geometry;
      const material = this.material;
      const matrixWorld = this.matrixWorld;
      if (material === void 0)
        return;
      if (geometry.boundingSphere === null)
        geometry.computeBoundingSphere();
      _sphere$3.copy(geometry.boundingSphere);
      _sphere$3.applyMatrix4(matrixWorld);
      if (raycaster.ray.intersectsSphere(_sphere$3) === false)
        return;
      _inverseMatrix$2.copy(matrixWorld).invert();
      _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
      if (geometry.boundingBox !== null) {
        if (_ray$2.intersectsBox(geometry.boundingBox) === false)
          return;
      }
      let intersection;
      if (geometry.isBufferGeometry) {
        const index = geometry.index;
        const position = geometry.attributes.position;
        const morphPosition = geometry.morphAttributes.position;
        const morphTargetsRelative = geometry.morphTargetsRelative;
        const uv = geometry.attributes.uv;
        const uv2 = geometry.attributes.uv2;
        const groups = geometry.groups;
        const drawRange = geometry.drawRange;
        if (index !== null) {
          if (Array.isArray(material)) {
            for (let i2 = 0, il = groups.length; i2 < il; i2++) {
              const group = groups[i2];
              const groupMaterial = material[group.materialIndex];
              const start = Math.max(group.start, drawRange.start);
              const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
              for (let j2 = start, jl = end; j2 < jl; j2 += 3) {
                const a2 = index.getX(j2);
                const b2 = index.getX(j2 + 1);
                const c2 = index.getX(j2 + 2);
                intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2);
                if (intersection) {
                  intersection.faceIndex = Math.floor(j2 / 3);
                  intersection.face.materialIndex = group.materialIndex;
                  intersects2.push(intersection);
                }
              }
            }
          } else {
            const start = Math.max(0, drawRange.start);
            const end = Math.min(index.count, drawRange.start + drawRange.count);
            for (let i2 = start, il = end; i2 < il; i2 += 3) {
              const a2 = index.getX(i2);
              const b2 = index.getX(i2 + 1);
              const c2 = index.getX(i2 + 2);
              intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2);
              if (intersection) {
                intersection.faceIndex = Math.floor(i2 / 3);
                intersects2.push(intersection);
              }
            }
          }
        } else if (position !== void 0) {
          if (Array.isArray(material)) {
            for (let i2 = 0, il = groups.length; i2 < il; i2++) {
              const group = groups[i2];
              const groupMaterial = material[group.materialIndex];
              const start = Math.max(group.start, drawRange.start);
              const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
              for (let j2 = start, jl = end; j2 < jl; j2 += 3) {
                const a2 = j2;
                const b2 = j2 + 1;
                const c2 = j2 + 2;
                intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2);
                if (intersection) {
                  intersection.faceIndex = Math.floor(j2 / 3);
                  intersection.face.materialIndex = group.materialIndex;
                  intersects2.push(intersection);
                }
              }
            }
          } else {
            const start = Math.max(0, drawRange.start);
            const end = Math.min(position.count, drawRange.start + drawRange.count);
            for (let i2 = start, il = end; i2 < il; i2 += 3) {
              const a2 = i2;
              const b2 = i2 + 1;
              const c2 = i2 + 2;
              intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2);
              if (intersection) {
                intersection.faceIndex = Math.floor(i2 / 3);
                intersects2.push(intersection);
              }
            }
          }
        }
      } else if (geometry.isGeometry) {
        console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  };
  Mesh.prototype.isMesh = true;
  function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
    let intersect;
    if (material.side === BackSide) {
      intersect = ray.intersectTriangle(pC, pB, pA, true, point);
    } else {
      intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
    }
    if (intersect === null)
      return null;
    _intersectionPointWorld.copy(point);
    _intersectionPointWorld.applyMatrix4(object.matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
    if (distance < raycaster.near || distance > raycaster.far)
      return null;
    return {
      distance,
      point: _intersectionPointWorld.clone(),
      object
    };
  }
  function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a2, b2, c2) {
    _vA$1.fromBufferAttribute(position, a2);
    _vB$1.fromBufferAttribute(position, b2);
    _vC$1.fromBufferAttribute(position, c2);
    const morphInfluences = object.morphTargetInfluences;
    if (morphPosition && morphInfluences) {
      _morphA.set(0, 0, 0);
      _morphB.set(0, 0, 0);
      _morphC.set(0, 0, 0);
      for (let i2 = 0, il = morphPosition.length; i2 < il; i2++) {
        const influence = morphInfluences[i2];
        const morphAttribute = morphPosition[i2];
        if (influence === 0)
          continue;
        _tempA.fromBufferAttribute(morphAttribute, a2);
        _tempB.fromBufferAttribute(morphAttribute, b2);
        _tempC.fromBufferAttribute(morphAttribute, c2);
        if (morphTargetsRelative) {
          _morphA.addScaledVector(_tempA, influence);
          _morphB.addScaledVector(_tempB, influence);
          _morphC.addScaledVector(_tempC, influence);
        } else {
          _morphA.addScaledVector(_tempA.sub(_vA$1), influence);
          _morphB.addScaledVector(_tempB.sub(_vB$1), influence);
          _morphC.addScaledVector(_tempC.sub(_vC$1), influence);
        }
      }
      _vA$1.add(_morphA);
      _vB$1.add(_morphB);
      _vC$1.add(_morphC);
    }
    if (object.isSkinnedMesh) {
      object.boneTransform(a2, _vA$1);
      object.boneTransform(b2, _vB$1);
      object.boneTransform(c2, _vC$1);
    }
    const intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
    if (intersection) {
      if (uv) {
        _uvA$1.fromBufferAttribute(uv, a2);
        _uvB$1.fromBufferAttribute(uv, b2);
        _uvC$1.fromBufferAttribute(uv, c2);
        intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
      }
      if (uv2) {
        _uvA$1.fromBufferAttribute(uv2, a2);
        _uvB$1.fromBufferAttribute(uv2, b2);
        _uvC$1.fromBufferAttribute(uv2, c2);
        intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
      }
      const face = {
        a: a2,
        b: b2,
        c: c2,
        normal: new Vector3(),
        materialIndex: 0
      };
      Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
      intersection.face = face;
    }
    return intersection;
  }
  var BoxGeometry = class extends BufferGeometry {
    constructor(width2 = 1, height2 = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
      super();
      this.type = "BoxGeometry";
      this.parameters = {
        width: width2,
        height: height2,
        depth,
        widthSegments,
        heightSegments,
        depthSegments
      };
      const scope = this;
      widthSegments = Math.floor(widthSegments);
      heightSegments = Math.floor(heightSegments);
      depthSegments = Math.floor(depthSegments);
      const indices = [];
      const vertices = [];
      const normals = [];
      const uvs = [];
      let numberOfVertices = 0;
      let groupStart = 0;
      buildPlane("z", "y", "x", -1, -1, depth, height2, width2, depthSegments, heightSegments, 0);
      buildPlane("z", "y", "x", 1, -1, depth, height2, -width2, depthSegments, heightSegments, 1);
      buildPlane("x", "z", "y", 1, 1, width2, depth, height2, widthSegments, depthSegments, 2);
      buildPlane("x", "z", "y", 1, -1, width2, depth, -height2, widthSegments, depthSegments, 3);
      buildPlane("x", "y", "z", 1, -1, width2, height2, depth, widthSegments, heightSegments, 4);
      buildPlane("x", "y", "z", -1, -1, width2, height2, -depth, widthSegments, heightSegments, 5);
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
      function buildPlane(u2, v2, w2, udir, vdir, width3, height3, depth2, gridX, gridY, materialIndex) {
        const segmentWidth = width3 / gridX;
        const segmentHeight = height3 / gridY;
        const widthHalf = width3 / 2;
        const heightHalf = height3 / 2;
        const depthHalf = depth2 / 2;
        const gridX1 = gridX + 1;
        const gridY1 = gridY + 1;
        let vertexCounter = 0;
        let groupCount = 0;
        const vector = new Vector3();
        for (let iy = 0; iy < gridY1; iy++) {
          const y2 = iy * segmentHeight - heightHalf;
          for (let ix = 0; ix < gridX1; ix++) {
            const x2 = ix * segmentWidth - widthHalf;
            vector[u2] = x2 * udir;
            vector[v2] = y2 * vdir;
            vector[w2] = depthHalf;
            vertices.push(vector.x, vector.y, vector.z);
            vector[u2] = 0;
            vector[v2] = 0;
            vector[w2] = depth2 > 0 ? 1 : -1;
            normals.push(vector.x, vector.y, vector.z);
            uvs.push(ix / gridX);
            uvs.push(1 - iy / gridY);
            vertexCounter += 1;
          }
        }
        for (let iy = 0; iy < gridY; iy++) {
          for (let ix = 0; ix < gridX; ix++) {
            const a2 = numberOfVertices + ix + gridX1 * iy;
            const b2 = numberOfVertices + ix + gridX1 * (iy + 1);
            const c2 = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
            const d2 = numberOfVertices + (ix + 1) + gridX1 * iy;
            indices.push(a2, b2, d2);
            indices.push(b2, c2, d2);
            groupCount += 6;
          }
        }
        scope.addGroup(groupStart, groupCount, materialIndex);
        groupStart += groupCount;
        numberOfVertices += vertexCounter;
      }
    }
    static fromJSON(data) {
      return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
    }
  };
  function cloneUniforms(src) {
    const dst = {};
    for (const u2 in src) {
      dst[u2] = {};
      for (const p2 in src[u2]) {
        const property = src[u2][p2];
        if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
          dst[u2][p2] = property.clone();
        } else if (Array.isArray(property)) {
          dst[u2][p2] = property.slice();
        } else {
          dst[u2][p2] = property;
        }
      }
    }
    return dst;
  }
  function mergeUniforms(uniforms) {
    const merged = {};
    for (let u2 = 0; u2 < uniforms.length; u2++) {
      const tmp2 = cloneUniforms(uniforms[u2]);
      for (const p2 in tmp2) {
        merged[p2] = tmp2[p2];
      }
    }
    return merged;
  }
  var UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
  var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
  var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
  var ShaderMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.type = "ShaderMaterial";
      this.defines = {};
      this.uniforms = {};
      this.vertexShader = default_vertex;
      this.fragmentShader = default_fragment;
      this.linewidth = 1;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.fog = false;
      this.lights = false;
      this.clipping = false;
      this.extensions = {
        derivatives: false,
        fragDepth: false,
        drawBuffers: false,
        shaderTextureLOD: false
      };
      this.defaultAttributeValues = {
        "color": [1, 1, 1],
        "uv": [0, 0],
        "uv2": [0, 0]
      };
      this.index0AttributeName = void 0;
      this.uniformsNeedUpdate = false;
      this.glslVersion = null;
      if (parameters !== void 0) {
        if (parameters.attributes !== void 0) {
          console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
        }
        this.setValues(parameters);
      }
    }
    copy(source) {
      super.copy(source);
      this.fragmentShader = source.fragmentShader;
      this.vertexShader = source.vertexShader;
      this.uniforms = cloneUniforms(source.uniforms);
      this.defines = Object.assign({}, source.defines);
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.lights = source.lights;
      this.clipping = source.clipping;
      this.extensions = Object.assign({}, source.extensions);
      this.glslVersion = source.glslVersion;
      return this;
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      data.glslVersion = this.glslVersion;
      data.uniforms = {};
      for (const name in this.uniforms) {
        const uniform = this.uniforms[name];
        const value = uniform.value;
        if (value && value.isTexture) {
          data.uniforms[name] = {
            type: "t",
            value: value.toJSON(meta).uuid
          };
        } else if (value && value.isColor) {
          data.uniforms[name] = {
            type: "c",
            value: value.getHex()
          };
        } else if (value && value.isVector2) {
          data.uniforms[name] = {
            type: "v2",
            value: value.toArray()
          };
        } else if (value && value.isVector3) {
          data.uniforms[name] = {
            type: "v3",
            value: value.toArray()
          };
        } else if (value && value.isVector4) {
          data.uniforms[name] = {
            type: "v4",
            value: value.toArray()
          };
        } else if (value && value.isMatrix3) {
          data.uniforms[name] = {
            type: "m3",
            value: value.toArray()
          };
        } else if (value && value.isMatrix4) {
          data.uniforms[name] = {
            type: "m4",
            value: value.toArray()
          };
        } else {
          data.uniforms[name] = {
            value
          };
        }
      }
      if (Object.keys(this.defines).length > 0)
        data.defines = this.defines;
      data.vertexShader = this.vertexShader;
      data.fragmentShader = this.fragmentShader;
      const extensions = {};
      for (const key in this.extensions) {
        if (this.extensions[key] === true)
          extensions[key] = true;
      }
      if (Object.keys(extensions).length > 0)
        data.extensions = extensions;
      return data;
    }
  };
  ShaderMaterial.prototype.isShaderMaterial = true;
  var Camera = class extends Object3D {
    constructor() {
      super();
      this.type = "Camera";
      this.matrixWorldInverse = new Matrix4();
      this.projectionMatrix = new Matrix4();
      this.projectionMatrixInverse = new Matrix4();
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      this.matrixWorldInverse.copy(source.matrixWorldInverse);
      this.projectionMatrix.copy(source.projectionMatrix);
      this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
      return this;
    }
    getWorldDirection(target) {
      this.updateWorldMatrix(true, false);
      const e2 = this.matrixWorld.elements;
      return target.set(-e2[8], -e2[9], -e2[10]).normalize();
    }
    updateMatrixWorld(force) {
      super.updateMatrixWorld(force);
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(updateParents, updateChildren) {
      super.updateWorldMatrix(updateParents, updateChildren);
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  Camera.prototype.isCamera = true;
  var PerspectiveCamera = class extends Camera {
    constructor(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
      super();
      this.type = "PerspectiveCamera";
      this.fov = fov2;
      this.zoom = 1;
      this.near = near;
      this.far = far;
      this.focus = 10;
      this.aspect = aspect2;
      this.view = null;
      this.filmGauge = 35;
      this.filmOffset = 0;
      this.updateProjectionMatrix();
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      this.fov = source.fov;
      this.zoom = source.zoom;
      this.near = source.near;
      this.far = source.far;
      this.focus = source.focus;
      this.aspect = source.aspect;
      this.view = source.view === null ? null : Object.assign({}, source.view);
      this.filmGauge = source.filmGauge;
      this.filmOffset = source.filmOffset;
      return this;
    }
    setFocalLength(focalLength) {
      const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
      this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
      this.updateProjectionMatrix();
    }
    getFocalLength() {
      const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
      return 0.5 * this.getFilmHeight() / vExtentSlope;
    }
    getEffectiveFOV() {
      return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);
    }
    getFilmWidth() {
      return this.filmGauge * Math.min(this.aspect, 1);
    }
    getFilmHeight() {
      return this.filmGauge / Math.max(this.aspect, 1);
    }
    setViewOffset(fullWidth, fullHeight, x2, y2, width2, height2) {
      this.aspect = fullWidth / fullHeight;
      if (this.view === null) {
        this.view = {
          enabled: true,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        };
      }
      this.view.enabled = true;
      this.view.fullWidth = fullWidth;
      this.view.fullHeight = fullHeight;
      this.view.offsetX = x2;
      this.view.offsetY = y2;
      this.view.width = width2;
      this.view.height = height2;
      this.updateProjectionMatrix();
    }
    clearViewOffset() {
      if (this.view !== null) {
        this.view.enabled = false;
      }
      this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const near = this.near;
      let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
      let height2 = 2 * top;
      let width2 = this.aspect * height2;
      let left = -0.5 * width2;
      const view = this.view;
      if (this.view !== null && this.view.enabled) {
        const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
        left += view.offsetX * width2 / fullWidth;
        top -= view.offsetY * height2 / fullHeight;
        width2 *= view.width / fullWidth;
        height2 *= view.height / fullHeight;
      }
      const skew = this.filmOffset;
      if (skew !== 0)
        left += near * skew / this.getFilmWidth();
      this.projectionMatrix.makePerspective(left, left + width2, top, top - height2, near, this.far);
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      data.object.fov = this.fov;
      data.object.zoom = this.zoom;
      data.object.near = this.near;
      data.object.far = this.far;
      data.object.focus = this.focus;
      data.object.aspect = this.aspect;
      if (this.view !== null)
        data.object.view = Object.assign({}, this.view);
      data.object.filmGauge = this.filmGauge;
      data.object.filmOffset = this.filmOffset;
      return data;
    }
  };
  PerspectiveCamera.prototype.isPerspectiveCamera = true;
  var fov = 90;
  var aspect = 1;
  var CubeCamera = class extends Object3D {
    constructor(near, far, renderTarget) {
      super();
      this.type = "CubeCamera";
      if (renderTarget.isWebGLCubeRenderTarget !== true) {
        console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
        return;
      }
      this.renderTarget = renderTarget;
      const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
      cameraPX.layers = this.layers;
      cameraPX.up.set(0, -1, 0);
      cameraPX.lookAt(new Vector3(1, 0, 0));
      this.add(cameraPX);
      const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
      cameraNX.layers = this.layers;
      cameraNX.up.set(0, -1, 0);
      cameraNX.lookAt(new Vector3(-1, 0, 0));
      this.add(cameraNX);
      const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
      cameraPY.layers = this.layers;
      cameraPY.up.set(0, 0, 1);
      cameraPY.lookAt(new Vector3(0, 1, 0));
      this.add(cameraPY);
      const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
      cameraNY.layers = this.layers;
      cameraNY.up.set(0, 0, -1);
      cameraNY.lookAt(new Vector3(0, -1, 0));
      this.add(cameraNY);
      const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
      cameraPZ.layers = this.layers;
      cameraPZ.up.set(0, -1, 0);
      cameraPZ.lookAt(new Vector3(0, 0, 1));
      this.add(cameraPZ);
      const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
      cameraNZ.layers = this.layers;
      cameraNZ.up.set(0, -1, 0);
      cameraNZ.lookAt(new Vector3(0, 0, -1));
      this.add(cameraNZ);
    }
    update(renderer2, scene2) {
      if (this.parent === null)
        this.updateMatrixWorld();
      const renderTarget = this.renderTarget;
      const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
      const currentXrEnabled = renderer2.xr.enabled;
      const currentRenderTarget = renderer2.getRenderTarget();
      renderer2.xr.enabled = false;
      const generateMipmaps = renderTarget.texture.generateMipmaps;
      renderTarget.texture.generateMipmaps = false;
      renderer2.setRenderTarget(renderTarget, 0);
      renderer2.render(scene2, cameraPX);
      renderer2.setRenderTarget(renderTarget, 1);
      renderer2.render(scene2, cameraNX);
      renderer2.setRenderTarget(renderTarget, 2);
      renderer2.render(scene2, cameraPY);
      renderer2.setRenderTarget(renderTarget, 3);
      renderer2.render(scene2, cameraNY);
      renderer2.setRenderTarget(renderTarget, 4);
      renderer2.render(scene2, cameraPZ);
      renderTarget.texture.generateMipmaps = generateMipmaps;
      renderer2.setRenderTarget(renderTarget, 5);
      renderer2.render(scene2, cameraNZ);
      renderer2.setRenderTarget(currentRenderTarget);
      renderer2.xr.enabled = currentXrEnabled;
    }
  };
  var CubeTexture = class extends Texture {
    constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
      images = images !== void 0 ? images : [];
      mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
      super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
      this.flipY = false;
    }
    get images() {
      return this.image;
    }
    set images(value) {
      this.image = value;
    }
  };
  CubeTexture.prototype.isCubeTexture = true;
  var WebGLCubeRenderTarget = class extends WebGLRenderTarget {
    constructor(size, options, dummy) {
      if (Number.isInteger(options)) {
        console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )");
        options = dummy;
      }
      super(size, size, options);
      options = options || {};
      this.texture = new CubeTexture(void 0, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
      this.texture.isRenderTargetTexture = true;
      this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
      this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
      this.texture._needsFlipEnvMap = false;
    }
    fromEquirectangularTexture(renderer2, texture) {
      this.texture.type = texture.type;
      this.texture.format = RGBAFormat;
      this.texture.encoding = texture.encoding;
      this.texture.generateMipmaps = texture.generateMipmaps;
      this.texture.minFilter = texture.minFilter;
      this.texture.magFilter = texture.magFilter;
      const shader = {
        uniforms: {
          tEquirect: { value: null }
        },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      };
      const geometry = new BoxGeometry(5, 5, 5);
      const material = new ShaderMaterial({
        name: "CubemapFromEquirect",
        uniforms: cloneUniforms(shader.uniforms),
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader,
        side: BackSide,
        blending: NoBlending
      });
      material.uniforms.tEquirect.value = texture;
      const mesh = new Mesh(geometry, material);
      const currentMinFilter = texture.minFilter;
      if (texture.minFilter === LinearMipmapLinearFilter)
        texture.minFilter = LinearFilter;
      const camera2 = new CubeCamera(1, 10, this);
      camera2.update(renderer2, mesh);
      texture.minFilter = currentMinFilter;
      mesh.geometry.dispose();
      mesh.material.dispose();
      return this;
    }
    clear(renderer2, color, depth, stencil) {
      const currentRenderTarget = renderer2.getRenderTarget();
      for (let i2 = 0; i2 < 6; i2++) {
        renderer2.setRenderTarget(this, i2);
        renderer2.clear(color, depth, stencil);
      }
      renderer2.setRenderTarget(currentRenderTarget);
    }
  };
  WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;
  var _vector1 = /* @__PURE__ */ new Vector3();
  var _vector2 = /* @__PURE__ */ new Vector3();
  var _normalMatrix = /* @__PURE__ */ new Matrix3();
  var Plane = class {
    constructor(normal = new Vector3(1, 0, 0), constant = 0) {
      this.normal = normal;
      this.constant = constant;
    }
    set(normal, constant) {
      this.normal.copy(normal);
      this.constant = constant;
      return this;
    }
    setComponents(x2, y2, z2, w2) {
      this.normal.set(x2, y2, z2);
      this.constant = w2;
      return this;
    }
    setFromNormalAndCoplanarPoint(normal, point) {
      this.normal.copy(normal);
      this.constant = -point.dot(this.normal);
      return this;
    }
    setFromCoplanarPoints(a2, b2, c2) {
      const normal = _vector1.subVectors(c2, b2).cross(_vector2.subVectors(a2, b2)).normalize();
      this.setFromNormalAndCoplanarPoint(normal, a2);
      return this;
    }
    copy(plane) {
      this.normal.copy(plane.normal);
      this.constant = plane.constant;
      return this;
    }
    normalize() {
      const inverseNormalLength = 1 / this.normal.length();
      this.normal.multiplyScalar(inverseNormalLength);
      this.constant *= inverseNormalLength;
      return this;
    }
    negate() {
      this.constant *= -1;
      this.normal.negate();
      return this;
    }
    distanceToPoint(point) {
      return this.normal.dot(point) + this.constant;
    }
    distanceToSphere(sphere) {
      return this.distanceToPoint(sphere.center) - sphere.radius;
    }
    projectPoint(point, target) {
      return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
    }
    intersectLine(line, target) {
      const direction = line.delta(_vector1);
      const denominator = this.normal.dot(direction);
      if (denominator === 0) {
        if (this.distanceToPoint(line.start) === 0) {
          return target.copy(line.start);
        }
        return null;
      }
      const t2 = -(line.start.dot(this.normal) + this.constant) / denominator;
      if (t2 < 0 || t2 > 1) {
        return null;
      }
      return target.copy(direction).multiplyScalar(t2).add(line.start);
    }
    intersectsLine(line) {
      const startSign = this.distanceToPoint(line.start);
      const endSign = this.distanceToPoint(line.end);
      return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
    }
    intersectsBox(box) {
      return box.intersectsPlane(this);
    }
    intersectsSphere(sphere) {
      return sphere.intersectsPlane(this);
    }
    coplanarPoint(target) {
      return target.copy(this.normal).multiplyScalar(-this.constant);
    }
    applyMatrix4(matrix, optionalNormalMatrix) {
      const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
      const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
      const normal = this.normal.applyMatrix3(normalMatrix).normalize();
      this.constant = -referencePoint.dot(normal);
      return this;
    }
    translate(offset) {
      this.constant -= offset.dot(this.normal);
      return this;
    }
    equals(plane) {
      return plane.normal.equals(this.normal) && plane.constant === this.constant;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  Plane.prototype.isPlane = true;
  var _sphere$2 = /* @__PURE__ */ new Sphere();
  var _vector$7 = /* @__PURE__ */ new Vector3();
  var Frustum = class {
    constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
      this.planes = [p0, p1, p2, p3, p4, p5];
    }
    set(p0, p1, p2, p3, p4, p5) {
      const planes = this.planes;
      planes[0].copy(p0);
      planes[1].copy(p1);
      planes[2].copy(p2);
      planes[3].copy(p3);
      planes[4].copy(p4);
      planes[5].copy(p5);
      return this;
    }
    copy(frustum) {
      const planes = this.planes;
      for (let i2 = 0; i2 < 6; i2++) {
        planes[i2].copy(frustum.planes[i2]);
      }
      return this;
    }
    setFromProjectionMatrix(m2) {
      const planes = this.planes;
      const me2 = m2.elements;
      const me0 = me2[0], me1 = me2[1], me22 = me2[2], me3 = me2[3];
      const me4 = me2[4], me5 = me2[5], me6 = me2[6], me7 = me2[7];
      const me8 = me2[8], me9 = me2[9], me10 = me2[10], me11 = me2[11];
      const me12 = me2[12], me13 = me2[13], me14 = me2[14], me15 = me2[15];
      planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
      planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
      planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
      planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
      planes[4].setComponents(me3 - me22, me7 - me6, me11 - me10, me15 - me14).normalize();
      planes[5].setComponents(me3 + me22, me7 + me6, me11 + me10, me15 + me14).normalize();
      return this;
    }
    intersectsObject(object) {
      const geometry = object.geometry;
      if (geometry.boundingSphere === null)
        geometry.computeBoundingSphere();
      _sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
      return this.intersectsSphere(_sphere$2);
    }
    intersectsSprite(sprite) {
      _sphere$2.center.set(0, 0, 0);
      _sphere$2.radius = 0.7071067811865476;
      _sphere$2.applyMatrix4(sprite.matrixWorld);
      return this.intersectsSphere(_sphere$2);
    }
    intersectsSphere(sphere) {
      const planes = this.planes;
      const center = sphere.center;
      const negRadius = -sphere.radius;
      for (let i2 = 0; i2 < 6; i2++) {
        const distance = planes[i2].distanceToPoint(center);
        if (distance < negRadius) {
          return false;
        }
      }
      return true;
    }
    intersectsBox(box) {
      const planes = this.planes;
      for (let i2 = 0; i2 < 6; i2++) {
        const plane = planes[i2];
        _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
        _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
        _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
        if (plane.distanceToPoint(_vector$7) < 0) {
          return false;
        }
      }
      return true;
    }
    containsPoint(point) {
      const planes = this.planes;
      for (let i2 = 0; i2 < 6; i2++) {
        if (planes[i2].distanceToPoint(point) < 0) {
          return false;
        }
      }
      return true;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  function WebGLAnimation() {
    let context = null;
    let isAnimating = false;
    let animationLoop = null;
    let requestId = null;
    function onAnimationFrame(time, frame) {
      animationLoop(time, frame);
      requestId = context.requestAnimationFrame(onAnimationFrame);
    }
    return {
      start: function() {
        if (isAnimating === true)
          return;
        if (animationLoop === null)
          return;
        requestId = context.requestAnimationFrame(onAnimationFrame);
        isAnimating = true;
      },
      stop: function() {
        context.cancelAnimationFrame(requestId);
        isAnimating = false;
      },
      setAnimationLoop: function(callback) {
        animationLoop = callback;
      },
      setContext: function(value) {
        context = value;
      }
    };
  }
  function WebGLAttributes(gl, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    const buffers = new WeakMap();
    function createBuffer(attribute, bufferType) {
      const array = attribute.array;
      const usage = attribute.usage;
      const buffer = gl.createBuffer();
      gl.bindBuffer(bufferType, buffer);
      gl.bufferData(bufferType, array, usage);
      attribute.onUploadCallback();
      let type = 5126;
      if (array instanceof Float32Array) {
        type = 5126;
      } else if (array instanceof Float64Array) {
        console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.");
      } else if (array instanceof Uint16Array) {
        if (attribute.isFloat16BufferAttribute) {
          if (isWebGL2) {
            type = 5131;
          } else {
            console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
          }
        } else {
          type = 5123;
        }
      } else if (array instanceof Int16Array) {
        type = 5122;
      } else if (array instanceof Uint32Array) {
        type = 5125;
      } else if (array instanceof Int32Array) {
        type = 5124;
      } else if (array instanceof Int8Array) {
        type = 5120;
      } else if (array instanceof Uint8Array) {
        type = 5121;
      } else if (array instanceof Uint8ClampedArray) {
        type = 5121;
      }
      return {
        buffer,
        type,
        bytesPerElement: array.BYTES_PER_ELEMENT,
        version: attribute.version
      };
    }
    function updateBuffer(buffer, attribute, bufferType) {
      const array = attribute.array;
      const updateRange = attribute.updateRange;
      gl.bindBuffer(bufferType, buffer);
      if (updateRange.count === -1) {
        gl.bufferSubData(bufferType, 0, array);
      } else {
        if (isWebGL2) {
          gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
        } else {
          gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
        }
        updateRange.count = -1;
      }
    }
    function get(attribute) {
      if (attribute.isInterleavedBufferAttribute)
        attribute = attribute.data;
      return buffers.get(attribute);
    }
    function remove(attribute) {
      if (attribute.isInterleavedBufferAttribute)
        attribute = attribute.data;
      const data = buffers.get(attribute);
      if (data) {
        gl.deleteBuffer(data.buffer);
        buffers.delete(attribute);
      }
    }
    function update2(attribute, bufferType) {
      if (attribute.isGLBufferAttribute) {
        const cached = buffers.get(attribute);
        if (!cached || cached.version < attribute.version) {
          buffers.set(attribute, {
            buffer: attribute.buffer,
            type: attribute.type,
            bytesPerElement: attribute.elementSize,
            version: attribute.version
          });
        }
        return;
      }
      if (attribute.isInterleavedBufferAttribute)
        attribute = attribute.data;
      const data = buffers.get(attribute);
      if (data === void 0) {
        buffers.set(attribute, createBuffer(attribute, bufferType));
      } else if (data.version < attribute.version) {
        updateBuffer(data.buffer, attribute, bufferType);
        data.version = attribute.version;
      }
    }
    return {
      get,
      remove,
      update: update2
    };
  }
  var PlaneGeometry = class extends BufferGeometry {
    constructor(width2 = 1, height2 = 1, widthSegments = 1, heightSegments = 1) {
      super();
      this.type = "PlaneGeometry";
      this.parameters = {
        width: width2,
        height: height2,
        widthSegments,
        heightSegments
      };
      const width_half = width2 / 2;
      const height_half = height2 / 2;
      const gridX = Math.floor(widthSegments);
      const gridY = Math.floor(heightSegments);
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      const segment_width = width2 / gridX;
      const segment_height = height2 / gridY;
      const indices = [];
      const vertices = [];
      const normals = [];
      const uvs = [];
      for (let iy = 0; iy < gridY1; iy++) {
        const y2 = iy * segment_height - height_half;
        for (let ix = 0; ix < gridX1; ix++) {
          const x2 = ix * segment_width - width_half;
          vertices.push(x2, -y2, 0);
          normals.push(0, 0, 1);
          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);
        }
      }
      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a2 = ix + gridX1 * iy;
          const b2 = ix + gridX1 * (iy + 1);
          const c2 = ix + 1 + gridX1 * (iy + 1);
          const d2 = ix + 1 + gridX1 * iy;
          indices.push(a2, b2, d2);
          indices.push(b2, c2, d2);
        }
      }
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    static fromJSON(data) {
      return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
    }
  };
  var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
  var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
  var alphatest_fragment = "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif";
  var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif";
  var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif";
  var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
  var begin_vertex = "vec3 transformed = vec3( position );";
  var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
  var bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenTint, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenTint * ( D * V );\n}\n#endif";
  var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
  var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif";
  var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
  var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
  var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
  var color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
  var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
  var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif";
  var color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif";
  var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}";
  var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_maxMipLevel 8.0\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_maxTileSize 256.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n		vec2 f = fract( uv );\n		uv += 0.5 - f;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		if ( mipInt < cubeUV_maxMipLevel ) {\n			uv.y += 2.0 * cubeUV_maxTileSize;\n		}\n		uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n		uv *= texelSize;\n		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x += texelSize;\n		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.y += texelSize;\n		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		uv.x -= texelSize;\n		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n		vec3 tm = mix( tl, tr, f.x );\n		vec3 bm = mix( bl, br, f.x );\n		return mix( tm, bm, f.y );\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
  var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
  var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
  var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
  var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
  var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
  var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
  var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract( Le );\n	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n	return vec4( max( vRGB, 0.0 ), 1.0 );\n}";
  var envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n		envColor = envMapTexelToLinear( envColor );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
  var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
  var envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
  var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
  var envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
  var fog_vertex = "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif";
  var fog_pars_vertex = "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif";
  var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
  var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
  var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return texture2D( gradientMap, coord ).rgb;\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}";
  var lightmap_fragment = "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n	vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		lightMapIrradiance *= PI;\n	#endif\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";
  var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
  var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointLightInfo( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotLightInfo( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif";
  var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#else\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif";
  var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n	#ifdef ENVMAP_MODE_REFRACTION\n		uniform float refractionRatio;\n	#endif\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 reflectVec;\n			#ifdef ENVMAP_MODE_REFLECTION\n				reflectVec = reflect( - viewDir, normal );\n				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			#else\n				reflectVec = refract( - viewDir, normal, refractionRatio );\n			#endif\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n#endif";
  var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
  var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)";
  var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
  var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)";
  var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	#ifdef SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularTintFactor = specularTint;\n		#ifdef USE_SPECULARINTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n		#endif\n		#ifdef USE_SPECULARTINTMAP\n			specularTintFactor *= specularTintMapTexelToLinear( texture2D( specularTintMap, vUv ) ).rgb;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularTintFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularTintFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenTint = sheenTint;\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n#endif";
  var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenTint;\n		float sheenRoughness;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		reflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenTint, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
  var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
  var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry.normal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif";
  var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
  var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
  var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
  var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
  var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif";
  var map_fragment = "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif";
  var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
  var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
  var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
  var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
  var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
  var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif";
  var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform vec2 morphTargetsTextureSize;\n		vec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n			float texelIndex = float( vertexIndex * stride + offset );\n			float y = floor( texelIndex / morphTargetsTextureSize.x );\n			float x = texelIndex - y * morphTargetsTextureSize.x;\n			vec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n			return texture( morphTargetsTexture, morphUV ).xyz;\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif";
  var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			#ifndef USE_MORPHNORMALS\n				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n			#else\n				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n			#endif\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif";
  var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;";
  var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
  var normal_pars_fragment = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
  var normal_pars_vertex = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
  var normal_vertex = "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif";
  var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif";
  var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif";
  var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif";
  var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif";
  var output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
  var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
  var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
  var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
  var dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
  var dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
  var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
  var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
  var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
  var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
  var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif";
  var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
  var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
  var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif";
  var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
  var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
  var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
  var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
  var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
  var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
  var transmission_fragment = "#ifdef USE_TRANSMISSION\n	float transmissionAlpha = 1.0;\n	float transmissionFactor = transmission;\n	float thicknessFactor = thickness;\n	#ifdef USE_TRANSMISSIONMAP\n		transmissionFactor *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		thicknessFactor *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmission = getIBLVolumeRefraction(\n		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n		attenuationTint, attenuationDistance );\n	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif";
  var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationTint;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( float roughness, float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		#ifdef TEXTURE_LOD_EXT\n			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#else\n			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#endif\n	}\n	vec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n		if ( attenuationDistance == 0.0 ) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n		vec3 attenuationColor, float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n	}\n#endif";
  var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif";
  var uv_pars_vertex = "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif";
  var uv_vertex = "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
  var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
  var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif";
  var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
  var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
  var vertex$g = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
  var fragment$g = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
  var vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
  var fragment$f = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
  var vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
  var fragment$e = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
  var vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
  var fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
  var vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
  var fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
  var vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
  var fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
  var vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
  var fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel= texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var vertex$9 = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
  var fragment$9 = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
  var fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
  var fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
  var vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
  var fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}";
  var fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularTint;\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n	#ifdef USE_SPECULARTINTMAP\n		uniform sampler2D specularTintMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenTint;\n	uniform float sheenRoughness;\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
  var fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
  var fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
  var vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
  var fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
  var vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
  var fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
  var ShaderChunk = {
    alphamap_fragment,
    alphamap_pars_fragment,
    alphatest_fragment,
    alphatest_pars_fragment,
    aomap_fragment,
    aomap_pars_fragment,
    begin_vertex,
    beginnormal_vertex,
    bsdfs,
    bumpmap_pars_fragment,
    clipping_planes_fragment,
    clipping_planes_pars_fragment,
    clipping_planes_pars_vertex,
    clipping_planes_vertex,
    color_fragment,
    color_pars_fragment,
    color_pars_vertex,
    color_vertex,
    common,
    cube_uv_reflection_fragment,
    defaultnormal_vertex,
    displacementmap_pars_vertex,
    displacementmap_vertex,
    emissivemap_fragment,
    emissivemap_pars_fragment,
    encodings_fragment,
    encodings_pars_fragment,
    envmap_fragment,
    envmap_common_pars_fragment,
    envmap_pars_fragment,
    envmap_pars_vertex,
    envmap_physical_pars_fragment,
    envmap_vertex,
    fog_vertex,
    fog_pars_vertex,
    fog_fragment,
    fog_pars_fragment,
    gradientmap_pars_fragment,
    lightmap_fragment,
    lightmap_pars_fragment,
    lights_lambert_vertex,
    lights_pars_begin,
    lights_toon_fragment,
    lights_toon_pars_fragment,
    lights_phong_fragment,
    lights_phong_pars_fragment,
    lights_physical_fragment,
    lights_physical_pars_fragment,
    lights_fragment_begin,
    lights_fragment_maps,
    lights_fragment_end,
    logdepthbuf_fragment,
    logdepthbuf_pars_fragment,
    logdepthbuf_pars_vertex,
    logdepthbuf_vertex,
    map_fragment,
    map_pars_fragment,
    map_particle_fragment,
    map_particle_pars_fragment,
    metalnessmap_fragment,
    metalnessmap_pars_fragment,
    morphnormal_vertex,
    morphtarget_pars_vertex,
    morphtarget_vertex,
    normal_fragment_begin,
    normal_fragment_maps,
    normal_pars_fragment,
    normal_pars_vertex,
    normal_vertex,
    normalmap_pars_fragment,
    clearcoat_normal_fragment_begin,
    clearcoat_normal_fragment_maps,
    clearcoat_pars_fragment,
    output_fragment,
    packing,
    premultiplied_alpha_fragment,
    project_vertex,
    dithering_fragment,
    dithering_pars_fragment,
    roughnessmap_fragment,
    roughnessmap_pars_fragment,
    shadowmap_pars_fragment,
    shadowmap_pars_vertex,
    shadowmap_vertex,
    shadowmask_pars_fragment,
    skinbase_vertex,
    skinning_pars_vertex,
    skinning_vertex,
    skinnormal_vertex,
    specularmap_fragment,
    specularmap_pars_fragment,
    tonemapping_fragment,
    tonemapping_pars_fragment,
    transmission_fragment,
    transmission_pars_fragment,
    uv_pars_fragment,
    uv_pars_vertex,
    uv_vertex,
    uv2_pars_fragment,
    uv2_pars_vertex,
    uv2_vertex,
    worldpos_vertex,
    background_vert: vertex$g,
    background_frag: fragment$g,
    cube_vert: vertex$f,
    cube_frag: fragment$f,
    depth_vert: vertex$e,
    depth_frag: fragment$e,
    distanceRGBA_vert: vertex$d,
    distanceRGBA_frag: fragment$d,
    equirect_vert: vertex$c,
    equirect_frag: fragment$c,
    linedashed_vert: vertex$b,
    linedashed_frag: fragment$b,
    meshbasic_vert: vertex$a,
    meshbasic_frag: fragment$a,
    meshlambert_vert: vertex$9,
    meshlambert_frag: fragment$9,
    meshmatcap_vert: vertex$8,
    meshmatcap_frag: fragment$8,
    meshnormal_vert: vertex$7,
    meshnormal_frag: fragment$7,
    meshphong_vert: vertex$6,
    meshphong_frag: fragment$6,
    meshphysical_vert: vertex$5,
    meshphysical_frag: fragment$5,
    meshtoon_vert: vertex$4,
    meshtoon_frag: fragment$4,
    points_vert: vertex$3,
    points_frag: fragment$3,
    shadow_vert: vertex$2,
    shadow_frag: fragment$2,
    sprite_vert: vertex$1,
    sprite_frag: fragment$1
  };
  var UniformsLib = {
    common: {
      diffuse: { value: new Color(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      uvTransform: { value: new Matrix3() },
      uv2Transform: { value: new Matrix3() },
      alphaMap: { value: null },
      alphaTest: { value: 0 }
    },
    specularmap: {
      specularMap: { value: null }
    },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
      maxMipLevel: { value: 0 }
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 }
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 }
    },
    emissivemap: {
      emissiveMap: { value: null }
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpScale: { value: 1 }
    },
    normalmap: {
      normalMap: { value: null },
      normalScale: { value: new Vector2(1, 1) }
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 }
    },
    roughnessmap: {
      roughnessMap: { value: null }
    },
    metalnessmap: {
      metalnessMap: { value: null }
    },
    gradientmap: {
      gradientMap: { value: null }
    },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new Color(16777215) }
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: { value: [], properties: {
        direction: {},
        color: {}
      } },
      directionalLightShadows: { value: [], properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      } },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: { value: [], properties: {
        color: {},
        position: {},
        direction: {},
        distance: {},
        coneCos: {},
        penumbraCos: {},
        decay: {}
      } },
      spotLightShadows: { value: [], properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      } },
      spotShadowMap: { value: [] },
      spotShadowMatrix: { value: [] },
      pointLights: { value: [], properties: {
        color: {},
        position: {},
        decay: {},
        distance: {}
      } },
      pointLightShadows: { value: [], properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {},
        shadowCameraNear: {},
        shadowCameraFar: {}
      } },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: { value: [], properties: {
        direction: {},
        skyColor: {},
        groundColor: {}
      } },
      rectAreaLights: { value: [], properties: {
        color: {},
        position: {},
        width: {},
        height: {}
      } },
      ltc_1: { value: null },
      ltc_2: { value: null }
    },
    points: {
      diffuse: { value: new Color(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
      uvTransform: { value: new Matrix3() }
    },
    sprite: {
      diffuse: { value: new Color(16777215) },
      opacity: { value: 1 },
      center: { value: new Vector2(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
      uvTransform: { value: new Matrix3() }
    }
  };
  var ShaderLib = {
    basic: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.fog
      ]),
      vertexShader: ShaderChunk.meshbasic_vert,
      fragmentShader: ShaderChunk.meshbasic_frag
    },
    lambert: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: new Color(0) }
        }
      ]),
      vertexShader: ShaderChunk.meshlambert_vert,
      fragmentShader: ShaderChunk.meshlambert_frag
    },
    phong: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: new Color(0) },
          specular: { value: new Color(1118481) },
          shininess: { value: 30 }
        }
      ]),
      vertexShader: ShaderChunk.meshphong_vert,
      fragmentShader: ShaderChunk.meshphong_frag
    },
    standard: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.roughnessmap,
        UniformsLib.metalnessmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: new Color(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 }
        }
      ]),
      vertexShader: ShaderChunk.meshphysical_vert,
      fragmentShader: ShaderChunk.meshphysical_frag
    },
    toon: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.gradientmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: new Color(0) }
        }
      ]),
      vertexShader: ShaderChunk.meshtoon_vert,
      fragmentShader: ShaderChunk.meshtoon_frag
    },
    matcap: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.fog,
        {
          matcap: { value: null }
        }
      ]),
      vertexShader: ShaderChunk.meshmatcap_vert,
      fragmentShader: ShaderChunk.meshmatcap_frag
    },
    points: {
      uniforms: mergeUniforms([
        UniformsLib.points,
        UniformsLib.fog
      ]),
      vertexShader: ShaderChunk.points_vert,
      fragmentShader: ShaderChunk.points_frag
    },
    dashed: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 }
        }
      ]),
      vertexShader: ShaderChunk.linedashed_vert,
      fragmentShader: ShaderChunk.linedashed_frag
    },
    depth: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.displacementmap
      ]),
      vertexShader: ShaderChunk.depth_vert,
      fragmentShader: ShaderChunk.depth_frag
    },
    normal: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        {
          opacity: { value: 1 }
        }
      ]),
      vertexShader: ShaderChunk.meshnormal_vert,
      fragmentShader: ShaderChunk.meshnormal_frag
    },
    sprite: {
      uniforms: mergeUniforms([
        UniformsLib.sprite,
        UniformsLib.fog
      ]),
      vertexShader: ShaderChunk.sprite_vert,
      fragmentShader: ShaderChunk.sprite_frag
    },
    background: {
      uniforms: {
        uvTransform: { value: new Matrix3() },
        t2D: { value: null }
      },
      vertexShader: ShaderChunk.background_vert,
      fragmentShader: ShaderChunk.background_frag
    },
    cube: {
      uniforms: mergeUniforms([
        UniformsLib.envmap,
        {
          opacity: { value: 1 }
        }
      ]),
      vertexShader: ShaderChunk.cube_vert,
      fragmentShader: ShaderChunk.cube_frag
    },
    equirect: {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: ShaderChunk.equirect_vert,
      fragmentShader: ShaderChunk.equirect_frag
    },
    distanceRGBA: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.displacementmap,
        {
          referencePosition: { value: new Vector3() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 }
        }
      ]),
      vertexShader: ShaderChunk.distanceRGBA_vert,
      fragmentShader: ShaderChunk.distanceRGBA_frag
    },
    shadow: {
      uniforms: mergeUniforms([
        UniformsLib.lights,
        UniformsLib.fog,
        {
          color: { value: new Color(0) },
          opacity: { value: 1 }
        }
      ]),
      vertexShader: ShaderChunk.shadow_vert,
      fragmentShader: ShaderChunk.shadow_frag
    }
  };
  ShaderLib.physical = {
    uniforms: mergeUniforms([
      ShaderLib.standard.uniforms,
      {
        clearcoat: { value: 0 },
        clearcoatMap: { value: null },
        clearcoatRoughness: { value: 0 },
        clearcoatRoughnessMap: { value: null },
        clearcoatNormalScale: { value: new Vector2(1, 1) },
        clearcoatNormalMap: { value: null },
        sheen: { value: 0 },
        sheenTint: { value: new Color(0) },
        sheenRoughness: { value: 0 },
        transmission: { value: 0 },
        transmissionMap: { value: null },
        transmissionSamplerSize: { value: new Vector2() },
        transmissionSamplerMap: { value: null },
        thickness: { value: 0 },
        thicknessMap: { value: null },
        attenuationDistance: { value: 0 },
        attenuationTint: { value: new Color(0) },
        specularIntensity: { value: 0 },
        specularIntensityMap: { value: null },
        specularTint: { value: new Color(1, 1, 1) },
        specularTintMap: { value: null }
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  };
  function WebGLBackground(renderer2, cubemaps, state2, objects, premultipliedAlpha) {
    const clearColor = new Color(0);
    let clearAlpha = 0;
    let planeMesh;
    let boxMesh;
    let currentBackground = null;
    let currentBackgroundVersion = 0;
    let currentTonemapping = null;
    function render(renderList, scene2) {
      let forceClear = false;
      let background = scene2.isScene === true ? scene2.background : null;
      if (background && background.isTexture) {
        background = cubemaps.get(background);
      }
      const xr = renderer2.xr;
      const session = xr.getSession && xr.getSession();
      if (session && session.environmentBlendMode === "additive") {
        background = null;
      }
      if (background === null) {
        setClear(clearColor, clearAlpha);
      } else if (background && background.isColor) {
        setClear(background, 1);
        forceClear = true;
      }
      if (renderer2.autoClear || forceClear) {
        renderer2.clear(renderer2.autoClearColor, renderer2.autoClearDepth, renderer2.autoClearStencil);
      }
      if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
        if (boxMesh === void 0) {
          boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
            name: "BackgroundCubeMaterial",
            uniforms: cloneUniforms(ShaderLib.cube.uniforms),
            vertexShader: ShaderLib.cube.vertexShader,
            fragmentShader: ShaderLib.cube.fragmentShader,
            side: BackSide,
            depthTest: false,
            depthWrite: false,
            fog: false
          }));
          boxMesh.geometry.deleteAttribute("normal");
          boxMesh.geometry.deleteAttribute("uv");
          boxMesh.onBeforeRender = function(renderer3, scene3, camera2) {
            this.matrixWorld.copyPosition(camera2.matrixWorld);
          };
          Object.defineProperty(boxMesh.material, "envMap", {
            get: function() {
              return this.uniforms.envMap.value;
            }
          });
          objects.update(boxMesh);
        }
        boxMesh.material.uniforms.envMap.value = background;
        boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
        if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer2.toneMapping) {
          boxMesh.material.needsUpdate = true;
          currentBackground = background;
          currentBackgroundVersion = background.version;
          currentTonemapping = renderer2.toneMapping;
        }
        renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
      } else if (background && background.isTexture) {
        if (planeMesh === void 0) {
          planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
            name: "BackgroundMaterial",
            uniforms: cloneUniforms(ShaderLib.background.uniforms),
            vertexShader: ShaderLib.background.vertexShader,
            fragmentShader: ShaderLib.background.fragmentShader,
            side: FrontSide,
            depthTest: false,
            depthWrite: false,
            fog: false
          }));
          planeMesh.geometry.deleteAttribute("normal");
          Object.defineProperty(planeMesh.material, "map", {
            get: function() {
              return this.uniforms.t2D.value;
            }
          });
          objects.update(planeMesh);
        }
        planeMesh.material.uniforms.t2D.value = background;
        if (background.matrixAutoUpdate === true) {
          background.updateMatrix();
        }
        planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
        if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer2.toneMapping) {
          planeMesh.material.needsUpdate = true;
          currentBackground = background;
          currentBackgroundVersion = background.version;
          currentTonemapping = renderer2.toneMapping;
        }
        renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
      }
    }
    function setClear(color, alpha) {
      state2.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
    }
    return {
      getClearColor: function() {
        return clearColor;
      },
      setClearColor: function(color, alpha = 1) {
        clearColor.set(color);
        clearAlpha = alpha;
        setClear(clearColor, clearAlpha);
      },
      getClearAlpha: function() {
        return clearAlpha;
      },
      setClearAlpha: function(alpha) {
        clearAlpha = alpha;
        setClear(clearColor, clearAlpha);
      },
      render
    };
  }
  function WebGLBindingStates(gl, extensions, attributes, capabilities) {
    const maxVertexAttributes = gl.getParameter(34921);
    const extension = capabilities.isWebGL2 ? null : extensions.get("OES_vertex_array_object");
    const vaoAvailable = capabilities.isWebGL2 || extension !== null;
    const bindingStates = {};
    const defaultState = createBindingState(null);
    let currentState = defaultState;
    function setup(object, material, program, geometry, index) {
      let updateBuffers = false;
      if (vaoAvailable) {
        const state2 = getBindingState(geometry, program, material);
        if (currentState !== state2) {
          currentState = state2;
          bindVertexArrayObject(currentState.object);
        }
        updateBuffers = needsUpdate(geometry, index);
        if (updateBuffers)
          saveCache(geometry, index);
      } else {
        const wireframe = material.wireframe === true;
        if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
          currentState.geometry = geometry.id;
          currentState.program = program.id;
          currentState.wireframe = wireframe;
          updateBuffers = true;
        }
      }
      if (object.isInstancedMesh === true) {
        updateBuffers = true;
      }
      if (index !== null) {
        attributes.update(index, 34963);
      }
      if (updateBuffers) {
        setupVertexAttributes(object, material, program, geometry);
        if (index !== null) {
          gl.bindBuffer(34963, attributes.get(index).buffer);
        }
      }
    }
    function createVertexArrayObject() {
      if (capabilities.isWebGL2)
        return gl.createVertexArray();
      return extension.createVertexArrayOES();
    }
    function bindVertexArrayObject(vao) {
      if (capabilities.isWebGL2)
        return gl.bindVertexArray(vao);
      return extension.bindVertexArrayOES(vao);
    }
    function deleteVertexArrayObject(vao) {
      if (capabilities.isWebGL2)
        return gl.deleteVertexArray(vao);
      return extension.deleteVertexArrayOES(vao);
    }
    function getBindingState(geometry, program, material) {
      const wireframe = material.wireframe === true;
      let programMap = bindingStates[geometry.id];
      if (programMap === void 0) {
        programMap = {};
        bindingStates[geometry.id] = programMap;
      }
      let stateMap = programMap[program.id];
      if (stateMap === void 0) {
        stateMap = {};
        programMap[program.id] = stateMap;
      }
      let state2 = stateMap[wireframe];
      if (state2 === void 0) {
        state2 = createBindingState(createVertexArrayObject());
        stateMap[wireframe] = state2;
      }
      return state2;
    }
    function createBindingState(vao) {
      const newAttributes = [];
      const enabledAttributes = [];
      const attributeDivisors = [];
      for (let i2 = 0; i2 < maxVertexAttributes; i2++) {
        newAttributes[i2] = 0;
        enabledAttributes[i2] = 0;
        attributeDivisors[i2] = 0;
      }
      return {
        geometry: null,
        program: null,
        wireframe: false,
        newAttributes,
        enabledAttributes,
        attributeDivisors,
        object: vao,
        attributes: {},
        index: null
      };
    }
    function needsUpdate(geometry, index) {
      const cachedAttributes = currentState.attributes;
      const geometryAttributes = geometry.attributes;
      let attributesNum = 0;
      for (const key in geometryAttributes) {
        const cachedAttribute = cachedAttributes[key];
        const geometryAttribute = geometryAttributes[key];
        if (cachedAttribute === void 0)
          return true;
        if (cachedAttribute.attribute !== geometryAttribute)
          return true;
        if (cachedAttribute.data !== geometryAttribute.data)
          return true;
        attributesNum++;
      }
      if (currentState.attributesNum !== attributesNum)
        return true;
      if (currentState.index !== index)
        return true;
      return false;
    }
    function saveCache(geometry, index) {
      const cache = {};
      const attributes2 = geometry.attributes;
      let attributesNum = 0;
      for (const key in attributes2) {
        const attribute = attributes2[key];
        const data = {};
        data.attribute = attribute;
        if (attribute.data) {
          data.data = attribute.data;
        }
        cache[key] = data;
        attributesNum++;
      }
      currentState.attributes = cache;
      currentState.attributesNum = attributesNum;
      currentState.index = index;
    }
    function initAttributes() {
      const newAttributes = currentState.newAttributes;
      for (let i2 = 0, il = newAttributes.length; i2 < il; i2++) {
        newAttributes[i2] = 0;
      }
    }
    function enableAttribute(attribute) {
      enableAttributeAndDivisor(attribute, 0);
    }
    function enableAttributeAndDivisor(attribute, meshPerAttribute) {
      const newAttributes = currentState.newAttributes;
      const enabledAttributes = currentState.enabledAttributes;
      const attributeDivisors = currentState.attributeDivisors;
      newAttributes[attribute] = 1;
      if (enabledAttributes[attribute] === 0) {
        gl.enableVertexAttribArray(attribute);
        enabledAttributes[attribute] = 1;
      }
      if (attributeDivisors[attribute] !== meshPerAttribute) {
        const extension2 = capabilities.isWebGL2 ? gl : extensions.get("ANGLE_instanced_arrays");
        extension2[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
        attributeDivisors[attribute] = meshPerAttribute;
      }
    }
    function disableUnusedAttributes() {
      const newAttributes = currentState.newAttributes;
      const enabledAttributes = currentState.enabledAttributes;
      for (let i2 = 0, il = enabledAttributes.length; i2 < il; i2++) {
        if (enabledAttributes[i2] !== newAttributes[i2]) {
          gl.disableVertexAttribArray(i2);
          enabledAttributes[i2] = 0;
        }
      }
    }
    function vertexAttribPointer(index, size, type, normalized, stride, offset) {
      if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) {
        gl.vertexAttribIPointer(index, size, type, stride, offset);
      } else {
        gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
      }
    }
    function setupVertexAttributes(object, material, program, geometry) {
      if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
        if (extensions.get("ANGLE_instanced_arrays") === null)
          return;
      }
      initAttributes();
      const geometryAttributes = geometry.attributes;
      const programAttributes = program.getAttributes();
      const materialDefaultAttributeValues = material.defaultAttributeValues;
      for (const name in programAttributes) {
        const programAttribute = programAttributes[name];
        if (programAttribute.location >= 0) {
          let geometryAttribute = geometryAttributes[name];
          if (geometryAttribute === void 0) {
            if (name === "instanceMatrix" && object.instanceMatrix)
              geometryAttribute = object.instanceMatrix;
            if (name === "instanceColor" && object.instanceColor)
              geometryAttribute = object.instanceColor;
          }
          if (geometryAttribute !== void 0) {
            const normalized = geometryAttribute.normalized;
            const size = geometryAttribute.itemSize;
            const attribute = attributes.get(geometryAttribute);
            if (attribute === void 0)
              continue;
            const buffer = attribute.buffer;
            const type = attribute.type;
            const bytesPerElement = attribute.bytesPerElement;
            if (geometryAttribute.isInterleavedBufferAttribute) {
              const data = geometryAttribute.data;
              const stride = data.stride;
              const offset = geometryAttribute.offset;
              if (data && data.isInstancedInterleavedBuffer) {
                for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                  enableAttributeAndDivisor(programAttribute.location + i2, data.meshPerAttribute);
                }
                if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                  geometry._maxInstanceCount = data.meshPerAttribute * data.count;
                }
              } else {
                for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                  enableAttribute(programAttribute.location + i2);
                }
              }
              gl.bindBuffer(34962, buffer);
              for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                vertexAttribPointer(programAttribute.location + i2, size / programAttribute.locationSize, type, normalized, stride * bytesPerElement, (offset + size / programAttribute.locationSize * i2) * bytesPerElement);
              }
            } else {
              if (geometryAttribute.isInstancedBufferAttribute) {
                for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                  enableAttributeAndDivisor(programAttribute.location + i2, geometryAttribute.meshPerAttribute);
                }
                if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                  geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                }
              } else {
                for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                  enableAttribute(programAttribute.location + i2);
                }
              }
              gl.bindBuffer(34962, buffer);
              for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                vertexAttribPointer(programAttribute.location + i2, size / programAttribute.locationSize, type, normalized, size * bytesPerElement, size / programAttribute.locationSize * i2 * bytesPerElement);
              }
            }
          } else if (materialDefaultAttributeValues !== void 0) {
            const value = materialDefaultAttributeValues[name];
            if (value !== void 0) {
              switch (value.length) {
                case 2:
                  gl.vertexAttrib2fv(programAttribute.location, value);
                  break;
                case 3:
                  gl.vertexAttrib3fv(programAttribute.location, value);
                  break;
                case 4:
                  gl.vertexAttrib4fv(programAttribute.location, value);
                  break;
                default:
                  gl.vertexAttrib1fv(programAttribute.location, value);
              }
            }
          }
        }
      }
      disableUnusedAttributes();
    }
    function dispose() {
      reset();
      for (const geometryId in bindingStates) {
        const programMap = bindingStates[geometryId];
        for (const programId in programMap) {
          const stateMap = programMap[programId];
          for (const wireframe in stateMap) {
            deleteVertexArrayObject(stateMap[wireframe].object);
            delete stateMap[wireframe];
          }
          delete programMap[programId];
        }
        delete bindingStates[geometryId];
      }
    }
    function releaseStatesOfGeometry(geometry) {
      if (bindingStates[geometry.id] === void 0)
        return;
      const programMap = bindingStates[geometry.id];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometry.id];
    }
    function releaseStatesOfProgram(program) {
      for (const geometryId in bindingStates) {
        const programMap = bindingStates[geometryId];
        if (programMap[program.id] === void 0)
          continue;
        const stateMap = programMap[program.id];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[program.id];
      }
    }
    function reset() {
      resetDefaultState();
      if (currentState === defaultState)
        return;
      currentState = defaultState;
      bindVertexArrayObject(currentState.object);
    }
    function resetDefaultState() {
      defaultState.geometry = null;
      defaultState.program = null;
      defaultState.wireframe = false;
    }
    return {
      setup,
      reset,
      resetDefaultState,
      dispose,
      releaseStatesOfGeometry,
      releaseStatesOfProgram,
      initAttributes,
      enableAttribute,
      disableUnusedAttributes
    };
  }
  function WebGLBufferRenderer(gl, extensions, info, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    let mode;
    function setMode(value) {
      mode = value;
    }
    function render(start, count) {
      gl.drawArrays(mode, start, count);
      info.update(count, mode, 1);
    }
    function renderInstances(start, count, primcount) {
      if (primcount === 0)
        return;
      let extension, methodName;
      if (isWebGL2) {
        extension = gl;
        methodName = "drawArraysInstanced";
      } else {
        extension = extensions.get("ANGLE_instanced_arrays");
        methodName = "drawArraysInstancedANGLE";
        if (extension === null) {
          console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
          return;
        }
      }
      extension[methodName](mode, start, count, primcount);
      info.update(count, mode, primcount);
    }
    this.setMode = setMode;
    this.render = render;
    this.renderInstances = renderInstances;
  }
  function WebGLCapabilities(gl, extensions, parameters) {
    let maxAnisotropy;
    function getMaxAnisotropy() {
      if (maxAnisotropy !== void 0)
        return maxAnisotropy;
      if (extensions.has("EXT_texture_filter_anisotropic") === true) {
        const extension = extensions.get("EXT_texture_filter_anisotropic");
        maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      } else {
        maxAnisotropy = 0;
      }
      return maxAnisotropy;
    }
    function getMaxPrecision(precision2) {
      if (precision2 === "highp") {
        if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
          return "highp";
        }
        precision2 = "mediump";
      }
      if (precision2 === "mediump") {
        if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
          return "mediump";
        }
      }
      return "lowp";
    }
    const isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== "undefined" && gl instanceof WebGL2ComputeRenderingContext;
    let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
    const maxPrecision = getMaxPrecision(precision);
    if (maxPrecision !== precision) {
      console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
      precision = maxPrecision;
    }
    const drawBuffers = isWebGL2 || extensions.has("WEBGL_draw_buffers");
    const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
    const maxTextures = gl.getParameter(34930);
    const maxVertexTextures = gl.getParameter(35660);
    const maxTextureSize = gl.getParameter(3379);
    const maxCubemapSize = gl.getParameter(34076);
    const maxAttributes = gl.getParameter(34921);
    const maxVertexUniforms = gl.getParameter(36347);
    const maxVaryings = gl.getParameter(36348);
    const maxFragmentUniforms = gl.getParameter(36349);
    const vertexTextures = maxVertexTextures > 0;
    const floatFragmentTextures = isWebGL2 || extensions.has("OES_texture_float");
    const floatVertexTextures = vertexTextures && floatFragmentTextures;
    const maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
    return {
      isWebGL2,
      drawBuffers,
      getMaxAnisotropy,
      getMaxPrecision,
      precision,
      logarithmicDepthBuffer,
      maxTextures,
      maxVertexTextures,
      maxTextureSize,
      maxCubemapSize,
      maxAttributes,
      maxVertexUniforms,
      maxVaryings,
      maxFragmentUniforms,
      vertexTextures,
      floatFragmentTextures,
      floatVertexTextures,
      maxSamples
    };
  }
  function WebGLClipping(properties) {
    const scope = this;
    let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
    const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = { value: null, needsUpdate: false };
    this.uniform = uniform;
    this.numPlanes = 0;
    this.numIntersection = 0;
    this.init = function(planes, enableLocalClipping, camera2) {
      const enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
      localClippingEnabled = enableLocalClipping;
      globalState = projectPlanes(planes, camera2, 0);
      numGlobalPlanes = planes.length;
      return enabled;
    };
    this.beginShadows = function() {
      renderingShadows = true;
      projectPlanes(null);
    };
    this.endShadows = function() {
      renderingShadows = false;
      resetGlobalState();
    };
    this.setState = function(material, camera2, useCache) {
      const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
      const materialProperties = properties.get(material);
      if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
        if (renderingShadows) {
          projectPlanes(null);
        } else {
          resetGlobalState();
        }
      } else {
        const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
        let dstArray = materialProperties.clippingState || null;
        uniform.value = dstArray;
        dstArray = projectPlanes(planes, camera2, lGlobal, useCache);
        for (let i2 = 0; i2 !== lGlobal; ++i2) {
          dstArray[i2] = globalState[i2];
        }
        materialProperties.clippingState = dstArray;
        this.numIntersection = clipIntersection ? this.numPlanes : 0;
        this.numPlanes += nGlobal;
      }
    };
    function resetGlobalState() {
      if (uniform.value !== globalState) {
        uniform.value = globalState;
        uniform.needsUpdate = numGlobalPlanes > 0;
      }
      scope.numPlanes = numGlobalPlanes;
      scope.numIntersection = 0;
    }
    function projectPlanes(planes, camera2, dstOffset, skipTransform) {
      const nPlanes = planes !== null ? planes.length : 0;
      let dstArray = null;
      if (nPlanes !== 0) {
        dstArray = uniform.value;
        if (skipTransform !== true || dstArray === null) {
          const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera2.matrixWorldInverse;
          viewNormalMatrix.getNormalMatrix(viewMatrix);
          if (dstArray === null || dstArray.length < flatSize) {
            dstArray = new Float32Array(flatSize);
          }
          for (let i2 = 0, i4 = dstOffset; i2 !== nPlanes; ++i2, i4 += 4) {
            plane.copy(planes[i2]).applyMatrix4(viewMatrix, viewNormalMatrix);
            plane.normal.toArray(dstArray, i4);
            dstArray[i4 + 3] = plane.constant;
          }
        }
        uniform.value = dstArray;
        uniform.needsUpdate = true;
      }
      scope.numPlanes = nPlanes;
      scope.numIntersection = 0;
      return dstArray;
    }
  }
  function WebGLCubeMaps(renderer2) {
    let cubemaps = new WeakMap();
    function mapTextureMapping(texture, mapping) {
      if (mapping === EquirectangularReflectionMapping) {
        texture.mapping = CubeReflectionMapping;
      } else if (mapping === EquirectangularRefractionMapping) {
        texture.mapping = CubeRefractionMapping;
      }
      return texture;
    }
    function get(texture) {
      if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
        const mapping = texture.mapping;
        if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
          if (cubemaps.has(texture)) {
            const cubemap = cubemaps.get(texture).texture;
            return mapTextureMapping(cubemap, texture.mapping);
          } else {
            const image = texture.image;
            if (image && image.height > 0) {
              const currentRenderTarget = renderer2.getRenderTarget();
              const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
              renderTarget.fromEquirectangularTexture(renderer2, texture);
              cubemaps.set(texture, renderTarget);
              renderer2.setRenderTarget(currentRenderTarget);
              texture.addEventListener("dispose", onTextureDispose);
              return mapTextureMapping(renderTarget.texture, texture.mapping);
            } else {
              return null;
            }
          }
        }
      }
      return texture;
    }
    function onTextureDispose(event) {
      const texture = event.target;
      texture.removeEventListener("dispose", onTextureDispose);
      const cubemap = cubemaps.get(texture);
      if (cubemap !== void 0) {
        cubemaps.delete(texture);
        cubemap.dispose();
      }
    }
    function dispose() {
      cubemaps = new WeakMap();
    }
    return {
      get,
      dispose
    };
  }
  var OrthographicCamera = class extends Camera {
    constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
      super();
      this.type = "OrthographicCamera";
      this.zoom = 1;
      this.view = null;
      this.left = left;
      this.right = right;
      this.top = top;
      this.bottom = bottom;
      this.near = near;
      this.far = far;
      this.updateProjectionMatrix();
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      this.left = source.left;
      this.right = source.right;
      this.top = source.top;
      this.bottom = source.bottom;
      this.near = source.near;
      this.far = source.far;
      this.zoom = source.zoom;
      this.view = source.view === null ? null : Object.assign({}, source.view);
      return this;
    }
    setViewOffset(fullWidth, fullHeight, x2, y2, width2, height2) {
      if (this.view === null) {
        this.view = {
          enabled: true,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        };
      }
      this.view.enabled = true;
      this.view.fullWidth = fullWidth;
      this.view.fullHeight = fullHeight;
      this.view.offsetX = x2;
      this.view.offsetY = y2;
      this.view.width = width2;
      this.view.height = height2;
      this.updateProjectionMatrix();
    }
    clearViewOffset() {
      if (this.view !== null) {
        this.view.enabled = false;
      }
      this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const dx = (this.right - this.left) / (2 * this.zoom);
      const dy = (this.top - this.bottom) / (2 * this.zoom);
      const cx = (this.right + this.left) / 2;
      const cy = (this.top + this.bottom) / 2;
      let left = cx - dx;
      let right = cx + dx;
      let top = cy + dy;
      let bottom = cy - dy;
      if (this.view !== null && this.view.enabled) {
        const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
        const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        left += scaleW * this.view.offsetX;
        right = left + scaleW * this.view.width;
        top -= scaleH * this.view.offsetY;
        bottom = top - scaleH * this.view.height;
      }
      this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      data.object.zoom = this.zoom;
      data.object.left = this.left;
      data.object.right = this.right;
      data.object.top = this.top;
      data.object.bottom = this.bottom;
      data.object.near = this.near;
      data.object.far = this.far;
      if (this.view !== null)
        data.object.view = Object.assign({}, this.view);
      return data;
    }
  };
  OrthographicCamera.prototype.isOrthographicCamera = true;
  var RawShaderMaterial = class extends ShaderMaterial {
    constructor(parameters) {
      super(parameters);
      this.type = "RawShaderMaterial";
    }
  };
  RawShaderMaterial.prototype.isRawShaderMaterial = true;
  var LOD_MIN = 4;
  var LOD_MAX = 8;
  var SIZE_MAX = Math.pow(2, LOD_MAX);
  var EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
  var TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
  var MAX_SAMPLES = 20;
  var ENCODINGS = {
    [LinearEncoding]: 0,
    [sRGBEncoding]: 1,
    [RGBEEncoding]: 2,
    [RGBM7Encoding]: 3,
    [RGBM16Encoding]: 4,
    [RGBDEncoding]: 5,
    [GammaEncoding]: 6
  };
  var _flatCamera = /* @__PURE__ */ new OrthographicCamera();
  var { _lodPlanes, _sizeLods, _sigmas } = /* @__PURE__ */ _createPlanes();
  var _clearColor = /* @__PURE__ */ new Color();
  var _oldTarget = null;
  var PHI = (1 + Math.sqrt(5)) / 2;
  var INV_PHI = 1 / PHI;
  var _axisDirections = [
    /* @__PURE__ */ new Vector3(1, 1, 1),
    /* @__PURE__ */ new Vector3(-1, 1, 1),
    /* @__PURE__ */ new Vector3(1, 1, -1),
    /* @__PURE__ */ new Vector3(-1, 1, -1),
    /* @__PURE__ */ new Vector3(0, PHI, INV_PHI),
    /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI),
    /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI),
    /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI),
    /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0),
    /* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0)
  ];
  var PMREMGenerator = class {
    constructor(renderer2) {
      this._renderer = renderer2;
      this._pingPongRenderTarget = null;
      this._blurMaterial = _getBlurShader(MAX_SAMPLES);
      this._equirectShader = null;
      this._cubemapShader = null;
      this._compileMaterial(this._blurMaterial);
    }
    fromScene(scene2, sigma = 0, near = 0.1, far = 100) {
      _oldTarget = this._renderer.getRenderTarget();
      const cubeUVRenderTarget = this._allocateTargets();
      this._sceneToCubeUV(scene2, near, far, cubeUVRenderTarget);
      if (sigma > 0) {
        this._blur(cubeUVRenderTarget, 0, 0, sigma);
      }
      this._applyPMREM(cubeUVRenderTarget);
      this._cleanup(cubeUVRenderTarget);
      return cubeUVRenderTarget;
    }
    fromEquirectangular(equirectangular) {
      return this._fromTexture(equirectangular);
    }
    fromCubemap(cubemap) {
      return this._fromTexture(cubemap);
    }
    compileCubemapShader() {
      if (this._cubemapShader === null) {
        this._cubemapShader = _getCubemapShader();
        this._compileMaterial(this._cubemapShader);
      }
    }
    compileEquirectangularShader() {
      if (this._equirectShader === null) {
        this._equirectShader = _getEquirectShader();
        this._compileMaterial(this._equirectShader);
      }
    }
    dispose() {
      this._blurMaterial.dispose();
      if (this._cubemapShader !== null)
        this._cubemapShader.dispose();
      if (this._equirectShader !== null)
        this._equirectShader.dispose();
      for (let i2 = 0; i2 < _lodPlanes.length; i2++) {
        _lodPlanes[i2].dispose();
      }
    }
    _cleanup(outputTarget) {
      this._pingPongRenderTarget.dispose();
      this._renderer.setRenderTarget(_oldTarget);
      outputTarget.scissorTest = false;
      _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
    }
    _fromTexture(texture) {
      _oldTarget = this._renderer.getRenderTarget();
      const cubeUVRenderTarget = this._allocateTargets(texture);
      this._textureToCubeUV(texture, cubeUVRenderTarget);
      this._applyPMREM(cubeUVRenderTarget);
      this._cleanup(cubeUVRenderTarget);
      return cubeUVRenderTarget;
    }
    _allocateTargets(texture) {
      const params = {
        magFilter: NearestFilter,
        minFilter: NearestFilter,
        generateMipmaps: false,
        type: UnsignedByteType,
        format: RGBEFormat,
        encoding: _isLDR(texture) ? texture.encoding : RGBEEncoding,
        depthBuffer: false
      };
      const cubeUVRenderTarget = _createRenderTarget(params);
      cubeUVRenderTarget.depthBuffer = texture ? false : true;
      this._pingPongRenderTarget = _createRenderTarget(params);
      return cubeUVRenderTarget;
    }
    _compileMaterial(material) {
      const tmpMesh = new Mesh(_lodPlanes[0], material);
      this._renderer.compile(tmpMesh, _flatCamera);
    }
    _sceneToCubeUV(scene2, near, far, cubeUVRenderTarget) {
      const fov2 = 90;
      const aspect2 = 1;
      const cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far);
      const upSign = [1, -1, 1, 1, 1, 1];
      const forwardSign = [1, 1, 1, -1, -1, -1];
      const renderer2 = this._renderer;
      const originalAutoClear = renderer2.autoClear;
      const outputEncoding = renderer2.outputEncoding;
      const toneMapping = renderer2.toneMapping;
      renderer2.getClearColor(_clearColor);
      renderer2.toneMapping = NoToneMapping;
      renderer2.outputEncoding = LinearEncoding;
      renderer2.autoClear = false;
      const backgroundMaterial = new MeshBasicMaterial({
        name: "PMREM.Background",
        side: BackSide,
        depthWrite: false,
        depthTest: false
      });
      const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
      let useSolidColor = false;
      const background = scene2.background;
      if (background) {
        if (background.isColor) {
          backgroundMaterial.color.copy(background);
          scene2.background = null;
          useSolidColor = true;
        }
      } else {
        backgroundMaterial.color.copy(_clearColor);
        useSolidColor = true;
      }
      for (let i2 = 0; i2 < 6; i2++) {
        const col = i2 % 3;
        if (col == 0) {
          cubeCamera.up.set(0, upSign[i2], 0);
          cubeCamera.lookAt(forwardSign[i2], 0, 0);
        } else if (col == 1) {
          cubeCamera.up.set(0, 0, upSign[i2]);
          cubeCamera.lookAt(0, forwardSign[i2], 0);
        } else {
          cubeCamera.up.set(0, upSign[i2], 0);
          cubeCamera.lookAt(0, 0, forwardSign[i2]);
        }
        _setViewport(cubeUVRenderTarget, col * SIZE_MAX, i2 > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);
        renderer2.setRenderTarget(cubeUVRenderTarget);
        if (useSolidColor) {
          renderer2.render(backgroundBox, cubeCamera);
        }
        renderer2.render(scene2, cubeCamera);
      }
      backgroundBox.geometry.dispose();
      backgroundBox.material.dispose();
      renderer2.toneMapping = toneMapping;
      renderer2.outputEncoding = outputEncoding;
      renderer2.autoClear = originalAutoClear;
      scene2.background = background;
    }
    _setEncoding(uniform, texture) {
      if (this._renderer.capabilities.isWebGL2 === true && texture.format === RGBAFormat && texture.type === UnsignedByteType && texture.encoding === sRGBEncoding) {
        uniform.value = ENCODINGS[LinearEncoding];
      } else {
        uniform.value = ENCODINGS[texture.encoding];
      }
    }
    _textureToCubeUV(texture, cubeUVRenderTarget) {
      const renderer2 = this._renderer;
      if (texture.isCubeTexture) {
        if (this._cubemapShader == null) {
          this._cubemapShader = _getCubemapShader();
        }
      } else {
        if (this._equirectShader == null) {
          this._equirectShader = _getEquirectShader();
        }
      }
      const material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;
      const mesh = new Mesh(_lodPlanes[0], material);
      const uniforms = material.uniforms;
      uniforms["envMap"].value = texture;
      if (!texture.isCubeTexture) {
        uniforms["texelSize"].value.set(1 / texture.image.width, 1 / texture.image.height);
      }
      this._setEncoding(uniforms["inputEncoding"], texture);
      this._setEncoding(uniforms["outputEncoding"], cubeUVRenderTarget.texture);
      _setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);
      renderer2.setRenderTarget(cubeUVRenderTarget);
      renderer2.render(mesh, _flatCamera);
    }
    _applyPMREM(cubeUVRenderTarget) {
      const renderer2 = this._renderer;
      const autoClear = renderer2.autoClear;
      renderer2.autoClear = false;
      for (let i2 = 1; i2 < TOTAL_LODS; i2++) {
        const sigma = Math.sqrt(_sigmas[i2] * _sigmas[i2] - _sigmas[i2 - 1] * _sigmas[i2 - 1]);
        const poleAxis = _axisDirections[(i2 - 1) % _axisDirections.length];
        this._blur(cubeUVRenderTarget, i2 - 1, i2, sigma, poleAxis);
      }
      renderer2.autoClear = autoClear;
    }
    _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
      const pingPongRenderTarget = this._pingPongRenderTarget;
      this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, "latitudinal", poleAxis);
      this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, "longitudinal", poleAxis);
    }
    _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
      const renderer2 = this._renderer;
      const blurMaterial = this._blurMaterial;
      if (direction !== "latitudinal" && direction !== "longitudinal") {
        console.error("blur direction must be either latitudinal or longitudinal!");
      }
      const STANDARD_DEVIATIONS = 3;
      const blurMesh = new Mesh(_lodPlanes[lodOut], blurMaterial);
      const blurUniforms = blurMaterial.uniforms;
      const pixels = _sizeLods[lodIn] - 1;
      const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
      const sigmaPixels = sigmaRadians / radiansPerPixel;
      const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
      if (samples > MAX_SAMPLES) {
        console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
      }
      const weights = [];
      let sum = 0;
      for (let i2 = 0; i2 < MAX_SAMPLES; ++i2) {
        const x3 = i2 / sigmaPixels;
        const weight = Math.exp(-x3 * x3 / 2);
        weights.push(weight);
        if (i2 == 0) {
          sum += weight;
        } else if (i2 < samples) {
          sum += 2 * weight;
        }
      }
      for (let i2 = 0; i2 < weights.length; i2++) {
        weights[i2] = weights[i2] / sum;
      }
      blurUniforms["envMap"].value = targetIn.texture;
      blurUniforms["samples"].value = samples;
      blurUniforms["weights"].value = weights;
      blurUniforms["latitudinal"].value = direction === "latitudinal";
      if (poleAxis) {
        blurUniforms["poleAxis"].value = poleAxis;
      }
      blurUniforms["dTheta"].value = radiansPerPixel;
      blurUniforms["mipInt"].value = LOD_MAX - lodIn;
      this._setEncoding(blurUniforms["inputEncoding"], targetIn.texture);
      this._setEncoding(blurUniforms["outputEncoding"], targetIn.texture);
      const outputSize = _sizeLods[lodOut];
      const x2 = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);
      const y2 = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);
      _setViewport(targetOut, x2, y2, 3 * outputSize, 2 * outputSize);
      renderer2.setRenderTarget(targetOut);
      renderer2.render(blurMesh, _flatCamera);
    }
  };
  function _isLDR(texture) {
    if (texture === void 0 || texture.type !== UnsignedByteType)
      return false;
    return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;
  }
  function _createPlanes() {
    const _lodPlanes2 = [];
    const _sizeLods2 = [];
    const _sigmas2 = [];
    let lod = LOD_MAX;
    for (let i2 = 0; i2 < TOTAL_LODS; i2++) {
      const sizeLod = Math.pow(2, lod);
      _sizeLods2.push(sizeLod);
      let sigma = 1 / sizeLod;
      if (i2 > LOD_MAX - LOD_MIN) {
        sigma = EXTRA_LOD_SIGMA[i2 - LOD_MAX + LOD_MIN - 1];
      } else if (i2 == 0) {
        sigma = 0;
      }
      _sigmas2.push(sigma);
      const texelSize = 1 / (sizeLod - 1);
      const min = -texelSize / 2;
      const max = 1 + texelSize / 2;
      const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
      const cubeFaces = 6;
      const vertices = 6;
      const positionSize = 3;
      const uvSize = 2;
      const faceIndexSize = 1;
      const position = new Float32Array(positionSize * vertices * cubeFaces);
      const uv = new Float32Array(uvSize * vertices * cubeFaces);
      const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
      for (let face = 0; face < cubeFaces; face++) {
        const x2 = face % 3 * 2 / 3 - 1;
        const y2 = face > 2 ? 0 : -1;
        const coordinates = [
          x2,
          y2,
          0,
          x2 + 2 / 3,
          y2,
          0,
          x2 + 2 / 3,
          y2 + 1,
          0,
          x2,
          y2,
          0,
          x2 + 2 / 3,
          y2 + 1,
          0,
          x2,
          y2 + 1,
          0
        ];
        position.set(coordinates, positionSize * vertices * face);
        uv.set(uv1, uvSize * vertices * face);
        const fill = [face, face, face, face, face, face];
        faceIndex.set(fill, faceIndexSize * vertices * face);
      }
      const planes = new BufferGeometry();
      planes.setAttribute("position", new BufferAttribute(position, positionSize));
      planes.setAttribute("uv", new BufferAttribute(uv, uvSize));
      planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
      _lodPlanes2.push(planes);
      if (lod > LOD_MIN) {
        lod--;
      }
    }
    return { _lodPlanes: _lodPlanes2, _sizeLods: _sizeLods2, _sigmas: _sigmas2 };
  }
  function _createRenderTarget(params) {
    const cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);
    cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
    cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
    cubeUVRenderTarget.scissorTest = true;
    return cubeUVRenderTarget;
  }
  function _setViewport(target, x2, y2, width2, height2) {
    target.viewport.set(x2, y2, width2, height2);
    target.scissor.set(x2, y2, width2, height2);
  }
  function _getBlurShader(maxSamples) {
    const weights = new Float32Array(maxSamples);
    const poleAxis = new Vector3(0, 1, 0);
    const shaderMaterial = new RawShaderMaterial({
      name: "SphericalGaussianBlur",
      defines: { "n": maxSamples },
      uniforms: {
        "envMap": { value: null },
        "samples": { value: 1 },
        "weights": { value: weights },
        "latitudinal": { value: false },
        "dTheta": { value: 0 },
        "mipInt": { value: 0 },
        "poleAxis": { value: poleAxis },
        "inputEncoding": { value: ENCODINGS[LinearEncoding] },
        "outputEncoding": { value: ENCODINGS[LinearEncoding] }
      },
      vertexShader: _getCommonVertexShader(),
      fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${_getEncodings()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
      blending: NoBlending,
      depthTest: false,
      depthWrite: false
    });
    return shaderMaterial;
  }
  function _getEquirectShader() {
    const texelSize = new Vector2(1, 1);
    const shaderMaterial = new RawShaderMaterial({
      name: "EquirectangularToCubeUV",
      uniforms: {
        "envMap": { value: null },
        "texelSize": { value: texelSize },
        "inputEncoding": { value: ENCODINGS[LinearEncoding] },
        "outputEncoding": { value: ENCODINGS[LinearEncoding] }
      },
      vertexShader: _getCommonVertexShader(),
      fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${_getEncodings()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
      blending: NoBlending,
      depthTest: false,
      depthWrite: false
    });
    return shaderMaterial;
  }
  function _getCubemapShader() {
    const shaderMaterial = new RawShaderMaterial({
      name: "CubemapToCubeUV",
      uniforms: {
        "envMap": { value: null },
        "inputEncoding": { value: ENCODINGS[LinearEncoding] },
        "outputEncoding": { value: ENCODINGS[LinearEncoding] }
      },
      vertexShader: _getCommonVertexShader(),
      fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${_getEncodings()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,
      blending: NoBlending,
      depthTest: false,
      depthWrite: false
    });
    return shaderMaterial;
  }
  function _getCommonVertexShader() {
    return `

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
  }
  function _getEncodings() {
    return `

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`;
  }
  function WebGLCubeUVMaps(renderer2) {
    let cubeUVmaps = new WeakMap();
    let pmremGenerator = null;
    function get(texture) {
      if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
        const mapping = texture.mapping;
        const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
        const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;
        if (isEquirectMap || isCubeMap) {
          if (cubeUVmaps.has(texture)) {
            return cubeUVmaps.get(texture).texture;
          } else {
            const image = texture.image;
            if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
              const currentRenderTarget = renderer2.getRenderTarget();
              if (pmremGenerator === null)
                pmremGenerator = new PMREMGenerator(renderer2);
              const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
              cubeUVmaps.set(texture, renderTarget);
              renderer2.setRenderTarget(currentRenderTarget);
              texture.addEventListener("dispose", onTextureDispose);
              return renderTarget.texture;
            } else {
              return null;
            }
          }
        }
      }
      return texture;
    }
    function isCubeTextureComplete(image) {
      let count = 0;
      const length = 6;
      for (let i2 = 0; i2 < length; i2++) {
        if (image[i2] !== void 0)
          count++;
      }
      return count === length;
    }
    function onTextureDispose(event) {
      const texture = event.target;
      texture.removeEventListener("dispose", onTextureDispose);
      const cubemapUV = cubeUVmaps.get(texture);
      if (cubemapUV !== void 0) {
        cubeUVmaps.delete(texture);
        cubemapUV.dispose();
      }
    }
    function dispose() {
      cubeUVmaps = new WeakMap();
      if (pmremGenerator !== null) {
        pmremGenerator.dispose();
        pmremGenerator = null;
      }
    }
    return {
      get,
      dispose
    };
  }
  function WebGLExtensions(gl) {
    const extensions = {};
    function getExtension(name) {
      if (extensions[name] !== void 0) {
        return extensions[name];
      }
      let extension;
      switch (name) {
        case "WEBGL_depth_texture":
          extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          extension = gl.getExtension(name);
      }
      extensions[name] = extension;
      return extension;
    }
    return {
      has: function(name) {
        return getExtension(name) !== null;
      },
      init: function(capabilities) {
        if (capabilities.isWebGL2) {
          getExtension("EXT_color_buffer_float");
        } else {
          getExtension("WEBGL_depth_texture");
          getExtension("OES_texture_float");
          getExtension("OES_texture_half_float");
          getExtension("OES_texture_half_float_linear");
          getExtension("OES_standard_derivatives");
          getExtension("OES_element_index_uint");
          getExtension("OES_vertex_array_object");
          getExtension("ANGLE_instanced_arrays");
        }
        getExtension("OES_texture_float_linear");
        getExtension("EXT_color_buffer_half_float");
      },
      get: function(name) {
        const extension = getExtension(name);
        if (extension === null) {
          console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
        }
        return extension;
      }
    };
  }
  function WebGLGeometries(gl, attributes, info, bindingStates) {
    const geometries = {};
    const wireframeAttributes = new WeakMap();
    function onGeometryDispose(event) {
      const geometry = event.target;
      if (geometry.index !== null) {
        attributes.remove(geometry.index);
      }
      for (const name in geometry.attributes) {
        attributes.remove(geometry.attributes[name]);
      }
      geometry.removeEventListener("dispose", onGeometryDispose);
      delete geometries[geometry.id];
      const attribute = wireframeAttributes.get(geometry);
      if (attribute) {
        attributes.remove(attribute);
        wireframeAttributes.delete(geometry);
      }
      bindingStates.releaseStatesOfGeometry(geometry);
      if (geometry.isInstancedBufferGeometry === true) {
        delete geometry._maxInstanceCount;
      }
      info.memory.geometries--;
    }
    function get(object, geometry) {
      if (geometries[geometry.id] === true)
        return geometry;
      geometry.addEventListener("dispose", onGeometryDispose);
      geometries[geometry.id] = true;
      info.memory.geometries++;
      return geometry;
    }
    function update2(geometry) {
      const geometryAttributes = geometry.attributes;
      for (const name in geometryAttributes) {
        attributes.update(geometryAttributes[name], 34962);
      }
      const morphAttributes = geometry.morphAttributes;
      for (const name in morphAttributes) {
        const array = morphAttributes[name];
        for (let i2 = 0, l2 = array.length; i2 < l2; i2++) {
          attributes.update(array[i2], 34962);
        }
      }
    }
    function updateWireframeAttribute(geometry) {
      const indices = [];
      const geometryIndex = geometry.index;
      const geometryPosition = geometry.attributes.position;
      let version = 0;
      if (geometryIndex !== null) {
        const array = geometryIndex.array;
        version = geometryIndex.version;
        for (let i2 = 0, l2 = array.length; i2 < l2; i2 += 3) {
          const a2 = array[i2 + 0];
          const b2 = array[i2 + 1];
          const c2 = array[i2 + 2];
          indices.push(a2, b2, b2, c2, c2, a2);
        }
      } else {
        const array = geometryPosition.array;
        version = geometryPosition.version;
        for (let i2 = 0, l2 = array.length / 3 - 1; i2 < l2; i2 += 3) {
          const a2 = i2 + 0;
          const b2 = i2 + 1;
          const c2 = i2 + 2;
          indices.push(a2, b2, b2, c2, c2, a2);
        }
      }
      const attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
      attribute.version = version;
      const previousAttribute = wireframeAttributes.get(geometry);
      if (previousAttribute)
        attributes.remove(previousAttribute);
      wireframeAttributes.set(geometry, attribute);
    }
    function getWireframeAttribute(geometry) {
      const currentAttribute = wireframeAttributes.get(geometry);
      if (currentAttribute) {
        const geometryIndex = geometry.index;
        if (geometryIndex !== null) {
          if (currentAttribute.version < geometryIndex.version) {
            updateWireframeAttribute(geometry);
          }
        }
      } else {
        updateWireframeAttribute(geometry);
      }
      return wireframeAttributes.get(geometry);
    }
    return {
      get,
      update: update2,
      getWireframeAttribute
    };
  }
  function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    let mode;
    function setMode(value) {
      mode = value;
    }
    let type, bytesPerElement;
    function setIndex(value) {
      type = value.type;
      bytesPerElement = value.bytesPerElement;
    }
    function render(start, count) {
      gl.drawElements(mode, count, type, start * bytesPerElement);
      info.update(count, mode, 1);
    }
    function renderInstances(start, count, primcount) {
      if (primcount === 0)
        return;
      let extension, methodName;
      if (isWebGL2) {
        extension = gl;
        methodName = "drawElementsInstanced";
      } else {
        extension = extensions.get("ANGLE_instanced_arrays");
        methodName = "drawElementsInstancedANGLE";
        if (extension === null) {
          console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
          return;
        }
      }
      extension[methodName](mode, count, type, start * bytesPerElement, primcount);
      info.update(count, mode, primcount);
    }
    this.setMode = setMode;
    this.setIndex = setIndex;
    this.render = render;
    this.renderInstances = renderInstances;
  }
  function WebGLInfo(gl) {
    const memory = {
      geometries: 0,
      textures: 0
    };
    const render = {
      frame: 0,
      calls: 0,
      triangles: 0,
      points: 0,
      lines: 0
    };
    function update2(count, mode, instanceCount) {
      render.calls++;
      switch (mode) {
        case 4:
          render.triangles += instanceCount * (count / 3);
          break;
        case 1:
          render.lines += instanceCount * (count / 2);
          break;
        case 3:
          render.lines += instanceCount * (count - 1);
          break;
        case 2:
          render.lines += instanceCount * count;
          break;
        case 0:
          render.points += instanceCount * count;
          break;
        default:
          console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
          break;
      }
    }
    function reset() {
      render.frame++;
      render.calls = 0;
      render.triangles = 0;
      render.points = 0;
      render.lines = 0;
    }
    return {
      memory,
      render,
      programs: null,
      autoReset: true,
      reset,
      update: update2
    };
  }
  var DataTexture2DArray = class extends Texture {
    constructor(data = null, width2 = 1, height2 = 1, depth = 1) {
      super(null);
      this.image = { data, width: width2, height: height2, depth };
      this.magFilter = NearestFilter;
      this.minFilter = NearestFilter;
      this.wrapR = ClampToEdgeWrapping;
      this.generateMipmaps = false;
      this.flipY = false;
      this.unpackAlignment = 1;
      this.needsUpdate = true;
    }
  };
  DataTexture2DArray.prototype.isDataTexture2DArray = true;
  function numericalSort(a2, b2) {
    return a2[0] - b2[0];
  }
  function absNumericalSort(a2, b2) {
    return Math.abs(b2[1]) - Math.abs(a2[1]);
  }
  function denormalize(morph, attribute) {
    let denominator = 1;
    const array = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;
    if (array instanceof Int8Array)
      denominator = 127;
    else if (array instanceof Int16Array)
      denominator = 32767;
    else if (array instanceof Int32Array)
      denominator = 2147483647;
    else
      console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", array);
    morph.divideScalar(denominator);
  }
  function WebGLMorphtargets(gl, capabilities, textures) {
    const influencesList = {};
    const morphInfluences = new Float32Array(8);
    const morphTextures = new WeakMap();
    const morph = new Vector3();
    const workInfluences = [];
    for (let i2 = 0; i2 < 8; i2++) {
      workInfluences[i2] = [i2, 0];
    }
    function update2(object, geometry, material, program) {
      const objectInfluences = object.morphTargetInfluences;
      if (capabilities.isWebGL2 === true) {
        const numberOfMorphTargets = geometry.morphAttributes.position.length;
        let entry = morphTextures.get(geometry);
        if (entry === void 0 || entry.count !== numberOfMorphTargets) {
          if (entry !== void 0)
            entry.texture.dispose();
          const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
          const morphTargets = geometry.morphAttributes.position;
          const morphNormals = geometry.morphAttributes.normal || [];
          const numberOfVertices = geometry.attributes.position.count;
          const numberOfVertexData = hasMorphNormals === true ? 2 : 1;
          let width2 = numberOfVertices * numberOfVertexData;
          let height2 = 1;
          if (width2 > capabilities.maxTextureSize) {
            height2 = Math.ceil(width2 / capabilities.maxTextureSize);
            width2 = capabilities.maxTextureSize;
          }
          const buffer = new Float32Array(width2 * height2 * 4 * numberOfMorphTargets);
          const texture = new DataTexture2DArray(buffer, width2, height2, numberOfMorphTargets);
          texture.format = RGBAFormat;
          texture.type = FloatType;
          const vertexDataStride = numberOfVertexData * 4;
          for (let i2 = 0; i2 < numberOfMorphTargets; i2++) {
            const morphTarget = morphTargets[i2];
            const morphNormal = morphNormals[i2];
            const offset = width2 * height2 * 4 * i2;
            for (let j2 = 0; j2 < morphTarget.count; j2++) {
              morph.fromBufferAttribute(morphTarget, j2);
              if (morphTarget.normalized === true)
                denormalize(morph, morphTarget);
              const stride = j2 * vertexDataStride;
              buffer[offset + stride + 0] = morph.x;
              buffer[offset + stride + 1] = morph.y;
              buffer[offset + stride + 2] = morph.z;
              buffer[offset + stride + 3] = 0;
              if (hasMorphNormals === true) {
                morph.fromBufferAttribute(morphNormal, j2);
                if (morphNormal.normalized === true)
                  denormalize(morph, morphNormal);
                buffer[offset + stride + 4] = morph.x;
                buffer[offset + stride + 5] = morph.y;
                buffer[offset + stride + 6] = morph.z;
                buffer[offset + stride + 7] = 0;
              }
            }
          }
          entry = {
            count: numberOfMorphTargets,
            texture,
            size: new Vector2(width2, height2)
          };
          morphTextures.set(geometry, entry);
        }
        let morphInfluencesSum = 0;
        for (let i2 = 0; i2 < objectInfluences.length; i2++) {
          morphInfluencesSum += objectInfluences[i2];
        }
        const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
        program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
        program.getUniforms().setValue(gl, "morphTargetInfluences", objectInfluences);
        program.getUniforms().setValue(gl, "morphTargetsTexture", entry.texture, textures);
        program.getUniforms().setValue(gl, "morphTargetsTextureSize", entry.size);
      } else {
        const length = objectInfluences === void 0 ? 0 : objectInfluences.length;
        let influences = influencesList[geometry.id];
        if (influences === void 0 || influences.length !== length) {
          influences = [];
          for (let i2 = 0; i2 < length; i2++) {
            influences[i2] = [i2, 0];
          }
          influencesList[geometry.id] = influences;
        }
        for (let i2 = 0; i2 < length; i2++) {
          const influence = influences[i2];
          influence[0] = i2;
          influence[1] = objectInfluences[i2];
        }
        influences.sort(absNumericalSort);
        for (let i2 = 0; i2 < 8; i2++) {
          if (i2 < length && influences[i2][1]) {
            workInfluences[i2][0] = influences[i2][0];
            workInfluences[i2][1] = influences[i2][1];
          } else {
            workInfluences[i2][0] = Number.MAX_SAFE_INTEGER;
            workInfluences[i2][1] = 0;
          }
        }
        workInfluences.sort(numericalSort);
        const morphTargets = geometry.morphAttributes.position;
        const morphNormals = geometry.morphAttributes.normal;
        let morphInfluencesSum = 0;
        for (let i2 = 0; i2 < 8; i2++) {
          const influence = workInfluences[i2];
          const index = influence[0];
          const value = influence[1];
          if (index !== Number.MAX_SAFE_INTEGER && value) {
            if (morphTargets && geometry.getAttribute("morphTarget" + i2) !== morphTargets[index]) {
              geometry.setAttribute("morphTarget" + i2, morphTargets[index]);
            }
            if (morphNormals && geometry.getAttribute("morphNormal" + i2) !== morphNormals[index]) {
              geometry.setAttribute("morphNormal" + i2, morphNormals[index]);
            }
            morphInfluences[i2] = value;
            morphInfluencesSum += value;
          } else {
            if (morphTargets && geometry.hasAttribute("morphTarget" + i2) === true) {
              geometry.deleteAttribute("morphTarget" + i2);
            }
            if (morphNormals && geometry.hasAttribute("morphNormal" + i2) === true) {
              geometry.deleteAttribute("morphNormal" + i2);
            }
            morphInfluences[i2] = 0;
          }
        }
        const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
        program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
        program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
      }
    }
    return {
      update: update2
    };
  }
  function WebGLObjects(gl, geometries, attributes, info) {
    let updateMap = new WeakMap();
    function update2(object) {
      const frame = info.render.frame;
      const geometry = object.geometry;
      const buffergeometry = geometries.get(object, geometry);
      if (updateMap.get(buffergeometry) !== frame) {
        geometries.update(buffergeometry);
        updateMap.set(buffergeometry, frame);
      }
      if (object.isInstancedMesh) {
        if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
          object.addEventListener("dispose", onInstancedMeshDispose);
        }
        attributes.update(object.instanceMatrix, 34962);
        if (object.instanceColor !== null) {
          attributes.update(object.instanceColor, 34962);
        }
      }
      return buffergeometry;
    }
    function dispose() {
      updateMap = new WeakMap();
    }
    function onInstancedMeshDispose(event) {
      const instancedMesh = event.target;
      instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
      attributes.remove(instancedMesh.instanceMatrix);
      if (instancedMesh.instanceColor !== null)
        attributes.remove(instancedMesh.instanceColor);
    }
    return {
      update: update2,
      dispose
    };
  }
  var DataTexture3D = class extends Texture {
    constructor(data = null, width2 = 1, height2 = 1, depth = 1) {
      super(null);
      this.image = { data, width: width2, height: height2, depth };
      this.magFilter = NearestFilter;
      this.minFilter = NearestFilter;
      this.wrapR = ClampToEdgeWrapping;
      this.generateMipmaps = false;
      this.flipY = false;
      this.unpackAlignment = 1;
      this.needsUpdate = true;
    }
  };
  DataTexture3D.prototype.isDataTexture3D = true;
  var emptyTexture = new Texture();
  var emptyTexture2dArray = new DataTexture2DArray();
  var emptyTexture3d = new DataTexture3D();
  var emptyCubeTexture = new CubeTexture();
  var arrayCacheF32 = [];
  var arrayCacheI32 = [];
  var mat4array = new Float32Array(16);
  var mat3array = new Float32Array(9);
  var mat2array = new Float32Array(4);
  function flatten(array, nBlocks, blockSize) {
    const firstElem = array[0];
    if (firstElem <= 0 || firstElem > 0)
      return array;
    const n2 = nBlocks * blockSize;
    let r2 = arrayCacheF32[n2];
    if (r2 === void 0) {
      r2 = new Float32Array(n2);
      arrayCacheF32[n2] = r2;
    }
    if (nBlocks !== 0) {
      firstElem.toArray(r2, 0);
      for (let i2 = 1, offset = 0; i2 !== nBlocks; ++i2) {
        offset += blockSize;
        array[i2].toArray(r2, offset);
      }
    }
    return r2;
  }
  function arraysEqual(a2, b2) {
    if (a2.length !== b2.length)
      return false;
    for (let i2 = 0, l2 = a2.length; i2 < l2; i2++) {
      if (a2[i2] !== b2[i2])
        return false;
    }
    return true;
  }
  function copyArray(a2, b2) {
    for (let i2 = 0, l2 = b2.length; i2 < l2; i2++) {
      a2[i2] = b2[i2];
    }
  }
  function allocTexUnits(textures, n2) {
    let r2 = arrayCacheI32[n2];
    if (r2 === void 0) {
      r2 = new Int32Array(n2);
      arrayCacheI32[n2] = r2;
    }
    for (let i2 = 0; i2 !== n2; ++i2) {
      r2[i2] = textures.allocateTextureUnit();
    }
    return r2;
  }
  function setValueV1f(gl, v2) {
    const cache = this.cache;
    if (cache[0] === v2)
      return;
    gl.uniform1f(this.addr, v2);
    cache[0] = v2;
  }
  function setValueV2f(gl, v2) {
    const cache = this.cache;
    if (v2.x !== void 0) {
      if (cache[0] !== v2.x || cache[1] !== v2.y) {
        gl.uniform2f(this.addr, v2.x, v2.y);
        cache[0] = v2.x;
        cache[1] = v2.y;
      }
    } else {
      if (arraysEqual(cache, v2))
        return;
      gl.uniform2fv(this.addr, v2);
      copyArray(cache, v2);
    }
  }
  function setValueV3f(gl, v2) {
    const cache = this.cache;
    if (v2.x !== void 0) {
      if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z) {
        gl.uniform3f(this.addr, v2.x, v2.y, v2.z);
        cache[0] = v2.x;
        cache[1] = v2.y;
        cache[2] = v2.z;
      }
    } else if (v2.r !== void 0) {
      if (cache[0] !== v2.r || cache[1] !== v2.g || cache[2] !== v2.b) {
        gl.uniform3f(this.addr, v2.r, v2.g, v2.b);
        cache[0] = v2.r;
        cache[1] = v2.g;
        cache[2] = v2.b;
      }
    } else {
      if (arraysEqual(cache, v2))
        return;
      gl.uniform3fv(this.addr, v2);
      copyArray(cache, v2);
    }
  }
  function setValueV4f(gl, v2) {
    const cache = this.cache;
    if (v2.x !== void 0) {
      if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z || cache[3] !== v2.w) {
        gl.uniform4f(this.addr, v2.x, v2.y, v2.z, v2.w);
        cache[0] = v2.x;
        cache[1] = v2.y;
        cache[2] = v2.z;
        cache[3] = v2.w;
      }
    } else {
      if (arraysEqual(cache, v2))
        return;
      gl.uniform4fv(this.addr, v2);
      copyArray(cache, v2);
    }
  }
  function setValueM2(gl, v2) {
    const cache = this.cache;
    const elements = v2.elements;
    if (elements === void 0) {
      if (arraysEqual(cache, v2))
        return;
      gl.uniformMatrix2fv(this.addr, false, v2);
      copyArray(cache, v2);
    } else {
      if (arraysEqual(cache, elements))
        return;
      mat2array.set(elements);
      gl.uniformMatrix2fv(this.addr, false, mat2array);
      copyArray(cache, elements);
    }
  }
  function setValueM3(gl, v2) {
    const cache = this.cache;
    const elements = v2.elements;
    if (elements === void 0) {
      if (arraysEqual(cache, v2))
        return;
      gl.uniformMatrix3fv(this.addr, false, v2);
      copyArray(cache, v2);
    } else {
      if (arraysEqual(cache, elements))
        return;
      mat3array.set(elements);
      gl.uniformMatrix3fv(this.addr, false, mat3array);
      copyArray(cache, elements);
    }
  }
  function setValueM4(gl, v2) {
    const cache = this.cache;
    const elements = v2.elements;
    if (elements === void 0) {
      if (arraysEqual(cache, v2))
        return;
      gl.uniformMatrix4fv(this.addr, false, v2);
      copyArray(cache, v2);
    } else {
      if (arraysEqual(cache, elements))
        return;
      mat4array.set(elements);
      gl.uniformMatrix4fv(this.addr, false, mat4array);
      copyArray(cache, elements);
    }
  }
  function setValueV1i(gl, v2) {
    const cache = this.cache;
    if (cache[0] === v2)
      return;
    gl.uniform1i(this.addr, v2);
    cache[0] = v2;
  }
  function setValueV2i(gl, v2) {
    const cache = this.cache;
    if (arraysEqual(cache, v2))
      return;
    gl.uniform2iv(this.addr, v2);
    copyArray(cache, v2);
  }
  function setValueV3i(gl, v2) {
    const cache = this.cache;
    if (arraysEqual(cache, v2))
      return;
    gl.uniform3iv(this.addr, v2);
    copyArray(cache, v2);
  }
  function setValueV4i(gl, v2) {
    const cache = this.cache;
    if (arraysEqual(cache, v2))
      return;
    gl.uniform4iv(this.addr, v2);
    copyArray(cache, v2);
  }
  function setValueV1ui(gl, v2) {
    const cache = this.cache;
    if (cache[0] === v2)
      return;
    gl.uniform1ui(this.addr, v2);
    cache[0] = v2;
  }
  function setValueV2ui(gl, v2) {
    const cache = this.cache;
    if (arraysEqual(cache, v2))
      return;
    gl.uniform2uiv(this.addr, v2);
    copyArray(cache, v2);
  }
  function setValueV3ui(gl, v2) {
    const cache = this.cache;
    if (arraysEqual(cache, v2))
      return;
    gl.uniform3uiv(this.addr, v2);
    copyArray(cache, v2);
  }
  function setValueV4ui(gl, v2) {
    const cache = this.cache;
    if (arraysEqual(cache, v2))
      return;
    gl.uniform4uiv(this.addr, v2);
    copyArray(cache, v2);
  }
  function setValueT1(gl, v2, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.safeSetTexture2D(v2 || emptyTexture, unit);
  }
  function setValueT3D1(gl, v2, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.setTexture3D(v2 || emptyTexture3d, unit);
  }
  function setValueT6(gl, v2, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.safeSetTextureCube(v2 || emptyCubeTexture, unit);
  }
  function setValueT2DArray1(gl, v2, textures) {
    const cache = this.cache;
    const unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.setTexture2DArray(v2 || emptyTexture2dArray, unit);
  }
  function getSingularSetter(type) {
    switch (type) {
      case 5126:
        return setValueV1f;
      case 35664:
        return setValueV2f;
      case 35665:
        return setValueV3f;
      case 35666:
        return setValueV4f;
      case 35674:
        return setValueM2;
      case 35675:
        return setValueM3;
      case 35676:
        return setValueM4;
      case 5124:
      case 35670:
        return setValueV1i;
      case 35667:
      case 35671:
        return setValueV2i;
      case 35668:
      case 35672:
        return setValueV3i;
      case 35669:
      case 35673:
        return setValueV4i;
      case 5125:
        return setValueV1ui;
      case 36294:
        return setValueV2ui;
      case 36295:
        return setValueV3ui;
      case 36296:
        return setValueV4ui;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return setValueT1;
      case 35679:
      case 36299:
      case 36307:
        return setValueT3D1;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return setValueT6;
      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return setValueT2DArray1;
    }
  }
  function setValueV1fArray(gl, v2) {
    gl.uniform1fv(this.addr, v2);
  }
  function setValueV2fArray(gl, v2) {
    const data = flatten(v2, this.size, 2);
    gl.uniform2fv(this.addr, data);
  }
  function setValueV3fArray(gl, v2) {
    const data = flatten(v2, this.size, 3);
    gl.uniform3fv(this.addr, data);
  }
  function setValueV4fArray(gl, v2) {
    const data = flatten(v2, this.size, 4);
    gl.uniform4fv(this.addr, data);
  }
  function setValueM2Array(gl, v2) {
    const data = flatten(v2, this.size, 4);
    gl.uniformMatrix2fv(this.addr, false, data);
  }
  function setValueM3Array(gl, v2) {
    const data = flatten(v2, this.size, 9);
    gl.uniformMatrix3fv(this.addr, false, data);
  }
  function setValueM4Array(gl, v2) {
    const data = flatten(v2, this.size, 16);
    gl.uniformMatrix4fv(this.addr, false, data);
  }
  function setValueV1iArray(gl, v2) {
    gl.uniform1iv(this.addr, v2);
  }
  function setValueV2iArray(gl, v2) {
    gl.uniform2iv(this.addr, v2);
  }
  function setValueV3iArray(gl, v2) {
    gl.uniform3iv(this.addr, v2);
  }
  function setValueV4iArray(gl, v2) {
    gl.uniform4iv(this.addr, v2);
  }
  function setValueV1uiArray(gl, v2) {
    gl.uniform1uiv(this.addr, v2);
  }
  function setValueV2uiArray(gl, v2) {
    gl.uniform2uiv(this.addr, v2);
  }
  function setValueV3uiArray(gl, v2) {
    gl.uniform3uiv(this.addr, v2);
  }
  function setValueV4uiArray(gl, v2) {
    gl.uniform4uiv(this.addr, v2);
  }
  function setValueT1Array(gl, v2, textures) {
    const n2 = v2.length;
    const units = allocTexUnits(textures, n2);
    gl.uniform1iv(this.addr, units);
    for (let i2 = 0; i2 !== n2; ++i2) {
      textures.safeSetTexture2D(v2[i2] || emptyTexture, units[i2]);
    }
  }
  function setValueT6Array(gl, v2, textures) {
    const n2 = v2.length;
    const units = allocTexUnits(textures, n2);
    gl.uniform1iv(this.addr, units);
    for (let i2 = 0; i2 !== n2; ++i2) {
      textures.safeSetTextureCube(v2[i2] || emptyCubeTexture, units[i2]);
    }
  }
  function getPureArraySetter(type) {
    switch (type) {
      case 5126:
        return setValueV1fArray;
      case 35664:
        return setValueV2fArray;
      case 35665:
        return setValueV3fArray;
      case 35666:
        return setValueV4fArray;
      case 35674:
        return setValueM2Array;
      case 35675:
        return setValueM3Array;
      case 35676:
        return setValueM4Array;
      case 5124:
      case 35670:
        return setValueV1iArray;
      case 35667:
      case 35671:
        return setValueV2iArray;
      case 35668:
      case 35672:
        return setValueV3iArray;
      case 35669:
      case 35673:
        return setValueV4iArray;
      case 5125:
        return setValueV1uiArray;
      case 36294:
        return setValueV2uiArray;
      case 36295:
        return setValueV3uiArray;
      case 36296:
        return setValueV4uiArray;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return setValueT1Array;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return setValueT6Array;
    }
  }
  function SingleUniform(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.setValue = getSingularSetter(activeInfo.type);
  }
  function PureArrayUniform(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.size = activeInfo.size;
    this.setValue = getPureArraySetter(activeInfo.type);
  }
  PureArrayUniform.prototype.updateCache = function(data) {
    const cache = this.cache;
    if (data instanceof Float32Array && cache.length !== data.length) {
      this.cache = new Float32Array(data.length);
    }
    copyArray(cache, data);
  };
  function StructuredUniform(id) {
    this.id = id;
    this.seq = [];
    this.map = {};
  }
  StructuredUniform.prototype.setValue = function(gl, value, textures) {
    const seq = this.seq;
    for (let i2 = 0, n2 = seq.length; i2 !== n2; ++i2) {
      const u2 = seq[i2];
      u2.setValue(gl, value[u2.id], textures);
    }
  };
  var RePathPart = /(\w+)(\])?(\[|\.)?/g;
  function addUniform(container, uniformObject) {
    container.seq.push(uniformObject);
    container.map[uniformObject.id] = uniformObject;
  }
  function parseUniform(activeInfo, addr, container) {
    const path = activeInfo.name, pathLength = path.length;
    RePathPart.lastIndex = 0;
    while (true) {
      const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
      let id = match[1];
      const idIsIndex = match[2] === "]", subscript = match[3];
      if (idIsIndex)
        id = id | 0;
      if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
        addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
        break;
      } else {
        const map = container.map;
        let next = map[id];
        if (next === void 0) {
          next = new StructuredUniform(id);
          addUniform(container, next);
        }
        container = next;
      }
    }
  }
  function WebGLUniforms(gl, program) {
    this.seq = [];
    this.map = {};
    const n2 = gl.getProgramParameter(program, 35718);
    for (let i2 = 0; i2 < n2; ++i2) {
      const info = gl.getActiveUniform(program, i2), addr = gl.getUniformLocation(program, info.name);
      parseUniform(info, addr, this);
    }
  }
  WebGLUniforms.prototype.setValue = function(gl, name, value, textures) {
    const u2 = this.map[name];
    if (u2 !== void 0)
      u2.setValue(gl, value, textures);
  };
  WebGLUniforms.prototype.setOptional = function(gl, object, name) {
    const v2 = object[name];
    if (v2 !== void 0)
      this.setValue(gl, name, v2);
  };
  WebGLUniforms.upload = function(gl, seq, values, textures) {
    for (let i2 = 0, n2 = seq.length; i2 !== n2; ++i2) {
      const u2 = seq[i2], v2 = values[u2.id];
      if (v2.needsUpdate !== false) {
        u2.setValue(gl, v2.value, textures);
      }
    }
  };
  WebGLUniforms.seqWithValue = function(seq, values) {
    const r2 = [];
    for (let i2 = 0, n2 = seq.length; i2 !== n2; ++i2) {
      const u2 = seq[i2];
      if (u2.id in values)
        r2.push(u2);
    }
    return r2;
  };
  function WebGLShader(gl, type, string) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, string);
    gl.compileShader(shader);
    return shader;
  }
  var programIdCount = 0;
  function addLineNumbers(string) {
    const lines = string.split("\n");
    for (let i2 = 0; i2 < lines.length; i2++) {
      lines[i2] = i2 + 1 + ": " + lines[i2];
    }
    return lines.join("\n");
  }
  function getEncodingComponents(encoding) {
    switch (encoding) {
      case LinearEncoding:
        return ["Linear", "( value )"];
      case sRGBEncoding:
        return ["sRGB", "( value )"];
      case RGBEEncoding:
        return ["RGBE", "( value )"];
      case RGBM7Encoding:
        return ["RGBM", "( value, 7.0 )"];
      case RGBM16Encoding:
        return ["RGBM", "( value, 16.0 )"];
      case RGBDEncoding:
        return ["RGBD", "( value, 256.0 )"];
      case GammaEncoding:
        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
      case LogLuvEncoding:
        return ["LogLuv", "( value )"];
      default:
        console.warn("THREE.WebGLProgram: Unsupported encoding:", encoding);
        return ["Linear", "( value )"];
    }
  }
  function getShaderErrors(gl, shader, type) {
    const status = gl.getShaderParameter(shader, 35713);
    const errors = gl.getShaderInfoLog(shader).trim();
    if (status && errors === "")
      return "";
    return type.toUpperCase() + "\n\n" + errors + "\n\n" + addLineNumbers(gl.getShaderSource(shader));
  }
  function getTexelDecodingFunction(functionName, encoding) {
    const components = getEncodingComponents(encoding);
    return "vec4 " + functionName + "( vec4 value ) { return " + components[0] + "ToLinear" + components[1] + "; }";
  }
  function getTexelEncodingFunction(functionName, encoding) {
    const components = getEncodingComponents(encoding);
    return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
  }
  function getToneMappingFunction(functionName, toneMapping) {
    let toneMappingName;
    switch (toneMapping) {
      case LinearToneMapping:
        toneMappingName = "Linear";
        break;
      case ReinhardToneMapping:
        toneMappingName = "Reinhard";
        break;
      case CineonToneMapping:
        toneMappingName = "OptimizedCineon";
        break;
      case ACESFilmicToneMapping:
        toneMappingName = "ACESFilmic";
        break;
      case CustomToneMapping:
        toneMappingName = "Custom";
        break;
      default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
        toneMappingName = "Linear";
    }
    return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
  }
  function generateExtensions(parameters) {
    const chunks = [
      parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
      (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
      parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
      (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
    ];
    return chunks.filter(filterEmptyLine).join("\n");
  }
  function generateDefines(defines) {
    const chunks = [];
    for (const name in defines) {
      const value = defines[name];
      if (value === false)
        continue;
      chunks.push("#define " + name + " " + value);
    }
    return chunks.join("\n");
  }
  function fetchAttributeLocations(gl, program) {
    const attributes = {};
    const n2 = gl.getProgramParameter(program, 35721);
    for (let i2 = 0; i2 < n2; i2++) {
      const info = gl.getActiveAttrib(program, i2);
      const name = info.name;
      let locationSize = 1;
      if (info.type === 35674)
        locationSize = 2;
      if (info.type === 35675)
        locationSize = 3;
      if (info.type === 35676)
        locationSize = 4;
      attributes[name] = {
        type: info.type,
        location: gl.getAttribLocation(program, name),
        locationSize
      };
    }
    return attributes;
  }
  function filterEmptyLine(string) {
    return string !== "";
  }
  function replaceLightNums(string, parameters) {
    return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
  }
  function replaceClippingPlaneNums(string, parameters) {
    return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
  }
  var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function resolveIncludes(string) {
    return string.replace(includePattern, includeReplacer);
  }
  function includeReplacer(match, include) {
    const string = ShaderChunk[include];
    if (string === void 0) {
      throw new Error("Can not resolve #include <" + include + ">");
    }
    return resolveIncludes(string);
  }
  var deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
  var unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
  function unrollLoops(string) {
    return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
  }
  function deprecatedLoopReplacer(match, start, end, snippet) {
    console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.");
    return loopReplacer(match, start, end, snippet);
  }
  function loopReplacer(match, start, end, snippet) {
    let string = "";
    for (let i2 = parseInt(start); i2 < parseInt(end); i2++) {
      string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i2 + " ]").replace(/UNROLLED_LOOP_INDEX/g, i2);
    }
    return string;
  }
  function generatePrecision(parameters) {
    let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
    if (parameters.precision === "highp") {
      precisionstring += "\n#define HIGH_PRECISION";
    } else if (parameters.precision === "mediump") {
      precisionstring += "\n#define MEDIUM_PRECISION";
    } else if (parameters.precision === "lowp") {
      precisionstring += "\n#define LOW_PRECISION";
    }
    return precisionstring;
  }
  function generateShadowMapTypeDefine(parameters) {
    let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
    if (parameters.shadowMapType === PCFShadowMap) {
      shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
    } else if (parameters.shadowMapType === PCFSoftShadowMap) {
      shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
    } else if (parameters.shadowMapType === VSMShadowMap) {
      shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
    }
    return shadowMapTypeDefine;
  }
  function generateEnvMapTypeDefine(parameters) {
    let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
    if (parameters.envMap) {
      switch (parameters.envMapMode) {
        case CubeReflectionMapping:
        case CubeRefractionMapping:
          envMapTypeDefine = "ENVMAP_TYPE_CUBE";
          break;
        case CubeUVReflectionMapping:
        case CubeUVRefractionMapping:
          envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
          break;
      }
    }
    return envMapTypeDefine;
  }
  function generateEnvMapModeDefine(parameters) {
    let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
    if (parameters.envMap) {
      switch (parameters.envMapMode) {
        case CubeRefractionMapping:
        case CubeUVRefractionMapping:
          envMapModeDefine = "ENVMAP_MODE_REFRACTION";
          break;
      }
    }
    return envMapModeDefine;
  }
  function generateEnvMapBlendingDefine(parameters) {
    let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
    if (parameters.envMap) {
      switch (parameters.combine) {
        case MultiplyOperation:
          envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
          break;
        case MixOperation:
          envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
          break;
        case AddOperation:
          envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
          break;
      }
    }
    return envMapBlendingDefine;
  }
  function WebGLProgram(renderer2, cacheKey, parameters, bindingStates) {
    const gl = renderer2.getContext();
    const defines = parameters.defines;
    let vertexShader = parameters.vertexShader;
    let fragmentShader = parameters.fragmentShader;
    const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
    const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
    const envMapModeDefine = generateEnvMapModeDefine(parameters);
    const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
    const gammaFactorDefine = renderer2.gammaFactor > 0 ? renderer2.gammaFactor : 1;
    const customExtensions = parameters.isWebGL2 ? "" : generateExtensions(parameters);
    const customDefines = generateDefines(defines);
    const program = gl.createProgram();
    let prefixVertex, prefixFragment;
    let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
    if (parameters.isRawShaderMaterial) {
      prefixVertex = [
        customDefines
      ].filter(filterEmptyLine).join("\n");
      if (prefixVertex.length > 0) {
        prefixVertex += "\n";
      }
      prefixFragment = [
        customExtensions,
        customDefines
      ].filter(filterEmptyLine).join("\n");
      if (prefixFragment.length > 0) {
        prefixFragment += "\n";
      }
    } else {
      prefixVertex = [
        generatePrecision(parameters),
        "#define SHADER_NAME " + parameters.shaderName,
        customDefines,
        parameters.instancing ? "#define USE_INSTANCING" : "",
        parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
        "#define GAMMA_FACTOR " + gammaFactorDefine,
        "#define MAX_BONES " + parameters.maxBones,
        parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
        parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
        parameters.map ? "#define USE_MAP" : "",
        parameters.envMap ? "#define USE_ENVMAP" : "",
        parameters.envMap ? "#define " + envMapModeDefine : "",
        parameters.lightMap ? "#define USE_LIGHTMAP" : "",
        parameters.aoMap ? "#define USE_AOMAP" : "",
        parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        parameters.bumpMap ? "#define USE_BUMPMAP" : "",
        parameters.normalMap ? "#define USE_NORMALMAP" : "",
        parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
        parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
        parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
        parameters.specularMap ? "#define USE_SPECULARMAP" : "",
        parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
        parameters.specularTintMap ? "#define USE_SPECULARTINTMAP" : "",
        parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
        parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
        parameters.transmission ? "#define USE_TRANSMISSION" : "",
        parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        parameters.vertexTangents ? "#define USE_TANGENT" : "",
        parameters.vertexColors ? "#define USE_COLOR" : "",
        parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        parameters.vertexUvs ? "#define USE_UV" : "",
        parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
        parameters.flatShading ? "#define FLAT_SHADED" : "",
        parameters.skinning ? "#define USE_SKINNING" : "",
        parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",
        parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
        parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
        parameters.morphTargets && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
        parameters.morphTargets && parameters.isWebGL2 ? "#define MORPHTARGETS_COUNT " + parameters.morphTargetsCount : "",
        parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
        parameters.flipSided ? "#define FLIP_SIDED" : "",
        parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
        parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        "\n"
      ].filter(filterEmptyLine).join("\n");
      prefixFragment = [
        customExtensions,
        generatePrecision(parameters),
        "#define SHADER_NAME " + parameters.shaderName,
        customDefines,
        "#define GAMMA_FACTOR " + gammaFactorDefine,
        parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
        parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
        parameters.map ? "#define USE_MAP" : "",
        parameters.matcap ? "#define USE_MATCAP" : "",
        parameters.envMap ? "#define USE_ENVMAP" : "",
        parameters.envMap ? "#define " + envMapTypeDefine : "",
        parameters.envMap ? "#define " + envMapModeDefine : "",
        parameters.envMap ? "#define " + envMapBlendingDefine : "",
        parameters.lightMap ? "#define USE_LIGHTMAP" : "",
        parameters.aoMap ? "#define USE_AOMAP" : "",
        parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        parameters.bumpMap ? "#define USE_BUMPMAP" : "",
        parameters.normalMap ? "#define USE_NORMALMAP" : "",
        parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
        parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
        parameters.clearcoat ? "#define USE_CLEARCOAT" : "",
        parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        parameters.specularMap ? "#define USE_SPECULARMAP" : "",
        parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
        parameters.specularTintMap ? "#define USE_SPECULARTINTMAP" : "",
        parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
        parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
        parameters.alphaTest ? "#define USE_ALPHATEST" : "",
        parameters.sheen ? "#define USE_SHEEN" : "",
        parameters.transmission ? "#define USE_TRANSMISSION" : "",
        parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        parameters.vertexTangents ? "#define USE_TANGENT" : "",
        parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "",
        parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        parameters.vertexUvs ? "#define USE_UV" : "",
        parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
        parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
        parameters.flatShading ? "#define FLAT_SHADED" : "",
        parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
        parameters.flipSided ? "#define FLIP_SIDED" : "",
        parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
        parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
        parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
        (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
        parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
        parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
        parameters.dithering ? "#define DITHERING" : "",
        parameters.format === RGBFormat ? "#define OPAQUE" : "",
        ShaderChunk["encodings_pars_fragment"],
        parameters.map ? getTexelDecodingFunction("mapTexelToLinear", parameters.mapEncoding) : "",
        parameters.matcap ? getTexelDecodingFunction("matcapTexelToLinear", parameters.matcapEncoding) : "",
        parameters.envMap ? getTexelDecodingFunction("envMapTexelToLinear", parameters.envMapEncoding) : "",
        parameters.emissiveMap ? getTexelDecodingFunction("emissiveMapTexelToLinear", parameters.emissiveMapEncoding) : "",
        parameters.specularTintMap ? getTexelDecodingFunction("specularTintMapTexelToLinear", parameters.specularTintMapEncoding) : "",
        parameters.lightMap ? getTexelDecodingFunction("lightMapTexelToLinear", parameters.lightMapEncoding) : "",
        getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding),
        parameters.depthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
        "\n"
      ].filter(filterEmptyLine).join("\n");
    }
    vertexShader = resolveIncludes(vertexShader);
    vertexShader = replaceLightNums(vertexShader, parameters);
    vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
    fragmentShader = resolveIncludes(fragmentShader);
    fragmentShader = replaceLightNums(fragmentShader, parameters);
    fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
    vertexShader = unrollLoops(vertexShader);
    fragmentShader = unrollLoops(fragmentShader);
    if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
      versionString = "#version 300 es\n";
      prefixVertex = [
        "precision mediump sampler2DArray;",
        "#define attribute in",
        "#define varying out",
        "#define texture2D texture"
      ].join("\n") + "\n" + prefixVertex;
      prefixFragment = [
        "#define varying in",
        parameters.glslVersion === GLSL3 ? "" : "out highp vec4 pc_fragColor;",
        parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
        "#define gl_FragDepthEXT gl_FragDepth",
        "#define texture2D texture",
        "#define textureCube texture",
        "#define texture2DProj textureProj",
        "#define texture2DLodEXT textureLod",
        "#define texture2DProjLodEXT textureProjLod",
        "#define textureCubeLodEXT textureLod",
        "#define texture2DGradEXT textureGrad",
        "#define texture2DProjGradEXT textureProjGrad",
        "#define textureCubeGradEXT textureGrad"
      ].join("\n") + "\n" + prefixFragment;
    }
    const vertexGlsl = versionString + prefixVertex + vertexShader;
    const fragmentGlsl = versionString + prefixFragment + fragmentShader;
    const glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
    const glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
    gl.attachShader(program, glVertexShader);
    gl.attachShader(program, glFragmentShader);
    if (parameters.index0AttributeName !== void 0) {
      gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
    } else if (parameters.morphTargets === true) {
      gl.bindAttribLocation(program, 0, "position");
    }
    gl.linkProgram(program);
    if (renderer2.debug.checkShaderErrors) {
      const programLog = gl.getProgramInfoLog(program).trim();
      const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
      const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
      let runnable = true;
      let haveDiagnostics = true;
      if (gl.getProgramParameter(program, 35714) === false) {
        runnable = false;
        const vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
        const fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
        console.error("THREE.WebGLProgram: Shader Error " + gl.getError() + " - VALIDATE_STATUS " + gl.getProgramParameter(program, 35715) + "\n\nProgram Info Log: " + programLog + "\n" + vertexErrors + "\n" + fragmentErrors);
      } else if (programLog !== "") {
        console.warn("THREE.WebGLProgram: Program Info Log:", programLog);
      } else if (vertexLog === "" || fragmentLog === "") {
        haveDiagnostics = false;
      }
      if (haveDiagnostics) {
        this.diagnostics = {
          runnable,
          programLog,
          vertexShader: {
            log: vertexLog,
            prefix: prefixVertex
          },
          fragmentShader: {
            log: fragmentLog,
            prefix: prefixFragment
          }
        };
      }
    }
    gl.deleteShader(glVertexShader);
    gl.deleteShader(glFragmentShader);
    let cachedUniforms;
    this.getUniforms = function() {
      if (cachedUniforms === void 0) {
        cachedUniforms = new WebGLUniforms(gl, program);
      }
      return cachedUniforms;
    };
    let cachedAttributes;
    this.getAttributes = function() {
      if (cachedAttributes === void 0) {
        cachedAttributes = fetchAttributeLocations(gl, program);
      }
      return cachedAttributes;
    };
    this.destroy = function() {
      bindingStates.releaseStatesOfProgram(this);
      gl.deleteProgram(program);
      this.program = void 0;
    };
    this.name = parameters.shaderName;
    this.id = programIdCount++;
    this.cacheKey = cacheKey;
    this.usedTimes = 1;
    this.program = program;
    this.vertexShader = glVertexShader;
    this.fragmentShader = glFragmentShader;
    return this;
  }
  function WebGLPrograms(renderer2, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
    const programs = [];
    const isWebGL2 = capabilities.isWebGL2;
    const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
    const floatVertexTextures = capabilities.floatVertexTextures;
    const maxVertexUniforms = capabilities.maxVertexUniforms;
    const vertexTextures = capabilities.vertexTextures;
    let precision = capabilities.precision;
    const shaderIDs = {
      MeshDepthMaterial: "depth",
      MeshDistanceMaterial: "distanceRGBA",
      MeshNormalMaterial: "normal",
      MeshBasicMaterial: "basic",
      MeshLambertMaterial: "lambert",
      MeshPhongMaterial: "phong",
      MeshToonMaterial: "toon",
      MeshStandardMaterial: "physical",
      MeshPhysicalMaterial: "physical",
      MeshMatcapMaterial: "matcap",
      LineBasicMaterial: "basic",
      LineDashedMaterial: "dashed",
      PointsMaterial: "points",
      ShadowMaterial: "shadow",
      SpriteMaterial: "sprite"
    };
    const parameterNames = [
      "precision",
      "isWebGL2",
      "supportsVertexTextures",
      "outputEncoding",
      "instancing",
      "instancingColor",
      "map",
      "mapEncoding",
      "matcap",
      "matcapEncoding",
      "envMap",
      "envMapMode",
      "envMapEncoding",
      "envMapCubeUV",
      "lightMap",
      "lightMapEncoding",
      "aoMap",
      "emissiveMap",
      "emissiveMapEncoding",
      "bumpMap",
      "normalMap",
      "objectSpaceNormalMap",
      "tangentSpaceNormalMap",
      "clearcoat",
      "clearcoatMap",
      "clearcoatRoughnessMap",
      "clearcoatNormalMap",
      "displacementMap",
      "specularMap",
      "specularIntensityMap",
      "specularTintMap",
      "specularTintMapEncoding",
      "roughnessMap",
      "metalnessMap",
      "gradientMap",
      "alphaMap",
      "alphaTest",
      "combine",
      "vertexColors",
      "vertexAlphas",
      "vertexTangents",
      "vertexUvs",
      "uvsVertexOnly",
      "fog",
      "useFog",
      "fogExp2",
      "flatShading",
      "sizeAttenuation",
      "logarithmicDepthBuffer",
      "skinning",
      "maxBones",
      "useVertexTexture",
      "morphTargets",
      "morphNormals",
      "morphTargetsCount",
      "premultipliedAlpha",
      "numDirLights",
      "numPointLights",
      "numSpotLights",
      "numHemiLights",
      "numRectAreaLights",
      "numDirLightShadows",
      "numPointLightShadows",
      "numSpotLightShadows",
      "shadowMapEnabled",
      "shadowMapType",
      "toneMapping",
      "physicallyCorrectLights",
      "doubleSided",
      "flipSided",
      "numClippingPlanes",
      "numClipIntersection",
      "depthPacking",
      "dithering",
      "format",
      "sheen",
      "transmission",
      "transmissionMap",
      "thicknessMap"
    ];
    function getMaxBones(object) {
      const skeleton = object.skeleton;
      const bones = skeleton.bones;
      if (floatVertexTextures) {
        return 1024;
      } else {
        const nVertexUniforms = maxVertexUniforms;
        const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
        const maxBones = Math.min(nVertexMatrices, bones.length);
        if (maxBones < bones.length) {
          console.warn("THREE.WebGLRenderer: Skeleton has " + bones.length + " bones. This GPU supports " + maxBones + ".");
          return 0;
        }
        return maxBones;
      }
    }
    function getTextureEncodingFromMap(map) {
      let encoding;
      if (map && map.isTexture) {
        encoding = map.encoding;
      } else if (map && map.isWebGLRenderTarget) {
        console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
        encoding = map.texture.encoding;
      } else {
        encoding = LinearEncoding;
      }
      if (isWebGL2 && map && map.isTexture && map.format === RGBAFormat && map.type === UnsignedByteType && map.encoding === sRGBEncoding) {
        encoding = LinearEncoding;
      }
      return encoding;
    }
    function getParameters(material, lights, shadows, scene2, object) {
      const fog = scene2.fog;
      const environment = material.isMeshStandardMaterial ? scene2.environment : null;
      const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
      const shaderID = shaderIDs[material.type];
      const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;
      if (material.precision !== null) {
        precision = capabilities.getMaxPrecision(material.precision);
        if (precision !== material.precision) {
          console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
        }
      }
      let vertexShader, fragmentShader;
      if (shaderID) {
        const shader = ShaderLib[shaderID];
        vertexShader = shader.vertexShader;
        fragmentShader = shader.fragmentShader;
      } else {
        vertexShader = material.vertexShader;
        fragmentShader = material.fragmentShader;
      }
      const currentRenderTarget = renderer2.getRenderTarget();
      const useAlphaTest = material.alphaTest > 0;
      const useClearcoat = material.clearcoat > 0;
      const parameters = {
        isWebGL2,
        shaderID,
        shaderName: material.type,
        vertexShader,
        fragmentShader,
        defines: material.defines,
        isRawShaderMaterial: material.isRawShaderMaterial === true,
        glslVersion: material.glslVersion,
        precision,
        instancing: object.isInstancedMesh === true,
        instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
        supportsVertexTextures: vertexTextures,
        outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer2.outputEncoding,
        map: !!material.map,
        mapEncoding: getTextureEncodingFromMap(material.map),
        matcap: !!material.matcap,
        matcapEncoding: getTextureEncodingFromMap(material.matcap),
        envMap: !!envMap,
        envMapMode: envMap && envMap.mapping,
        envMapEncoding: getTextureEncodingFromMap(envMap),
        envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
        lightMap: !!material.lightMap,
        lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
        aoMap: !!material.aoMap,
        emissiveMap: !!material.emissiveMap,
        emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
        bumpMap: !!material.bumpMap,
        normalMap: !!material.normalMap,
        objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
        tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
        clearcoat: useClearcoat,
        clearcoatMap: useClearcoat && !!material.clearcoatMap,
        clearcoatRoughnessMap: useClearcoat && !!material.clearcoatRoughnessMap,
        clearcoatNormalMap: useClearcoat && !!material.clearcoatNormalMap,
        displacementMap: !!material.displacementMap,
        roughnessMap: !!material.roughnessMap,
        metalnessMap: !!material.metalnessMap,
        specularMap: !!material.specularMap,
        specularIntensityMap: !!material.specularIntensityMap,
        specularTintMap: !!material.specularTintMap,
        specularTintMapEncoding: getTextureEncodingFromMap(material.specularTintMap),
        alphaMap: !!material.alphaMap,
        alphaTest: useAlphaTest,
        gradientMap: !!material.gradientMap,
        sheen: material.sheen > 0,
        transmission: material.transmission > 0,
        transmissionMap: !!material.transmissionMap,
        thicknessMap: !!material.thicknessMap,
        combine: material.combine,
        vertexTangents: !!material.normalMap && !!object.geometry && !!object.geometry.attributes.tangent,
        vertexColors: material.vertexColors,
        vertexAlphas: material.vertexColors === true && !!object.geometry && !!object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4,
        vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularTintMap,
        uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || material.transmission > 0 || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularTintMap) && !!material.displacementMap,
        fog: !!fog,
        useFog: material.fog,
        fogExp2: fog && fog.isFogExp2,
        flatShading: !!material.flatShading,
        sizeAttenuation: material.sizeAttenuation,
        logarithmicDepthBuffer,
        skinning: object.isSkinnedMesh === true && maxBones > 0,
        maxBones,
        useVertexTexture: floatVertexTextures,
        morphTargets: !!object.geometry && !!object.geometry.morphAttributes.position,
        morphNormals: !!object.geometry && !!object.geometry.morphAttributes.normal,
        morphTargetsCount: !!object.geometry && !!object.geometry.morphAttributes.position ? object.geometry.morphAttributes.position.length : 0,
        numDirLights: lights.directional.length,
        numPointLights: lights.point.length,
        numSpotLights: lights.spot.length,
        numRectAreaLights: lights.rectArea.length,
        numHemiLights: lights.hemi.length,
        numDirLightShadows: lights.directionalShadowMap.length,
        numPointLightShadows: lights.pointShadowMap.length,
        numSpotLightShadows: lights.spotShadowMap.length,
        numClippingPlanes: clipping.numPlanes,
        numClipIntersection: clipping.numIntersection,
        format: material.format,
        dithering: material.dithering,
        shadowMapEnabled: renderer2.shadowMap.enabled && shadows.length > 0,
        shadowMapType: renderer2.shadowMap.type,
        toneMapping: material.toneMapped ? renderer2.toneMapping : NoToneMapping,
        physicallyCorrectLights: renderer2.physicallyCorrectLights,
        premultipliedAlpha: material.premultipliedAlpha,
        doubleSided: material.side === DoubleSide,
        flipSided: material.side === BackSide,
        depthPacking: material.depthPacking !== void 0 ? material.depthPacking : false,
        index0AttributeName: material.index0AttributeName,
        extensionDerivatives: material.extensions && material.extensions.derivatives,
        extensionFragDepth: material.extensions && material.extensions.fragDepth,
        extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
        extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
        rendererExtensionFragDepth: isWebGL2 || extensions.has("EXT_frag_depth"),
        rendererExtensionDrawBuffers: isWebGL2 || extensions.has("WEBGL_draw_buffers"),
        rendererExtensionShaderTextureLod: isWebGL2 || extensions.has("EXT_shader_texture_lod"),
        customProgramCacheKey: material.customProgramCacheKey()
      };
      return parameters;
    }
    function getProgramCacheKey(parameters) {
      const array = [];
      if (parameters.shaderID) {
        array.push(parameters.shaderID);
      } else {
        array.push(parameters.fragmentShader);
        array.push(parameters.vertexShader);
      }
      if (parameters.defines !== void 0) {
        for (const name in parameters.defines) {
          array.push(name);
          array.push(parameters.defines[name]);
        }
      }
      if (parameters.isRawShaderMaterial === false) {
        for (let i2 = 0; i2 < parameterNames.length; i2++) {
          array.push(parameters[parameterNames[i2]]);
        }
        array.push(renderer2.outputEncoding);
        array.push(renderer2.gammaFactor);
      }
      array.push(parameters.customProgramCacheKey);
      return array.join();
    }
    function getUniforms(material) {
      const shaderID = shaderIDs[material.type];
      let uniforms;
      if (shaderID) {
        const shader = ShaderLib[shaderID];
        uniforms = UniformsUtils.clone(shader.uniforms);
      } else {
        uniforms = material.uniforms;
      }
      return uniforms;
    }
    function acquireProgram(parameters, cacheKey) {
      let program;
      for (let p2 = 0, pl = programs.length; p2 < pl; p2++) {
        const preexistingProgram = programs[p2];
        if (preexistingProgram.cacheKey === cacheKey) {
          program = preexistingProgram;
          ++program.usedTimes;
          break;
        }
      }
      if (program === void 0) {
        program = new WebGLProgram(renderer2, cacheKey, parameters, bindingStates);
        programs.push(program);
      }
      return program;
    }
    function releaseProgram(program) {
      if (--program.usedTimes === 0) {
        const i2 = programs.indexOf(program);
        programs[i2] = programs[programs.length - 1];
        programs.pop();
        program.destroy();
      }
    }
    return {
      getParameters,
      getProgramCacheKey,
      getUniforms,
      acquireProgram,
      releaseProgram,
      programs
    };
  }
  function WebGLProperties() {
    let properties = new WeakMap();
    function get(object) {
      let map = properties.get(object);
      if (map === void 0) {
        map = {};
        properties.set(object, map);
      }
      return map;
    }
    function remove(object) {
      properties.delete(object);
    }
    function update2(object, key, value) {
      properties.get(object)[key] = value;
    }
    function dispose() {
      properties = new WeakMap();
    }
    return {
      get,
      remove,
      update: update2,
      dispose
    };
  }
  function painterSortStable(a2, b2) {
    if (a2.groupOrder !== b2.groupOrder) {
      return a2.groupOrder - b2.groupOrder;
    } else if (a2.renderOrder !== b2.renderOrder) {
      return a2.renderOrder - b2.renderOrder;
    } else if (a2.program !== b2.program) {
      return a2.program.id - b2.program.id;
    } else if (a2.material.id !== b2.material.id) {
      return a2.material.id - b2.material.id;
    } else if (a2.z !== b2.z) {
      return a2.z - b2.z;
    } else {
      return a2.id - b2.id;
    }
  }
  function reversePainterSortStable(a2, b2) {
    if (a2.groupOrder !== b2.groupOrder) {
      return a2.groupOrder - b2.groupOrder;
    } else if (a2.renderOrder !== b2.renderOrder) {
      return a2.renderOrder - b2.renderOrder;
    } else if (a2.z !== b2.z) {
      return b2.z - a2.z;
    } else {
      return a2.id - b2.id;
    }
  }
  function WebGLRenderList(properties) {
    const renderItems = [];
    let renderItemsIndex = 0;
    const opaque = [];
    const transmissive = [];
    const transparent = [];
    const defaultProgram = { id: -1 };
    function init() {
      renderItemsIndex = 0;
      opaque.length = 0;
      transmissive.length = 0;
      transparent.length = 0;
    }
    function getNextRenderItem(object, geometry, material, groupOrder, z2, group) {
      let renderItem = renderItems[renderItemsIndex];
      const materialProperties = properties.get(material);
      if (renderItem === void 0) {
        renderItem = {
          id: object.id,
          object,
          geometry,
          material,
          program: materialProperties.program || defaultProgram,
          groupOrder,
          renderOrder: object.renderOrder,
          z: z2,
          group
        };
        renderItems[renderItemsIndex] = renderItem;
      } else {
        renderItem.id = object.id;
        renderItem.object = object;
        renderItem.geometry = geometry;
        renderItem.material = material;
        renderItem.program = materialProperties.program || defaultProgram;
        renderItem.groupOrder = groupOrder;
        renderItem.renderOrder = object.renderOrder;
        renderItem.z = z2;
        renderItem.group = group;
      }
      renderItemsIndex++;
      return renderItem;
    }
    function push(object, geometry, material, groupOrder, z2, group) {
      const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z2, group);
      if (material.transmission > 0) {
        transmissive.push(renderItem);
      } else if (material.transparent === true) {
        transparent.push(renderItem);
      } else {
        opaque.push(renderItem);
      }
    }
    function unshift(object, geometry, material, groupOrder, z2, group) {
      const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z2, group);
      if (material.transmission > 0) {
        transmissive.unshift(renderItem);
      } else if (material.transparent === true) {
        transparent.unshift(renderItem);
      } else {
        opaque.unshift(renderItem);
      }
    }
    function sort(customOpaqueSort, customTransparentSort) {
      if (opaque.length > 1)
        opaque.sort(customOpaqueSort || painterSortStable);
      if (transmissive.length > 1)
        transmissive.sort(customTransparentSort || reversePainterSortStable);
      if (transparent.length > 1)
        transparent.sort(customTransparentSort || reversePainterSortStable);
    }
    function finish() {
      for (let i2 = renderItemsIndex, il = renderItems.length; i2 < il; i2++) {
        const renderItem = renderItems[i2];
        if (renderItem.id === null)
          break;
        renderItem.id = null;
        renderItem.object = null;
        renderItem.geometry = null;
        renderItem.material = null;
        renderItem.program = null;
        renderItem.group = null;
      }
    }
    return {
      opaque,
      transmissive,
      transparent,
      init,
      push,
      unshift,
      finish,
      sort
    };
  }
  function WebGLRenderLists(properties) {
    let lists = new WeakMap();
    function get(scene2, renderCallDepth) {
      let list;
      if (lists.has(scene2) === false) {
        list = new WebGLRenderList(properties);
        lists.set(scene2, [list]);
      } else {
        if (renderCallDepth >= lists.get(scene2).length) {
          list = new WebGLRenderList(properties);
          lists.get(scene2).push(list);
        } else {
          list = lists.get(scene2)[renderCallDepth];
        }
      }
      return list;
    }
    function dispose() {
      lists = new WeakMap();
    }
    return {
      get,
      dispose
    };
  }
  function UniformsCache() {
    const lights = {};
    return {
      get: function(light2) {
        if (lights[light2.id] !== void 0) {
          return lights[light2.id];
        }
        let uniforms;
        switch (light2.type) {
          case "DirectionalLight":
            uniforms = {
              direction: new Vector3(),
              color: new Color()
            };
            break;
          case "SpotLight":
            uniforms = {
              position: new Vector3(),
              direction: new Vector3(),
              color: new Color(),
              distance: 0,
              coneCos: 0,
              penumbraCos: 0,
              decay: 0
            };
            break;
          case "PointLight":
            uniforms = {
              position: new Vector3(),
              color: new Color(),
              distance: 0,
              decay: 0
            };
            break;
          case "HemisphereLight":
            uniforms = {
              direction: new Vector3(),
              skyColor: new Color(),
              groundColor: new Color()
            };
            break;
          case "RectAreaLight":
            uniforms = {
              color: new Color(),
              position: new Vector3(),
              halfWidth: new Vector3(),
              halfHeight: new Vector3()
            };
            break;
        }
        lights[light2.id] = uniforms;
        return uniforms;
      }
    };
  }
  function ShadowUniformsCache() {
    const lights = {};
    return {
      get: function(light2) {
        if (lights[light2.id] !== void 0) {
          return lights[light2.id];
        }
        let uniforms;
        switch (light2.type) {
          case "DirectionalLight":
            uniforms = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2()
            };
            break;
          case "SpotLight":
            uniforms = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2()
            };
            break;
          case "PointLight":
            uniforms = {
              shadowBias: 0,
              shadowNormalBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2(),
              shadowCameraNear: 1,
              shadowCameraFar: 1e3
            };
            break;
        }
        lights[light2.id] = uniforms;
        return uniforms;
      }
    };
  }
  var nextVersion = 0;
  function shadowCastingLightsFirst(lightA, lightB) {
    return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
  }
  function WebGLLights(extensions, capabilities) {
    const cache = new UniformsCache();
    const shadowCache = ShadowUniformsCache();
    const state2 = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotShadow: [],
      spotShadowMap: [],
      spotShadowMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: []
    };
    for (let i2 = 0; i2 < 9; i2++)
      state2.probe.push(new Vector3());
    const vector3 = new Vector3();
    const matrix4 = new Matrix4();
    const matrix42 = new Matrix4();
    function setup(lights, physicallyCorrectLights) {
      let r2 = 0, g2 = 0, b2 = 0;
      for (let i2 = 0; i2 < 9; i2++)
        state2.probe[i2].set(0, 0, 0);
      let directionalLength = 0;
      let pointLength = 0;
      let spotLength = 0;
      let rectAreaLength = 0;
      let hemiLength = 0;
      let numDirectionalShadows = 0;
      let numPointShadows = 0;
      let numSpotShadows = 0;
      lights.sort(shadowCastingLightsFirst);
      const scaleFactor = physicallyCorrectLights !== true ? Math.PI : 1;
      for (let i2 = 0, l2 = lights.length; i2 < l2; i2++) {
        const light2 = lights[i2];
        const color = light2.color;
        const intensity = light2.intensity;
        const distance = light2.distance;
        const shadowMap = light2.shadow && light2.shadow.map ? light2.shadow.map.texture : null;
        if (light2.isAmbientLight) {
          r2 += color.r * intensity * scaleFactor;
          g2 += color.g * intensity * scaleFactor;
          b2 += color.b * intensity * scaleFactor;
        } else if (light2.isLightProbe) {
          for (let j2 = 0; j2 < 9; j2++) {
            state2.probe[j2].addScaledVector(light2.sh.coefficients[j2], intensity);
          }
        } else if (light2.isDirectionalLight) {
          const uniforms = cache.get(light2);
          uniforms.color.copy(light2.color).multiplyScalar(light2.intensity * scaleFactor);
          if (light2.castShadow) {
            const shadow = light2.shadow;
            const shadowUniforms = shadowCache.get(light2);
            shadowUniforms.shadowBias = shadow.bias;
            shadowUniforms.shadowNormalBias = shadow.normalBias;
            shadowUniforms.shadowRadius = shadow.radius;
            shadowUniforms.shadowMapSize = shadow.mapSize;
            state2.directionalShadow[directionalLength] = shadowUniforms;
            state2.directionalShadowMap[directionalLength] = shadowMap;
            state2.directionalShadowMatrix[directionalLength] = light2.shadow.matrix;
            numDirectionalShadows++;
          }
          state2.directional[directionalLength] = uniforms;
          directionalLength++;
        } else if (light2.isSpotLight) {
          const uniforms = cache.get(light2);
          uniforms.position.setFromMatrixPosition(light2.matrixWorld);
          uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor);
          uniforms.distance = distance;
          uniforms.coneCos = Math.cos(light2.angle);
          uniforms.penumbraCos = Math.cos(light2.angle * (1 - light2.penumbra));
          uniforms.decay = light2.decay;
          if (light2.castShadow) {
            const shadow = light2.shadow;
            const shadowUniforms = shadowCache.get(light2);
            shadowUniforms.shadowBias = shadow.bias;
            shadowUniforms.shadowNormalBias = shadow.normalBias;
            shadowUniforms.shadowRadius = shadow.radius;
            shadowUniforms.shadowMapSize = shadow.mapSize;
            state2.spotShadow[spotLength] = shadowUniforms;
            state2.spotShadowMap[spotLength] = shadowMap;
            state2.spotShadowMatrix[spotLength] = light2.shadow.matrix;
            numSpotShadows++;
          }
          state2.spot[spotLength] = uniforms;
          spotLength++;
        } else if (light2.isRectAreaLight) {
          const uniforms = cache.get(light2);
          uniforms.color.copy(color).multiplyScalar(intensity);
          uniforms.halfWidth.set(light2.width * 0.5, 0, 0);
          uniforms.halfHeight.set(0, light2.height * 0.5, 0);
          state2.rectArea[rectAreaLength] = uniforms;
          rectAreaLength++;
        } else if (light2.isPointLight) {
          const uniforms = cache.get(light2);
          uniforms.color.copy(light2.color).multiplyScalar(light2.intensity * scaleFactor);
          uniforms.distance = light2.distance;
          uniforms.decay = light2.decay;
          if (light2.castShadow) {
            const shadow = light2.shadow;
            const shadowUniforms = shadowCache.get(light2);
            shadowUniforms.shadowBias = shadow.bias;
            shadowUniforms.shadowNormalBias = shadow.normalBias;
            shadowUniforms.shadowRadius = shadow.radius;
            shadowUniforms.shadowMapSize = shadow.mapSize;
            shadowUniforms.shadowCameraNear = shadow.camera.near;
            shadowUniforms.shadowCameraFar = shadow.camera.far;
            state2.pointShadow[pointLength] = shadowUniforms;
            state2.pointShadowMap[pointLength] = shadowMap;
            state2.pointShadowMatrix[pointLength] = light2.shadow.matrix;
            numPointShadows++;
          }
          state2.point[pointLength] = uniforms;
          pointLength++;
        } else if (light2.isHemisphereLight) {
          const uniforms = cache.get(light2);
          uniforms.skyColor.copy(light2.color).multiplyScalar(intensity * scaleFactor);
          uniforms.groundColor.copy(light2.groundColor).multiplyScalar(intensity * scaleFactor);
          state2.hemi[hemiLength] = uniforms;
          hemiLength++;
        }
      }
      if (rectAreaLength > 0) {
        if (capabilities.isWebGL2) {
          state2.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
          state2.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
        } else {
          if (extensions.has("OES_texture_float_linear") === true) {
            state2.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
            state2.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
          } else if (extensions.has("OES_texture_half_float_linear") === true) {
            state2.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
            state2.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
          } else {
            console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.");
          }
        }
      }
      state2.ambient[0] = r2;
      state2.ambient[1] = g2;
      state2.ambient[2] = b2;
      const hash = state2.hash;
      if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
        state2.directional.length = directionalLength;
        state2.spot.length = spotLength;
        state2.rectArea.length = rectAreaLength;
        state2.point.length = pointLength;
        state2.hemi.length = hemiLength;
        state2.directionalShadow.length = numDirectionalShadows;
        state2.directionalShadowMap.length = numDirectionalShadows;
        state2.pointShadow.length = numPointShadows;
        state2.pointShadowMap.length = numPointShadows;
        state2.spotShadow.length = numSpotShadows;
        state2.spotShadowMap.length = numSpotShadows;
        state2.directionalShadowMatrix.length = numDirectionalShadows;
        state2.pointShadowMatrix.length = numPointShadows;
        state2.spotShadowMatrix.length = numSpotShadows;
        hash.directionalLength = directionalLength;
        hash.pointLength = pointLength;
        hash.spotLength = spotLength;
        hash.rectAreaLength = rectAreaLength;
        hash.hemiLength = hemiLength;
        hash.numDirectionalShadows = numDirectionalShadows;
        hash.numPointShadows = numPointShadows;
        hash.numSpotShadows = numSpotShadows;
        state2.version = nextVersion++;
      }
    }
    function setupView(lights, camera2) {
      let directionalLength = 0;
      let pointLength = 0;
      let spotLength = 0;
      let rectAreaLength = 0;
      let hemiLength = 0;
      const viewMatrix = camera2.matrixWorldInverse;
      for (let i2 = 0, l2 = lights.length; i2 < l2; i2++) {
        const light2 = lights[i2];
        if (light2.isDirectionalLight) {
          const uniforms = state2.directional[directionalLength];
          uniforms.direction.setFromMatrixPosition(light2.matrixWorld);
          vector3.setFromMatrixPosition(light2.target.matrixWorld);
          uniforms.direction.sub(vector3);
          uniforms.direction.transformDirection(viewMatrix);
          directionalLength++;
        } else if (light2.isSpotLight) {
          const uniforms = state2.spot[spotLength];
          uniforms.position.setFromMatrixPosition(light2.matrixWorld);
          uniforms.position.applyMatrix4(viewMatrix);
          uniforms.direction.setFromMatrixPosition(light2.matrixWorld);
          vector3.setFromMatrixPosition(light2.target.matrixWorld);
          uniforms.direction.sub(vector3);
          uniforms.direction.transformDirection(viewMatrix);
          spotLength++;
        } else if (light2.isRectAreaLight) {
          const uniforms = state2.rectArea[rectAreaLength];
          uniforms.position.setFromMatrixPosition(light2.matrixWorld);
          uniforms.position.applyMatrix4(viewMatrix);
          matrix42.identity();
          matrix4.copy(light2.matrixWorld);
          matrix4.premultiply(viewMatrix);
          matrix42.extractRotation(matrix4);
          uniforms.halfWidth.set(light2.width * 0.5, 0, 0);
          uniforms.halfHeight.set(0, light2.height * 0.5, 0);
          uniforms.halfWidth.applyMatrix4(matrix42);
          uniforms.halfHeight.applyMatrix4(matrix42);
          rectAreaLength++;
        } else if (light2.isPointLight) {
          const uniforms = state2.point[pointLength];
          uniforms.position.setFromMatrixPosition(light2.matrixWorld);
          uniforms.position.applyMatrix4(viewMatrix);
          pointLength++;
        } else if (light2.isHemisphereLight) {
          const uniforms = state2.hemi[hemiLength];
          uniforms.direction.setFromMatrixPosition(light2.matrixWorld);
          uniforms.direction.transformDirection(viewMatrix);
          uniforms.direction.normalize();
          hemiLength++;
        }
      }
    }
    return {
      setup,
      setupView,
      state: state2
    };
  }
  function WebGLRenderState(extensions, capabilities) {
    const lights = new WebGLLights(extensions, capabilities);
    const lightsArray = [];
    const shadowsArray = [];
    function init() {
      lightsArray.length = 0;
      shadowsArray.length = 0;
    }
    function pushLight(light2) {
      lightsArray.push(light2);
    }
    function pushShadow(shadowLight) {
      shadowsArray.push(shadowLight);
    }
    function setupLights(physicallyCorrectLights) {
      lights.setup(lightsArray, physicallyCorrectLights);
    }
    function setupLightsView(camera2) {
      lights.setupView(lightsArray, camera2);
    }
    const state2 = {
      lightsArray,
      shadowsArray,
      lights
    };
    return {
      init,
      state: state2,
      setupLights,
      setupLightsView,
      pushLight,
      pushShadow
    };
  }
  function WebGLRenderStates(extensions, capabilities) {
    let renderStates = new WeakMap();
    function get(scene2, renderCallDepth = 0) {
      let renderState;
      if (renderStates.has(scene2) === false) {
        renderState = new WebGLRenderState(extensions, capabilities);
        renderStates.set(scene2, [renderState]);
      } else {
        if (renderCallDepth >= renderStates.get(scene2).length) {
          renderState = new WebGLRenderState(extensions, capabilities);
          renderStates.get(scene2).push(renderState);
        } else {
          renderState = renderStates.get(scene2)[renderCallDepth];
        }
      }
      return renderState;
    }
    function dispose() {
      renderStates = new WeakMap();
    }
    return {
      get,
      dispose
    };
  }
  var MeshDepthMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.type = "MeshDepthMaterial";
      this.depthPacking = BasicDepthPacking;
      this.map = null;
      this.alphaMap = null;
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.fog = false;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.depthPacking = source.depthPacking;
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      return this;
    }
  };
  MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
  var MeshDistanceMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.type = "MeshDistanceMaterial";
      this.referencePosition = new Vector3();
      this.nearDistance = 1;
      this.farDistance = 1e3;
      this.map = null;
      this.alphaMap = null;
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.fog = false;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.referencePosition.copy(source.referencePosition);
      this.nearDistance = source.nearDistance;
      this.farDistance = source.farDistance;
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      return this;
    }
  };
  MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
  var vertex = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
  var fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\nuniform float samples;\n#include <packing>\nvoid main() {\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
  function WebGLShadowMap(_renderer, _objects, _capabilities) {
    let _frustum = new Frustum();
    const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), _distanceMaterial = new MeshDistanceMaterial(), _materialCache = {}, _maxTextureSize = _capabilities.maxTextureSize;
    const shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };
    const shadowMaterialVertical = new ShaderMaterial({
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new Vector2() },
        radius: { value: 4 },
        samples: { value: 8 }
      },
      vertexShader: vertex,
      fragmentShader: fragment
    });
    const shadowMaterialHorizontal = shadowMaterialVertical.clone();
    shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
    const fullScreenTri = new BufferGeometry();
    fullScreenTri.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
    const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
    const scope = this;
    this.enabled = false;
    this.autoUpdate = true;
    this.needsUpdate = false;
    this.type = PCFShadowMap;
    this.render = function(lights, scene2, camera2) {
      if (scope.enabled === false)
        return;
      if (scope.autoUpdate === false && scope.needsUpdate === false)
        return;
      if (lights.length === 0)
        return;
      const currentRenderTarget = _renderer.getRenderTarget();
      const activeCubeFace = _renderer.getActiveCubeFace();
      const activeMipmapLevel = _renderer.getActiveMipmapLevel();
      const _state = _renderer.state;
      _state.setBlending(NoBlending);
      _state.buffers.color.setClear(1, 1, 1, 1);
      _state.buffers.depth.setTest(true);
      _state.setScissorTest(false);
      for (let i2 = 0, il = lights.length; i2 < il; i2++) {
        const light2 = lights[i2];
        const shadow = light2.shadow;
        if (shadow === void 0) {
          console.warn("THREE.WebGLShadowMap:", light2, "has no shadow.");
          continue;
        }
        if (shadow.autoUpdate === false && shadow.needsUpdate === false)
          continue;
        _shadowMapSize.copy(shadow.mapSize);
        const shadowFrameExtents = shadow.getFrameExtents();
        _shadowMapSize.multiply(shadowFrameExtents);
        _viewportSize.copy(shadow.mapSize);
        if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
          if (_shadowMapSize.x > _maxTextureSize) {
            _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
            _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
            shadow.mapSize.x = _viewportSize.x;
          }
          if (_shadowMapSize.y > _maxTextureSize) {
            _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
            _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
            shadow.mapSize.y = _viewportSize.y;
          }
        }
        if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
          const pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };
          shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
          shadow.map.texture.name = light2.name + ".shadowMap";
          shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
          shadow.camera.updateProjectionMatrix();
        }
        if (shadow.map === null) {
          const pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };
          shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
          shadow.map.texture.name = light2.name + ".shadowMap";
          shadow.camera.updateProjectionMatrix();
        }
        _renderer.setRenderTarget(shadow.map);
        _renderer.clear();
        const viewportCount = shadow.getViewportCount();
        for (let vp = 0; vp < viewportCount; vp++) {
          const viewport = shadow.getViewport(vp);
          _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
          _state.viewport(_viewport);
          shadow.updateMatrices(light2, vp);
          _frustum = shadow.getFrustum();
          renderObject(scene2, camera2, shadow.camera, light2, this.type);
        }
        if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
          VSMPass(shadow, camera2);
        }
        shadow.needsUpdate = false;
      }
      scope.needsUpdate = false;
      _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
    };
    function VSMPass(shadow, camera2) {
      const geometry = _objects.update(fullScreenMesh);
      shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
      shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
      shadowMaterialVertical.uniforms.radius.value = shadow.radius;
      shadowMaterialVertical.uniforms.samples.value = shadow.blurSamples;
      _renderer.setRenderTarget(shadow.mapPass);
      _renderer.clear();
      _renderer.renderBufferDirect(camera2, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
      shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
      shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
      shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
      shadowMaterialHorizontal.uniforms.samples.value = shadow.blurSamples;
      _renderer.setRenderTarget(shadow.map);
      _renderer.clear();
      _renderer.renderBufferDirect(camera2, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
    }
    function getDepthMaterial(object, geometry, material, light2, shadowCameraNear, shadowCameraFar, type) {
      let result = null;
      const customMaterial = light2.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;
      if (customMaterial !== void 0) {
        result = customMaterial;
      } else {
        result = light2.isPointLight === true ? _distanceMaterial : _depthMaterial;
      }
      if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0) {
        const keyA = result.uuid, keyB = material.uuid;
        let materialsForVariant = _materialCache[keyA];
        if (materialsForVariant === void 0) {
          materialsForVariant = {};
          _materialCache[keyA] = materialsForVariant;
        }
        let cachedMaterial = materialsForVariant[keyB];
        if (cachedMaterial === void 0) {
          cachedMaterial = result.clone();
          materialsForVariant[keyB] = cachedMaterial;
        }
        result = cachedMaterial;
      }
      result.visible = material.visible;
      result.wireframe = material.wireframe;
      if (type === VSMShadowMap) {
        result.side = material.shadowSide !== null ? material.shadowSide : material.side;
      } else {
        result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
      }
      result.alphaMap = material.alphaMap;
      result.alphaTest = material.alphaTest;
      result.clipShadows = material.clipShadows;
      result.clippingPlanes = material.clippingPlanes;
      result.clipIntersection = material.clipIntersection;
      result.displacementMap = material.displacementMap;
      result.displacementScale = material.displacementScale;
      result.displacementBias = material.displacementBias;
      result.wireframeLinewidth = material.wireframeLinewidth;
      result.linewidth = material.linewidth;
      if (light2.isPointLight === true && result.isMeshDistanceMaterial === true) {
        result.referencePosition.setFromMatrixPosition(light2.matrixWorld);
        result.nearDistance = shadowCameraNear;
        result.farDistance = shadowCameraFar;
      }
      return result;
    }
    function renderObject(object, camera2, shadowCamera, light2, type) {
      if (object.visible === false)
        return;
      const visible = object.layers.test(camera2.layers);
      if (visible && (object.isMesh || object.isLine || object.isPoints)) {
        if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
          object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
          const geometry = _objects.update(object);
          const material = object.material;
          if (Array.isArray(material)) {
            const groups = geometry.groups;
            for (let k2 = 0, kl = groups.length; k2 < kl; k2++) {
              const group = groups[k2];
              const groupMaterial = material[group.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                const depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light2, shadowCamera.near, shadowCamera.far, type);
                _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
              }
            }
          } else if (material.visible) {
            const depthMaterial = getDepthMaterial(object, geometry, material, light2, shadowCamera.near, shadowCamera.far, type);
            _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
          }
        }
      }
      const children = object.children;
      for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
        renderObject(children[i2], camera2, shadowCamera, light2, type);
      }
    }
  }
  function WebGLState(gl, extensions, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    function ColorBuffer() {
      let locked = false;
      const color = new Vector4();
      let currentColorMask = null;
      const currentColorClear = new Vector4(0, 0, 0, 0);
      return {
        setMask: function(colorMask) {
          if (currentColorMask !== colorMask && !locked) {
            gl.colorMask(colorMask, colorMask, colorMask, colorMask);
            currentColorMask = colorMask;
          }
        },
        setLocked: function(lock) {
          locked = lock;
        },
        setClear: function(r2, g2, b2, a2, premultipliedAlpha) {
          if (premultipliedAlpha === true) {
            r2 *= a2;
            g2 *= a2;
            b2 *= a2;
          }
          color.set(r2, g2, b2, a2);
          if (currentColorClear.equals(color) === false) {
            gl.clearColor(r2, g2, b2, a2);
            currentColorClear.copy(color);
          }
        },
        reset: function() {
          locked = false;
          currentColorMask = null;
          currentColorClear.set(-1, 0, 0, 0);
        }
      };
    }
    function DepthBuffer() {
      let locked = false;
      let currentDepthMask = null;
      let currentDepthFunc = null;
      let currentDepthClear = null;
      return {
        setTest: function(depthTest) {
          if (depthTest) {
            enable(2929);
          } else {
            disable(2929);
          }
        },
        setMask: function(depthMask) {
          if (currentDepthMask !== depthMask && !locked) {
            gl.depthMask(depthMask);
            currentDepthMask = depthMask;
          }
        },
        setFunc: function(depthFunc) {
          if (currentDepthFunc !== depthFunc) {
            if (depthFunc) {
              switch (depthFunc) {
                case NeverDepth:
                  gl.depthFunc(512);
                  break;
                case AlwaysDepth:
                  gl.depthFunc(519);
                  break;
                case LessDepth:
                  gl.depthFunc(513);
                  break;
                case LessEqualDepth:
                  gl.depthFunc(515);
                  break;
                case EqualDepth:
                  gl.depthFunc(514);
                  break;
                case GreaterEqualDepth:
                  gl.depthFunc(518);
                  break;
                case GreaterDepth:
                  gl.depthFunc(516);
                  break;
                case NotEqualDepth:
                  gl.depthFunc(517);
                  break;
                default:
                  gl.depthFunc(515);
              }
            } else {
              gl.depthFunc(515);
            }
            currentDepthFunc = depthFunc;
          }
        },
        setLocked: function(lock) {
          locked = lock;
        },
        setClear: function(depth) {
          if (currentDepthClear !== depth) {
            gl.clearDepth(depth);
            currentDepthClear = depth;
          }
        },
        reset: function() {
          locked = false;
          currentDepthMask = null;
          currentDepthFunc = null;
          currentDepthClear = null;
        }
      };
    }
    function StencilBuffer() {
      let locked = false;
      let currentStencilMask = null;
      let currentStencilFunc = null;
      let currentStencilRef = null;
      let currentStencilFuncMask = null;
      let currentStencilFail = null;
      let currentStencilZFail = null;
      let currentStencilZPass = null;
      let currentStencilClear = null;
      return {
        setTest: function(stencilTest) {
          if (!locked) {
            if (stencilTest) {
              enable(2960);
            } else {
              disable(2960);
            }
          }
        },
        setMask: function(stencilMask) {
          if (currentStencilMask !== stencilMask && !locked) {
            gl.stencilMask(stencilMask);
            currentStencilMask = stencilMask;
          }
        },
        setFunc: function(stencilFunc, stencilRef, stencilMask) {
          if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
            gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
            currentStencilFunc = stencilFunc;
            currentStencilRef = stencilRef;
            currentStencilFuncMask = stencilMask;
          }
        },
        setOp: function(stencilFail, stencilZFail, stencilZPass) {
          if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
            gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
            currentStencilFail = stencilFail;
            currentStencilZFail = stencilZFail;
            currentStencilZPass = stencilZPass;
          }
        },
        setLocked: function(lock) {
          locked = lock;
        },
        setClear: function(stencil) {
          if (currentStencilClear !== stencil) {
            gl.clearStencil(stencil);
            currentStencilClear = stencil;
          }
        },
        reset: function() {
          locked = false;
          currentStencilMask = null;
          currentStencilFunc = null;
          currentStencilRef = null;
          currentStencilFuncMask = null;
          currentStencilFail = null;
          currentStencilZFail = null;
          currentStencilZPass = null;
          currentStencilClear = null;
        }
      };
    }
    const colorBuffer = new ColorBuffer();
    const depthBuffer = new DepthBuffer();
    const stencilBuffer = new StencilBuffer();
    let enabledCapabilities = {};
    let xrFramebuffer = null;
    let currentBoundFramebuffers = {};
    let currentProgram = null;
    let currentBlendingEnabled = false;
    let currentBlending = null;
    let currentBlendEquation = null;
    let currentBlendSrc = null;
    let currentBlendDst = null;
    let currentBlendEquationAlpha = null;
    let currentBlendSrcAlpha = null;
    let currentBlendDstAlpha = null;
    let currentPremultipledAlpha = false;
    let currentFlipSided = null;
    let currentCullFace = null;
    let currentLineWidth = null;
    let currentPolygonOffsetFactor = null;
    let currentPolygonOffsetUnits = null;
    const maxTextures = gl.getParameter(35661);
    let lineWidthAvailable = false;
    let version = 0;
    const glVersion = gl.getParameter(7938);
    if (glVersion.indexOf("WebGL") !== -1) {
      version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
      lineWidthAvailable = version >= 1;
    } else if (glVersion.indexOf("OpenGL ES") !== -1) {
      version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
      lineWidthAvailable = version >= 2;
    }
    let currentTextureSlot = null;
    let currentBoundTextures = {};
    const scissorParam = gl.getParameter(3088);
    const viewportParam = gl.getParameter(2978);
    const currentScissor = new Vector4().fromArray(scissorParam);
    const currentViewport = new Vector4().fromArray(viewportParam);
    function createTexture(type, target, count) {
      const data = new Uint8Array(4);
      const texture = gl.createTexture();
      gl.bindTexture(type, texture);
      gl.texParameteri(type, 10241, 9728);
      gl.texParameteri(type, 10240, 9728);
      for (let i2 = 0; i2 < count; i2++) {
        gl.texImage2D(target + i2, 0, 6408, 1, 1, 0, 6408, 5121, data);
      }
      return texture;
    }
    const emptyTextures = {};
    emptyTextures[3553] = createTexture(3553, 3553, 1);
    emptyTextures[34067] = createTexture(34067, 34069, 6);
    colorBuffer.setClear(0, 0, 0, 1);
    depthBuffer.setClear(1);
    stencilBuffer.setClear(0);
    enable(2929);
    depthBuffer.setFunc(LessEqualDepth);
    setFlipSided(false);
    setCullFace(CullFaceBack);
    enable(2884);
    setBlending(NoBlending);
    function enable(id) {
      if (enabledCapabilities[id] !== true) {
        gl.enable(id);
        enabledCapabilities[id] = true;
      }
    }
    function disable(id) {
      if (enabledCapabilities[id] !== false) {
        gl.disable(id);
        enabledCapabilities[id] = false;
      }
    }
    function bindXRFramebuffer(framebuffer) {
      if (framebuffer !== xrFramebuffer) {
        gl.bindFramebuffer(36160, framebuffer);
        xrFramebuffer = framebuffer;
      }
    }
    function bindFramebuffer(target, framebuffer) {
      if (framebuffer === null && xrFramebuffer !== null)
        framebuffer = xrFramebuffer;
      if (currentBoundFramebuffers[target] !== framebuffer) {
        gl.bindFramebuffer(target, framebuffer);
        currentBoundFramebuffers[target] = framebuffer;
        if (isWebGL2) {
          if (target === 36009) {
            currentBoundFramebuffers[36160] = framebuffer;
          }
          if (target === 36160) {
            currentBoundFramebuffers[36009] = framebuffer;
          }
        }
        return true;
      }
      return false;
    }
    function useProgram(program) {
      if (currentProgram !== program) {
        gl.useProgram(program);
        currentProgram = program;
        return true;
      }
      return false;
    }
    const equationToGL = {
      [AddEquation]: 32774,
      [SubtractEquation]: 32778,
      [ReverseSubtractEquation]: 32779
    };
    if (isWebGL2) {
      equationToGL[MinEquation] = 32775;
      equationToGL[MaxEquation] = 32776;
    } else {
      const extension = extensions.get("EXT_blend_minmax");
      if (extension !== null) {
        equationToGL[MinEquation] = extension.MIN_EXT;
        equationToGL[MaxEquation] = extension.MAX_EXT;
      }
    }
    const factorToGL = {
      [ZeroFactor]: 0,
      [OneFactor]: 1,
      [SrcColorFactor]: 768,
      [SrcAlphaFactor]: 770,
      [SrcAlphaSaturateFactor]: 776,
      [DstColorFactor]: 774,
      [DstAlphaFactor]: 772,
      [OneMinusSrcColorFactor]: 769,
      [OneMinusSrcAlphaFactor]: 771,
      [OneMinusDstColorFactor]: 775,
      [OneMinusDstAlphaFactor]: 773
    };
    function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
      if (blending === NoBlending) {
        if (currentBlendingEnabled === true) {
          disable(3042);
          currentBlendingEnabled = false;
        }
        return;
      }
      if (currentBlendingEnabled === false) {
        enable(3042);
        currentBlendingEnabled = true;
      }
      if (blending !== CustomBlending) {
        if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
          if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
            gl.blendEquation(32774);
            currentBlendEquation = AddEquation;
            currentBlendEquationAlpha = AddEquation;
          }
          if (premultipliedAlpha) {
            switch (blending) {
              case NormalBlending:
                gl.blendFuncSeparate(1, 771, 1, 771);
                break;
              case AdditiveBlending:
                gl.blendFunc(1, 1);
                break;
              case SubtractiveBlending:
                gl.blendFuncSeparate(0, 0, 769, 771);
                break;
              case MultiplyBlending:
                gl.blendFuncSeparate(0, 768, 0, 770);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", blending);
                break;
            }
          } else {
            switch (blending) {
              case NormalBlending:
                gl.blendFuncSeparate(770, 771, 1, 771);
                break;
              case AdditiveBlending:
                gl.blendFunc(770, 1);
                break;
              case SubtractiveBlending:
                gl.blendFunc(0, 769);
                break;
              case MultiplyBlending:
                gl.blendFunc(0, 768);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", blending);
                break;
            }
          }
          currentBlendSrc = null;
          currentBlendDst = null;
          currentBlendSrcAlpha = null;
          currentBlendDstAlpha = null;
          currentBlending = blending;
          currentPremultipledAlpha = premultipliedAlpha;
        }
        return;
      }
      blendEquationAlpha = blendEquationAlpha || blendEquation;
      blendSrcAlpha = blendSrcAlpha || blendSrc;
      blendDstAlpha = blendDstAlpha || blendDst;
      if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
        gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
        currentBlendEquation = blendEquation;
        currentBlendEquationAlpha = blendEquationAlpha;
      }
      if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
        gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
        currentBlendSrc = blendSrc;
        currentBlendDst = blendDst;
        currentBlendSrcAlpha = blendSrcAlpha;
        currentBlendDstAlpha = blendDstAlpha;
      }
      currentBlending = blending;
      currentPremultipledAlpha = null;
    }
    function setMaterial(material, frontFaceCW) {
      material.side === DoubleSide ? disable(2884) : enable(2884);
      let flipSided = material.side === BackSide;
      if (frontFaceCW)
        flipSided = !flipSided;
      setFlipSided(flipSided);
      material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
      depthBuffer.setFunc(material.depthFunc);
      depthBuffer.setTest(material.depthTest);
      depthBuffer.setMask(material.depthWrite);
      colorBuffer.setMask(material.colorWrite);
      const stencilWrite = material.stencilWrite;
      stencilBuffer.setTest(stencilWrite);
      if (stencilWrite) {
        stencilBuffer.setMask(material.stencilWriteMask);
        stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
        stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
      }
      setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
      material.alphaToCoverage === true ? enable(32926) : disable(32926);
    }
    function setFlipSided(flipSided) {
      if (currentFlipSided !== flipSided) {
        if (flipSided) {
          gl.frontFace(2304);
        } else {
          gl.frontFace(2305);
        }
        currentFlipSided = flipSided;
      }
    }
    function setCullFace(cullFace) {
      if (cullFace !== CullFaceNone) {
        enable(2884);
        if (cullFace !== currentCullFace) {
          if (cullFace === CullFaceBack) {
            gl.cullFace(1029);
          } else if (cullFace === CullFaceFront) {
            gl.cullFace(1028);
          } else {
            gl.cullFace(1032);
          }
        }
      } else {
        disable(2884);
      }
      currentCullFace = cullFace;
    }
    function setLineWidth(width2) {
      if (width2 !== currentLineWidth) {
        if (lineWidthAvailable)
          gl.lineWidth(width2);
        currentLineWidth = width2;
      }
    }
    function setPolygonOffset(polygonOffset, factor, units) {
      if (polygonOffset) {
        enable(32823);
        if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
          gl.polygonOffset(factor, units);
          currentPolygonOffsetFactor = factor;
          currentPolygonOffsetUnits = units;
        }
      } else {
        disable(32823);
      }
    }
    function setScissorTest(scissorTest) {
      if (scissorTest) {
        enable(3089);
      } else {
        disable(3089);
      }
    }
    function activeTexture(webglSlot) {
      if (webglSlot === void 0)
        webglSlot = 33984 + maxTextures - 1;
      if (currentTextureSlot !== webglSlot) {
        gl.activeTexture(webglSlot);
        currentTextureSlot = webglSlot;
      }
    }
    function bindTexture(webglType, webglTexture) {
      if (currentTextureSlot === null) {
        activeTexture();
      }
      let boundTexture = currentBoundTextures[currentTextureSlot];
      if (boundTexture === void 0) {
        boundTexture = { type: void 0, texture: void 0 };
        currentBoundTextures[currentTextureSlot] = boundTexture;
      }
      if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
        gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
        boundTexture.type = webglType;
        boundTexture.texture = webglTexture;
      }
    }
    function unbindTexture() {
      const boundTexture = currentBoundTextures[currentTextureSlot];
      if (boundTexture !== void 0 && boundTexture.type !== void 0) {
        gl.bindTexture(boundTexture.type, null);
        boundTexture.type = void 0;
        boundTexture.texture = void 0;
      }
    }
    function compressedTexImage2D() {
      try {
        gl.compressedTexImage2D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texImage2D() {
      try {
        gl.texImage2D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texImage3D() {
      try {
        gl.texImage3D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function scissor(scissor2) {
      if (currentScissor.equals(scissor2) === false) {
        gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
        currentScissor.copy(scissor2);
      }
    }
    function viewport(viewport2) {
      if (currentViewport.equals(viewport2) === false) {
        gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
        currentViewport.copy(viewport2);
      }
    }
    function reset() {
      gl.disable(3042);
      gl.disable(2884);
      gl.disable(2929);
      gl.disable(32823);
      gl.disable(3089);
      gl.disable(2960);
      gl.disable(32926);
      gl.blendEquation(32774);
      gl.blendFunc(1, 0);
      gl.blendFuncSeparate(1, 0, 1, 0);
      gl.colorMask(true, true, true, true);
      gl.clearColor(0, 0, 0, 0);
      gl.depthMask(true);
      gl.depthFunc(513);
      gl.clearDepth(1);
      gl.stencilMask(4294967295);
      gl.stencilFunc(519, 0, 4294967295);
      gl.stencilOp(7680, 7680, 7680);
      gl.clearStencil(0);
      gl.cullFace(1029);
      gl.frontFace(2305);
      gl.polygonOffset(0, 0);
      gl.activeTexture(33984);
      gl.bindFramebuffer(36160, null);
      if (isWebGL2 === true) {
        gl.bindFramebuffer(36009, null);
        gl.bindFramebuffer(36008, null);
      }
      gl.useProgram(null);
      gl.lineWidth(1);
      gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
      enabledCapabilities = {};
      currentTextureSlot = null;
      currentBoundTextures = {};
      xrFramebuffer = null;
      currentBoundFramebuffers = {};
      currentProgram = null;
      currentBlendingEnabled = false;
      currentBlending = null;
      currentBlendEquation = null;
      currentBlendSrc = null;
      currentBlendDst = null;
      currentBlendEquationAlpha = null;
      currentBlendSrcAlpha = null;
      currentBlendDstAlpha = null;
      currentPremultipledAlpha = false;
      currentFlipSided = null;
      currentCullFace = null;
      currentLineWidth = null;
      currentPolygonOffsetFactor = null;
      currentPolygonOffsetUnits = null;
      currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
      currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
      colorBuffer.reset();
      depthBuffer.reset();
      stencilBuffer.reset();
    }
    return {
      buffers: {
        color: colorBuffer,
        depth: depthBuffer,
        stencil: stencilBuffer
      },
      enable,
      disable,
      bindFramebuffer,
      bindXRFramebuffer,
      useProgram,
      setBlending,
      setMaterial,
      setFlipSided,
      setCullFace,
      setLineWidth,
      setPolygonOffset,
      setScissorTest,
      activeTexture,
      bindTexture,
      unbindTexture,
      compressedTexImage2D,
      texImage2D,
      texImage3D,
      scissor,
      viewport,
      reset
    };
  }
  function WebGLTextures(_gl, extensions, state2, properties, capabilities, utils, info) {
    const isWebGL2 = capabilities.isWebGL2;
    const maxTextures = capabilities.maxTextures;
    const maxCubemapSize = capabilities.maxCubemapSize;
    const maxTextureSize = capabilities.maxTextureSize;
    const maxSamples = capabilities.maxSamples;
    const _videoTextures = new WeakMap();
    let _canvas2;
    let useOffscreenCanvas = false;
    try {
      useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
    } catch (err) {
    }
    function createCanvas(width2, height2) {
      return useOffscreenCanvas ? new OffscreenCanvas(width2, height2) : createElementNS("canvas");
    }
    function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
      let scale = 1;
      if (image.width > maxSize || image.height > maxSize) {
        scale = maxSize / Math.max(image.width, image.height);
      }
      if (scale < 1 || needsPowerOfTwo === true) {
        if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
          const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
          const width2 = floor(scale * image.width);
          const height2 = floor(scale * image.height);
          if (_canvas2 === void 0)
            _canvas2 = createCanvas(width2, height2);
          const canvas = needsNewCanvas ? createCanvas(width2, height2) : _canvas2;
          canvas.width = width2;
          canvas.height = height2;
          const context = canvas.getContext("2d");
          context.drawImage(image, 0, 0, width2, height2);
          console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width2 + "x" + height2 + ").");
          return canvas;
        } else {
          if ("data" in image) {
            console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
          }
          return image;
        }
      }
      return image;
    }
    function isPowerOfTwo$1(image) {
      return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);
    }
    function textureNeedsPowerOfTwo(texture) {
      if (isWebGL2)
        return false;
      return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
    }
    function textureNeedsGenerateMipmaps(texture, supportsMips) {
      return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
    }
    function generateMipmap(target, texture, width2, height2, depth = 1) {
      _gl.generateMipmap(target);
      const textureProperties = properties.get(texture);
      textureProperties.__maxMipLevel = Math.log2(Math.max(width2, height2, depth));
    }
    function getInternalFormat(internalFormatName, glFormat, glType, encoding) {
      if (isWebGL2 === false)
        return glFormat;
      if (internalFormatName !== null) {
        if (_gl[internalFormatName] !== void 0)
          return _gl[internalFormatName];
        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
      }
      let internalFormat = glFormat;
      if (glFormat === 6403) {
        if (glType === 5126)
          internalFormat = 33326;
        if (glType === 5131)
          internalFormat = 33325;
        if (glType === 5121)
          internalFormat = 33321;
      }
      if (glFormat === 6407) {
        if (glType === 5126)
          internalFormat = 34837;
        if (glType === 5131)
          internalFormat = 34843;
        if (glType === 5121)
          internalFormat = 32849;
      }
      if (glFormat === 6408) {
        if (glType === 5126)
          internalFormat = 34836;
        if (glType === 5131)
          internalFormat = 34842;
        if (glType === 5121)
          internalFormat = encoding === sRGBEncoding ? 35907 : 32856;
      }
      if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836) {
        extensions.get("EXT_color_buffer_float");
      }
      return internalFormat;
    }
    function filterFallback(f2) {
      if (f2 === NearestFilter || f2 === NearestMipmapNearestFilter || f2 === NearestMipmapLinearFilter) {
        return 9728;
      }
      return 9729;
    }
    function onTextureDispose(event) {
      const texture = event.target;
      texture.removeEventListener("dispose", onTextureDispose);
      deallocateTexture(texture);
      if (texture.isVideoTexture) {
        _videoTextures.delete(texture);
      }
      info.memory.textures--;
    }
    function onRenderTargetDispose(event) {
      const renderTarget = event.target;
      renderTarget.removeEventListener("dispose", onRenderTargetDispose);
      deallocateRenderTarget(renderTarget);
    }
    function deallocateTexture(texture) {
      const textureProperties = properties.get(texture);
      if (textureProperties.__webglInit === void 0)
        return;
      _gl.deleteTexture(textureProperties.__webglTexture);
      properties.remove(texture);
    }
    function deallocateRenderTarget(renderTarget) {
      const texture = renderTarget.texture;
      const renderTargetProperties = properties.get(renderTarget);
      const textureProperties = properties.get(texture);
      if (!renderTarget)
        return;
      if (textureProperties.__webglTexture !== void 0) {
        _gl.deleteTexture(textureProperties.__webglTexture);
        info.memory.textures--;
      }
      if (renderTarget.depthTexture) {
        renderTarget.depthTexture.dispose();
      }
      if (renderTarget.isWebGLCubeRenderTarget) {
        for (let i2 = 0; i2 < 6; i2++) {
          _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i2]);
          if (renderTargetProperties.__webglDepthbuffer)
            _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i2]);
        }
      } else {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
        if (renderTargetProperties.__webglDepthbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
        if (renderTargetProperties.__webglMultisampledFramebuffer)
          _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
        if (renderTargetProperties.__webglColorRenderbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
        if (renderTargetProperties.__webglDepthRenderbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
      }
      if (renderTarget.isWebGLMultipleRenderTargets) {
        for (let i2 = 0, il = texture.length; i2 < il; i2++) {
          const attachmentProperties = properties.get(texture[i2]);
          if (attachmentProperties.__webglTexture) {
            _gl.deleteTexture(attachmentProperties.__webglTexture);
            info.memory.textures--;
          }
          properties.remove(texture[i2]);
        }
      }
      properties.remove(texture);
      properties.remove(renderTarget);
    }
    let textureUnits = 0;
    function resetTextureUnits() {
      textureUnits = 0;
    }
    function allocateTextureUnit() {
      const textureUnit = textureUnits;
      if (textureUnit >= maxTextures) {
        console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
      }
      textureUnits += 1;
      return textureUnit;
    }
    function setTexture2D(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.isVideoTexture)
        updateVideoTexture(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        const image = texture.image;
        if (image === void 0) {
          console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
        } else if (image.complete === false) {
          console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
        } else {
          uploadTexture(textureProperties, texture, slot);
          return;
        }
      }
      state2.activeTexture(33984 + slot);
      state2.bindTexture(3553, textureProperties.__webglTexture);
    }
    function setTexture2DArray(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
      state2.activeTexture(33984 + slot);
      state2.bindTexture(35866, textureProperties.__webglTexture);
    }
    function setTexture3D(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
      state2.activeTexture(33984 + slot);
      state2.bindTexture(32879, textureProperties.__webglTexture);
    }
    function setTextureCube(texture, slot) {
      const textureProperties = properties.get(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        uploadCubeTexture(textureProperties, texture, slot);
        return;
      }
      state2.activeTexture(33984 + slot);
      state2.bindTexture(34067, textureProperties.__webglTexture);
    }
    const wrappingToGL = {
      [RepeatWrapping]: 10497,
      [ClampToEdgeWrapping]: 33071,
      [MirroredRepeatWrapping]: 33648
    };
    const filterToGL = {
      [NearestFilter]: 9728,
      [NearestMipmapNearestFilter]: 9984,
      [NearestMipmapLinearFilter]: 9986,
      [LinearFilter]: 9729,
      [LinearMipmapNearestFilter]: 9985,
      [LinearMipmapLinearFilter]: 9987
    };
    function setTextureParameters(textureType, texture, supportsMips) {
      if (supportsMips) {
        _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);
        _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);
        if (textureType === 32879 || textureType === 35866) {
          _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
        }
        _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);
        _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
      } else {
        _gl.texParameteri(textureType, 10242, 33071);
        _gl.texParameteri(textureType, 10243, 33071);
        if (textureType === 32879 || textureType === 35866) {
          _gl.texParameteri(textureType, 32882, 33071);
        }
        if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
          console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
        }
        _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
        _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));
        if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
          console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
        }
      }
      if (extensions.has("EXT_texture_filter_anisotropic") === true) {
        const extension = extensions.get("EXT_texture_filter_anisotropic");
        if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false)
          return;
        if (isWebGL2 === false && (texture.type === HalfFloatType && extensions.has("OES_texture_half_float_linear") === false))
          return;
        if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
          _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
          properties.get(texture).__currentAnisotropy = texture.anisotropy;
        }
      }
    }
    function initTexture(textureProperties, texture) {
      if (textureProperties.__webglInit === void 0) {
        textureProperties.__webglInit = true;
        texture.addEventListener("dispose", onTextureDispose);
        textureProperties.__webglTexture = _gl.createTexture();
        info.memory.textures++;
      }
    }
    function uploadTexture(textureProperties, texture, slot) {
      let textureType = 3553;
      if (texture.isDataTexture2DArray)
        textureType = 35866;
      if (texture.isDataTexture3D)
        textureType = 32879;
      initTexture(textureProperties, texture);
      state2.activeTexture(33984 + slot);
      state2.bindTexture(textureType, textureProperties.__webglTexture);
      _gl.pixelStorei(37440, texture.flipY);
      _gl.pixelStorei(37441, texture.premultiplyAlpha);
      _gl.pixelStorei(3317, texture.unpackAlignment);
      _gl.pixelStorei(37443, 0);
      const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;
      const image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
      const supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format);
      let glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
      setTextureParameters(textureType, texture, supportsMips);
      let mipmap;
      const mipmaps = texture.mipmaps;
      if (texture.isDepthTexture) {
        glInternalFormat = 6402;
        if (isWebGL2) {
          if (texture.type === FloatType) {
            glInternalFormat = 36012;
          } else if (texture.type === UnsignedIntType) {
            glInternalFormat = 33190;
          } else if (texture.type === UnsignedInt248Type) {
            glInternalFormat = 35056;
          } else {
            glInternalFormat = 33189;
          }
        } else {
          if (texture.type === FloatType) {
            console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
          }
        }
        if (texture.format === DepthFormat && glInternalFormat === 6402) {
          if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
            console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
            texture.type = UnsignedShortType;
            glType = utils.convert(texture.type);
          }
        }
        if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {
          glInternalFormat = 34041;
          if (texture.type !== UnsignedInt248Type) {
            console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
            texture.type = UnsignedInt248Type;
            glType = utils.convert(texture.type);
          }
        }
        state2.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
      } else if (texture.isDataTexture) {
        if (mipmaps.length > 0 && supportsMips) {
          for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
            mipmap = mipmaps[i2];
            state2.texImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
          }
          texture.generateMipmaps = false;
          textureProperties.__maxMipLevel = mipmaps.length - 1;
        } else {
          state2.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
          textureProperties.__maxMipLevel = 0;
        }
      } else if (texture.isCompressedTexture) {
        for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
          mipmap = mipmaps[i2];
          if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
            if (glFormat !== null) {
              state2.compressedTexImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
            } else {
              console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
            }
          } else {
            state2.texImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
          }
        }
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else if (texture.isDataTexture2DArray) {
        state2.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        textureProperties.__maxMipLevel = 0;
      } else if (texture.isDataTexture3D) {
        state2.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        textureProperties.__maxMipLevel = 0;
      } else {
        if (mipmaps.length > 0 && supportsMips) {
          for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
            mipmap = mipmaps[i2];
            state2.texImage2D(3553, i2, glInternalFormat, glFormat, glType, mipmap);
          }
          texture.generateMipmaps = false;
          textureProperties.__maxMipLevel = mipmaps.length - 1;
        } else {
          state2.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
          textureProperties.__maxMipLevel = 0;
        }
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(textureType, texture, image.width, image.height);
      }
      textureProperties.__version = texture.version;
      if (texture.onUpdate)
        texture.onUpdate(texture);
    }
    function uploadCubeTexture(textureProperties, texture, slot) {
      if (texture.image.length !== 6)
        return;
      initTexture(textureProperties, texture);
      state2.activeTexture(33984 + slot);
      state2.bindTexture(34067, textureProperties.__webglTexture);
      _gl.pixelStorei(37440, texture.flipY);
      _gl.pixelStorei(37441, texture.premultiplyAlpha);
      _gl.pixelStorei(3317, texture.unpackAlignment);
      _gl.pixelStorei(37443, 0);
      const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
      const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
      const cubeImage = [];
      for (let i2 = 0; i2 < 6; i2++) {
        if (!isCompressed && !isDataTexture) {
          cubeImage[i2] = resizeImage(texture.image[i2], false, true, maxCubemapSize);
        } else {
          cubeImage[i2] = isDataTexture ? texture.image[i2].image : texture.image[i2];
        }
      }
      const image = cubeImage[0], supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
      setTextureParameters(34067, texture, supportsMips);
      let mipmaps;
      if (isCompressed) {
        for (let i2 = 0; i2 < 6; i2++) {
          mipmaps = cubeImage[i2].mipmaps;
          for (let j2 = 0; j2 < mipmaps.length; j2++) {
            const mipmap = mipmaps[j2];
            if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
              if (glFormat !== null) {
                state2.compressedTexImage2D(34069 + i2, j2, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
              }
            } else {
              state2.texImage2D(34069 + i2, j2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
        }
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else {
        mipmaps = texture.mipmaps;
        for (let i2 = 0; i2 < 6; i2++) {
          if (isDataTexture) {
            state2.texImage2D(34069 + i2, 0, glInternalFormat, cubeImage[i2].width, cubeImage[i2].height, 0, glFormat, glType, cubeImage[i2].data);
            for (let j2 = 0; j2 < mipmaps.length; j2++) {
              const mipmap = mipmaps[j2];
              const mipmapImage = mipmap.image[i2].image;
              state2.texImage2D(34069 + i2, j2 + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
            }
          } else {
            state2.texImage2D(34069 + i2, 0, glInternalFormat, glFormat, glType, cubeImage[i2]);
            for (let j2 = 0; j2 < mipmaps.length; j2++) {
              const mipmap = mipmaps[j2];
              state2.texImage2D(34069 + i2, j2 + 1, glInternalFormat, glFormat, glType, mipmap.image[i2]);
            }
          }
        }
        textureProperties.__maxMipLevel = mipmaps.length;
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(34067, texture, image.width, image.height);
      }
      textureProperties.__version = texture.version;
      if (texture.onUpdate)
        texture.onUpdate(texture);
    }
    function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {
      const glFormat = utils.convert(texture.format);
      const glType = utils.convert(texture.type);
      const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
      if (textureTarget === 32879 || textureTarget === 35866) {
        state2.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
      } else {
        state2.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
      }
      state2.bindFramebuffer(36160, framebuffer);
      _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0);
      state2.bindFramebuffer(36160, null);
    }
    function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
      _gl.bindRenderbuffer(36161, renderbuffer);
      if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
        let glInternalFormat = 33189;
        if (isMultisample) {
          const depthTexture = renderTarget.depthTexture;
          if (depthTexture && depthTexture.isDepthTexture) {
            if (depthTexture.type === FloatType) {
              glInternalFormat = 36012;
            } else if (depthTexture.type === UnsignedIntType) {
              glInternalFormat = 33190;
            }
          }
          const samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
        }
        _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
      } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
        if (isMultisample) {
          const samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
        }
        _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
      } else {
        const texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[0] : renderTarget.texture;
        const glFormat = utils.convert(texture.format);
        const glType = utils.convert(texture.type);
        const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
        if (isMultisample) {
          const samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
        }
      }
      _gl.bindRenderbuffer(36161, null);
    }
    function setupDepthTexture(framebuffer, renderTarget) {
      const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
      if (isCube)
        throw new Error("Depth Texture with cube render targets is not supported");
      state2.bindFramebuffer(36160, framebuffer);
      if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
        throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
      }
      if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
        renderTarget.depthTexture.image.width = renderTarget.width;
        renderTarget.depthTexture.image.height = renderTarget.height;
        renderTarget.depthTexture.needsUpdate = true;
      }
      setTexture2D(renderTarget.depthTexture, 0);
      const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
      if (renderTarget.depthTexture.format === DepthFormat) {
        _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
      } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
        _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
      } else {
        throw new Error("Unknown depthTexture format");
      }
    }
    function setupDepthRenderbuffer(renderTarget) {
      const renderTargetProperties = properties.get(renderTarget);
      const isCube = renderTarget.isWebGLCubeRenderTarget === true;
      if (renderTarget.depthTexture) {
        if (isCube)
          throw new Error("target.depthTexture not supported in Cube render targets");
        setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
      } else {
        if (isCube) {
          renderTargetProperties.__webglDepthbuffer = [];
          for (let i2 = 0; i2 < 6; i2++) {
            state2.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i2]);
            renderTargetProperties.__webglDepthbuffer[i2] = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i2], renderTarget, false);
          }
        } else {
          state2.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
          renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
        }
      }
      state2.bindFramebuffer(36160, null);
    }
    function setupRenderTarget(renderTarget) {
      const texture = renderTarget.texture;
      const renderTargetProperties = properties.get(renderTarget);
      const textureProperties = properties.get(texture);
      renderTarget.addEventListener("dispose", onRenderTargetDispose);
      if (renderTarget.isWebGLMultipleRenderTargets !== true) {
        textureProperties.__webglTexture = _gl.createTexture();
        textureProperties.__version = texture.version;
        info.memory.textures++;
      }
      const isCube = renderTarget.isWebGLCubeRenderTarget === true;
      const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
      const isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
      const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;
      const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
      if (isWebGL2 && texture.format === RGBFormat && (texture.type === FloatType || texture.type === HalfFloatType)) {
        texture.format = RGBAFormat;
        console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.");
      }
      if (isCube) {
        renderTargetProperties.__webglFramebuffer = [];
        for (let i2 = 0; i2 < 6; i2++) {
          renderTargetProperties.__webglFramebuffer[i2] = _gl.createFramebuffer();
        }
      } else {
        renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
        if (isMultipleRenderTargets) {
          if (capabilities.drawBuffers) {
            const textures = renderTarget.texture;
            for (let i2 = 0, il = textures.length; i2 < il; i2++) {
              const attachmentProperties = properties.get(textures[i2]);
              if (attachmentProperties.__webglTexture === void 0) {
                attachmentProperties.__webglTexture = _gl.createTexture();
                info.memory.textures++;
              }
            }
          } else {
            console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
          }
        } else if (isMultisample) {
          if (isWebGL2) {
            renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
            renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
            _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);
            const glFormat = utils.convert(texture.format);
            const glType = utils.convert(texture.type);
            const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
            const samples = getRenderTargetSamples(renderTarget);
            _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
            state2.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
            _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);
            _gl.bindRenderbuffer(36161, null);
            if (renderTarget.depthBuffer) {
              renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
              setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
            }
            state2.bindFramebuffer(36160, null);
          } else {
            console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
          }
        }
      }
      if (isCube) {
        state2.bindTexture(34067, textureProperties.__webglTexture);
        setTextureParameters(34067, texture, supportsMips);
        for (let i2 = 0; i2 < 6; i2++) {
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i2], renderTarget, texture, 36064, 34069 + i2);
        }
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          generateMipmap(34067, texture, renderTarget.width, renderTarget.height);
        }
        state2.unbindTexture();
      } else if (isMultipleRenderTargets) {
        const textures = renderTarget.texture;
        for (let i2 = 0, il = textures.length; i2 < il; i2++) {
          const attachment = textures[i2];
          const attachmentProperties = properties.get(attachment);
          state2.bindTexture(3553, attachmentProperties.__webglTexture);
          setTextureParameters(3553, attachment, supportsMips);
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, 36064 + i2, 3553);
          if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
            generateMipmap(3553, attachment, renderTarget.width, renderTarget.height);
          }
        }
        state2.unbindTexture();
      } else {
        let glTextureType = 3553;
        if (isRenderTarget3D) {
          if (isWebGL2) {
            const isTexture3D = texture.isDataTexture3D;
            glTextureType = isTexture3D ? 32879 : 35866;
          } else {
            console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
          }
        }
        state2.bindTexture(glTextureType, textureProperties.__webglTexture);
        setTextureParameters(glTextureType, texture, supportsMips);
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, 36064, glTextureType);
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          generateMipmap(glTextureType, texture, renderTarget.width, renderTarget.height, renderTarget.depth);
        }
        state2.unbindTexture();
      }
      if (renderTarget.depthBuffer) {
        setupDepthRenderbuffer(renderTarget);
      }
    }
    function updateRenderTargetMipmap(renderTarget) {
      const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
      const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
      for (let i2 = 0, il = textures.length; i2 < il; i2++) {
        const texture = textures[i2];
        if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
          const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
          const webglTexture = properties.get(texture).__webglTexture;
          state2.bindTexture(target, webglTexture);
          generateMipmap(target, texture, renderTarget.width, renderTarget.height);
          state2.unbindTexture();
        }
      }
    }
    function updateMultisampleRenderTarget(renderTarget) {
      if (renderTarget.isWebGLMultisampleRenderTarget) {
        if (isWebGL2) {
          const width2 = renderTarget.width;
          const height2 = renderTarget.height;
          let mask = 16384;
          if (renderTarget.depthBuffer)
            mask |= 256;
          if (renderTarget.stencilBuffer)
            mask |= 1024;
          const renderTargetProperties = properties.get(renderTarget);
          state2.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
          state2.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
          _gl.blitFramebuffer(0, 0, width2, height2, 0, 0, width2, height2, mask, 9728);
          state2.bindFramebuffer(36008, null);
          state2.bindFramebuffer(36009, renderTargetProperties.__webglMultisampledFramebuffer);
        } else {
          console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
        }
      }
    }
    function getRenderTargetSamples(renderTarget) {
      return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;
    }
    function updateVideoTexture(texture) {
      const frame = info.render.frame;
      if (_videoTextures.get(texture) !== frame) {
        _videoTextures.set(texture, frame);
        texture.update();
      }
    }
    let warnedTexture2D = false;
    let warnedTextureCube = false;
    function safeSetTexture2D(texture, slot) {
      if (texture && texture.isWebGLRenderTarget) {
        if (warnedTexture2D === false) {
          console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
          warnedTexture2D = true;
        }
        texture = texture.texture;
      }
      setTexture2D(texture, slot);
    }
    function safeSetTextureCube(texture, slot) {
      if (texture && texture.isWebGLCubeRenderTarget) {
        if (warnedTextureCube === false) {
          console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
          warnedTextureCube = true;
        }
        texture = texture.texture;
      }
      setTextureCube(texture, slot);
    }
    this.allocateTextureUnit = allocateTextureUnit;
    this.resetTextureUnits = resetTextureUnits;
    this.setTexture2D = setTexture2D;
    this.setTexture2DArray = setTexture2DArray;
    this.setTexture3D = setTexture3D;
    this.setTextureCube = setTextureCube;
    this.setupRenderTarget = setupRenderTarget;
    this.updateRenderTargetMipmap = updateRenderTargetMipmap;
    this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
    this.safeSetTexture2D = safeSetTexture2D;
    this.safeSetTextureCube = safeSetTextureCube;
  }
  function WebGLUtils(gl, extensions, capabilities) {
    const isWebGL2 = capabilities.isWebGL2;
    function convert(p2) {
      let extension;
      if (p2 === UnsignedByteType)
        return 5121;
      if (p2 === UnsignedShort4444Type)
        return 32819;
      if (p2 === UnsignedShort5551Type)
        return 32820;
      if (p2 === UnsignedShort565Type)
        return 33635;
      if (p2 === ByteType)
        return 5120;
      if (p2 === ShortType)
        return 5122;
      if (p2 === UnsignedShortType)
        return 5123;
      if (p2 === IntType)
        return 5124;
      if (p2 === UnsignedIntType)
        return 5125;
      if (p2 === FloatType)
        return 5126;
      if (p2 === HalfFloatType) {
        if (isWebGL2)
          return 5131;
        extension = extensions.get("OES_texture_half_float");
        if (extension !== null) {
          return extension.HALF_FLOAT_OES;
        } else {
          return null;
        }
      }
      if (p2 === AlphaFormat)
        return 6406;
      if (p2 === RGBFormat)
        return 6407;
      if (p2 === RGBAFormat)
        return 6408;
      if (p2 === LuminanceFormat)
        return 6409;
      if (p2 === LuminanceAlphaFormat)
        return 6410;
      if (p2 === DepthFormat)
        return 6402;
      if (p2 === DepthStencilFormat)
        return 34041;
      if (p2 === RedFormat)
        return 6403;
      if (p2 === RedIntegerFormat)
        return 36244;
      if (p2 === RGFormat)
        return 33319;
      if (p2 === RGIntegerFormat)
        return 33320;
      if (p2 === RGBIntegerFormat)
        return 36248;
      if (p2 === RGBAIntegerFormat)
        return 36249;
      if (p2 === RGB_S3TC_DXT1_Format || p2 === RGBA_S3TC_DXT1_Format || p2 === RGBA_S3TC_DXT3_Format || p2 === RGBA_S3TC_DXT5_Format) {
        extension = extensions.get("WEBGL_compressed_texture_s3tc");
        if (extension !== null) {
          if (p2 === RGB_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (p2 === RGBA_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (p2 === RGBA_S3TC_DXT3_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (p2 === RGBA_S3TC_DXT5_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      }
      if (p2 === RGB_PVRTC_4BPPV1_Format || p2 === RGB_PVRTC_2BPPV1_Format || p2 === RGBA_PVRTC_4BPPV1_Format || p2 === RGBA_PVRTC_2BPPV1_Format) {
        extension = extensions.get("WEBGL_compressed_texture_pvrtc");
        if (extension !== null) {
          if (p2 === RGB_PVRTC_4BPPV1_Format)
            return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (p2 === RGB_PVRTC_2BPPV1_Format)
            return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (p2 === RGBA_PVRTC_4BPPV1_Format)
            return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (p2 === RGBA_PVRTC_2BPPV1_Format)
            return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        } else {
          return null;
        }
      }
      if (p2 === RGB_ETC1_Format) {
        extension = extensions.get("WEBGL_compressed_texture_etc1");
        if (extension !== null) {
          return extension.COMPRESSED_RGB_ETC1_WEBGL;
        } else {
          return null;
        }
      }
      if (p2 === RGB_ETC2_Format || p2 === RGBA_ETC2_EAC_Format) {
        extension = extensions.get("WEBGL_compressed_texture_etc");
        if (extension !== null) {
          if (p2 === RGB_ETC2_Format)
            return extension.COMPRESSED_RGB8_ETC2;
          if (p2 === RGBA_ETC2_EAC_Format)
            return extension.COMPRESSED_RGBA8_ETC2_EAC;
        }
      }
      if (p2 === RGBA_ASTC_4x4_Format || p2 === RGBA_ASTC_5x4_Format || p2 === RGBA_ASTC_5x5_Format || p2 === RGBA_ASTC_6x5_Format || p2 === RGBA_ASTC_6x6_Format || p2 === RGBA_ASTC_8x5_Format || p2 === RGBA_ASTC_8x6_Format || p2 === RGBA_ASTC_8x8_Format || p2 === RGBA_ASTC_10x5_Format || p2 === RGBA_ASTC_10x6_Format || p2 === RGBA_ASTC_10x8_Format || p2 === RGBA_ASTC_10x10_Format || p2 === RGBA_ASTC_12x10_Format || p2 === RGBA_ASTC_12x12_Format || p2 === SRGB8_ALPHA8_ASTC_4x4_Format || p2 === SRGB8_ALPHA8_ASTC_5x4_Format || p2 === SRGB8_ALPHA8_ASTC_5x5_Format || p2 === SRGB8_ALPHA8_ASTC_6x5_Format || p2 === SRGB8_ALPHA8_ASTC_6x6_Format || p2 === SRGB8_ALPHA8_ASTC_8x5_Format || p2 === SRGB8_ALPHA8_ASTC_8x6_Format || p2 === SRGB8_ALPHA8_ASTC_8x8_Format || p2 === SRGB8_ALPHA8_ASTC_10x5_Format || p2 === SRGB8_ALPHA8_ASTC_10x6_Format || p2 === SRGB8_ALPHA8_ASTC_10x8_Format || p2 === SRGB8_ALPHA8_ASTC_10x10_Format || p2 === SRGB8_ALPHA8_ASTC_12x10_Format || p2 === SRGB8_ALPHA8_ASTC_12x12_Format) {
        extension = extensions.get("WEBGL_compressed_texture_astc");
        if (extension !== null) {
          return p2;
        } else {
          return null;
        }
      }
      if (p2 === RGBA_BPTC_Format) {
        extension = extensions.get("EXT_texture_compression_bptc");
        if (extension !== null) {
          return p2;
        } else {
          return null;
        }
      }
      if (p2 === UnsignedInt248Type) {
        if (isWebGL2)
          return 34042;
        extension = extensions.get("WEBGL_depth_texture");
        if (extension !== null) {
          return extension.UNSIGNED_INT_24_8_WEBGL;
        } else {
          return null;
        }
      }
    }
    return { convert };
  }
  var ArrayCamera = class extends PerspectiveCamera {
    constructor(array = []) {
      super();
      this.cameras = array;
    }
  };
  ArrayCamera.prototype.isArrayCamera = true;
  var Group = class extends Object3D {
    constructor() {
      super();
      this.type = "Group";
    }
  };
  Group.prototype.isGroup = true;
  var _moveEvent = { type: "move" };
  var WebXRController = class {
    constructor() {
      this._targetRay = null;
      this._grip = null;
      this._hand = null;
    }
    getHandSpace() {
      if (this._hand === null) {
        this._hand = new Group();
        this._hand.matrixAutoUpdate = false;
        this._hand.visible = false;
        this._hand.joints = {};
        this._hand.inputState = { pinching: false };
      }
      return this._hand;
    }
    getTargetRaySpace() {
      if (this._targetRay === null) {
        this._targetRay = new Group();
        this._targetRay.matrixAutoUpdate = false;
        this._targetRay.visible = false;
        this._targetRay.hasLinearVelocity = false;
        this._targetRay.linearVelocity = new Vector3();
        this._targetRay.hasAngularVelocity = false;
        this._targetRay.angularVelocity = new Vector3();
      }
      return this._targetRay;
    }
    getGripSpace() {
      if (this._grip === null) {
        this._grip = new Group();
        this._grip.matrixAutoUpdate = false;
        this._grip.visible = false;
        this._grip.hasLinearVelocity = false;
        this._grip.linearVelocity = new Vector3();
        this._grip.hasAngularVelocity = false;
        this._grip.angularVelocity = new Vector3();
      }
      return this._grip;
    }
    dispatchEvent(event) {
      if (this._targetRay !== null) {
        this._targetRay.dispatchEvent(event);
      }
      if (this._grip !== null) {
        this._grip.dispatchEvent(event);
      }
      if (this._hand !== null) {
        this._hand.dispatchEvent(event);
      }
      return this;
    }
    disconnect(inputSource) {
      this.dispatchEvent({ type: "disconnected", data: inputSource });
      if (this._targetRay !== null) {
        this._targetRay.visible = false;
      }
      if (this._grip !== null) {
        this._grip.visible = false;
      }
      if (this._hand !== null) {
        this._hand.visible = false;
      }
      return this;
    }
    update(inputSource, frame, referenceSpace) {
      let inputPose = null;
      let gripPose = null;
      let handPose = null;
      const targetRay = this._targetRay;
      const grip = this._grip;
      const hand = this._hand;
      if (inputSource && frame.session.visibilityState !== "visible-blurred") {
        if (targetRay !== null) {
          inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
          if (inputPose !== null) {
            targetRay.matrix.fromArray(inputPose.transform.matrix);
            targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
            if (inputPose.linearVelocity) {
              targetRay.hasLinearVelocity = true;
              targetRay.linearVelocity.copy(inputPose.linearVelocity);
            } else {
              targetRay.hasLinearVelocity = false;
            }
            if (inputPose.angularVelocity) {
              targetRay.hasAngularVelocity = true;
              targetRay.angularVelocity.copy(inputPose.angularVelocity);
            } else {
              targetRay.hasAngularVelocity = false;
            }
            this.dispatchEvent(_moveEvent);
          }
        }
        if (hand && inputSource.hand) {
          handPose = true;
          for (const inputjoint of inputSource.hand.values()) {
            const jointPose = frame.getJointPose(inputjoint, referenceSpace);
            if (hand.joints[inputjoint.jointName] === void 0) {
              const joint2 = new Group();
              joint2.matrixAutoUpdate = false;
              joint2.visible = false;
              hand.joints[inputjoint.jointName] = joint2;
              hand.add(joint2);
            }
            const joint = hand.joints[inputjoint.jointName];
            if (jointPose !== null) {
              joint.matrix.fromArray(jointPose.transform.matrix);
              joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
              joint.jointRadius = jointPose.radius;
            }
            joint.visible = jointPose !== null;
          }
          const indexTip = hand.joints["index-finger-tip"];
          const thumbTip = hand.joints["thumb-tip"];
          const distance = indexTip.position.distanceTo(thumbTip.position);
          const distanceToPinch = 0.02;
          const threshold = 5e-3;
          if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
            hand.inputState.pinching = false;
            this.dispatchEvent({
              type: "pinchend",
              handedness: inputSource.handedness,
              target: this
            });
          } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
            hand.inputState.pinching = true;
            this.dispatchEvent({
              type: "pinchstart",
              handedness: inputSource.handedness,
              target: this
            });
          }
        } else {
          if (grip !== null && inputSource.gripSpace) {
            gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
            if (gripPose !== null) {
              grip.matrix.fromArray(gripPose.transform.matrix);
              grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
              if (gripPose.linearVelocity) {
                grip.hasLinearVelocity = true;
                grip.linearVelocity.copy(gripPose.linearVelocity);
              } else {
                grip.hasLinearVelocity = false;
              }
              if (gripPose.angularVelocity) {
                grip.hasAngularVelocity = true;
                grip.angularVelocity.copy(gripPose.angularVelocity);
              } else {
                grip.hasAngularVelocity = false;
              }
            }
          }
        }
      }
      if (targetRay !== null) {
        targetRay.visible = inputPose !== null;
      }
      if (grip !== null) {
        grip.visible = gripPose !== null;
      }
      if (hand !== null) {
        hand.visible = handPose !== null;
      }
      return this;
    }
  };
  var WebXRManager = class extends EventDispatcher {
    constructor(renderer2, gl) {
      super();
      const scope = this;
      const state2 = renderer2.state;
      let session = null;
      let framebufferScaleFactor = 1;
      let referenceSpace = null;
      let referenceSpaceType = "local-floor";
      let pose2 = null;
      let glBinding = null;
      let glFramebuffer = null;
      let glProjLayer = null;
      let glBaseLayer = null;
      let isMultisample = false;
      let glMultisampledFramebuffer = null;
      let glColorRenderbuffer = null;
      let glDepthRenderbuffer = null;
      let xrFrame = null;
      let depthStyle = null;
      let clearStyle = null;
      const controllers = [];
      const inputSourcesMap = new Map();
      const cameraL = new PerspectiveCamera();
      cameraL.layers.enable(1);
      cameraL.viewport = new Vector4();
      const cameraR = new PerspectiveCamera();
      cameraR.layers.enable(2);
      cameraR.viewport = new Vector4();
      const cameras = [cameraL, cameraR];
      const cameraVR = new ArrayCamera();
      cameraVR.layers.enable(1);
      cameraVR.layers.enable(2);
      let _currentDepthNear = null;
      let _currentDepthFar = null;
      this.cameraAutoUpdate = true;
      this.enabled = false;
      this.isPresenting = false;
      this.getController = function(index) {
        let controller = controllers[index];
        if (controller === void 0) {
          controller = new WebXRController();
          controllers[index] = controller;
        }
        return controller.getTargetRaySpace();
      };
      this.getControllerGrip = function(index) {
        let controller = controllers[index];
        if (controller === void 0) {
          controller = new WebXRController();
          controllers[index] = controller;
        }
        return controller.getGripSpace();
      };
      this.getHand = function(index) {
        let controller = controllers[index];
        if (controller === void 0) {
          controller = new WebXRController();
          controllers[index] = controller;
        }
        return controller.getHandSpace();
      };
      function onSessionEvent(event) {
        const controller = inputSourcesMap.get(event.inputSource);
        if (controller) {
          controller.dispatchEvent({ type: event.type, data: event.inputSource });
        }
      }
      function onSessionEnd() {
        inputSourcesMap.forEach(function(controller, inputSource) {
          controller.disconnect(inputSource);
        });
        inputSourcesMap.clear();
        _currentDepthNear = null;
        _currentDepthFar = null;
        state2.bindXRFramebuffer(null);
        renderer2.setRenderTarget(renderer2.getRenderTarget());
        if (glFramebuffer)
          gl.deleteFramebuffer(glFramebuffer);
        if (glMultisampledFramebuffer)
          gl.deleteFramebuffer(glMultisampledFramebuffer);
        if (glColorRenderbuffer)
          gl.deleteRenderbuffer(glColorRenderbuffer);
        if (glDepthRenderbuffer)
          gl.deleteRenderbuffer(glDepthRenderbuffer);
        glFramebuffer = null;
        glMultisampledFramebuffer = null;
        glColorRenderbuffer = null;
        glDepthRenderbuffer = null;
        glBaseLayer = null;
        glProjLayer = null;
        glBinding = null;
        session = null;
        animation.stop();
        scope.isPresenting = false;
        scope.dispatchEvent({ type: "sessionend" });
      }
      this.setFramebufferScaleFactor = function(value) {
        framebufferScaleFactor = value;
        if (scope.isPresenting === true) {
          console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
        }
      };
      this.setReferenceSpaceType = function(value) {
        referenceSpaceType = value;
        if (scope.isPresenting === true) {
          console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
        }
      };
      this.getReferenceSpace = function() {
        return referenceSpace;
      };
      this.getBaseLayer = function() {
        return glProjLayer !== null ? glProjLayer : glBaseLayer;
      };
      this.getBinding = function() {
        return glBinding;
      };
      this.getFrame = function() {
        return xrFrame;
      };
      this.getSession = function() {
        return session;
      };
      this.setSession = async function(value) {
        session = value;
        if (session !== null) {
          session.addEventListener("select", onSessionEvent);
          session.addEventListener("selectstart", onSessionEvent);
          session.addEventListener("selectend", onSessionEvent);
          session.addEventListener("squeeze", onSessionEvent);
          session.addEventListener("squeezestart", onSessionEvent);
          session.addEventListener("squeezeend", onSessionEvent);
          session.addEventListener("end", onSessionEnd);
          session.addEventListener("inputsourceschange", onInputSourcesChange);
          const attributes = gl.getContextAttributes();
          if (attributes.xrCompatible !== true) {
            await gl.makeXRCompatible();
          }
          if (session.renderState.layers === void 0) {
            const layerInit = {
              antialias: attributes.antialias,
              alpha: attributes.alpha,
              depth: attributes.depth,
              stencil: attributes.stencil,
              framebufferScaleFactor
            };
            glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
            session.updateRenderState({ baseLayer: glBaseLayer });
          } else if (gl instanceof WebGLRenderingContext) {
            const layerInit = {
              antialias: true,
              alpha: attributes.alpha,
              depth: attributes.depth,
              stencil: attributes.stencil,
              framebufferScaleFactor
            };
            glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
            session.updateRenderState({ layers: [glBaseLayer] });
          } else {
            isMultisample = attributes.antialias;
            let depthFormat = null;
            if (attributes.depth) {
              clearStyle = 256;
              if (attributes.stencil)
                clearStyle |= 1024;
              depthStyle = attributes.stencil ? 33306 : 36096;
              depthFormat = attributes.stencil ? 35056 : 33190;
            }
            const projectionlayerInit = {
              colorFormat: attributes.alpha ? 32856 : 32849,
              depthFormat,
              scaleFactor: framebufferScaleFactor
            };
            glBinding = new XRWebGLBinding(session, gl);
            glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
            glFramebuffer = gl.createFramebuffer();
            session.updateRenderState({ layers: [glProjLayer] });
            if (isMultisample) {
              glMultisampledFramebuffer = gl.createFramebuffer();
              glColorRenderbuffer = gl.createRenderbuffer();
              gl.bindRenderbuffer(36161, glColorRenderbuffer);
              gl.renderbufferStorageMultisample(36161, 4, 32856, glProjLayer.textureWidth, glProjLayer.textureHeight);
              state2.bindFramebuffer(36160, glMultisampledFramebuffer);
              gl.framebufferRenderbuffer(36160, 36064, 36161, glColorRenderbuffer);
              gl.bindRenderbuffer(36161, null);
              if (depthFormat !== null) {
                glDepthRenderbuffer = gl.createRenderbuffer();
                gl.bindRenderbuffer(36161, glDepthRenderbuffer);
                gl.renderbufferStorageMultisample(36161, 4, depthFormat, glProjLayer.textureWidth, glProjLayer.textureHeight);
                gl.framebufferRenderbuffer(36160, depthStyle, 36161, glDepthRenderbuffer);
                gl.bindRenderbuffer(36161, null);
              }
              state2.bindFramebuffer(36160, null);
            }
          }
          referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
          animation.setContext(session);
          animation.start();
          scope.isPresenting = true;
          scope.dispatchEvent({ type: "sessionstart" });
        }
      };
      function onInputSourcesChange(event) {
        const inputSources = session.inputSources;
        for (let i2 = 0; i2 < controllers.length; i2++) {
          inputSourcesMap.set(inputSources[i2], controllers[i2]);
        }
        for (let i2 = 0; i2 < event.removed.length; i2++) {
          const inputSource = event.removed[i2];
          const controller = inputSourcesMap.get(inputSource);
          if (controller) {
            controller.dispatchEvent({ type: "disconnected", data: inputSource });
            inputSourcesMap.delete(inputSource);
          }
        }
        for (let i2 = 0; i2 < event.added.length; i2++) {
          const inputSource = event.added[i2];
          const controller = inputSourcesMap.get(inputSource);
          if (controller) {
            controller.dispatchEvent({ type: "connected", data: inputSource });
          }
        }
      }
      const cameraLPos = new Vector3();
      const cameraRPos = new Vector3();
      function setProjectionFromUnion(camera2, cameraL2, cameraR2) {
        cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
        cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
        const ipd = cameraLPos.distanceTo(cameraRPos);
        const projL = cameraL2.projectionMatrix.elements;
        const projR = cameraR2.projectionMatrix.elements;
        const near = projL[14] / (projL[10] - 1);
        const far = projL[14] / (projL[10] + 1);
        const topFov = (projL[9] + 1) / projL[5];
        const bottomFov = (projL[9] - 1) / projL[5];
        const leftFov = (projL[8] - 1) / projL[0];
        const rightFov = (projR[8] + 1) / projR[0];
        const left = near * leftFov;
        const right = near * rightFov;
        const zOffset = ipd / (-leftFov + rightFov);
        const xOffset = zOffset * -leftFov;
        cameraL2.matrixWorld.decompose(camera2.position, camera2.quaternion, camera2.scale);
        camera2.translateX(xOffset);
        camera2.translateZ(zOffset);
        camera2.matrixWorld.compose(camera2.position, camera2.quaternion, camera2.scale);
        camera2.matrixWorldInverse.copy(camera2.matrixWorld).invert();
        const near2 = near + zOffset;
        const far2 = far + zOffset;
        const left2 = left - xOffset;
        const right2 = right + (ipd - xOffset);
        const top2 = topFov * far / far2 * near2;
        const bottom2 = bottomFov * far / far2 * near2;
        camera2.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
      }
      function updateCamera(camera2, parent) {
        if (parent === null) {
          camera2.matrixWorld.copy(camera2.matrix);
        } else {
          camera2.matrixWorld.multiplyMatrices(parent.matrixWorld, camera2.matrix);
        }
        camera2.matrixWorldInverse.copy(camera2.matrixWorld).invert();
      }
      this.updateCamera = function(camera2) {
        if (session === null)
          return;
        cameraVR.near = cameraR.near = cameraL.near = camera2.near;
        cameraVR.far = cameraR.far = cameraL.far = camera2.far;
        if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
          session.updateRenderState({
            depthNear: cameraVR.near,
            depthFar: cameraVR.far
          });
          _currentDepthNear = cameraVR.near;
          _currentDepthFar = cameraVR.far;
        }
        const parent = camera2.parent;
        const cameras2 = cameraVR.cameras;
        updateCamera(cameraVR, parent);
        for (let i2 = 0; i2 < cameras2.length; i2++) {
          updateCamera(cameras2[i2], parent);
        }
        cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale);
        camera2.position.copy(cameraVR.position);
        camera2.quaternion.copy(cameraVR.quaternion);
        camera2.scale.copy(cameraVR.scale);
        camera2.matrix.copy(cameraVR.matrix);
        camera2.matrixWorld.copy(cameraVR.matrixWorld);
        const children = camera2.children;
        for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
          children[i2].updateMatrixWorld(true);
        }
        if (cameras2.length === 2) {
          setProjectionFromUnion(cameraVR, cameraL, cameraR);
        } else {
          cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
        }
      };
      this.getCamera = function() {
        return cameraVR;
      };
      this.getFoveation = function() {
        if (glProjLayer !== null) {
          return glProjLayer.fixedFoveation;
        }
        if (glBaseLayer !== null) {
          return glBaseLayer.fixedFoveation;
        }
        return void 0;
      };
      this.setFoveation = function(foveation) {
        if (glProjLayer !== null) {
          glProjLayer.fixedFoveation = foveation;
        }
        if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== void 0) {
          glBaseLayer.fixedFoveation = foveation;
        }
      };
      let onAnimationFrameCallback = null;
      function onAnimationFrame(time, frame) {
        pose2 = frame.getViewerPose(referenceSpace);
        xrFrame = frame;
        if (pose2 !== null) {
          const views = pose2.views;
          if (glBaseLayer !== null) {
            state2.bindXRFramebuffer(glBaseLayer.framebuffer);
          }
          let cameraVRNeedsUpdate = false;
          if (views.length !== cameraVR.cameras.length) {
            cameraVR.cameras.length = 0;
            cameraVRNeedsUpdate = true;
          }
          for (let i2 = 0; i2 < views.length; i2++) {
            const view = views[i2];
            let viewport = null;
            if (glBaseLayer !== null) {
              viewport = glBaseLayer.getViewport(view);
            } else {
              const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
              state2.bindXRFramebuffer(glFramebuffer);
              if (glSubImage.depthStencilTexture !== void 0) {
                gl.framebufferTexture2D(36160, depthStyle, 3553, glSubImage.depthStencilTexture, 0);
              }
              gl.framebufferTexture2D(36160, 36064, 3553, glSubImage.colorTexture, 0);
              viewport = glSubImage.viewport;
            }
            const camera2 = cameras[i2];
            camera2.matrix.fromArray(view.transform.matrix);
            camera2.projectionMatrix.fromArray(view.projectionMatrix);
            camera2.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
            if (i2 === 0) {
              cameraVR.matrix.copy(camera2.matrix);
            }
            if (cameraVRNeedsUpdate === true) {
              cameraVR.cameras.push(camera2);
            }
          }
          if (isMultisample) {
            state2.bindXRFramebuffer(glMultisampledFramebuffer);
            if (clearStyle !== null)
              gl.clear(clearStyle);
          }
        }
        const inputSources = session.inputSources;
        for (let i2 = 0; i2 < controllers.length; i2++) {
          const controller = controllers[i2];
          const inputSource = inputSources[i2];
          controller.update(inputSource, frame, referenceSpace);
        }
        if (onAnimationFrameCallback)
          onAnimationFrameCallback(time, frame);
        if (isMultisample) {
          const width2 = glProjLayer.textureWidth;
          const height2 = glProjLayer.textureHeight;
          state2.bindFramebuffer(36008, glMultisampledFramebuffer);
          state2.bindFramebuffer(36009, glFramebuffer);
          gl.invalidateFramebuffer(36008, [depthStyle]);
          gl.invalidateFramebuffer(36009, [depthStyle]);
          gl.blitFramebuffer(0, 0, width2, height2, 0, 0, width2, height2, 16384, 9728);
          gl.invalidateFramebuffer(36008, [36064]);
          state2.bindFramebuffer(36008, null);
          state2.bindFramebuffer(36009, null);
          state2.bindFramebuffer(36160, glMultisampledFramebuffer);
        }
        xrFrame = null;
      }
      const animation = new WebGLAnimation();
      animation.setAnimationLoop(onAnimationFrame);
      this.setAnimationLoop = function(callback) {
        onAnimationFrameCallback = callback;
      };
      this.dispose = function() {
      };
    }
  };
  function WebGLMaterials(properties) {
    function refreshFogUniforms(uniforms, fog) {
      uniforms.fogColor.value.copy(fog.color);
      if (fog.isFog) {
        uniforms.fogNear.value = fog.near;
        uniforms.fogFar.value = fog.far;
      } else if (fog.isFogExp2) {
        uniforms.fogDensity.value = fog.density;
      }
    }
    function refreshMaterialUniforms(uniforms, material, pixelRatio, height2, transmissionRenderTarget) {
      if (material.isMeshBasicMaterial) {
        refreshUniformsCommon(uniforms, material);
      } else if (material.isMeshLambertMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsLambert(uniforms, material);
      } else if (material.isMeshToonMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsToon(uniforms, material);
      } else if (material.isMeshPhongMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsPhong(uniforms, material);
      } else if (material.isMeshStandardMaterial) {
        refreshUniformsCommon(uniforms, material);
        if (material.isMeshPhysicalMaterial) {
          refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
        } else {
          refreshUniformsStandard(uniforms, material);
        }
      } else if (material.isMeshMatcapMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsMatcap(uniforms, material);
      } else if (material.isMeshDepthMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsDepth(uniforms, material);
      } else if (material.isMeshDistanceMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsDistance(uniforms, material);
      } else if (material.isMeshNormalMaterial) {
        refreshUniformsCommon(uniforms, material);
        refreshUniformsNormal(uniforms, material);
      } else if (material.isLineBasicMaterial) {
        refreshUniformsLine(uniforms, material);
        if (material.isLineDashedMaterial) {
          refreshUniformsDash(uniforms, material);
        }
      } else if (material.isPointsMaterial) {
        refreshUniformsPoints(uniforms, material, pixelRatio, height2);
      } else if (material.isSpriteMaterial) {
        refreshUniformsSprites(uniforms, material);
      } else if (material.isShadowMaterial) {
        uniforms.color.value.copy(material.color);
        uniforms.opacity.value = material.opacity;
      } else if (material.isShaderMaterial) {
        material.uniformsNeedUpdate = false;
      }
    }
    function refreshUniformsCommon(uniforms, material) {
      uniforms.opacity.value = material.opacity;
      if (material.color) {
        uniforms.diffuse.value.copy(material.color);
      }
      if (material.emissive) {
        uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
      }
      if (material.map) {
        uniforms.map.value = material.map;
      }
      if (material.alphaMap) {
        uniforms.alphaMap.value = material.alphaMap;
      }
      if (material.specularMap) {
        uniforms.specularMap.value = material.specularMap;
      }
      if (material.alphaTest > 0) {
        uniforms.alphaTest.value = material.alphaTest;
      }
      const envMap = properties.get(material).envMap;
      if (envMap) {
        uniforms.envMap.value = envMap;
        uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
        uniforms.reflectivity.value = material.reflectivity;
        uniforms.ior.value = material.ior;
        uniforms.refractionRatio.value = material.refractionRatio;
        const maxMipLevel = properties.get(envMap).__maxMipLevel;
        if (maxMipLevel !== void 0) {
          uniforms.maxMipLevel.value = maxMipLevel;
        }
      }
      if (material.lightMap) {
        uniforms.lightMap.value = material.lightMap;
        uniforms.lightMapIntensity.value = material.lightMapIntensity;
      }
      if (material.aoMap) {
        uniforms.aoMap.value = material.aoMap;
        uniforms.aoMapIntensity.value = material.aoMapIntensity;
      }
      let uvScaleMap;
      if (material.map) {
        uvScaleMap = material.map;
      } else if (material.specularMap) {
        uvScaleMap = material.specularMap;
      } else if (material.displacementMap) {
        uvScaleMap = material.displacementMap;
      } else if (material.normalMap) {
        uvScaleMap = material.normalMap;
      } else if (material.bumpMap) {
        uvScaleMap = material.bumpMap;
      } else if (material.roughnessMap) {
        uvScaleMap = material.roughnessMap;
      } else if (material.metalnessMap) {
        uvScaleMap = material.metalnessMap;
      } else if (material.alphaMap) {
        uvScaleMap = material.alphaMap;
      } else if (material.emissiveMap) {
        uvScaleMap = material.emissiveMap;
      } else if (material.clearcoatMap) {
        uvScaleMap = material.clearcoatMap;
      } else if (material.clearcoatNormalMap) {
        uvScaleMap = material.clearcoatNormalMap;
      } else if (material.clearcoatRoughnessMap) {
        uvScaleMap = material.clearcoatRoughnessMap;
      } else if (material.specularIntensityMap) {
        uvScaleMap = material.specularIntensityMap;
      } else if (material.specularTintMap) {
        uvScaleMap = material.specularTintMap;
      } else if (material.transmissionMap) {
        uvScaleMap = material.transmissionMap;
      } else if (material.thicknessMap) {
        uvScaleMap = material.thicknessMap;
      }
      if (uvScaleMap !== void 0) {
        if (uvScaleMap.isWebGLRenderTarget) {
          uvScaleMap = uvScaleMap.texture;
        }
        if (uvScaleMap.matrixAutoUpdate === true) {
          uvScaleMap.updateMatrix();
        }
        uniforms.uvTransform.value.copy(uvScaleMap.matrix);
      }
      let uv2ScaleMap;
      if (material.aoMap) {
        uv2ScaleMap = material.aoMap;
      } else if (material.lightMap) {
        uv2ScaleMap = material.lightMap;
      }
      if (uv2ScaleMap !== void 0) {
        if (uv2ScaleMap.isWebGLRenderTarget) {
          uv2ScaleMap = uv2ScaleMap.texture;
        }
        if (uv2ScaleMap.matrixAutoUpdate === true) {
          uv2ScaleMap.updateMatrix();
        }
        uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
      }
    }
    function refreshUniformsLine(uniforms, material) {
      uniforms.diffuse.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    }
    function refreshUniformsDash(uniforms, material) {
      uniforms.dashSize.value = material.dashSize;
      uniforms.totalSize.value = material.dashSize + material.gapSize;
      uniforms.scale.value = material.scale;
    }
    function refreshUniformsPoints(uniforms, material, pixelRatio, height2) {
      uniforms.diffuse.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
      uniforms.size.value = material.size * pixelRatio;
      uniforms.scale.value = height2 * 0.5;
      if (material.map) {
        uniforms.map.value = material.map;
      }
      if (material.alphaMap) {
        uniforms.alphaMap.value = material.alphaMap;
      }
      if (material.alphaTest > 0) {
        uniforms.alphaTest.value = material.alphaTest;
      }
      let uvScaleMap;
      if (material.map) {
        uvScaleMap = material.map;
      } else if (material.alphaMap) {
        uvScaleMap = material.alphaMap;
      }
      if (uvScaleMap !== void 0) {
        if (uvScaleMap.matrixAutoUpdate === true) {
          uvScaleMap.updateMatrix();
        }
        uniforms.uvTransform.value.copy(uvScaleMap.matrix);
      }
    }
    function refreshUniformsSprites(uniforms, material) {
      uniforms.diffuse.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
      uniforms.rotation.value = material.rotation;
      if (material.map) {
        uniforms.map.value = material.map;
      }
      if (material.alphaMap) {
        uniforms.alphaMap.value = material.alphaMap;
      }
      if (material.alphaTest > 0) {
        uniforms.alphaTest.value = material.alphaTest;
      }
      let uvScaleMap;
      if (material.map) {
        uvScaleMap = material.map;
      } else if (material.alphaMap) {
        uvScaleMap = material.alphaMap;
      }
      if (uvScaleMap !== void 0) {
        if (uvScaleMap.matrixAutoUpdate === true) {
          uvScaleMap.updateMatrix();
        }
        uniforms.uvTransform.value.copy(uvScaleMap.matrix);
      }
    }
    function refreshUniformsLambert(uniforms, material) {
      if (material.emissiveMap) {
        uniforms.emissiveMap.value = material.emissiveMap;
      }
    }
    function refreshUniformsPhong(uniforms, material) {
      uniforms.specular.value.copy(material.specular);
      uniforms.shininess.value = Math.max(material.shininess, 1e-4);
      if (material.emissiveMap) {
        uniforms.emissiveMap.value = material.emissiveMap;
      }
      if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;
        if (material.side === BackSide)
          uniforms.bumpScale.value *= -1;
      }
      if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy(material.normalScale);
        if (material.side === BackSide)
          uniforms.normalScale.value.negate();
      }
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
    }
    function refreshUniformsToon(uniforms, material) {
      if (material.gradientMap) {
        uniforms.gradientMap.value = material.gradientMap;
      }
      if (material.emissiveMap) {
        uniforms.emissiveMap.value = material.emissiveMap;
      }
      if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;
        if (material.side === BackSide)
          uniforms.bumpScale.value *= -1;
      }
      if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy(material.normalScale);
        if (material.side === BackSide)
          uniforms.normalScale.value.negate();
      }
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
    }
    function refreshUniformsStandard(uniforms, material) {
      uniforms.roughness.value = material.roughness;
      uniforms.metalness.value = material.metalness;
      if (material.roughnessMap) {
        uniforms.roughnessMap.value = material.roughnessMap;
      }
      if (material.metalnessMap) {
        uniforms.metalnessMap.value = material.metalnessMap;
      }
      if (material.emissiveMap) {
        uniforms.emissiveMap.value = material.emissiveMap;
      }
      if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;
        if (material.side === BackSide)
          uniforms.bumpScale.value *= -1;
      }
      if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy(material.normalScale);
        if (material.side === BackSide)
          uniforms.normalScale.value.negate();
      }
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
      const envMap = properties.get(material).envMap;
      if (envMap) {
        uniforms.envMapIntensity.value = material.envMapIntensity;
      }
    }
    function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
      refreshUniformsStandard(uniforms, material);
      uniforms.ior.value = material.ior;
      if (material.sheen > 0) {
        uniforms.sheenTint.value.copy(material.sheenTint).multiplyScalar(material.sheen);
        uniforms.sheenRoughness.value = material.sheenRoughness;
      }
      if (material.clearcoat > 0) {
        uniforms.clearcoat.value = material.clearcoat;
        uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
        if (material.clearcoatMap) {
          uniforms.clearcoatMap.value = material.clearcoatMap;
        }
        if (material.clearcoatRoughnessMap) {
          uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
        }
        if (material.clearcoatNormalMap) {
          uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
          uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
          if (material.side === BackSide) {
            uniforms.clearcoatNormalScale.value.negate();
          }
        }
      }
      if (material.transmission > 0) {
        uniforms.transmission.value = material.transmission;
        uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
        uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
        if (material.transmissionMap) {
          uniforms.transmissionMap.value = material.transmissionMap;
        }
        uniforms.thickness.value = material.thickness;
        if (material.thicknessMap) {
          uniforms.thicknessMap.value = material.thicknessMap;
        }
        uniforms.attenuationDistance.value = material.attenuationDistance;
        uniforms.attenuationTint.value.copy(material.attenuationTint);
      }
      uniforms.specularIntensity.value = material.specularIntensity;
      uniforms.specularTint.value.copy(material.specularTint);
      if (material.specularIntensityMap) {
        uniforms.specularIntensityMap.value = material.specularIntensityMap;
      }
      if (material.specularTintMap) {
        uniforms.specularTintMap.value = material.specularTintMap;
      }
    }
    function refreshUniformsMatcap(uniforms, material) {
      if (material.matcap) {
        uniforms.matcap.value = material.matcap;
      }
      if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;
        if (material.side === BackSide)
          uniforms.bumpScale.value *= -1;
      }
      if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy(material.normalScale);
        if (material.side === BackSide)
          uniforms.normalScale.value.negate();
      }
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
    }
    function refreshUniformsDepth(uniforms, material) {
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
    }
    function refreshUniformsDistance(uniforms, material) {
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
      uniforms.referencePosition.value.copy(material.referencePosition);
      uniforms.nearDistance.value = material.nearDistance;
      uniforms.farDistance.value = material.farDistance;
    }
    function refreshUniformsNormal(uniforms, material) {
      if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;
        if (material.side === BackSide)
          uniforms.bumpScale.value *= -1;
      }
      if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy(material.normalScale);
        if (material.side === BackSide)
          uniforms.normalScale.value.negate();
      }
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
    }
    return {
      refreshFogUniforms,
      refreshMaterialUniforms
    };
  }
  function createCanvasElement() {
    const canvas = createElementNS("canvas");
    canvas.style.display = "block";
    return canvas;
  }
  function WebGLRenderer(parameters = {}) {
    const _canvas2 = parameters.canvas !== void 0 ? parameters.canvas : createCanvasElement(), _context2 = parameters.context !== void 0 ? parameters.context : null, _alpha = parameters.alpha !== void 0 ? parameters.alpha : false, _depth = parameters.depth !== void 0 ? parameters.depth : true, _stencil = parameters.stencil !== void 0 ? parameters.stencil : true, _antialias = parameters.antialias !== void 0 ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== void 0 ? parameters.powerPreference : "default", _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== void 0 ? parameters.failIfMajorPerformanceCaveat : false;
    let currentRenderList = null;
    let currentRenderState = null;
    const renderListStack = [];
    const renderStateStack = [];
    this.domElement = _canvas2;
    this.debug = {
      checkShaderErrors: true
    };
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    this.sortObjects = true;
    this.clippingPlanes = [];
    this.localClippingEnabled = false;
    this.gammaFactor = 2;
    this.outputEncoding = LinearEncoding;
    this.physicallyCorrectLights = false;
    this.toneMapping = NoToneMapping;
    this.toneMappingExposure = 1;
    const _this = this;
    let _isContextLost = false;
    let _currentActiveCubeFace = 0;
    let _currentActiveMipmapLevel = 0;
    let _currentRenderTarget = null;
    let _currentMaterialId = -1;
    let _currentCamera = null;
    const _currentViewport = new Vector4();
    const _currentScissor = new Vector4();
    let _currentScissorTest = null;
    let _width = _canvas2.width;
    let _height = _canvas2.height;
    let _pixelRatio = 1;
    let _opaqueSort = null;
    let _transparentSort = null;
    const _viewport = new Vector4(0, 0, _width, _height);
    const _scissor = new Vector4(0, 0, _width, _height);
    let _scissorTest = false;
    const _currentDrawBuffers = [];
    const _frustum = new Frustum();
    let _clippingEnabled = false;
    let _localClippingEnabled = false;
    let _transmissionRenderTarget = null;
    const _projScreenMatrix2 = new Matrix4();
    const _vector3 = new Vector3();
    const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
    function getTargetPixelRatio() {
      return _currentRenderTarget === null ? _pixelRatio : 1;
    }
    let _gl = _context2;
    function getContext(contextNames, contextAttributes) {
      for (let i2 = 0; i2 < contextNames.length; i2++) {
        const contextName = contextNames[i2];
        const context = _canvas2.getContext(contextName, contextAttributes);
        if (context !== null)
          return context;
      }
      return null;
    }
    try {
      const contextAttributes = {
        alpha: _alpha,
        depth: _depth,
        stencil: _stencil,
        antialias: _antialias,
        premultipliedAlpha: _premultipliedAlpha,
        preserveDrawingBuffer: _preserveDrawingBuffer,
        powerPreference: _powerPreference,
        failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
      };
      _canvas2.addEventListener("webglcontextlost", onContextLost, false);
      _canvas2.addEventListener("webglcontextrestored", onContextRestore, false);
      if (_gl === null) {
        const contextNames = ["webgl2", "webgl", "experimental-webgl"];
        if (_this.isWebGL1Renderer === true) {
          contextNames.shift();
        }
        _gl = getContext(contextNames, contextAttributes);
        if (_gl === null) {
          if (getContext(contextNames)) {
            throw new Error("Error creating WebGL context with your selected attributes.");
          } else {
            throw new Error("Error creating WebGL context.");
          }
        }
      }
      if (_gl.getShaderPrecisionFormat === void 0) {
        _gl.getShaderPrecisionFormat = function() {
          return { "rangeMin": 1, "rangeMax": 1, "precision": 1 };
        };
      }
    } catch (error) {
      console.error("THREE.WebGLRenderer: " + error.message);
      throw error;
    }
    let extensions, capabilities, state2, info;
    let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
    let programCache, materials, renderLists, renderStates, clipping, shadowMap;
    let background, morphtargets, bufferRenderer, indexedBufferRenderer;
    let utils, bindingStates;
    function initGLContext() {
      extensions = new WebGLExtensions(_gl);
      capabilities = new WebGLCapabilities(_gl, extensions, parameters);
      extensions.init(capabilities);
      utils = new WebGLUtils(_gl, extensions, capabilities);
      state2 = new WebGLState(_gl, extensions, capabilities);
      _currentDrawBuffers[0] = 1029;
      info = new WebGLInfo(_gl);
      properties = new WebGLProperties();
      textures = new WebGLTextures(_gl, extensions, state2, properties, capabilities, utils, info);
      cubemaps = new WebGLCubeMaps(_this);
      cubeuvmaps = new WebGLCubeUVMaps(_this);
      attributes = new WebGLAttributes(_gl, capabilities);
      bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
      geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
      objects = new WebGLObjects(_gl, geometries, attributes, info);
      morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
      clipping = new WebGLClipping(properties);
      programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
      materials = new WebGLMaterials(properties);
      renderLists = new WebGLRenderLists(properties);
      renderStates = new WebGLRenderStates(extensions, capabilities);
      background = new WebGLBackground(_this, cubemaps, state2, objects, _premultipliedAlpha);
      shadowMap = new WebGLShadowMap(_this, objects, capabilities);
      bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
      indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
      info.programs = programCache.programs;
      _this.capabilities = capabilities;
      _this.extensions = extensions;
      _this.properties = properties;
      _this.renderLists = renderLists;
      _this.shadowMap = shadowMap;
      _this.state = state2;
      _this.info = info;
    }
    initGLContext();
    const xr = new WebXRManager(_this, _gl);
    this.xr = xr;
    this.getContext = function() {
      return _gl;
    };
    this.getContextAttributes = function() {
      return _gl.getContextAttributes();
    };
    this.forceContextLoss = function() {
      const extension = extensions.get("WEBGL_lose_context");
      if (extension)
        extension.loseContext();
    };
    this.forceContextRestore = function() {
      const extension = extensions.get("WEBGL_lose_context");
      if (extension)
        extension.restoreContext();
    };
    this.getPixelRatio = function() {
      return _pixelRatio;
    };
    this.setPixelRatio = function(value) {
      if (value === void 0)
        return;
      _pixelRatio = value;
      this.setSize(_width, _height, false);
    };
    this.getSize = function(target) {
      return target.set(_width, _height);
    };
    this.setSize = function(width2, height2, updateStyle) {
      if (xr.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      _width = width2;
      _height = height2;
      _canvas2.width = Math.floor(width2 * _pixelRatio);
      _canvas2.height = Math.floor(height2 * _pixelRatio);
      if (updateStyle !== false) {
        _canvas2.style.width = width2 + "px";
        _canvas2.style.height = height2 + "px";
      }
      this.setViewport(0, 0, width2, height2);
    };
    this.getDrawingBufferSize = function(target) {
      return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
    };
    this.setDrawingBufferSize = function(width2, height2, pixelRatio) {
      _width = width2;
      _height = height2;
      _pixelRatio = pixelRatio;
      _canvas2.width = Math.floor(width2 * pixelRatio);
      _canvas2.height = Math.floor(height2 * pixelRatio);
      this.setViewport(0, 0, width2, height2);
    };
    this.getCurrentViewport = function(target) {
      return target.copy(_currentViewport);
    };
    this.getViewport = function(target) {
      return target.copy(_viewport);
    };
    this.setViewport = function(x2, y2, width2, height2) {
      if (x2.isVector4) {
        _viewport.set(x2.x, x2.y, x2.z, x2.w);
      } else {
        _viewport.set(x2, y2, width2, height2);
      }
      state2.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissor = function(target) {
      return target.copy(_scissor);
    };
    this.setScissor = function(x2, y2, width2, height2) {
      if (x2.isVector4) {
        _scissor.set(x2.x, x2.y, x2.z, x2.w);
      } else {
        _scissor.set(x2, y2, width2, height2);
      }
      state2.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissorTest = function() {
      return _scissorTest;
    };
    this.setScissorTest = function(boolean) {
      state2.setScissorTest(_scissorTest = boolean);
    };
    this.setOpaqueSort = function(method) {
      _opaqueSort = method;
    };
    this.setTransparentSort = function(method) {
      _transparentSort = method;
    };
    this.getClearColor = function(target) {
      return target.copy(background.getClearColor());
    };
    this.setClearColor = function() {
      background.setClearColor.apply(background, arguments);
    };
    this.getClearAlpha = function() {
      return background.getClearAlpha();
    };
    this.setClearAlpha = function() {
      background.setClearAlpha.apply(background, arguments);
    };
    this.clear = function(color, depth, stencil) {
      let bits = 0;
      if (color === void 0 || color)
        bits |= 16384;
      if (depth === void 0 || depth)
        bits |= 256;
      if (stencil === void 0 || stencil)
        bits |= 1024;
      _gl.clear(bits);
    };
    this.clearColor = function() {
      this.clear(true, false, false);
    };
    this.clearDepth = function() {
      this.clear(false, true, false);
    };
    this.clearStencil = function() {
      this.clear(false, false, true);
    };
    this.dispose = function() {
      _canvas2.removeEventListener("webglcontextlost", onContextLost, false);
      _canvas2.removeEventListener("webglcontextrestored", onContextRestore, false);
      renderLists.dispose();
      renderStates.dispose();
      properties.dispose();
      cubemaps.dispose();
      cubeuvmaps.dispose();
      objects.dispose();
      bindingStates.dispose();
      xr.dispose();
      xr.removeEventListener("sessionstart", onXRSessionStart);
      xr.removeEventListener("sessionend", onXRSessionEnd);
      if (_transmissionRenderTarget) {
        _transmissionRenderTarget.dispose();
        _transmissionRenderTarget = null;
      }
      animation.stop();
    };
    function onContextLost(event) {
      event.preventDefault();
      console.log("THREE.WebGLRenderer: Context Lost.");
      _isContextLost = true;
    }
    function onContextRestore() {
      console.log("THREE.WebGLRenderer: Context Restored.");
      _isContextLost = false;
      const infoAutoReset = info.autoReset;
      const shadowMapEnabled = shadowMap.enabled;
      const shadowMapAutoUpdate = shadowMap.autoUpdate;
      const shadowMapNeedsUpdate = shadowMap.needsUpdate;
      const shadowMapType = shadowMap.type;
      initGLContext();
      info.autoReset = infoAutoReset;
      shadowMap.enabled = shadowMapEnabled;
      shadowMap.autoUpdate = shadowMapAutoUpdate;
      shadowMap.needsUpdate = shadowMapNeedsUpdate;
      shadowMap.type = shadowMapType;
    }
    function onMaterialDispose(event) {
      const material = event.target;
      material.removeEventListener("dispose", onMaterialDispose);
      deallocateMaterial(material);
    }
    function deallocateMaterial(material) {
      releaseMaterialProgramReferences(material);
      properties.remove(material);
    }
    function releaseMaterialProgramReferences(material) {
      const programs = properties.get(material).programs;
      if (programs !== void 0) {
        programs.forEach(function(program) {
          programCache.releaseProgram(program);
        });
      }
    }
    function renderObjectImmediate(object, program) {
      object.render(function(object2) {
        _this.renderBufferImmediate(object2, program);
      });
    }
    this.renderBufferImmediate = function(object, program) {
      bindingStates.initAttributes();
      const buffers = properties.get(object);
      if (object.hasPositions && !buffers.position)
        buffers.position = _gl.createBuffer();
      if (object.hasNormals && !buffers.normal)
        buffers.normal = _gl.createBuffer();
      if (object.hasUvs && !buffers.uv)
        buffers.uv = _gl.createBuffer();
      if (object.hasColors && !buffers.color)
        buffers.color = _gl.createBuffer();
      const programAttributes = program.getAttributes();
      if (object.hasPositions) {
        _gl.bindBuffer(34962, buffers.position);
        _gl.bufferData(34962, object.positionArray, 35048);
        bindingStates.enableAttribute(programAttributes.position.location);
        _gl.vertexAttribPointer(programAttributes.position.location, 3, 5126, false, 0, 0);
      }
      if (object.hasNormals) {
        _gl.bindBuffer(34962, buffers.normal);
        _gl.bufferData(34962, object.normalArray, 35048);
        bindingStates.enableAttribute(programAttributes.normal.location);
        _gl.vertexAttribPointer(programAttributes.normal.location, 3, 5126, false, 0, 0);
      }
      if (object.hasUvs) {
        _gl.bindBuffer(34962, buffers.uv);
        _gl.bufferData(34962, object.uvArray, 35048);
        bindingStates.enableAttribute(programAttributes.uv.location);
        _gl.vertexAttribPointer(programAttributes.uv.location, 2, 5126, false, 0, 0);
      }
      if (object.hasColors) {
        _gl.bindBuffer(34962, buffers.color);
        _gl.bufferData(34962, object.colorArray, 35048);
        bindingStates.enableAttribute(programAttributes.color.location);
        _gl.vertexAttribPointer(programAttributes.color.location, 3, 5126, false, 0, 0);
      }
      bindingStates.disableUnusedAttributes();
      _gl.drawArrays(4, 0, object.count);
      object.count = 0;
    };
    this.renderBufferDirect = function(camera2, scene2, geometry, material, object, group) {
      if (scene2 === null)
        scene2 = _emptyScene;
      const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
      const program = setProgram(camera2, scene2, geometry, material, object);
      state2.setMaterial(material, frontFaceCW);
      let index = geometry.index;
      const position = geometry.attributes.position;
      if (index === null) {
        if (position === void 0 || position.count === 0)
          return;
      } else if (index.count === 0) {
        return;
      }
      let rangeFactor = 1;
      if (material.wireframe === true) {
        index = geometries.getWireframeAttribute(geometry);
        rangeFactor = 2;
      }
      bindingStates.setup(object, material, program, geometry, index);
      let attribute;
      let renderer2 = bufferRenderer;
      if (index !== null) {
        attribute = attributes.get(index);
        renderer2 = indexedBufferRenderer;
        renderer2.setIndex(attribute);
      }
      const dataCount = index !== null ? index.count : position.count;
      const rangeStart = geometry.drawRange.start * rangeFactor;
      const rangeCount = geometry.drawRange.count * rangeFactor;
      const groupStart = group !== null ? group.start * rangeFactor : 0;
      const groupCount = group !== null ? group.count * rangeFactor : Infinity;
      const drawStart = Math.max(rangeStart, groupStart);
      const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
      const drawCount = Math.max(0, drawEnd - drawStart + 1);
      if (drawCount === 0)
        return;
      if (object.isMesh) {
        if (material.wireframe === true) {
          state2.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
          renderer2.setMode(1);
        } else {
          renderer2.setMode(4);
        }
      } else if (object.isLine) {
        let lineWidth = material.linewidth;
        if (lineWidth === void 0)
          lineWidth = 1;
        state2.setLineWidth(lineWidth * getTargetPixelRatio());
        if (object.isLineSegments) {
          renderer2.setMode(1);
        } else if (object.isLineLoop) {
          renderer2.setMode(2);
        } else {
          renderer2.setMode(3);
        }
      } else if (object.isPoints) {
        renderer2.setMode(0);
      } else if (object.isSprite) {
        renderer2.setMode(4);
      }
      if (object.isInstancedMesh) {
        renderer2.renderInstances(drawStart, drawCount, object.count);
      } else if (geometry.isInstancedBufferGeometry) {
        const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
        renderer2.renderInstances(drawStart, drawCount, instanceCount);
      } else {
        renderer2.render(drawStart, drawCount);
      }
    };
    this.compile = function(scene2, camera2) {
      currentRenderState = renderStates.get(scene2);
      currentRenderState.init();
      renderStateStack.push(currentRenderState);
      scene2.traverseVisible(function(object) {
        if (object.isLight && object.layers.test(camera2.layers)) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        }
      });
      currentRenderState.setupLights(_this.physicallyCorrectLights);
      scene2.traverse(function(object) {
        const material = object.material;
        if (material) {
          if (Array.isArray(material)) {
            for (let i2 = 0; i2 < material.length; i2++) {
              const material2 = material[i2];
              getProgram(material2, scene2, object);
            }
          } else {
            getProgram(material, scene2, object);
          }
        }
      });
      renderStateStack.pop();
      currentRenderState = null;
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time) {
      if (onAnimationFrameCallback)
        onAnimationFrameCallback(time);
    }
    function onXRSessionStart() {
      animation.stop();
    }
    function onXRSessionEnd() {
      animation.start();
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    if (typeof window !== "undefined")
      animation.setContext(window);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
      xr.setAnimationLoop(callback);
      callback === null ? animation.stop() : animation.start();
    };
    xr.addEventListener("sessionstart", onXRSessionStart);
    xr.addEventListener("sessionend", onXRSessionEnd);
    this.render = function(scene2, camera2) {
      if (camera2 !== void 0 && camera2.isCamera !== true) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (_isContextLost === true)
        return;
      if (scene2.autoUpdate === true)
        scene2.updateMatrixWorld();
      if (camera2.parent === null)
        camera2.updateMatrixWorld();
      if (xr.enabled === true && xr.isPresenting === true) {
        if (xr.cameraAutoUpdate === true)
          xr.updateCamera(camera2);
        camera2 = xr.getCamera();
      }
      if (scene2.isScene === true)
        scene2.onBeforeRender(_this, scene2, camera2, _currentRenderTarget);
      currentRenderState = renderStates.get(scene2, renderStateStack.length);
      currentRenderState.init();
      renderStateStack.push(currentRenderState);
      _projScreenMatrix2.multiplyMatrices(camera2.projectionMatrix, camera2.matrixWorldInverse);
      _frustum.setFromProjectionMatrix(_projScreenMatrix2);
      _localClippingEnabled = this.localClippingEnabled;
      _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera2);
      currentRenderList = renderLists.get(scene2, renderListStack.length);
      currentRenderList.init();
      renderListStack.push(currentRenderList);
      projectObject(scene2, camera2, 0, _this.sortObjects);
      currentRenderList.finish();
      if (_this.sortObjects === true) {
        currentRenderList.sort(_opaqueSort, _transparentSort);
      }
      if (_clippingEnabled === true)
        clipping.beginShadows();
      const shadowsArray = currentRenderState.state.shadowsArray;
      shadowMap.render(shadowsArray, scene2, camera2);
      if (_clippingEnabled === true)
        clipping.endShadows();
      if (this.info.autoReset === true)
        this.info.reset();
      background.render(currentRenderList, scene2);
      currentRenderState.setupLights(_this.physicallyCorrectLights);
      if (camera2.isArrayCamera) {
        const cameras = camera2.cameras;
        for (let i2 = 0, l2 = cameras.length; i2 < l2; i2++) {
          const camera22 = cameras[i2];
          renderScene(currentRenderList, scene2, camera22, camera22.viewport);
        }
      } else {
        renderScene(currentRenderList, scene2, camera2);
      }
      if (_currentRenderTarget !== null) {
        textures.updateMultisampleRenderTarget(_currentRenderTarget);
        textures.updateRenderTargetMipmap(_currentRenderTarget);
      }
      if (scene2.isScene === true)
        scene2.onAfterRender(_this, scene2, camera2);
      state2.buffers.depth.setTest(true);
      state2.buffers.depth.setMask(true);
      state2.buffers.color.setMask(true);
      state2.setPolygonOffset(false);
      bindingStates.resetDefaultState();
      _currentMaterialId = -1;
      _currentCamera = null;
      renderStateStack.pop();
      if (renderStateStack.length > 0) {
        currentRenderState = renderStateStack[renderStateStack.length - 1];
      } else {
        currentRenderState = null;
      }
      renderListStack.pop();
      if (renderListStack.length > 0) {
        currentRenderList = renderListStack[renderListStack.length - 1];
      } else {
        currentRenderList = null;
      }
    };
    function projectObject(object, camera2, groupOrder, sortObjects) {
      if (object.visible === false)
        return;
      const visible = object.layers.test(camera2.layers);
      if (visible) {
        if (object.isGroup) {
          groupOrder = object.renderOrder;
        } else if (object.isLOD) {
          if (object.autoUpdate === true)
            object.update(camera2);
        } else if (object.isLight) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        } else if (object.isSprite) {
          if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
            if (sortObjects) {
              _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
            }
            const geometry = objects.update(object);
            const material = object.material;
            if (material.visible) {
              currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
            }
          }
        } else if (object.isImmediateRenderObject) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
          }
          currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);
        } else if (object.isMesh || object.isLine || object.isPoints) {
          if (object.isSkinnedMesh) {
            if (object.skeleton.frame !== info.render.frame) {
              object.skeleton.update();
              object.skeleton.frame = info.render.frame;
            }
          }
          if (!object.frustumCulled || _frustum.intersectsObject(object)) {
            if (sortObjects) {
              _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
            }
            const geometry = objects.update(object);
            const material = object.material;
            if (Array.isArray(material)) {
              const groups = geometry.groups;
              for (let i2 = 0, l2 = groups.length; i2 < l2; i2++) {
                const group = groups[i2];
                const groupMaterial = material[group.materialIndex];
                if (groupMaterial && groupMaterial.visible) {
                  currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
                }
              }
            } else if (material.visible) {
              currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
            }
          }
        }
      }
      const children = object.children;
      for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
        projectObject(children[i2], camera2, groupOrder, sortObjects);
      }
    }
    function renderScene(currentRenderList2, scene2, camera2, viewport) {
      const opaqueObjects = currentRenderList2.opaque;
      const transmissiveObjects = currentRenderList2.transmissive;
      const transparentObjects = currentRenderList2.transparent;
      currentRenderState.setupLightsView(camera2);
      if (transmissiveObjects.length > 0)
        renderTransmissionPass(opaqueObjects, scene2, camera2);
      if (viewport)
        state2.viewport(_currentViewport.copy(viewport));
      if (opaqueObjects.length > 0)
        renderObjects(opaqueObjects, scene2, camera2);
      if (transmissiveObjects.length > 0)
        renderObjects(transmissiveObjects, scene2, camera2);
      if (transparentObjects.length > 0)
        renderObjects(transparentObjects, scene2, camera2);
    }
    function renderTransmissionPass(opaqueObjects, scene2, camera2) {
      if (_transmissionRenderTarget === null) {
        const needsAntialias = _antialias === true && capabilities.isWebGL2 === true;
        const renderTargetType = needsAntialias ? WebGLMultisampleRenderTarget : WebGLRenderTarget;
        _transmissionRenderTarget = new renderTargetType(1024, 1024, {
          generateMipmaps: true,
          type: utils.convert(HalfFloatType) !== null ? HalfFloatType : UnsignedByteType,
          minFilter: LinearMipmapLinearFilter,
          magFilter: NearestFilter,
          wrapS: ClampToEdgeWrapping,
          wrapT: ClampToEdgeWrapping
        });
      }
      const currentRenderTarget = _this.getRenderTarget();
      _this.setRenderTarget(_transmissionRenderTarget);
      _this.clear();
      const currentToneMapping = _this.toneMapping;
      _this.toneMapping = NoToneMapping;
      renderObjects(opaqueObjects, scene2, camera2);
      _this.toneMapping = currentToneMapping;
      textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
      textures.updateRenderTargetMipmap(_transmissionRenderTarget);
      _this.setRenderTarget(currentRenderTarget);
    }
    function renderObjects(renderList, scene2, camera2) {
      const overrideMaterial = scene2.isScene === true ? scene2.overrideMaterial : null;
      for (let i2 = 0, l2 = renderList.length; i2 < l2; i2++) {
        const renderItem = renderList[i2];
        const object = renderItem.object;
        const geometry = renderItem.geometry;
        const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
        const group = renderItem.group;
        if (object.layers.test(camera2.layers)) {
          renderObject(object, scene2, camera2, geometry, material, group);
        }
      }
    }
    function renderObject(object, scene2, camera2, geometry, material, group) {
      object.onBeforeRender(_this, scene2, camera2, geometry, material, group);
      object.modelViewMatrix.multiplyMatrices(camera2.matrixWorldInverse, object.matrixWorld);
      object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
      material.onBeforeRender(_this, scene2, camera2, geometry, object, group);
      if (object.isImmediateRenderObject) {
        const program = setProgram(camera2, scene2, geometry, material, object);
        state2.setMaterial(material);
        bindingStates.reset();
        renderObjectImmediate(object, program);
      } else {
        if (material.transparent === true && material.side === DoubleSide) {
          material.side = BackSide;
          material.needsUpdate = true;
          _this.renderBufferDirect(camera2, scene2, geometry, material, object, group);
          material.side = FrontSide;
          material.needsUpdate = true;
          _this.renderBufferDirect(camera2, scene2, geometry, material, object, group);
          material.side = DoubleSide;
        } else {
          _this.renderBufferDirect(camera2, scene2, geometry, material, object, group);
        }
      }
      object.onAfterRender(_this, scene2, camera2, geometry, material, group);
    }
    function getProgram(material, scene2, object) {
      if (scene2.isScene !== true)
        scene2 = _emptyScene;
      const materialProperties = properties.get(material);
      const lights = currentRenderState.state.lights;
      const shadowsArray = currentRenderState.state.shadowsArray;
      const lightsStateVersion = lights.state.version;
      const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene2, object);
      const programCacheKey = programCache.getProgramCacheKey(parameters2);
      let programs = materialProperties.programs;
      materialProperties.environment = material.isMeshStandardMaterial ? scene2.environment : null;
      materialProperties.fog = scene2.fog;
      materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
      if (programs === void 0) {
        material.addEventListener("dispose", onMaterialDispose);
        programs = new Map();
        materialProperties.programs = programs;
      }
      let program = programs.get(programCacheKey);
      if (program !== void 0) {
        if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
          updateCommonMaterialProperties(material, parameters2);
          return program;
        }
      } else {
        parameters2.uniforms = programCache.getUniforms(material);
        material.onBuild(parameters2, _this);
        material.onBeforeCompile(parameters2, _this);
        program = programCache.acquireProgram(parameters2, programCacheKey);
        programs.set(programCacheKey, program);
        materialProperties.uniforms = parameters2.uniforms;
      }
      const uniforms = materialProperties.uniforms;
      if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
        uniforms.clippingPlanes = clipping.uniform;
      }
      updateCommonMaterialProperties(material, parameters2);
      materialProperties.needsLights = materialNeedsLights(material);
      materialProperties.lightsStateVersion = lightsStateVersion;
      if (materialProperties.needsLights) {
        uniforms.ambientLightColor.value = lights.state.ambient;
        uniforms.lightProbe.value = lights.state.probe;
        uniforms.directionalLights.value = lights.state.directional;
        uniforms.directionalLightShadows.value = lights.state.directionalShadow;
        uniforms.spotLights.value = lights.state.spot;
        uniforms.spotLightShadows.value = lights.state.spotShadow;
        uniforms.rectAreaLights.value = lights.state.rectArea;
        uniforms.ltc_1.value = lights.state.rectAreaLTC1;
        uniforms.ltc_2.value = lights.state.rectAreaLTC2;
        uniforms.pointLights.value = lights.state.point;
        uniforms.pointLightShadows.value = lights.state.pointShadow;
        uniforms.hemisphereLights.value = lights.state.hemi;
        uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
        uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
        uniforms.spotShadowMap.value = lights.state.spotShadowMap;
        uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
        uniforms.pointShadowMap.value = lights.state.pointShadowMap;
        uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
      }
      const progUniforms = program.getUniforms();
      const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
      materialProperties.currentProgram = program;
      materialProperties.uniformsList = uniformsList;
      return program;
    }
    function updateCommonMaterialProperties(material, parameters2) {
      const materialProperties = properties.get(material);
      materialProperties.outputEncoding = parameters2.outputEncoding;
      materialProperties.instancing = parameters2.instancing;
      materialProperties.skinning = parameters2.skinning;
      materialProperties.morphTargets = parameters2.morphTargets;
      materialProperties.morphNormals = parameters2.morphNormals;
      materialProperties.morphTargetsCount = parameters2.morphTargetsCount;
      materialProperties.numClippingPlanes = parameters2.numClippingPlanes;
      materialProperties.numIntersection = parameters2.numClipIntersection;
      materialProperties.vertexAlphas = parameters2.vertexAlphas;
      materialProperties.vertexTangents = parameters2.vertexTangents;
    }
    function setProgram(camera2, scene2, geometry, material, object) {
      if (scene2.isScene !== true)
        scene2 = _emptyScene;
      textures.resetTextureUnits();
      const fog = scene2.fog;
      const environment = material.isMeshStandardMaterial ? scene2.environment : null;
      const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
      const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
      const vertexAlphas = material.vertexColors === true && !!geometry && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
      const vertexTangents = !!material.normalMap && !!geometry && !!geometry.attributes.tangent;
      const morphTargets = !!geometry && !!geometry.morphAttributes.position;
      const morphNormals = !!geometry && !!geometry.morphAttributes.normal;
      const morphTargetsCount = !!geometry && !!geometry.morphAttributes.position ? geometry.morphAttributes.position.length : 0;
      const materialProperties = properties.get(material);
      const lights = currentRenderState.state.lights;
      if (_clippingEnabled === true) {
        if (_localClippingEnabled === true || camera2 !== _currentCamera) {
          const useCache = camera2 === _currentCamera && material.id === _currentMaterialId;
          clipping.setState(material, camera2, useCache);
        }
      }
      let needsProgramChange = false;
      if (material.version === materialProperties.__version) {
        if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
          needsProgramChange = true;
        } else if (materialProperties.outputEncoding !== encoding) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancing === false) {
          needsProgramChange = true;
        } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
          needsProgramChange = true;
        } else if (object.isSkinnedMesh && materialProperties.skinning === false) {
          needsProgramChange = true;
        } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
          needsProgramChange = true;
        } else if (materialProperties.envMap !== envMap) {
          needsProgramChange = true;
        } else if (material.fog && materialProperties.fog !== fog) {
          needsProgramChange = true;
        } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
          needsProgramChange = true;
        } else if (materialProperties.vertexAlphas !== vertexAlphas) {
          needsProgramChange = true;
        } else if (materialProperties.vertexTangents !== vertexTangents) {
          needsProgramChange = true;
        } else if (materialProperties.morphTargets !== morphTargets) {
          needsProgramChange = true;
        } else if (materialProperties.morphNormals !== morphNormals) {
          needsProgramChange = true;
        } else if (capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount) {
          needsProgramChange = true;
        }
      } else {
        needsProgramChange = true;
        materialProperties.__version = material.version;
      }
      let program = materialProperties.currentProgram;
      if (needsProgramChange === true) {
        program = getProgram(material, scene2, object);
      }
      let refreshProgram = false;
      let refreshMaterial = false;
      let refreshLights = false;
      const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
      if (state2.useProgram(program.program)) {
        refreshProgram = true;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.id !== _currentMaterialId) {
        _currentMaterialId = material.id;
        refreshMaterial = true;
      }
      if (refreshProgram || _currentCamera !== camera2) {
        p_uniforms.setValue(_gl, "projectionMatrix", camera2.projectionMatrix);
        if (capabilities.logarithmicDepthBuffer) {
          p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera2.far + 1) / Math.LN2));
        }
        if (_currentCamera !== camera2) {
          _currentCamera = camera2;
          refreshMaterial = true;
          refreshLights = true;
        }
        if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
          const uCamPos = p_uniforms.map.cameraPosition;
          if (uCamPos !== void 0) {
            uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera2.matrixWorld));
          }
        }
        if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
          p_uniforms.setValue(_gl, "isOrthographic", camera2.isOrthographicCamera === true);
        }
        if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object.isSkinnedMesh) {
          p_uniforms.setValue(_gl, "viewMatrix", camera2.matrixWorldInverse);
        }
      }
      if (object.isSkinnedMesh) {
        p_uniforms.setOptional(_gl, object, "bindMatrix");
        p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
        const skeleton = object.skeleton;
        if (skeleton) {
          if (capabilities.floatVertexTextures) {
            if (skeleton.boneTexture === null)
              skeleton.computeBoneTexture();
            p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
            p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
          } else {
            p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
          }
        }
      }
      if (!!geometry && (geometry.morphAttributes.position !== void 0 || geometry.morphAttributes.normal !== void 0)) {
        morphtargets.update(object, geometry, material, program);
      }
      if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
        materialProperties.receiveShadow = object.receiveShadow;
        p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
      }
      if (refreshMaterial) {
        p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
        if (materialProperties.needsLights) {
          markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
        }
        if (fog && material.fog) {
          materials.refreshFogUniforms(m_uniforms, fog);
        }
        materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);
        WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
      }
      if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
        WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
        material.uniformsNeedUpdate = false;
      }
      if (material.isSpriteMaterial) {
        p_uniforms.setValue(_gl, "center", object.center);
      }
      p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
      p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
      p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
      return program;
    }
    function markUniformsLightsNeedsUpdate(uniforms, value) {
      uniforms.ambientLightColor.needsUpdate = value;
      uniforms.lightProbe.needsUpdate = value;
      uniforms.directionalLights.needsUpdate = value;
      uniforms.directionalLightShadows.needsUpdate = value;
      uniforms.pointLights.needsUpdate = value;
      uniforms.pointLightShadows.needsUpdate = value;
      uniforms.spotLights.needsUpdate = value;
      uniforms.spotLightShadows.needsUpdate = value;
      uniforms.rectAreaLights.needsUpdate = value;
      uniforms.hemisphereLights.needsUpdate = value;
    }
    function materialNeedsLights(material) {
      return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
    }
    this.getActiveCubeFace = function() {
      return _currentActiveCubeFace;
    };
    this.getActiveMipmapLevel = function() {
      return _currentActiveMipmapLevel;
    };
    this.getRenderTarget = function() {
      return _currentRenderTarget;
    };
    this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
      _currentRenderTarget = renderTarget;
      _currentActiveCubeFace = activeCubeFace;
      _currentActiveMipmapLevel = activeMipmapLevel;
      if (renderTarget && properties.get(renderTarget).__webglFramebuffer === void 0) {
        textures.setupRenderTarget(renderTarget);
      }
      let framebuffer = null;
      let isCube = false;
      let isRenderTarget3D = false;
      if (renderTarget) {
        const texture = renderTarget.texture;
        if (texture.isDataTexture3D || texture.isDataTexture2DArray) {
          isRenderTarget3D = true;
        }
        const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
        if (renderTarget.isWebGLCubeRenderTarget) {
          framebuffer = __webglFramebuffer[activeCubeFace];
          isCube = true;
        } else if (renderTarget.isWebGLMultisampleRenderTarget) {
          framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
        } else {
          framebuffer = __webglFramebuffer;
        }
        _currentViewport.copy(renderTarget.viewport);
        _currentScissor.copy(renderTarget.scissor);
        _currentScissorTest = renderTarget.scissorTest;
      } else {
        _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
        _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
        _currentScissorTest = _scissorTest;
      }
      const framebufferBound = state2.bindFramebuffer(36160, framebuffer);
      if (framebufferBound && capabilities.drawBuffers) {
        let needsUpdate = false;
        if (renderTarget) {
          if (renderTarget.isWebGLMultipleRenderTargets) {
            const textures2 = renderTarget.texture;
            if (_currentDrawBuffers.length !== textures2.length || _currentDrawBuffers[0] !== 36064) {
              for (let i2 = 0, il = textures2.length; i2 < il; i2++) {
                _currentDrawBuffers[i2] = 36064 + i2;
              }
              _currentDrawBuffers.length = textures2.length;
              needsUpdate = true;
            }
          } else {
            if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== 36064) {
              _currentDrawBuffers[0] = 36064;
              _currentDrawBuffers.length = 1;
              needsUpdate = true;
            }
          }
        } else {
          if (_currentDrawBuffers.length !== 1 || _currentDrawBuffers[0] !== 1029) {
            _currentDrawBuffers[0] = 1029;
            _currentDrawBuffers.length = 1;
            needsUpdate = true;
          }
        }
        if (needsUpdate) {
          if (capabilities.isWebGL2) {
            _gl.drawBuffers(_currentDrawBuffers);
          } else {
            extensions.get("WEBGL_draw_buffers").drawBuffersWEBGL(_currentDrawBuffers);
          }
        }
      }
      state2.viewport(_currentViewport);
      state2.scissor(_currentScissor);
      state2.setScissorTest(_currentScissorTest);
      if (isCube) {
        const textureProperties = properties.get(renderTarget.texture);
        _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
      } else if (isRenderTarget3D) {
        const textureProperties = properties.get(renderTarget.texture);
        const layer = activeCubeFace || 0;
        _gl.framebufferTextureLayer(36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
      }
      _currentMaterialId = -1;
    };
    this.readRenderTargetPixels = function(renderTarget, x2, y2, width2, height2, buffer, activeCubeFaceIndex) {
      if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let framebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
        framebuffer = framebuffer[activeCubeFaceIndex];
      }
      if (framebuffer) {
        state2.bindFramebuffer(36160, framebuffer);
        try {
          const texture = renderTarget.texture;
          const textureFormat = texture.format;
          const textureType = texture.type;
          if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || capabilities.isWebGL2 && extensions.has("EXT_color_buffer_float"));
          if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions.has("OES_texture_float") || extensions.has("WEBGL_color_buffer_float"))) && !halfFloatSupportedByExt) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          if (_gl.checkFramebufferStatus(36160) === 36053) {
            if (x2 >= 0 && x2 <= renderTarget.width - width2 && (y2 >= 0 && y2 <= renderTarget.height - height2)) {
              _gl.readPixels(x2, y2, width2, height2, utils.convert(textureFormat), utils.convert(textureType), buffer);
            }
          } else {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
          }
        } finally {
          const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
          state2.bindFramebuffer(36160, framebuffer2);
        }
      }
    };
    this.copyFramebufferToTexture = function(position, texture, level = 0) {
      const levelScale = Math.pow(2, -level);
      const width2 = Math.floor(texture.image.width * levelScale);
      const height2 = Math.floor(texture.image.height * levelScale);
      let glFormat = utils.convert(texture.format);
      if (capabilities.isWebGL2) {
        if (glFormat === 6407)
          glFormat = 32849;
        if (glFormat === 6408)
          glFormat = 32856;
      }
      textures.setTexture2D(texture, 0);
      _gl.copyTexImage2D(3553, level, glFormat, position.x, position.y, width2, height2, 0);
      state2.unbindTexture();
    };
    this.copyTextureToTexture = function(position, srcTexture, dstTexture, level = 0) {
      const width2 = srcTexture.image.width;
      const height2 = srcTexture.image.height;
      const glFormat = utils.convert(dstTexture.format);
      const glType = utils.convert(dstTexture.type);
      textures.setTexture2D(dstTexture, 0);
      _gl.pixelStorei(37440, dstTexture.flipY);
      _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
      _gl.pixelStorei(3317, dstTexture.unpackAlignment);
      if (srcTexture.isDataTexture) {
        _gl.texSubImage2D(3553, level, position.x, position.y, width2, height2, glFormat, glType, srcTexture.image.data);
      } else {
        if (srcTexture.isCompressedTexture) {
          _gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
        } else {
          _gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);
        }
      }
      if (level === 0 && dstTexture.generateMipmaps)
        _gl.generateMipmap(3553);
      state2.unbindTexture();
    };
    this.copyTextureToTexture3D = function(sourceBox, position, srcTexture, dstTexture, level = 0) {
      if (_this.isWebGL1Renderer) {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
        return;
      }
      const width2 = sourceBox.max.x - sourceBox.min.x + 1;
      const height2 = sourceBox.max.y - sourceBox.min.y + 1;
      const depth = sourceBox.max.z - sourceBox.min.z + 1;
      const glFormat = utils.convert(dstTexture.format);
      const glType = utils.convert(dstTexture.type);
      let glTarget;
      if (dstTexture.isDataTexture3D) {
        textures.setTexture3D(dstTexture, 0);
        glTarget = 32879;
      } else if (dstTexture.isDataTexture2DArray) {
        textures.setTexture2DArray(dstTexture, 0);
        glTarget = 35866;
      } else {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        return;
      }
      _gl.pixelStorei(37440, dstTexture.flipY);
      _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
      _gl.pixelStorei(3317, dstTexture.unpackAlignment);
      const unpackRowLen = _gl.getParameter(3314);
      const unpackImageHeight = _gl.getParameter(32878);
      const unpackSkipPixels = _gl.getParameter(3316);
      const unpackSkipRows = _gl.getParameter(3315);
      const unpackSkipImages = _gl.getParameter(32877);
      const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;
      _gl.pixelStorei(3314, image.width);
      _gl.pixelStorei(32878, image.height);
      _gl.pixelStorei(3316, sourceBox.min.x);
      _gl.pixelStorei(3315, sourceBox.min.y);
      _gl.pixelStorei(32877, sourceBox.min.z);
      if (srcTexture.isDataTexture || srcTexture.isDataTexture3D) {
        _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width2, height2, depth, glFormat, glType, image.data);
      } else {
        if (srcTexture.isCompressedTexture) {
          console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.");
          _gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width2, height2, depth, glFormat, image.data);
        } else {
          _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width2, height2, depth, glFormat, glType, image);
        }
      }
      _gl.pixelStorei(3314, unpackRowLen);
      _gl.pixelStorei(32878, unpackImageHeight);
      _gl.pixelStorei(3316, unpackSkipPixels);
      _gl.pixelStorei(3315, unpackSkipRows);
      _gl.pixelStorei(32877, unpackSkipImages);
      if (level === 0 && dstTexture.generateMipmaps)
        _gl.generateMipmap(glTarget);
      state2.unbindTexture();
    };
    this.initTexture = function(texture) {
      textures.setTexture2D(texture, 0);
      state2.unbindTexture();
    };
    this.resetState = function() {
      _currentActiveCubeFace = 0;
      _currentActiveMipmapLevel = 0;
      _currentRenderTarget = null;
      state2.reset();
      bindingStates.reset();
    };
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
  }
  var WebGL1Renderer = class extends WebGLRenderer {
  };
  WebGL1Renderer.prototype.isWebGL1Renderer = true;
  var FogExp2 = class {
    constructor(color, density = 25e-5) {
      this.name = "";
      this.color = new Color(color);
      this.density = density;
    }
    clone() {
      return new FogExp2(this.color, this.density);
    }
    toJSON() {
      return {
        type: "FogExp2",
        color: this.color.getHex(),
        density: this.density
      };
    }
  };
  FogExp2.prototype.isFogExp2 = true;
  var Fog = class {
    constructor(color, near = 1, far = 1e3) {
      this.name = "";
      this.color = new Color(color);
      this.near = near;
      this.far = far;
    }
    clone() {
      return new Fog(this.color, this.near, this.far);
    }
    toJSON() {
      return {
        type: "Fog",
        color: this.color.getHex(),
        near: this.near,
        far: this.far
      };
    }
  };
  Fog.prototype.isFog = true;
  var Scene = class extends Object3D {
    constructor() {
      super();
      this.type = "Scene";
      this.background = null;
      this.environment = null;
      this.fog = null;
      this.overrideMaterial = null;
      this.autoUpdate = true;
      if (typeof __THREE_DEVTOOLS__ !== "undefined") {
        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
      }
    }
    copy(source, recursive) {
      super.copy(source, recursive);
      if (source.background !== null)
        this.background = source.background.clone();
      if (source.environment !== null)
        this.environment = source.environment.clone();
      if (source.fog !== null)
        this.fog = source.fog.clone();
      if (source.overrideMaterial !== null)
        this.overrideMaterial = source.overrideMaterial.clone();
      this.autoUpdate = source.autoUpdate;
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      return this;
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      if (this.fog !== null)
        data.object.fog = this.fog.toJSON();
      return data;
    }
  };
  Scene.prototype.isScene = true;
  var InterleavedBuffer = class {
    constructor(array, stride) {
      this.array = array;
      this.stride = stride;
      this.count = array !== void 0 ? array.length / stride : 0;
      this.usage = StaticDrawUsage;
      this.updateRange = { offset: 0, count: -1 };
      this.version = 0;
      this.uuid = generateUUID();
    }
    onUploadCallback() {
    }
    set needsUpdate(value) {
      if (value === true)
        this.version++;
    }
    setUsage(value) {
      this.usage = value;
      return this;
    }
    copy(source) {
      this.array = new source.array.constructor(source.array);
      this.count = source.count;
      this.stride = source.stride;
      this.usage = source.usage;
      return this;
    }
    copyAt(index1, attribute, index2) {
      index1 *= this.stride;
      index2 *= attribute.stride;
      for (let i2 = 0, l2 = this.stride; i2 < l2; i2++) {
        this.array[index1 + i2] = attribute.array[index2 + i2];
      }
      return this;
    }
    set(value, offset = 0) {
      this.array.set(value, offset);
      return this;
    }
    clone(data) {
      if (data.arrayBuffers === void 0) {
        data.arrayBuffers = {};
      }
      if (this.array.buffer._uuid === void 0) {
        this.array.buffer._uuid = generateUUID();
      }
      if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
        data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
      }
      const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
      const ib = new this.constructor(array, this.stride);
      ib.setUsage(this.usage);
      return ib;
    }
    onUpload(callback) {
      this.onUploadCallback = callback;
      return this;
    }
    toJSON(data) {
      if (data.arrayBuffers === void 0) {
        data.arrayBuffers = {};
      }
      if (this.array.buffer._uuid === void 0) {
        this.array.buffer._uuid = generateUUID();
      }
      if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
        data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
      }
      return {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride
      };
    }
  };
  InterleavedBuffer.prototype.isInterleavedBuffer = true;
  var _vector$6 = /* @__PURE__ */ new Vector3();
  var InterleavedBufferAttribute = class {
    constructor(interleavedBuffer, itemSize, offset, normalized = false) {
      this.name = "";
      this.data = interleavedBuffer;
      this.itemSize = itemSize;
      this.offset = offset;
      this.normalized = normalized === true;
    }
    get count() {
      return this.data.count;
    }
    get array() {
      return this.data.array;
    }
    set needsUpdate(value) {
      this.data.needsUpdate = value;
    }
    applyMatrix4(m2) {
      for (let i2 = 0, l2 = this.data.count; i2 < l2; i2++) {
        _vector$6.x = this.getX(i2);
        _vector$6.y = this.getY(i2);
        _vector$6.z = this.getZ(i2);
        _vector$6.applyMatrix4(m2);
        this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
      }
      return this;
    }
    applyNormalMatrix(m2) {
      for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
        _vector$6.x = this.getX(i2);
        _vector$6.y = this.getY(i2);
        _vector$6.z = this.getZ(i2);
        _vector$6.applyNormalMatrix(m2);
        this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
      }
      return this;
    }
    transformDirection(m2) {
      for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
        _vector$6.x = this.getX(i2);
        _vector$6.y = this.getY(i2);
        _vector$6.z = this.getZ(i2);
        _vector$6.transformDirection(m2);
        this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
      }
      return this;
    }
    setX(index, x2) {
      this.data.array[index * this.data.stride + this.offset] = x2;
      return this;
    }
    setY(index, y2) {
      this.data.array[index * this.data.stride + this.offset + 1] = y2;
      return this;
    }
    setZ(index, z2) {
      this.data.array[index * this.data.stride + this.offset + 2] = z2;
      return this;
    }
    setW(index, w2) {
      this.data.array[index * this.data.stride + this.offset + 3] = w2;
      return this;
    }
    getX(index) {
      return this.data.array[index * this.data.stride + this.offset];
    }
    getY(index) {
      return this.data.array[index * this.data.stride + this.offset + 1];
    }
    getZ(index) {
      return this.data.array[index * this.data.stride + this.offset + 2];
    }
    getW(index) {
      return this.data.array[index * this.data.stride + this.offset + 3];
    }
    setXY(index, x2, y2) {
      index = index * this.data.stride + this.offset;
      this.data.array[index + 0] = x2;
      this.data.array[index + 1] = y2;
      return this;
    }
    setXYZ(index, x2, y2, z2) {
      index = index * this.data.stride + this.offset;
      this.data.array[index + 0] = x2;
      this.data.array[index + 1] = y2;
      this.data.array[index + 2] = z2;
      return this;
    }
    setXYZW(index, x2, y2, z2, w2) {
      index = index * this.data.stride + this.offset;
      this.data.array[index + 0] = x2;
      this.data.array[index + 1] = y2;
      this.data.array[index + 2] = z2;
      this.data.array[index + 3] = w2;
      return this;
    }
    clone(data) {
      if (data === void 0) {
        console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
        const array = [];
        for (let i2 = 0; i2 < this.count; i2++) {
          const index = i2 * this.data.stride + this.offset;
          for (let j2 = 0; j2 < this.itemSize; j2++) {
            array.push(this.data.array[index + j2]);
          }
        }
        return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
      } else {
        if (data.interleavedBuffers === void 0) {
          data.interleavedBuffers = {};
        }
        if (data.interleavedBuffers[this.data.uuid] === void 0) {
          data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
        }
        return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
      }
    }
    toJSON(data) {
      if (data === void 0) {
        console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
        const array = [];
        for (let i2 = 0; i2 < this.count; i2++) {
          const index = i2 * this.data.stride + this.offset;
          for (let j2 = 0; j2 < this.itemSize; j2++) {
            array.push(this.data.array[index + j2]);
          }
        }
        return {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array,
          normalized: this.normalized
        };
      } else {
        if (data.interleavedBuffers === void 0) {
          data.interleavedBuffers = {};
        }
        if (data.interleavedBuffers[this.data.uuid] === void 0) {
          data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
        }
        return {
          isInterleavedBufferAttribute: true,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized
        };
      }
    }
  };
  InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;
  var SpriteMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.type = "SpriteMaterial";
      this.color = new Color(16777215);
      this.map = null;
      this.alphaMap = null;
      this.rotation = 0;
      this.sizeAttenuation = true;
      this.transparent = true;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.rotation = source.rotation;
      this.sizeAttenuation = source.sizeAttenuation;
      return this;
    }
  };
  SpriteMaterial.prototype.isSpriteMaterial = true;
  var _geometry;
  var _intersectPoint = /* @__PURE__ */ new Vector3();
  var _worldScale = /* @__PURE__ */ new Vector3();
  var _mvPosition = /* @__PURE__ */ new Vector3();
  var _alignedPosition = /* @__PURE__ */ new Vector2();
  var _rotatedPosition = /* @__PURE__ */ new Vector2();
  var _viewWorldMatrix = /* @__PURE__ */ new Matrix4();
  var _vA = /* @__PURE__ */ new Vector3();
  var _vB = /* @__PURE__ */ new Vector3();
  var _vC = /* @__PURE__ */ new Vector3();
  var _uvA = /* @__PURE__ */ new Vector2();
  var _uvB = /* @__PURE__ */ new Vector2();
  var _uvC = /* @__PURE__ */ new Vector2();
  var Sprite = class extends Object3D {
    constructor(material) {
      super();
      this.type = "Sprite";
      if (_geometry === void 0) {
        _geometry = new BufferGeometry();
        const float32Array = new Float32Array([
          -0.5,
          -0.5,
          0,
          0,
          0,
          0.5,
          -0.5,
          0,
          1,
          0,
          0.5,
          0.5,
          0,
          1,
          1,
          -0.5,
          0.5,
          0,
          0,
          1
        ]);
        const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
        _geometry.setIndex([0, 1, 2, 0, 2, 3]);
        _geometry.setAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
        _geometry.setAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
      }
      this.geometry = _geometry;
      this.material = material !== void 0 ? material : new SpriteMaterial();
      this.center = new Vector2(0.5, 0.5);
    }
    raycast(raycaster, intersects2) {
      if (raycaster.camera === null) {
        console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
      }
      _worldScale.setFromMatrixScale(this.matrixWorld);
      _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
      this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
      _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
      if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
        _worldScale.multiplyScalar(-_mvPosition.z);
      }
      const rotation = this.material.rotation;
      let sin, cos;
      if (rotation !== 0) {
        cos = Math.cos(rotation);
        sin = Math.sin(rotation);
      }
      const center = this.center;
      transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
      transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
      transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
      _uvA.set(0, 0);
      _uvB.set(1, 0);
      _uvC.set(1, 1);
      let intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);
      if (intersect === null) {
        transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
        _uvB.set(0, 1);
        intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);
        if (intersect === null) {
          return;
        }
      }
      const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
      if (distance < raycaster.near || distance > raycaster.far)
        return;
      intersects2.push({
        distance,
        point: _intersectPoint.clone(),
        uv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),
        face: null,
        object: this
      });
    }
    copy(source) {
      super.copy(source);
      if (source.center !== void 0)
        this.center.copy(source.center);
      this.material = source.material;
      return this;
    }
  };
  Sprite.prototype.isSprite = true;
  function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
    _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);
    if (sin !== void 0) {
      _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
      _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
    } else {
      _rotatedPosition.copy(_alignedPosition);
    }
    vertexPosition.copy(mvPosition);
    vertexPosition.x += _rotatedPosition.x;
    vertexPosition.y += _rotatedPosition.y;
    vertexPosition.applyMatrix4(_viewWorldMatrix);
  }
  var _basePosition = /* @__PURE__ */ new Vector3();
  var _skinIndex = /* @__PURE__ */ new Vector4();
  var _skinWeight = /* @__PURE__ */ new Vector4();
  var _vector$5 = /* @__PURE__ */ new Vector3();
  var _matrix = /* @__PURE__ */ new Matrix4();
  var SkinnedMesh = class extends Mesh {
    constructor(geometry, material) {
      super(geometry, material);
      this.type = "SkinnedMesh";
      this.bindMode = "attached";
      this.bindMatrix = new Matrix4();
      this.bindMatrixInverse = new Matrix4();
    }
    copy(source) {
      super.copy(source);
      this.bindMode = source.bindMode;
      this.bindMatrix.copy(source.bindMatrix);
      this.bindMatrixInverse.copy(source.bindMatrixInverse);
      this.skeleton = source.skeleton;
      return this;
    }
    bind(skeleton, bindMatrix) {
      this.skeleton = skeleton;
      if (bindMatrix === void 0) {
        this.updateMatrixWorld(true);
        this.skeleton.calculateInverses();
        bindMatrix = this.matrixWorld;
      }
      this.bindMatrix.copy(bindMatrix);
      this.bindMatrixInverse.copy(bindMatrix).invert();
    }
    pose() {
      this.skeleton.pose();
    }
    normalizeSkinWeights() {
      const vector = new Vector4();
      const skinWeight = this.geometry.attributes.skinWeight;
      for (let i2 = 0, l2 = skinWeight.count; i2 < l2; i2++) {
        vector.x = skinWeight.getX(i2);
        vector.y = skinWeight.getY(i2);
        vector.z = skinWeight.getZ(i2);
        vector.w = skinWeight.getW(i2);
        const scale = 1 / vector.manhattanLength();
        if (scale !== Infinity) {
          vector.multiplyScalar(scale);
        } else {
          vector.set(1, 0, 0, 0);
        }
        skinWeight.setXYZW(i2, vector.x, vector.y, vector.z, vector.w);
      }
    }
    updateMatrixWorld(force) {
      super.updateMatrixWorld(force);
      if (this.bindMode === "attached") {
        this.bindMatrixInverse.copy(this.matrixWorld).invert();
      } else if (this.bindMode === "detached") {
        this.bindMatrixInverse.copy(this.bindMatrix).invert();
      } else {
        console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
      }
    }
    boneTransform(index, target) {
      const skeleton = this.skeleton;
      const geometry = this.geometry;
      _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
      _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
      _basePosition.copy(target).applyMatrix4(this.bindMatrix);
      target.set(0, 0, 0);
      for (let i2 = 0; i2 < 4; i2++) {
        const weight = _skinWeight.getComponent(i2);
        if (weight !== 0) {
          const boneIndex = _skinIndex.getComponent(i2);
          _matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
          target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), weight);
        }
      }
      return target.applyMatrix4(this.bindMatrixInverse);
    }
  };
  SkinnedMesh.prototype.isSkinnedMesh = true;
  var Bone = class extends Object3D {
    constructor() {
      super();
      this.type = "Bone";
    }
  };
  Bone.prototype.isBone = true;
  var DataTexture = class extends Texture {
    constructor(data = null, width2 = 1, height2 = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding) {
      super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
      this.image = { data, width: width2, height: height2 };
      this.magFilter = magFilter;
      this.minFilter = minFilter;
      this.generateMipmaps = false;
      this.flipY = false;
      this.unpackAlignment = 1;
      this.needsUpdate = true;
    }
  };
  DataTexture.prototype.isDataTexture = true;
  var _offsetMatrix = /* @__PURE__ */ new Matrix4();
  var _identityMatrix = /* @__PURE__ */ new Matrix4();
  var Skeleton = class {
    constructor(bones = [], boneInverses = []) {
      this.uuid = generateUUID();
      this.bones = bones.slice(0);
      this.boneInverses = boneInverses;
      this.boneMatrices = null;
      this.boneTexture = null;
      this.boneTextureSize = 0;
      this.frame = -1;
      this.init();
    }
    init() {
      const bones = this.bones;
      const boneInverses = this.boneInverses;
      this.boneMatrices = new Float32Array(bones.length * 16);
      if (boneInverses.length === 0) {
        this.calculateInverses();
      } else {
        if (bones.length !== boneInverses.length) {
          console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.");
          this.boneInverses = [];
          for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
            this.boneInverses.push(new Matrix4());
          }
        }
      }
    }
    calculateInverses() {
      this.boneInverses.length = 0;
      for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
        const inverse = new Matrix4();
        if (this.bones[i2]) {
          inverse.copy(this.bones[i2].matrixWorld).invert();
        }
        this.boneInverses.push(inverse);
      }
    }
    pose() {
      for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
        const bone = this.bones[i2];
        if (bone) {
          bone.matrixWorld.copy(this.boneInverses[i2]).invert();
        }
      }
      for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
        const bone = this.bones[i2];
        if (bone) {
          if (bone.parent && bone.parent.isBone) {
            bone.matrix.copy(bone.parent.matrixWorld).invert();
            bone.matrix.multiply(bone.matrixWorld);
          } else {
            bone.matrix.copy(bone.matrixWorld);
          }
          bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
        }
      }
    }
    update() {
      const bones = this.bones;
      const boneInverses = this.boneInverses;
      const boneMatrices = this.boneMatrices;
      const boneTexture = this.boneTexture;
      for (let i2 = 0, il = bones.length; i2 < il; i2++) {
        const matrix = bones[i2] ? bones[i2].matrixWorld : _identityMatrix;
        _offsetMatrix.multiplyMatrices(matrix, boneInverses[i2]);
        _offsetMatrix.toArray(boneMatrices, i2 * 16);
      }
      if (boneTexture !== null) {
        boneTexture.needsUpdate = true;
      }
    }
    clone() {
      return new Skeleton(this.bones, this.boneInverses);
    }
    computeBoneTexture() {
      let size = Math.sqrt(this.bones.length * 4);
      size = ceilPowerOfTwo(size);
      size = Math.max(size, 4);
      const boneMatrices = new Float32Array(size * size * 4);
      boneMatrices.set(this.boneMatrices);
      const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
      this.boneMatrices = boneMatrices;
      this.boneTexture = boneTexture;
      this.boneTextureSize = size;
      return this;
    }
    getBoneByName(name) {
      for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
        const bone = this.bones[i2];
        if (bone.name === name) {
          return bone;
        }
      }
      return void 0;
    }
    dispose() {
      if (this.boneTexture !== null) {
        this.boneTexture.dispose();
        this.boneTexture = null;
      }
    }
    fromJSON(json, bones) {
      this.uuid = json.uuid;
      for (let i2 = 0, l2 = json.bones.length; i2 < l2; i2++) {
        const uuid = json.bones[i2];
        let bone = bones[uuid];
        if (bone === void 0) {
          console.warn("THREE.Skeleton: No bone found with UUID:", uuid);
          bone = new Bone();
        }
        this.bones.push(bone);
        this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i2]));
      }
      this.init();
      return this;
    }
    toJSON() {
      const data = {
        metadata: {
          version: 4.5,
          type: "Skeleton",
          generator: "Skeleton.toJSON"
        },
        bones: [],
        boneInverses: []
      };
      data.uuid = this.uuid;
      const bones = this.bones;
      const boneInverses = this.boneInverses;
      for (let i2 = 0, l2 = bones.length; i2 < l2; i2++) {
        const bone = bones[i2];
        data.bones.push(bone.uuid);
        const boneInverse = boneInverses[i2];
        data.boneInverses.push(boneInverse.toArray());
      }
      return data;
    }
  };
  var InstancedBufferAttribute = class extends BufferAttribute {
    constructor(array, itemSize, normalized, meshPerAttribute = 1) {
      if (typeof normalized === "number") {
        meshPerAttribute = normalized;
        normalized = false;
        console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.");
      }
      super(array, itemSize, normalized);
      this.meshPerAttribute = meshPerAttribute;
    }
    copy(source) {
      super.copy(source);
      this.meshPerAttribute = source.meshPerAttribute;
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.meshPerAttribute = this.meshPerAttribute;
      data.isInstancedBufferAttribute = true;
      return data;
    }
  };
  InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;
  var _instanceLocalMatrix = /* @__PURE__ */ new Matrix4();
  var _instanceWorldMatrix = /* @__PURE__ */ new Matrix4();
  var _instanceIntersects = [];
  var _mesh = /* @__PURE__ */ new Mesh();
  var InstancedMesh = class extends Mesh {
    constructor(geometry, material, count) {
      super(geometry, material);
      this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);
      this.instanceColor = null;
      this.count = count;
      this.frustumCulled = false;
    }
    copy(source) {
      super.copy(source);
      this.instanceMatrix.copy(source.instanceMatrix);
      if (source.instanceColor !== null)
        this.instanceColor = source.instanceColor.clone();
      this.count = source.count;
      return this;
    }
    getColorAt(index, color) {
      color.fromArray(this.instanceColor.array, index * 3);
    }
    getMatrixAt(index, matrix) {
      matrix.fromArray(this.instanceMatrix.array, index * 16);
    }
    raycast(raycaster, intersects2) {
      const matrixWorld = this.matrixWorld;
      const raycastTimes = this.count;
      _mesh.geometry = this.geometry;
      _mesh.material = this.material;
      if (_mesh.material === void 0)
        return;
      for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
        this.getMatrixAt(instanceId, _instanceLocalMatrix);
        _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
        _mesh.matrixWorld = _instanceWorldMatrix;
        _mesh.raycast(raycaster, _instanceIntersects);
        for (let i2 = 0, l2 = _instanceIntersects.length; i2 < l2; i2++) {
          const intersect = _instanceIntersects[i2];
          intersect.instanceId = instanceId;
          intersect.object = this;
          intersects2.push(intersect);
        }
        _instanceIntersects.length = 0;
      }
    }
    setColorAt(index, color) {
      if (this.instanceColor === null) {
        this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);
      }
      color.toArray(this.instanceColor.array, index * 3);
    }
    setMatrixAt(index, matrix) {
      matrix.toArray(this.instanceMatrix.array, index * 16);
    }
    updateMorphTargets() {
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  };
  InstancedMesh.prototype.isInstancedMesh = true;
  var LineBasicMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.type = "LineBasicMaterial";
      this.color = new Color(16777215);
      this.linewidth = 1;
      this.linecap = "round";
      this.linejoin = "round";
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.linewidth = source.linewidth;
      this.linecap = source.linecap;
      this.linejoin = source.linejoin;
      return this;
    }
  };
  LineBasicMaterial.prototype.isLineBasicMaterial = true;
  var _start$1 = /* @__PURE__ */ new Vector3();
  var _end$1 = /* @__PURE__ */ new Vector3();
  var _inverseMatrix$1 = /* @__PURE__ */ new Matrix4();
  var _ray$1 = /* @__PURE__ */ new Ray();
  var _sphere$1 = /* @__PURE__ */ new Sphere();
  var Line = class extends Object3D {
    constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
      super();
      this.type = "Line";
      this.geometry = geometry;
      this.material = material;
      this.updateMorphTargets();
    }
    copy(source) {
      super.copy(source);
      this.material = source.material;
      this.geometry = source.geometry;
      return this;
    }
    computeLineDistances() {
      const geometry = this.geometry;
      if (geometry.isBufferGeometry) {
        if (geometry.index === null) {
          const positionAttribute = geometry.attributes.position;
          const lineDistances = [0];
          for (let i2 = 1, l2 = positionAttribute.count; i2 < l2; i2++) {
            _start$1.fromBufferAttribute(positionAttribute, i2 - 1);
            _end$1.fromBufferAttribute(positionAttribute, i2);
            lineDistances[i2] = lineDistances[i2 - 1];
            lineDistances[i2] += _start$1.distanceTo(_end$1);
          }
          geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
        } else {
          console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        }
      } else if (geometry.isGeometry) {
        console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
      return this;
    }
    raycast(raycaster, intersects2) {
      const geometry = this.geometry;
      const matrixWorld = this.matrixWorld;
      const threshold = raycaster.params.Line.threshold;
      const drawRange = geometry.drawRange;
      if (geometry.boundingSphere === null)
        geometry.computeBoundingSphere();
      _sphere$1.copy(geometry.boundingSphere);
      _sphere$1.applyMatrix4(matrixWorld);
      _sphere$1.radius += threshold;
      if (raycaster.ray.intersectsSphere(_sphere$1) === false)
        return;
      _inverseMatrix$1.copy(matrixWorld).invert();
      _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
      const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
      const localThresholdSq = localThreshold * localThreshold;
      const vStart = new Vector3();
      const vEnd = new Vector3();
      const interSegment = new Vector3();
      const interRay = new Vector3();
      const step = this.isLineSegments ? 2 : 1;
      if (geometry.isBufferGeometry) {
        const index = geometry.index;
        const attributes = geometry.attributes;
        const positionAttribute = attributes.position;
        if (index !== null) {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(index.count, drawRange.start + drawRange.count);
          for (let i2 = start, l2 = end - 1; i2 < l2; i2 += step) {
            const a2 = index.getX(i2);
            const b2 = index.getX(i2 + 1);
            vStart.fromBufferAttribute(positionAttribute, a2);
            vEnd.fromBufferAttribute(positionAttribute, b2);
            const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
            if (distSq > localThresholdSq)
              continue;
            interRay.applyMatrix4(this.matrixWorld);
            const distance = raycaster.ray.origin.distanceTo(interRay);
            if (distance < raycaster.near || distance > raycaster.far)
              continue;
            intersects2.push({
              distance,
              point: interSegment.clone().applyMatrix4(this.matrixWorld),
              index: i2,
              face: null,
              faceIndex: null,
              object: this
            });
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
          for (let i2 = start, l2 = end - 1; i2 < l2; i2 += step) {
            vStart.fromBufferAttribute(positionAttribute, i2);
            vEnd.fromBufferAttribute(positionAttribute, i2 + 1);
            const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
            if (distSq > localThresholdSq)
              continue;
            interRay.applyMatrix4(this.matrixWorld);
            const distance = raycaster.ray.origin.distanceTo(interRay);
            if (distance < raycaster.near || distance > raycaster.far)
              continue;
            intersects2.push({
              distance,
              point: interSegment.clone().applyMatrix4(this.matrixWorld),
              index: i2,
              face: null,
              faceIndex: null,
              object: this
            });
          }
        }
      } else if (geometry.isGeometry) {
        console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
    updateMorphTargets() {
      const geometry = this.geometry;
      if (geometry.isBufferGeometry) {
        const morphAttributes = geometry.morphAttributes;
        const keys = Object.keys(morphAttributes);
        if (keys.length > 0) {
          const morphAttribute = morphAttributes[keys[0]];
          if (morphAttribute !== void 0) {
            this.morphTargetInfluences = [];
            this.morphTargetDictionary = {};
            for (let m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
              const name = morphAttribute[m2].name || String(m2);
              this.morphTargetInfluences.push(0);
              this.morphTargetDictionary[name] = m2;
            }
          }
        }
      } else {
        const morphTargets = geometry.morphTargets;
        if (morphTargets !== void 0 && morphTargets.length > 0) {
          console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
      }
    }
  };
  Line.prototype.isLine = true;
  var _start = /* @__PURE__ */ new Vector3();
  var _end = /* @__PURE__ */ new Vector3();
  var LineSegments = class extends Line {
    constructor(geometry, material) {
      super(geometry, material);
      this.type = "LineSegments";
    }
    computeLineDistances() {
      const geometry = this.geometry;
      if (geometry.isBufferGeometry) {
        if (geometry.index === null) {
          const positionAttribute = geometry.attributes.position;
          const lineDistances = [];
          for (let i2 = 0, l2 = positionAttribute.count; i2 < l2; i2 += 2) {
            _start.fromBufferAttribute(positionAttribute, i2);
            _end.fromBufferAttribute(positionAttribute, i2 + 1);
            lineDistances[i2] = i2 === 0 ? 0 : lineDistances[i2 - 1];
            lineDistances[i2 + 1] = lineDistances[i2] + _start.distanceTo(_end);
          }
          geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
        } else {
          console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        }
      } else if (geometry.isGeometry) {
        console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
      return this;
    }
  };
  LineSegments.prototype.isLineSegments = true;
  var LineLoop = class extends Line {
    constructor(geometry, material) {
      super(geometry, material);
      this.type = "LineLoop";
    }
  };
  LineLoop.prototype.isLineLoop = true;
  var PointsMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.type = "PointsMaterial";
      this.color = new Color(16777215);
      this.map = null;
      this.alphaMap = null;
      this.size = 1;
      this.sizeAttenuation = true;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.map = source.map;
      this.alphaMap = source.alphaMap;
      this.size = source.size;
      this.sizeAttenuation = source.sizeAttenuation;
      return this;
    }
  };
  PointsMaterial.prototype.isPointsMaterial = true;
  var _inverseMatrix = /* @__PURE__ */ new Matrix4();
  var _ray = /* @__PURE__ */ new Ray();
  var _sphere = /* @__PURE__ */ new Sphere();
  var _position$2 = /* @__PURE__ */ new Vector3();
  var Points = class extends Object3D {
    constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {
      super();
      this.type = "Points";
      this.geometry = geometry;
      this.material = material;
      this.updateMorphTargets();
    }
    copy(source) {
      super.copy(source);
      this.material = source.material;
      this.geometry = source.geometry;
      return this;
    }
    raycast(raycaster, intersects2) {
      const geometry = this.geometry;
      const matrixWorld = this.matrixWorld;
      const threshold = raycaster.params.Points.threshold;
      const drawRange = geometry.drawRange;
      if (geometry.boundingSphere === null)
        geometry.computeBoundingSphere();
      _sphere.copy(geometry.boundingSphere);
      _sphere.applyMatrix4(matrixWorld);
      _sphere.radius += threshold;
      if (raycaster.ray.intersectsSphere(_sphere) === false)
        return;
      _inverseMatrix.copy(matrixWorld).invert();
      _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
      const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
      const localThresholdSq = localThreshold * localThreshold;
      if (geometry.isBufferGeometry) {
        const index = geometry.index;
        const attributes = geometry.attributes;
        const positionAttribute = attributes.position;
        if (index !== null) {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(index.count, drawRange.start + drawRange.count);
          for (let i2 = start, il = end; i2 < il; i2++) {
            const a2 = index.getX(i2);
            _position$2.fromBufferAttribute(positionAttribute, a2);
            testPoint(_position$2, a2, localThresholdSq, matrixWorld, raycaster, intersects2, this);
          }
        } else {
          const start = Math.max(0, drawRange.start);
          const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
          for (let i2 = start, l2 = end; i2 < l2; i2++) {
            _position$2.fromBufferAttribute(positionAttribute, i2);
            testPoint(_position$2, i2, localThresholdSq, matrixWorld, raycaster, intersects2, this);
          }
        }
      } else {
        console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
    updateMorphTargets() {
      const geometry = this.geometry;
      if (geometry.isBufferGeometry) {
        const morphAttributes = geometry.morphAttributes;
        const keys = Object.keys(morphAttributes);
        if (keys.length > 0) {
          const morphAttribute = morphAttributes[keys[0]];
          if (morphAttribute !== void 0) {
            this.morphTargetInfluences = [];
            this.morphTargetDictionary = {};
            for (let m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
              const name = morphAttribute[m2].name || String(m2);
              this.morphTargetInfluences.push(0);
              this.morphTargetDictionary[name] = m2;
            }
          }
        }
      } else {
        const morphTargets = geometry.morphTargets;
        if (morphTargets !== void 0 && morphTargets.length > 0) {
          console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
      }
    }
  };
  Points.prototype.isPoints = true;
  function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects2, object) {
    const rayPointDistanceSq = _ray.distanceSqToPoint(point);
    if (rayPointDistanceSq < localThresholdSq) {
      const intersectPoint = new Vector3();
      _ray.closestPointToPoint(point, intersectPoint);
      intersectPoint.applyMatrix4(matrixWorld);
      const distance = raycaster.ray.origin.distanceTo(intersectPoint);
      if (distance < raycaster.near || distance > raycaster.far)
        return;
      intersects2.push({
        distance,
        distanceToRay: Math.sqrt(rayPointDistanceSq),
        point: intersectPoint,
        index,
        face: null,
        object
      });
    }
  }
  var VideoTexture = class extends Texture {
    constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
      super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
      this.format = format !== void 0 ? format : RGBFormat;
      this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter;
      this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
      this.generateMipmaps = false;
      const scope = this;
      function updateVideo() {
        scope.needsUpdate = true;
        video.requestVideoFrameCallback(updateVideo);
      }
      if ("requestVideoFrameCallback" in video) {
        video.requestVideoFrameCallback(updateVideo);
      }
    }
    clone() {
      return new this.constructor(this.image).copy(this);
    }
    update() {
      const video = this.image;
      const hasVideoFrameCallback = "requestVideoFrameCallback" in video;
      if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
        this.needsUpdate = true;
      }
    }
  };
  VideoTexture.prototype.isVideoTexture = true;
  var CompressedTexture = class extends Texture {
    constructor(mipmaps, width2, height2, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
      super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
      this.image = { width: width2, height: height2 };
      this.mipmaps = mipmaps;
      this.flipY = false;
      this.generateMipmaps = false;
    }
  };
  CompressedTexture.prototype.isCompressedTexture = true;
  var CanvasTexture = class extends Texture {
    constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
      super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
      this.needsUpdate = true;
    }
  };
  CanvasTexture.prototype.isCanvasTexture = true;
  var DepthTexture = class extends Texture {
    constructor(width2, height2, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
      format = format !== void 0 ? format : DepthFormat;
      if (format !== DepthFormat && format !== DepthStencilFormat) {
        throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
      }
      if (type === void 0 && format === DepthFormat)
        type = UnsignedShortType;
      if (type === void 0 && format === DepthStencilFormat)
        type = UnsignedInt248Type;
      super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
      this.image = { width: width2, height: height2 };
      this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
      this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
      this.flipY = false;
      this.generateMipmaps = false;
    }
  };
  DepthTexture.prototype.isDepthTexture = true;
  var _v0 = new Vector3();
  var _v1$1 = new Vector3();
  var _normal = new Vector3();
  var _triangle = new Triangle();
  var Curve = class {
    constructor() {
      this.type = "Curve";
      this.arcLengthDivisions = 200;
    }
    getPoint() {
      console.warn("THREE.Curve: .getPoint() not implemented.");
      return null;
    }
    getPointAt(u2, optionalTarget) {
      const t2 = this.getUtoTmapping(u2);
      return this.getPoint(t2, optionalTarget);
    }
    getPoints(divisions = 5) {
      const points = [];
      for (let d2 = 0; d2 <= divisions; d2++) {
        points.push(this.getPoint(d2 / divisions));
      }
      return points;
    }
    getSpacedPoints(divisions = 5) {
      const points = [];
      for (let d2 = 0; d2 <= divisions; d2++) {
        points.push(this.getPointAt(d2 / divisions));
      }
      return points;
    }
    getLength() {
      const lengths = this.getLengths();
      return lengths[lengths.length - 1];
    }
    getLengths(divisions = this.arcLengthDivisions) {
      if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
        return this.cacheArcLengths;
      }
      this.needsUpdate = false;
      const cache = [];
      let current, last = this.getPoint(0);
      let sum = 0;
      cache.push(0);
      for (let p2 = 1; p2 <= divisions; p2++) {
        current = this.getPoint(p2 / divisions);
        sum += current.distanceTo(last);
        cache.push(sum);
        last = current;
      }
      this.cacheArcLengths = cache;
      return cache;
    }
    updateArcLengths() {
      this.needsUpdate = true;
      this.getLengths();
    }
    getUtoTmapping(u2, distance) {
      const arcLengths = this.getLengths();
      let i2 = 0;
      const il = arcLengths.length;
      let targetArcLength;
      if (distance) {
        targetArcLength = distance;
      } else {
        targetArcLength = u2 * arcLengths[il - 1];
      }
      let low = 0, high = il - 1, comparison;
      while (low <= high) {
        i2 = Math.floor(low + (high - low) / 2);
        comparison = arcLengths[i2] - targetArcLength;
        if (comparison < 0) {
          low = i2 + 1;
        } else if (comparison > 0) {
          high = i2 - 1;
        } else {
          high = i2;
          break;
        }
      }
      i2 = high;
      if (arcLengths[i2] === targetArcLength) {
        return i2 / (il - 1);
      }
      const lengthBefore = arcLengths[i2];
      const lengthAfter = arcLengths[i2 + 1];
      const segmentLength = lengthAfter - lengthBefore;
      const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
      const t2 = (i2 + segmentFraction) / (il - 1);
      return t2;
    }
    getTangent(t2, optionalTarget) {
      const delta = 1e-4;
      let t1 = t2 - delta;
      let t22 = t2 + delta;
      if (t1 < 0)
        t1 = 0;
      if (t22 > 1)
        t22 = 1;
      const pt1 = this.getPoint(t1);
      const pt2 = this.getPoint(t22);
      const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
      tangent.copy(pt2).sub(pt1).normalize();
      return tangent;
    }
    getTangentAt(u2, optionalTarget) {
      const t2 = this.getUtoTmapping(u2);
      return this.getTangent(t2, optionalTarget);
    }
    computeFrenetFrames(segments, closed) {
      const normal = new Vector3();
      const tangents = [];
      const normals = [];
      const binormals = [];
      const vec = new Vector3();
      const mat = new Matrix4();
      for (let i2 = 0; i2 <= segments; i2++) {
        const u2 = i2 / segments;
        tangents[i2] = this.getTangentAt(u2, new Vector3());
      }
      normals[0] = new Vector3();
      binormals[0] = new Vector3();
      let min = Number.MAX_VALUE;
      const tx = Math.abs(tangents[0].x);
      const ty = Math.abs(tangents[0].y);
      const tz = Math.abs(tangents[0].z);
      if (tx <= min) {
        min = tx;
        normal.set(1, 0, 0);
      }
      if (ty <= min) {
        min = ty;
        normal.set(0, 1, 0);
      }
      if (tz <= min) {
        normal.set(0, 0, 1);
      }
      vec.crossVectors(tangents[0], normal).normalize();
      normals[0].crossVectors(tangents[0], vec);
      binormals[0].crossVectors(tangents[0], normals[0]);
      for (let i2 = 1; i2 <= segments; i2++) {
        normals[i2] = normals[i2 - 1].clone();
        binormals[i2] = binormals[i2 - 1].clone();
        vec.crossVectors(tangents[i2 - 1], tangents[i2]);
        if (vec.length() > Number.EPSILON) {
          vec.normalize();
          const theta = Math.acos(clamp(tangents[i2 - 1].dot(tangents[i2]), -1, 1));
          normals[i2].applyMatrix4(mat.makeRotationAxis(vec, theta));
        }
        binormals[i2].crossVectors(tangents[i2], normals[i2]);
      }
      if (closed === true) {
        let theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));
        theta /= segments;
        if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
          theta = -theta;
        }
        for (let i2 = 1; i2 <= segments; i2++) {
          normals[i2].applyMatrix4(mat.makeRotationAxis(tangents[i2], theta * i2));
          binormals[i2].crossVectors(tangents[i2], normals[i2]);
        }
      }
      return {
        tangents,
        normals,
        binormals
      };
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(source) {
      this.arcLengthDivisions = source.arcLengthDivisions;
      return this;
    }
    toJSON() {
      const data = {
        metadata: {
          version: 4.5,
          type: "Curve",
          generator: "Curve.toJSON"
        }
      };
      data.arcLengthDivisions = this.arcLengthDivisions;
      data.type = this.type;
      return data;
    }
    fromJSON(json) {
      this.arcLengthDivisions = json.arcLengthDivisions;
      return this;
    }
  };
  var EllipseCurve = class extends Curve {
    constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
      super();
      this.type = "EllipseCurve";
      this.aX = aX;
      this.aY = aY;
      this.xRadius = xRadius;
      this.yRadius = yRadius;
      this.aStartAngle = aStartAngle;
      this.aEndAngle = aEndAngle;
      this.aClockwise = aClockwise;
      this.aRotation = aRotation;
    }
    getPoint(t2, optionalTarget) {
      const point = optionalTarget || new Vector2();
      const twoPi = Math.PI * 2;
      let deltaAngle = this.aEndAngle - this.aStartAngle;
      const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
      while (deltaAngle < 0)
        deltaAngle += twoPi;
      while (deltaAngle > twoPi)
        deltaAngle -= twoPi;
      if (deltaAngle < Number.EPSILON) {
        if (samePoints) {
          deltaAngle = 0;
        } else {
          deltaAngle = twoPi;
        }
      }
      if (this.aClockwise === true && !samePoints) {
        if (deltaAngle === twoPi) {
          deltaAngle = -twoPi;
        } else {
          deltaAngle = deltaAngle - twoPi;
        }
      }
      const angle = this.aStartAngle + t2 * deltaAngle;
      let x2 = this.aX + this.xRadius * Math.cos(angle);
      let y2 = this.aY + this.yRadius * Math.sin(angle);
      if (this.aRotation !== 0) {
        const cos = Math.cos(this.aRotation);
        const sin = Math.sin(this.aRotation);
        const tx = x2 - this.aX;
        const ty = y2 - this.aY;
        x2 = tx * cos - ty * sin + this.aX;
        y2 = tx * sin + ty * cos + this.aY;
      }
      return point.set(x2, y2);
    }
    copy(source) {
      super.copy(source);
      this.aX = source.aX;
      this.aY = source.aY;
      this.xRadius = source.xRadius;
      this.yRadius = source.yRadius;
      this.aStartAngle = source.aStartAngle;
      this.aEndAngle = source.aEndAngle;
      this.aClockwise = source.aClockwise;
      this.aRotation = source.aRotation;
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.aX = this.aX;
      data.aY = this.aY;
      data.xRadius = this.xRadius;
      data.yRadius = this.yRadius;
      data.aStartAngle = this.aStartAngle;
      data.aEndAngle = this.aEndAngle;
      data.aClockwise = this.aClockwise;
      data.aRotation = this.aRotation;
      return data;
    }
    fromJSON(json) {
      super.fromJSON(json);
      this.aX = json.aX;
      this.aY = json.aY;
      this.xRadius = json.xRadius;
      this.yRadius = json.yRadius;
      this.aStartAngle = json.aStartAngle;
      this.aEndAngle = json.aEndAngle;
      this.aClockwise = json.aClockwise;
      this.aRotation = json.aRotation;
      return this;
    }
  };
  EllipseCurve.prototype.isEllipseCurve = true;
  var ArcCurve = class extends EllipseCurve {
    constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
      super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
      this.type = "ArcCurve";
    }
  };
  ArcCurve.prototype.isArcCurve = true;
  function CubicPoly() {
    let c0 = 0, c1 = 0, c2 = 0, c3 = 0;
    function init(x0, x1, t0, t1) {
      c0 = x0;
      c1 = t0;
      c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
      c3 = 2 * x0 - 2 * x1 + t0 + t1;
    }
    return {
      initCatmullRom: function(x0, x1, x2, x3, tension) {
        init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
      },
      initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
        let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
        let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
        t1 *= dt1;
        t2 *= dt1;
        init(x1, x2, t1, t2);
      },
      calc: function(t2) {
        const t22 = t2 * t2;
        const t3 = t22 * t2;
        return c0 + c1 * t2 + c2 * t22 + c3 * t3;
      }
    };
  }
  var tmp = new Vector3();
  var px = new CubicPoly();
  var py = new CubicPoly();
  var pz = new CubicPoly();
  var CatmullRomCurve3 = class extends Curve {
    constructor(points = [], closed = false, curveType = "centripetal", tension = 0.5) {
      super();
      this.type = "CatmullRomCurve3";
      this.points = points;
      this.closed = closed;
      this.curveType = curveType;
      this.tension = tension;
    }
    getPoint(t2, optionalTarget = new Vector3()) {
      const point = optionalTarget;
      const points = this.points;
      const l2 = points.length;
      const p2 = (l2 - (this.closed ? 0 : 1)) * t2;
      let intPoint = Math.floor(p2);
      let weight = p2 - intPoint;
      if (this.closed) {
        intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l2) + 1) * l2;
      } else if (weight === 0 && intPoint === l2 - 1) {
        intPoint = l2 - 2;
        weight = 1;
      }
      let p0, p3;
      if (this.closed || intPoint > 0) {
        p0 = points[(intPoint - 1) % l2];
      } else {
        tmp.subVectors(points[0], points[1]).add(points[0]);
        p0 = tmp;
      }
      const p1 = points[intPoint % l2];
      const p22 = points[(intPoint + 1) % l2];
      if (this.closed || intPoint + 2 < l2) {
        p3 = points[(intPoint + 2) % l2];
      } else {
        tmp.subVectors(points[l2 - 1], points[l2 - 2]).add(points[l2 - 1]);
        p3 = tmp;
      }
      if (this.curveType === "centripetal" || this.curveType === "chordal") {
        const pow = this.curveType === "chordal" ? 0.5 : 0.25;
        let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
        let dt1 = Math.pow(p1.distanceToSquared(p22), pow);
        let dt2 = Math.pow(p22.distanceToSquared(p3), pow);
        if (dt1 < 1e-4)
          dt1 = 1;
        if (dt0 < 1e-4)
          dt0 = dt1;
        if (dt2 < 1e-4)
          dt2 = dt1;
        px.initNonuniformCatmullRom(p0.x, p1.x, p22.x, p3.x, dt0, dt1, dt2);
        py.initNonuniformCatmullRom(p0.y, p1.y, p22.y, p3.y, dt0, dt1, dt2);
        pz.initNonuniformCatmullRom(p0.z, p1.z, p22.z, p3.z, dt0, dt1, dt2);
      } else if (this.curveType === "catmullrom") {
        px.initCatmullRom(p0.x, p1.x, p22.x, p3.x, this.tension);
        py.initCatmullRom(p0.y, p1.y, p22.y, p3.y, this.tension);
        pz.initCatmullRom(p0.z, p1.z, p22.z, p3.z, this.tension);
      }
      point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
      return point;
    }
    copy(source) {
      super.copy(source);
      this.points = [];
      for (let i2 = 0, l2 = source.points.length; i2 < l2; i2++) {
        const point = source.points[i2];
        this.points.push(point.clone());
      }
      this.closed = source.closed;
      this.curveType = source.curveType;
      this.tension = source.tension;
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.points = [];
      for (let i2 = 0, l2 = this.points.length; i2 < l2; i2++) {
        const point = this.points[i2];
        data.points.push(point.toArray());
      }
      data.closed = this.closed;
      data.curveType = this.curveType;
      data.tension = this.tension;
      return data;
    }
    fromJSON(json) {
      super.fromJSON(json);
      this.points = [];
      for (let i2 = 0, l2 = json.points.length; i2 < l2; i2++) {
        const point = json.points[i2];
        this.points.push(new Vector3().fromArray(point));
      }
      this.closed = json.closed;
      this.curveType = json.curveType;
      this.tension = json.tension;
      return this;
    }
  };
  CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
  function CatmullRom(t2, p0, p1, p2, p3) {
    const v0 = (p2 - p0) * 0.5;
    const v1 = (p3 - p1) * 0.5;
    const t22 = t2 * t2;
    const t3 = t2 * t22;
    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t22 + v0 * t2 + p1;
  }
  function QuadraticBezierP0(t2, p2) {
    const k2 = 1 - t2;
    return k2 * k2 * p2;
  }
  function QuadraticBezierP1(t2, p2) {
    return 2 * (1 - t2) * t2 * p2;
  }
  function QuadraticBezierP2(t2, p2) {
    return t2 * t2 * p2;
  }
  function QuadraticBezier(t2, p0, p1, p2) {
    return QuadraticBezierP0(t2, p0) + QuadraticBezierP1(t2, p1) + QuadraticBezierP2(t2, p2);
  }
  function CubicBezierP0(t2, p2) {
    const k2 = 1 - t2;
    return k2 * k2 * k2 * p2;
  }
  function CubicBezierP1(t2, p2) {
    const k2 = 1 - t2;
    return 3 * k2 * k2 * t2 * p2;
  }
  function CubicBezierP2(t2, p2) {
    return 3 * (1 - t2) * t2 * t2 * p2;
  }
  function CubicBezierP3(t2, p2) {
    return t2 * t2 * t2 * p2;
  }
  function CubicBezier(t2, p0, p1, p2, p3) {
    return CubicBezierP0(t2, p0) + CubicBezierP1(t2, p1) + CubicBezierP2(t2, p2) + CubicBezierP3(t2, p3);
  }
  var CubicBezierCurve = class extends Curve {
    constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
      super();
      this.type = "CubicBezierCurve";
      this.v0 = v0;
      this.v1 = v1;
      this.v2 = v2;
      this.v3 = v3;
    }
    getPoint(t2, optionalTarget = new Vector2()) {
      const point = optionalTarget;
      const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
      point.set(CubicBezier(t2, v0.x, v1.x, v2.x, v3.x), CubicBezier(t2, v0.y, v1.y, v2.y, v3.y));
      return point;
    }
    copy(source) {
      super.copy(source);
      this.v0.copy(source.v0);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      this.v3.copy(source.v3);
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.v0 = this.v0.toArray();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      data.v3 = this.v3.toArray();
      return data;
    }
    fromJSON(json) {
      super.fromJSON(json);
      this.v0.fromArray(json.v0);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      this.v3.fromArray(json.v3);
      return this;
    }
  };
  CubicBezierCurve.prototype.isCubicBezierCurve = true;
  var CubicBezierCurve3 = class extends Curve {
    constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
      super();
      this.type = "CubicBezierCurve3";
      this.v0 = v0;
      this.v1 = v1;
      this.v2 = v2;
      this.v3 = v3;
    }
    getPoint(t2, optionalTarget = new Vector3()) {
      const point = optionalTarget;
      const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
      point.set(CubicBezier(t2, v0.x, v1.x, v2.x, v3.x), CubicBezier(t2, v0.y, v1.y, v2.y, v3.y), CubicBezier(t2, v0.z, v1.z, v2.z, v3.z));
      return point;
    }
    copy(source) {
      super.copy(source);
      this.v0.copy(source.v0);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      this.v3.copy(source.v3);
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.v0 = this.v0.toArray();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      data.v3 = this.v3.toArray();
      return data;
    }
    fromJSON(json) {
      super.fromJSON(json);
      this.v0.fromArray(json.v0);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      this.v3.fromArray(json.v3);
      return this;
    }
  };
  CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
  var LineCurve = class extends Curve {
    constructor(v1 = new Vector2(), v2 = new Vector2()) {
      super();
      this.type = "LineCurve";
      this.v1 = v1;
      this.v2 = v2;
    }
    getPoint(t2, optionalTarget = new Vector2()) {
      const point = optionalTarget;
      if (t2 === 1) {
        point.copy(this.v2);
      } else {
        point.copy(this.v2).sub(this.v1);
        point.multiplyScalar(t2).add(this.v1);
      }
      return point;
    }
    getPointAt(u2, optionalTarget) {
      return this.getPoint(u2, optionalTarget);
    }
    getTangent(t2, optionalTarget) {
      const tangent = optionalTarget || new Vector2();
      tangent.copy(this.v2).sub(this.v1).normalize();
      return tangent;
    }
    copy(source) {
      super.copy(source);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      return data;
    }
    fromJSON(json) {
      super.fromJSON(json);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      return this;
    }
  };
  LineCurve.prototype.isLineCurve = true;
  var LineCurve3 = class extends Curve {
    constructor(v1 = new Vector3(), v2 = new Vector3()) {
      super();
      this.type = "LineCurve3";
      this.isLineCurve3 = true;
      this.v1 = v1;
      this.v2 = v2;
    }
    getPoint(t2, optionalTarget = new Vector3()) {
      const point = optionalTarget;
      if (t2 === 1) {
        point.copy(this.v2);
      } else {
        point.copy(this.v2).sub(this.v1);
        point.multiplyScalar(t2).add(this.v1);
      }
      return point;
    }
    getPointAt(u2, optionalTarget) {
      return this.getPoint(u2, optionalTarget);
    }
    copy(source) {
      super.copy(source);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      return data;
    }
    fromJSON(json) {
      super.fromJSON(json);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      return this;
    }
  };
  var QuadraticBezierCurve = class extends Curve {
    constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
      super();
      this.type = "QuadraticBezierCurve";
      this.v0 = v0;
      this.v1 = v1;
      this.v2 = v2;
    }
    getPoint(t2, optionalTarget = new Vector2()) {
      const point = optionalTarget;
      const v0 = this.v0, v1 = this.v1, v2 = this.v2;
      point.set(QuadraticBezier(t2, v0.x, v1.x, v2.x), QuadraticBezier(t2, v0.y, v1.y, v2.y));
      return point;
    }
    copy(source) {
      super.copy(source);
      this.v0.copy(source.v0);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.v0 = this.v0.toArray();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      return data;
    }
    fromJSON(json) {
      super.fromJSON(json);
      this.v0.fromArray(json.v0);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      return this;
    }
  };
  QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
  var QuadraticBezierCurve3 = class extends Curve {
    constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
      super();
      this.type = "QuadraticBezierCurve3";
      this.v0 = v0;
      this.v1 = v1;
      this.v2 = v2;
    }
    getPoint(t2, optionalTarget = new Vector3()) {
      const point = optionalTarget;
      const v0 = this.v0, v1 = this.v1, v2 = this.v2;
      point.set(QuadraticBezier(t2, v0.x, v1.x, v2.x), QuadraticBezier(t2, v0.y, v1.y, v2.y), QuadraticBezier(t2, v0.z, v1.z, v2.z));
      return point;
    }
    copy(source) {
      super.copy(source);
      this.v0.copy(source.v0);
      this.v1.copy(source.v1);
      this.v2.copy(source.v2);
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.v0 = this.v0.toArray();
      data.v1 = this.v1.toArray();
      data.v2 = this.v2.toArray();
      return data;
    }
    fromJSON(json) {
      super.fromJSON(json);
      this.v0.fromArray(json.v0);
      this.v1.fromArray(json.v1);
      this.v2.fromArray(json.v2);
      return this;
    }
  };
  QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
  var SplineCurve = class extends Curve {
    constructor(points = []) {
      super();
      this.type = "SplineCurve";
      this.points = points;
    }
    getPoint(t2, optionalTarget = new Vector2()) {
      const point = optionalTarget;
      const points = this.points;
      const p2 = (points.length - 1) * t2;
      const intPoint = Math.floor(p2);
      const weight = p2 - intPoint;
      const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
      const p1 = points[intPoint];
      const p22 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
      const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
      point.set(CatmullRom(weight, p0.x, p1.x, p22.x, p3.x), CatmullRom(weight, p0.y, p1.y, p22.y, p3.y));
      return point;
    }
    copy(source) {
      super.copy(source);
      this.points = [];
      for (let i2 = 0, l2 = source.points.length; i2 < l2; i2++) {
        const point = source.points[i2];
        this.points.push(point.clone());
      }
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.points = [];
      for (let i2 = 0, l2 = this.points.length; i2 < l2; i2++) {
        const point = this.points[i2];
        data.points.push(point.toArray());
      }
      return data;
    }
    fromJSON(json) {
      super.fromJSON(json);
      this.points = [];
      for (let i2 = 0, l2 = json.points.length; i2 < l2; i2++) {
        const point = json.points[i2];
        this.points.push(new Vector2().fromArray(point));
      }
      return this;
    }
  };
  SplineCurve.prototype.isSplineCurve = true;
  var Curves = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ArcCurve,
    CatmullRomCurve3,
    CubicBezierCurve,
    CubicBezierCurve3,
    EllipseCurve,
    LineCurve,
    LineCurve3,
    QuadraticBezierCurve,
    QuadraticBezierCurve3,
    SplineCurve
  });
  var CurvePath = class extends Curve {
    constructor() {
      super();
      this.type = "CurvePath";
      this.curves = [];
      this.autoClose = false;
    }
    add(curve) {
      this.curves.push(curve);
    }
    closePath() {
      const startPoint = this.curves[0].getPoint(0);
      const endPoint = this.curves[this.curves.length - 1].getPoint(1);
      if (!startPoint.equals(endPoint)) {
        this.curves.push(new LineCurve(endPoint, startPoint));
      }
    }
    getPoint(t2, optionalTarget) {
      const d2 = t2 * this.getLength();
      const curveLengths = this.getCurveLengths();
      let i2 = 0;
      while (i2 < curveLengths.length) {
        if (curveLengths[i2] >= d2) {
          const diff = curveLengths[i2] - d2;
          const curve = this.curves[i2];
          const segmentLength = curve.getLength();
          const u2 = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
          return curve.getPointAt(u2, optionalTarget);
        }
        i2++;
      }
      return null;
    }
    getLength() {
      const lens = this.getCurveLengths();
      return lens[lens.length - 1];
    }
    updateArcLengths() {
      this.needsUpdate = true;
      this.cacheLengths = null;
      this.getCurveLengths();
    }
    getCurveLengths() {
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
        return this.cacheLengths;
      }
      const lengths = [];
      let sums = 0;
      for (let i2 = 0, l2 = this.curves.length; i2 < l2; i2++) {
        sums += this.curves[i2].getLength();
        lengths.push(sums);
      }
      this.cacheLengths = lengths;
      return lengths;
    }
    getSpacedPoints(divisions = 40) {
      const points = [];
      for (let i2 = 0; i2 <= divisions; i2++) {
        points.push(this.getPoint(i2 / divisions));
      }
      if (this.autoClose) {
        points.push(points[0]);
      }
      return points;
    }
    getPoints(divisions = 12) {
      const points = [];
      let last;
      for (let i2 = 0, curves = this.curves; i2 < curves.length; i2++) {
        const curve = curves[i2];
        const resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
        const pts = curve.getPoints(resolution);
        for (let j2 = 0; j2 < pts.length; j2++) {
          const point = pts[j2];
          if (last && last.equals(point))
            continue;
          points.push(point);
          last = point;
        }
      }
      if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
        points.push(points[0]);
      }
      return points;
    }
    copy(source) {
      super.copy(source);
      this.curves = [];
      for (let i2 = 0, l2 = source.curves.length; i2 < l2; i2++) {
        const curve = source.curves[i2];
        this.curves.push(curve.clone());
      }
      this.autoClose = source.autoClose;
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.autoClose = this.autoClose;
      data.curves = [];
      for (let i2 = 0, l2 = this.curves.length; i2 < l2; i2++) {
        const curve = this.curves[i2];
        data.curves.push(curve.toJSON());
      }
      return data;
    }
    fromJSON(json) {
      super.fromJSON(json);
      this.autoClose = json.autoClose;
      this.curves = [];
      for (let i2 = 0, l2 = json.curves.length; i2 < l2; i2++) {
        const curve = json.curves[i2];
        this.curves.push(new Curves[curve.type]().fromJSON(curve));
      }
      return this;
    }
  };
  var Path = class extends CurvePath {
    constructor(points) {
      super();
      this.type = "Path";
      this.currentPoint = new Vector2();
      if (points) {
        this.setFromPoints(points);
      }
    }
    setFromPoints(points) {
      this.moveTo(points[0].x, points[0].y);
      for (let i2 = 1, l2 = points.length; i2 < l2; i2++) {
        this.lineTo(points[i2].x, points[i2].y);
      }
      return this;
    }
    moveTo(x2, y2) {
      this.currentPoint.set(x2, y2);
      return this;
    }
    lineTo(x2, y2) {
      const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x2, y2));
      this.curves.push(curve);
      this.currentPoint.set(x2, y2);
      return this;
    }
    quadraticCurveTo(aCPx, aCPy, aX, aY) {
      const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
      this.curves.push(curve);
      this.currentPoint.set(aX, aY);
      return this;
    }
    bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
      const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
      this.curves.push(curve);
      this.currentPoint.set(aX, aY);
      return this;
    }
    splineThru(pts) {
      const npts = [this.currentPoint.clone()].concat(pts);
      const curve = new SplineCurve(npts);
      this.curves.push(curve);
      this.currentPoint.copy(pts[pts.length - 1]);
      return this;
    }
    arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
      const x0 = this.currentPoint.x;
      const y0 = this.currentPoint.y;
      this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
      return this;
    }
    absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
      this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
      return this;
    }
    ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
      const x0 = this.currentPoint.x;
      const y0 = this.currentPoint.y;
      this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
      return this;
    }
    absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
      const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
      if (this.curves.length > 0) {
        const firstPoint = curve.getPoint(0);
        if (!firstPoint.equals(this.currentPoint)) {
          this.lineTo(firstPoint.x, firstPoint.y);
        }
      }
      this.curves.push(curve);
      const lastPoint = curve.getPoint(1);
      this.currentPoint.copy(lastPoint);
      return this;
    }
    copy(source) {
      super.copy(source);
      this.currentPoint.copy(source.currentPoint);
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.currentPoint = this.currentPoint.toArray();
      return data;
    }
    fromJSON(json) {
      super.fromJSON(json);
      this.currentPoint.fromArray(json.currentPoint);
      return this;
    }
  };
  var Shape = class extends Path {
    constructor(points) {
      super(points);
      this.uuid = generateUUID();
      this.type = "Shape";
      this.holes = [];
    }
    getPointsHoles(divisions) {
      const holesPts = [];
      for (let i2 = 0, l2 = this.holes.length; i2 < l2; i2++) {
        holesPts[i2] = this.holes[i2].getPoints(divisions);
      }
      return holesPts;
    }
    extractPoints(divisions) {
      return {
        shape: this.getPoints(divisions),
        holes: this.getPointsHoles(divisions)
      };
    }
    copy(source) {
      super.copy(source);
      this.holes = [];
      for (let i2 = 0, l2 = source.holes.length; i2 < l2; i2++) {
        const hole = source.holes[i2];
        this.holes.push(hole.clone());
      }
      return this;
    }
    toJSON() {
      const data = super.toJSON();
      data.uuid = this.uuid;
      data.holes = [];
      for (let i2 = 0, l2 = this.holes.length; i2 < l2; i2++) {
        const hole = this.holes[i2];
        data.holes.push(hole.toJSON());
      }
      return data;
    }
    fromJSON(json) {
      super.fromJSON(json);
      this.uuid = json.uuid;
      this.holes = [];
      for (let i2 = 0, l2 = json.holes.length; i2 < l2; i2++) {
        const hole = json.holes[i2];
        this.holes.push(new Path().fromJSON(hole));
      }
      return this;
    }
  };
  var Earcut = {
    triangulate: function(data, holeIndices, dim = 2) {
      const hasHoles = holeIndices && holeIndices.length;
      const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
      let outerNode = linkedList(data, 0, outerLen, dim, true);
      const triangles = [];
      if (!outerNode || outerNode.next === outerNode.prev)
        return triangles;
      let minX, minY, maxX, maxY, x2, y2, invSize;
      if (hasHoles)
        outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
      if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for (let i2 = dim; i2 < outerLen; i2 += dim) {
          x2 = data[i2];
          y2 = data[i2 + 1];
          if (x2 < minX)
            minX = x2;
          if (y2 < minY)
            minY = y2;
          if (x2 > maxX)
            maxX = x2;
          if (y2 > maxY)
            maxY = y2;
        }
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 1 / invSize : 0;
      }
      earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
      return triangles;
    }
  };
  function linkedList(data, start, end, dim, clockwise) {
    let i2, last;
    if (clockwise === signedArea(data, start, end, dim) > 0) {
      for (i2 = start; i2 < end; i2 += dim)
        last = insertNode(i2, data[i2], data[i2 + 1], last);
    } else {
      for (i2 = end - dim; i2 >= start; i2 -= dim)
        last = insertNode(i2, data[i2], data[i2 + 1], last);
    }
    if (last && equals(last, last.next)) {
      removeNode(last);
      last = last.next;
    }
    return last;
  }
  function filterPoints(start, end) {
    if (!start)
      return start;
    if (!end)
      end = start;
    let p2 = start, again;
    do {
      again = false;
      if (!p2.steiner && (equals(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
        removeNode(p2);
        p2 = end = p2.prev;
        if (p2 === p2.next)
          break;
        again = true;
      } else {
        p2 = p2.next;
      }
    } while (again || p2 !== end);
    return end;
  }
  function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear)
      return;
    if (!pass && invSize)
      indexCurve(ear, minX, minY, invSize);
    let stop = ear, prev, next;
    while (ear.prev !== ear.next) {
      prev = ear.prev;
      next = ear.next;
      if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
        triangles.push(prev.i / dim);
        triangles.push(ear.i / dim);
        triangles.push(next.i / dim);
        removeNode(ear);
        ear = next.next;
        stop = next.next;
        continue;
      }
      ear = next;
      if (ear === stop) {
        if (!pass) {
          earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
        } else if (pass === 1) {
          ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
          earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
        } else if (pass === 2) {
          splitEarcut(ear, triangles, dim, minX, minY, invSize);
        }
        break;
      }
    }
  }
  function isEar(ear) {
    const a2 = ear.prev, b2 = ear, c2 = ear.next;
    if (area(a2, b2, c2) >= 0)
      return false;
    let p2 = ear.next.next;
    while (p2 !== ear.prev) {
      if (pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
        return false;
      p2 = p2.next;
    }
    return true;
  }
  function isEarHashed(ear, minX, minY, invSize) {
    const a2 = ear.prev, b2 = ear, c2 = ear.next;
    if (area(a2, b2, c2) >= 0)
      return false;
    const minTX = a2.x < b2.x ? a2.x < c2.x ? a2.x : c2.x : b2.x < c2.x ? b2.x : c2.x, minTY = a2.y < b2.y ? a2.y < c2.y ? a2.y : c2.y : b2.y < c2.y ? b2.y : c2.y, maxTX = a2.x > b2.x ? a2.x > c2.x ? a2.x : c2.x : b2.x > c2.x ? b2.x : c2.x, maxTY = a2.y > b2.y ? a2.y > c2.y ? a2.y : c2.y : b2.y > c2.y ? b2.y : c2.y;
    const minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
    let p2 = ear.prevZ, n2 = ear.nextZ;
    while (p2 && p2.z >= minZ && n2 && n2.z <= maxZ) {
      if (p2 !== ear.prev && p2 !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
        return false;
      p2 = p2.prevZ;
      if (n2 !== ear.prev && n2 !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
        return false;
      n2 = n2.nextZ;
    }
    while (p2 && p2.z >= minZ) {
      if (p2 !== ear.prev && p2 !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
        return false;
      p2 = p2.prevZ;
    }
    while (n2 && n2.z <= maxZ) {
      if (n2 !== ear.prev && n2 !== ear.next && pointInTriangle(a2.x, a2.y, b2.x, b2.y, c2.x, c2.y, n2.x, n2.y) && area(n2.prev, n2, n2.next) >= 0)
        return false;
      n2 = n2.nextZ;
    }
    return true;
  }
  function cureLocalIntersections(start, triangles, dim) {
    let p2 = start;
    do {
      const a2 = p2.prev, b2 = p2.next.next;
      if (!equals(a2, b2) && intersects(a2, p2, p2.next, b2) && locallyInside(a2, b2) && locallyInside(b2, a2)) {
        triangles.push(a2.i / dim);
        triangles.push(p2.i / dim);
        triangles.push(b2.i / dim);
        removeNode(p2);
        removeNode(p2.next);
        p2 = start = b2;
      }
      p2 = p2.next;
    } while (p2 !== start);
    return filterPoints(p2);
  }
  function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    let a2 = start;
    do {
      let b2 = a2.next.next;
      while (b2 !== a2.prev) {
        if (a2.i !== b2.i && isValidDiagonal(a2, b2)) {
          let c2 = splitPolygon(a2, b2);
          a2 = filterPoints(a2, a2.next);
          c2 = filterPoints(c2, c2.next);
          earcutLinked(a2, triangles, dim, minX, minY, invSize);
          earcutLinked(c2, triangles, dim, minX, minY, invSize);
          return;
        }
        b2 = b2.next;
      }
      a2 = a2.next;
    } while (a2 !== start);
  }
  function eliminateHoles(data, holeIndices, outerNode, dim) {
    const queue = [];
    let i2, len, start, end, list;
    for (i2 = 0, len = holeIndices.length; i2 < len; i2++) {
      start = holeIndices[i2] * dim;
      end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
      list = linkedList(data, start, end, dim, false);
      if (list === list.next)
        list.steiner = true;
      queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    for (i2 = 0; i2 < queue.length; i2++) {
      eliminateHole(queue[i2], outerNode);
      outerNode = filterPoints(outerNode, outerNode.next);
    }
    return outerNode;
  }
  function compareX(a2, b2) {
    return a2.x - b2.x;
  }
  function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
      const b2 = splitPolygon(outerNode, hole);
      filterPoints(outerNode, outerNode.next);
      filterPoints(b2, b2.next);
    }
  }
  function findHoleBridge(hole, outerNode) {
    let p2 = outerNode;
    const hx = hole.x;
    const hy = hole.y;
    let qx = -Infinity, m2;
    do {
      if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
        const x2 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
        if (x2 <= hx && x2 > qx) {
          qx = x2;
          if (x2 === hx) {
            if (hy === p2.y)
              return p2;
            if (hy === p2.next.y)
              return p2.next;
          }
          m2 = p2.x < p2.next.x ? p2 : p2.next;
        }
      }
      p2 = p2.next;
    } while (p2 !== outerNode);
    if (!m2)
      return null;
    if (hx === qx)
      return m2;
    const stop = m2, mx = m2.x, my = m2.y;
    let tanMin = Infinity, tan;
    p2 = m2;
    do {
      if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
        tan = Math.abs(hy - p2.y) / (hx - p2.x);
        if (locallyInside(p2, hole) && (tan < tanMin || tan === tanMin && (p2.x > m2.x || p2.x === m2.x && sectorContainsSector(m2, p2)))) {
          m2 = p2;
          tanMin = tan;
        }
      }
      p2 = p2.next;
    } while (p2 !== stop);
    return m2;
  }
  function sectorContainsSector(m2, p2) {
    return area(m2.prev, m2, p2.prev) < 0 && area(p2.next, m2, m2.next) < 0;
  }
  function indexCurve(start, minX, minY, invSize) {
    let p2 = start;
    do {
      if (p2.z === null)
        p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
      p2.prevZ = p2.prev;
      p2.nextZ = p2.next;
      p2 = p2.next;
    } while (p2 !== start);
    p2.prevZ.nextZ = null;
    p2.prevZ = null;
    sortLinked(p2);
  }
  function sortLinked(list) {
    let i2, p2, q2, e2, tail, numMerges, pSize, qSize, inSize = 1;
    do {
      p2 = list;
      list = null;
      tail = null;
      numMerges = 0;
      while (p2) {
        numMerges++;
        q2 = p2;
        pSize = 0;
        for (i2 = 0; i2 < inSize; i2++) {
          pSize++;
          q2 = q2.nextZ;
          if (!q2)
            break;
        }
        qSize = inSize;
        while (pSize > 0 || qSize > 0 && q2) {
          if (pSize !== 0 && (qSize === 0 || !q2 || p2.z <= q2.z)) {
            e2 = p2;
            p2 = p2.nextZ;
            pSize--;
          } else {
            e2 = q2;
            q2 = q2.nextZ;
            qSize--;
          }
          if (tail)
            tail.nextZ = e2;
          else
            list = e2;
          e2.prevZ = tail;
          tail = e2;
        }
        p2 = q2;
      }
      tail.nextZ = null;
      inSize *= 2;
    } while (numMerges > 1);
    return list;
  }
  function zOrder(x2, y2, minX, minY, invSize) {
    x2 = 32767 * (x2 - minX) * invSize;
    y2 = 32767 * (y2 - minY) * invSize;
    x2 = (x2 | x2 << 8) & 16711935;
    x2 = (x2 | x2 << 4) & 252645135;
    x2 = (x2 | x2 << 2) & 858993459;
    x2 = (x2 | x2 << 1) & 1431655765;
    y2 = (y2 | y2 << 8) & 16711935;
    y2 = (y2 | y2 << 4) & 252645135;
    y2 = (y2 | y2 << 2) & 858993459;
    y2 = (y2 | y2 << 1) & 1431655765;
    return x2 | y2 << 1;
  }
  function getLeftmost(start) {
    let p2 = start, leftmost = start;
    do {
      if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y)
        leftmost = p2;
      p2 = p2.next;
    } while (p2 !== start);
    return leftmost;
  }
  function pointInTriangle(ax, ay, bx, by, cx, cy, px2, py2) {
    return (cx - px2) * (ay - py2) - (ax - px2) * (cy - py2) >= 0 && (ax - px2) * (by - py2) - (bx - px2) * (ay - py2) >= 0 && (bx - px2) * (cy - py2) - (cx - px2) * (by - py2) >= 0;
  }
  function isValidDiagonal(a2, b2) {
    return a2.next.i !== b2.i && a2.prev.i !== b2.i && !intersectsPolygon(a2, b2) && (locallyInside(a2, b2) && locallyInside(b2, a2) && middleInside(a2, b2) && (area(a2.prev, a2, b2.prev) || area(a2, b2.prev, b2)) || equals(a2, b2) && area(a2.prev, a2, a2.next) > 0 && area(b2.prev, b2, b2.next) > 0);
  }
  function area(p2, q2, r2) {
    return (q2.y - p2.y) * (r2.x - q2.x) - (q2.x - p2.x) * (r2.y - q2.y);
  }
  function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
  }
  function intersects(p1, q1, p2, q2) {
    const o1 = sign(area(p1, q1, p2));
    const o2 = sign(area(p1, q1, q2));
    const o3 = sign(area(p2, q2, p1));
    const o4 = sign(area(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4)
      return true;
    if (o1 === 0 && onSegment(p1, p2, q1))
      return true;
    if (o2 === 0 && onSegment(p1, q2, q1))
      return true;
    if (o3 === 0 && onSegment(p2, p1, q2))
      return true;
    if (o4 === 0 && onSegment(p2, q1, q2))
      return true;
    return false;
  }
  function onSegment(p2, q2, r2) {
    return q2.x <= Math.max(p2.x, r2.x) && q2.x >= Math.min(p2.x, r2.x) && q2.y <= Math.max(p2.y, r2.y) && q2.y >= Math.min(p2.y, r2.y);
  }
  function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
  }
  function intersectsPolygon(a2, b2) {
    let p2 = a2;
    do {
      if (p2.i !== a2.i && p2.next.i !== a2.i && p2.i !== b2.i && p2.next.i !== b2.i && intersects(p2, p2.next, a2, b2))
        return true;
      p2 = p2.next;
    } while (p2 !== a2);
    return false;
  }
  function locallyInside(a2, b2) {
    return area(a2.prev, a2, a2.next) < 0 ? area(a2, b2, a2.next) >= 0 && area(a2, a2.prev, b2) >= 0 : area(a2, b2, a2.prev) < 0 || area(a2, a2.next, b2) < 0;
  }
  function middleInside(a2, b2) {
    let p2 = a2, inside = false;
    const px2 = (a2.x + b2.x) / 2, py2 = (a2.y + b2.y) / 2;
    do {
      if (p2.y > py2 !== p2.next.y > py2 && p2.next.y !== p2.y && px2 < (p2.next.x - p2.x) * (py2 - p2.y) / (p2.next.y - p2.y) + p2.x)
        inside = !inside;
      p2 = p2.next;
    } while (p2 !== a2);
    return inside;
  }
  function splitPolygon(a2, b2) {
    const a22 = new Node(a2.i, a2.x, a2.y), b22 = new Node(b2.i, b2.x, b2.y), an = a2.next, bp = b2.prev;
    a2.next = b2;
    b2.prev = a2;
    a22.next = an;
    an.prev = a22;
    b22.next = a22;
    a22.prev = b22;
    bp.next = b22;
    b22.prev = bp;
    return b22;
  }
  function insertNode(i2, x2, y2, last) {
    const p2 = new Node(i2, x2, y2);
    if (!last) {
      p2.prev = p2;
      p2.next = p2;
    } else {
      p2.next = last.next;
      p2.prev = last;
      last.next.prev = p2;
      last.next = p2;
    }
    return p2;
  }
  function removeNode(p2) {
    p2.next.prev = p2.prev;
    p2.prev.next = p2.next;
    if (p2.prevZ)
      p2.prevZ.nextZ = p2.nextZ;
    if (p2.nextZ)
      p2.nextZ.prevZ = p2.prevZ;
  }
  function Node(i2, x2, y2) {
    this.i = i2;
    this.x = x2;
    this.y = y2;
    this.prev = null;
    this.next = null;
    this.z = null;
    this.prevZ = null;
    this.nextZ = null;
    this.steiner = false;
  }
  function signedArea(data, start, end, dim) {
    let sum = 0;
    for (let i2 = start, j2 = end - dim; i2 < end; i2 += dim) {
      sum += (data[j2] - data[i2]) * (data[i2 + 1] + data[j2 + 1]);
      j2 = i2;
    }
    return sum;
  }
  var ShapeUtils = class {
    static area(contour) {
      const n2 = contour.length;
      let a2 = 0;
      for (let p2 = n2 - 1, q2 = 0; q2 < n2; p2 = q2++) {
        a2 += contour[p2].x * contour[q2].y - contour[q2].x * contour[p2].y;
      }
      return a2 * 0.5;
    }
    static isClockWise(pts) {
      return ShapeUtils.area(pts) < 0;
    }
    static triangulateShape(contour, holes) {
      const vertices = [];
      const holeIndices = [];
      const faces = [];
      removeDupEndPts(contour);
      addContour(vertices, contour);
      let holeIndex = contour.length;
      holes.forEach(removeDupEndPts);
      for (let i2 = 0; i2 < holes.length; i2++) {
        holeIndices.push(holeIndex);
        holeIndex += holes[i2].length;
        addContour(vertices, holes[i2]);
      }
      const triangles = Earcut.triangulate(vertices, holeIndices);
      for (let i2 = 0; i2 < triangles.length; i2 += 3) {
        faces.push(triangles.slice(i2, i2 + 3));
      }
      return faces;
    }
  };
  function removeDupEndPts(points) {
    const l2 = points.length;
    if (l2 > 2 && points[l2 - 1].equals(points[0])) {
      points.pop();
    }
  }
  function addContour(vertices, contour) {
    for (let i2 = 0; i2 < contour.length; i2++) {
      vertices.push(contour[i2].x);
      vertices.push(contour[i2].y);
    }
  }
  var ExtrudeGeometry = class extends BufferGeometry {
    constructor(shapes = new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), options = {}) {
      super();
      this.type = "ExtrudeGeometry";
      this.parameters = {
        shapes,
        options
      };
      shapes = Array.isArray(shapes) ? shapes : [shapes];
      const scope = this;
      const verticesArray = [];
      const uvArray = [];
      for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
        const shape = shapes[i2];
        addShape(shape);
      }
      this.setAttribute("position", new Float32BufferAttribute(verticesArray, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvArray, 2));
      this.computeVertexNormals();
      function addShape(shape) {
        const placeholder = [];
        const curveSegments = options.curveSegments !== void 0 ? options.curveSegments : 12;
        const steps = options.steps !== void 0 ? options.steps : 1;
        let depth = options.depth !== void 0 ? options.depth : 1;
        let bevelEnabled = options.bevelEnabled !== void 0 ? options.bevelEnabled : true;
        let bevelThickness = options.bevelThickness !== void 0 ? options.bevelThickness : 0.2;
        let bevelSize = options.bevelSize !== void 0 ? options.bevelSize : bevelThickness - 0.1;
        let bevelOffset = options.bevelOffset !== void 0 ? options.bevelOffset : 0;
        let bevelSegments = options.bevelSegments !== void 0 ? options.bevelSegments : 3;
        const extrudePath = options.extrudePath;
        const uvgen = options.UVGenerator !== void 0 ? options.UVGenerator : WorldUVGenerator;
        if (options.amount !== void 0) {
          console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth.");
          depth = options.amount;
        }
        let extrudePts, extrudeByPath = false;
        let splineTube, binormal, normal, position2;
        if (extrudePath) {
          extrudePts = extrudePath.getSpacedPoints(steps);
          extrudeByPath = true;
          bevelEnabled = false;
          splineTube = extrudePath.computeFrenetFrames(steps, false);
          binormal = new Vector3();
          normal = new Vector3();
          position2 = new Vector3();
        }
        if (!bevelEnabled) {
          bevelSegments = 0;
          bevelThickness = 0;
          bevelSize = 0;
          bevelOffset = 0;
        }
        const shapePoints = shape.extractPoints(curveSegments);
        let vertices = shapePoints.shape;
        const holes = shapePoints.holes;
        const reverse = !ShapeUtils.isClockWise(vertices);
        if (reverse) {
          vertices = vertices.reverse();
          for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
            const ahole = holes[h2];
            if (ShapeUtils.isClockWise(ahole)) {
              holes[h2] = ahole.reverse();
            }
          }
        }
        const faces = ShapeUtils.triangulateShape(vertices, holes);
        const contour = vertices;
        for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
          const ahole = holes[h2];
          vertices = vertices.concat(ahole);
        }
        function scalePt2(pt, vec, size) {
          if (!vec)
            console.error("THREE.ExtrudeGeometry: vec does not exist");
          return vec.clone().multiplyScalar(size).add(pt);
        }
        const vlen = vertices.length, flen = faces.length;
        function getBevelVec(inPt, inPrev, inNext) {
          let v_trans_x, v_trans_y, shrink_by;
          const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
          const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
          const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
          const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
          if (Math.abs(collinear0) > Number.EPSILON) {
            const v_prev_len = Math.sqrt(v_prev_lensq);
            const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
            const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
            const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
            const ptNextShift_x = inNext.x - v_next_y / v_next_len;
            const ptNextShift_y = inNext.y + v_next_x / v_next_len;
            const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
            v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
            v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
            const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
            if (v_trans_lensq <= 2) {
              return new Vector2(v_trans_x, v_trans_y);
            } else {
              shrink_by = Math.sqrt(v_trans_lensq / 2);
            }
          } else {
            let direction_eq = false;
            if (v_prev_x > Number.EPSILON) {
              if (v_next_x > Number.EPSILON) {
                direction_eq = true;
              }
            } else {
              if (v_prev_x < -Number.EPSILON) {
                if (v_next_x < -Number.EPSILON) {
                  direction_eq = true;
                }
              } else {
                if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                  direction_eq = true;
                }
              }
            }
            if (direction_eq) {
              v_trans_x = -v_prev_y;
              v_trans_y = v_prev_x;
              shrink_by = Math.sqrt(v_prev_lensq);
            } else {
              v_trans_x = v_prev_x;
              v_trans_y = v_prev_y;
              shrink_by = Math.sqrt(v_prev_lensq / 2);
            }
          }
          return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
        }
        const contourMovements = [];
        for (let i2 = 0, il = contour.length, j2 = il - 1, k2 = i2 + 1; i2 < il; i2++, j2++, k2++) {
          if (j2 === il)
            j2 = 0;
          if (k2 === il)
            k2 = 0;
          contourMovements[i2] = getBevelVec(contour[i2], contour[j2], contour[k2]);
        }
        const holesMovements = [];
        let oneHoleMovements, verticesMovements = contourMovements.concat();
        for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
          const ahole = holes[h2];
          oneHoleMovements = [];
          for (let i2 = 0, il = ahole.length, j2 = il - 1, k2 = i2 + 1; i2 < il; i2++, j2++, k2++) {
            if (j2 === il)
              j2 = 0;
            if (k2 === il)
              k2 = 0;
            oneHoleMovements[i2] = getBevelVec(ahole[i2], ahole[j2], ahole[k2]);
          }
          holesMovements.push(oneHoleMovements);
          verticesMovements = verticesMovements.concat(oneHoleMovements);
        }
        for (let b2 = 0; b2 < bevelSegments; b2++) {
          const t2 = b2 / bevelSegments;
          const z2 = bevelThickness * Math.cos(t2 * Math.PI / 2);
          const bs2 = bevelSize * Math.sin(t2 * Math.PI / 2) + bevelOffset;
          for (let i2 = 0, il = contour.length; i2 < il; i2++) {
            const vert = scalePt2(contour[i2], contourMovements[i2], bs2);
            v2(vert.x, vert.y, -z2);
          }
          for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
            const ahole = holes[h2];
            oneHoleMovements = holesMovements[h2];
            for (let i2 = 0, il = ahole.length; i2 < il; i2++) {
              const vert = scalePt2(ahole[i2], oneHoleMovements[i2], bs2);
              v2(vert.x, vert.y, -z2);
            }
          }
        }
        const bs = bevelSize + bevelOffset;
        for (let i2 = 0; i2 < vlen; i2++) {
          const vert = bevelEnabled ? scalePt2(vertices[i2], verticesMovements[i2], bs) : vertices[i2];
          if (!extrudeByPath) {
            v2(vert.x, vert.y, 0);
          } else {
            normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
            position2.copy(extrudePts[0]).add(normal).add(binormal);
            v2(position2.x, position2.y, position2.z);
          }
        }
        for (let s2 = 1; s2 <= steps; s2++) {
          for (let i2 = 0; i2 < vlen; i2++) {
            const vert = bevelEnabled ? scalePt2(vertices[i2], verticesMovements[i2], bs) : vertices[i2];
            if (!extrudeByPath) {
              v2(vert.x, vert.y, depth / steps * s2);
            } else {
              normal.copy(splineTube.normals[s2]).multiplyScalar(vert.x);
              binormal.copy(splineTube.binormals[s2]).multiplyScalar(vert.y);
              position2.copy(extrudePts[s2]).add(normal).add(binormal);
              v2(position2.x, position2.y, position2.z);
            }
          }
        }
        for (let b2 = bevelSegments - 1; b2 >= 0; b2--) {
          const t2 = b2 / bevelSegments;
          const z2 = bevelThickness * Math.cos(t2 * Math.PI / 2);
          const bs2 = bevelSize * Math.sin(t2 * Math.PI / 2) + bevelOffset;
          for (let i2 = 0, il = contour.length; i2 < il; i2++) {
            const vert = scalePt2(contour[i2], contourMovements[i2], bs2);
            v2(vert.x, vert.y, depth + z2);
          }
          for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
            const ahole = holes[h2];
            oneHoleMovements = holesMovements[h2];
            for (let i2 = 0, il = ahole.length; i2 < il; i2++) {
              const vert = scalePt2(ahole[i2], oneHoleMovements[i2], bs2);
              if (!extrudeByPath) {
                v2(vert.x, vert.y, depth + z2);
              } else {
                v2(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z2);
              }
            }
          }
        }
        buildLidFaces();
        buildSideFaces();
        function buildLidFaces() {
          const start = verticesArray.length / 3;
          if (bevelEnabled) {
            let layer = 0;
            let offset = vlen * layer;
            for (let i2 = 0; i2 < flen; i2++) {
              const face = faces[i2];
              f3(face[2] + offset, face[1] + offset, face[0] + offset);
            }
            layer = steps + bevelSegments * 2;
            offset = vlen * layer;
            for (let i2 = 0; i2 < flen; i2++) {
              const face = faces[i2];
              f3(face[0] + offset, face[1] + offset, face[2] + offset);
            }
          } else {
            for (let i2 = 0; i2 < flen; i2++) {
              const face = faces[i2];
              f3(face[2], face[1], face[0]);
            }
            for (let i2 = 0; i2 < flen; i2++) {
              const face = faces[i2];
              f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
            }
          }
          scope.addGroup(start, verticesArray.length / 3 - start, 0);
        }
        function buildSideFaces() {
          const start = verticesArray.length / 3;
          let layeroffset = 0;
          sidewalls(contour, layeroffset);
          layeroffset += contour.length;
          for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
            const ahole = holes[h2];
            sidewalls(ahole, layeroffset);
            layeroffset += ahole.length;
          }
          scope.addGroup(start, verticesArray.length / 3 - start, 1);
        }
        function sidewalls(contour2, layeroffset) {
          let i2 = contour2.length;
          while (--i2 >= 0) {
            const j2 = i2;
            let k2 = i2 - 1;
            if (k2 < 0)
              k2 = contour2.length - 1;
            for (let s2 = 0, sl = steps + bevelSegments * 2; s2 < sl; s2++) {
              const slen1 = vlen * s2;
              const slen2 = vlen * (s2 + 1);
              const a2 = layeroffset + j2 + slen1, b2 = layeroffset + k2 + slen1, c2 = layeroffset + k2 + slen2, d2 = layeroffset + j2 + slen2;
              f4(a2, b2, c2, d2);
            }
          }
        }
        function v2(x2, y2, z2) {
          placeholder.push(x2);
          placeholder.push(y2);
          placeholder.push(z2);
        }
        function f3(a2, b2, c2) {
          addVertex(a2);
          addVertex(b2);
          addVertex(c2);
          const nextIndex = verticesArray.length / 3;
          const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
          addUV(uvs[0]);
          addUV(uvs[1]);
          addUV(uvs[2]);
        }
        function f4(a2, b2, c2, d2) {
          addVertex(a2);
          addVertex(b2);
          addVertex(d2);
          addVertex(b2);
          addVertex(c2);
          addVertex(d2);
          const nextIndex = verticesArray.length / 3;
          const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
          addUV(uvs[0]);
          addUV(uvs[1]);
          addUV(uvs[3]);
          addUV(uvs[1]);
          addUV(uvs[2]);
          addUV(uvs[3]);
        }
        function addVertex(index) {
          verticesArray.push(placeholder[index * 3 + 0]);
          verticesArray.push(placeholder[index * 3 + 1]);
          verticesArray.push(placeholder[index * 3 + 2]);
        }
        function addUV(vector2) {
          uvArray.push(vector2.x);
          uvArray.push(vector2.y);
        }
      }
    }
    toJSON() {
      const data = super.toJSON();
      const shapes = this.parameters.shapes;
      const options = this.parameters.options;
      return toJSON$1(shapes, options, data);
    }
    static fromJSON(data, shapes) {
      const geometryShapes = [];
      for (let j2 = 0, jl = data.shapes.length; j2 < jl; j2++) {
        const shape = shapes[data.shapes[j2]];
        geometryShapes.push(shape);
      }
      const extrudePath = data.options.extrudePath;
      if (extrudePath !== void 0) {
        data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
      }
      return new ExtrudeGeometry(geometryShapes, data.options);
    }
  };
  var WorldUVGenerator = {
    generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
      const a_x = vertices[indexA * 3];
      const a_y = vertices[indexA * 3 + 1];
      const b_x = vertices[indexB * 3];
      const b_y = vertices[indexB * 3 + 1];
      const c_x = vertices[indexC * 3];
      const c_y = vertices[indexC * 3 + 1];
      return [
        new Vector2(a_x, a_y),
        new Vector2(b_x, b_y),
        new Vector2(c_x, c_y)
      ];
    },
    generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
      const a_x = vertices[indexA * 3];
      const a_y = vertices[indexA * 3 + 1];
      const a_z = vertices[indexA * 3 + 2];
      const b_x = vertices[indexB * 3];
      const b_y = vertices[indexB * 3 + 1];
      const b_z = vertices[indexB * 3 + 2];
      const c_x = vertices[indexC * 3];
      const c_y = vertices[indexC * 3 + 1];
      const c_z = vertices[indexC * 3 + 2];
      const d_x = vertices[indexD * 3];
      const d_y = vertices[indexD * 3 + 1];
      const d_z = vertices[indexD * 3 + 2];
      if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
        return [
          new Vector2(a_x, 1 - a_z),
          new Vector2(b_x, 1 - b_z),
          new Vector2(c_x, 1 - c_z),
          new Vector2(d_x, 1 - d_z)
        ];
      } else {
        return [
          new Vector2(a_y, 1 - a_z),
          new Vector2(b_y, 1 - b_z),
          new Vector2(c_y, 1 - c_z),
          new Vector2(d_y, 1 - d_z)
        ];
      }
    }
  };
  function toJSON$1(shapes, options, data) {
    data.shapes = [];
    if (Array.isArray(shapes)) {
      for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
        const shape = shapes[i2];
        data.shapes.push(shape.uuid);
      }
    } else {
      data.shapes.push(shapes.uuid);
    }
    if (options.extrudePath !== void 0)
      data.options.extrudePath = options.extrudePath.toJSON();
    return data;
  }
  var ShapeGeometry = class extends BufferGeometry {
    constructor(shapes = new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), curveSegments = 12) {
      super();
      this.type = "ShapeGeometry";
      this.parameters = {
        shapes,
        curveSegments
      };
      const indices = [];
      const vertices = [];
      const normals = [];
      const uvs = [];
      let groupStart = 0;
      let groupCount = 0;
      if (Array.isArray(shapes) === false) {
        addShape(shapes);
      } else {
        for (let i2 = 0; i2 < shapes.length; i2++) {
          addShape(shapes[i2]);
          this.addGroup(groupStart, groupCount, i2);
          groupStart += groupCount;
          groupCount = 0;
        }
      }
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
      function addShape(shape) {
        const indexOffset = vertices.length / 3;
        const points = shape.extractPoints(curveSegments);
        let shapeVertices = points.shape;
        const shapeHoles = points.holes;
        if (ShapeUtils.isClockWise(shapeVertices) === false) {
          shapeVertices = shapeVertices.reverse();
        }
        for (let i2 = 0, l2 = shapeHoles.length; i2 < l2; i2++) {
          const shapeHole = shapeHoles[i2];
          if (ShapeUtils.isClockWise(shapeHole) === true) {
            shapeHoles[i2] = shapeHole.reverse();
          }
        }
        const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
        for (let i2 = 0, l2 = shapeHoles.length; i2 < l2; i2++) {
          const shapeHole = shapeHoles[i2];
          shapeVertices = shapeVertices.concat(shapeHole);
        }
        for (let i2 = 0, l2 = shapeVertices.length; i2 < l2; i2++) {
          const vertex2 = shapeVertices[i2];
          vertices.push(vertex2.x, vertex2.y, 0);
          normals.push(0, 0, 1);
          uvs.push(vertex2.x, vertex2.y);
        }
        for (let i2 = 0, l2 = faces.length; i2 < l2; i2++) {
          const face = faces[i2];
          const a2 = face[0] + indexOffset;
          const b2 = face[1] + indexOffset;
          const c2 = face[2] + indexOffset;
          indices.push(a2, b2, c2);
          groupCount += 3;
        }
      }
    }
    toJSON() {
      const data = super.toJSON();
      const shapes = this.parameters.shapes;
      return toJSON(shapes, data);
    }
    static fromJSON(data, shapes) {
      const geometryShapes = [];
      for (let j2 = 0, jl = data.shapes.length; j2 < jl; j2++) {
        const shape = shapes[data.shapes[j2]];
        geometryShapes.push(shape);
      }
      return new ShapeGeometry(geometryShapes, data.curveSegments);
    }
  };
  function toJSON(shapes, data) {
    data.shapes = [];
    if (Array.isArray(shapes)) {
      for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
        const shape = shapes[i2];
        data.shapes.push(shape.uuid);
      }
    } else {
      data.shapes.push(shapes.uuid);
    }
    return data;
  }
  var SphereGeometry = class extends BufferGeometry {
    constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
      super();
      this.type = "SphereGeometry";
      this.parameters = {
        radius,
        widthSegments,
        heightSegments,
        phiStart,
        phiLength,
        thetaStart,
        thetaLength
      };
      widthSegments = Math.max(3, Math.floor(widthSegments));
      heightSegments = Math.max(2, Math.floor(heightSegments));
      const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
      let index = 0;
      const grid = [];
      const vertex2 = new Vector3();
      const normal = new Vector3();
      const indices = [];
      const vertices = [];
      const normals = [];
      const uvs = [];
      for (let iy = 0; iy <= heightSegments; iy++) {
        const verticesRow = [];
        const v2 = iy / heightSegments;
        let uOffset = 0;
        if (iy == 0 && thetaStart == 0) {
          uOffset = 0.5 / widthSegments;
        } else if (iy == heightSegments && thetaEnd == Math.PI) {
          uOffset = -0.5 / widthSegments;
        }
        for (let ix = 0; ix <= widthSegments; ix++) {
          const u2 = ix / widthSegments;
          vertex2.x = -radius * Math.cos(phiStart + u2 * phiLength) * Math.sin(thetaStart + v2 * thetaLength);
          vertex2.y = radius * Math.cos(thetaStart + v2 * thetaLength);
          vertex2.z = radius * Math.sin(phiStart + u2 * phiLength) * Math.sin(thetaStart + v2 * thetaLength);
          vertices.push(vertex2.x, vertex2.y, vertex2.z);
          normal.copy(vertex2).normalize();
          normals.push(normal.x, normal.y, normal.z);
          uvs.push(u2 + uOffset, 1 - v2);
          verticesRow.push(index++);
        }
        grid.push(verticesRow);
      }
      for (let iy = 0; iy < heightSegments; iy++) {
        for (let ix = 0; ix < widthSegments; ix++) {
          const a2 = grid[iy][ix + 1];
          const b2 = grid[iy][ix];
          const c2 = grid[iy + 1][ix];
          const d2 = grid[iy + 1][ix + 1];
          if (iy !== 0 || thetaStart > 0)
            indices.push(a2, b2, d2);
          if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
            indices.push(b2, c2, d2);
        }
      }
      this.setIndex(indices);
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    }
    static fromJSON(data) {
      return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
    }
  };
  var ShadowMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.type = "ShadowMaterial";
      this.color = new Color(0);
      this.transparent = true;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      return this;
    }
  };
  ShadowMaterial.prototype.isShadowMaterial = true;
  var MeshStandardMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.defines = { "STANDARD": "" };
      this.type = "MeshStandardMaterial";
      this.color = new Color(16777215);
      this.roughness = 1;
      this.metalness = 0;
      this.map = null;
      this.lightMap = null;
      this.lightMapIntensity = 1;
      this.aoMap = null;
      this.aoMapIntensity = 1;
      this.emissive = new Color(0);
      this.emissiveIntensity = 1;
      this.emissiveMap = null;
      this.bumpMap = null;
      this.bumpScale = 1;
      this.normalMap = null;
      this.normalMapType = TangentSpaceNormalMap;
      this.normalScale = new Vector2(1, 1);
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.roughnessMap = null;
      this.metalnessMap = null;
      this.alphaMap = null;
      this.envMap = null;
      this.envMapIntensity = 1;
      this.refractionRatio = 0.98;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = "round";
      this.wireframeLinejoin = "round";
      this.flatShading = false;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.defines = { "STANDARD": "" };
      this.color.copy(source.color);
      this.roughness = source.roughness;
      this.metalness = source.metalness;
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.roughnessMap = source.roughnessMap;
      this.metalnessMap = source.metalnessMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.envMapIntensity = source.envMapIntensity;
      this.refractionRatio = source.refractionRatio;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.flatShading = source.flatShading;
      return this;
    }
  };
  MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
  var MeshPhysicalMaterial = class extends MeshStandardMaterial {
    constructor(parameters) {
      super();
      this.defines = {
        "STANDARD": "",
        "PHYSICAL": ""
      };
      this.type = "MeshPhysicalMaterial";
      this.clearcoatMap = null;
      this.clearcoatRoughness = 0;
      this.clearcoatRoughnessMap = null;
      this.clearcoatNormalScale = new Vector2(1, 1);
      this.clearcoatNormalMap = null;
      this.ior = 1.5;
      Object.defineProperty(this, "reflectivity", {
        get: function() {
          return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
        },
        set: function(reflectivity) {
          this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
        }
      });
      this.sheenTint = new Color(0);
      this.sheenRoughness = 1;
      this.transmissionMap = null;
      this.thickness = 0.01;
      this.thicknessMap = null;
      this.attenuationDistance = 0;
      this.attenuationTint = new Color(1, 1, 1);
      this.specularIntensity = 1;
      this.specularIntensityMap = null;
      this.specularTint = new Color(1, 1, 1);
      this.specularTintMap = null;
      this._sheen = 0;
      this._clearcoat = 0;
      this._transmission = 0;
      this.setValues(parameters);
    }
    get sheen() {
      return this._sheen;
    }
    set sheen(value) {
      if (this._sheen > 0 !== value > 0) {
        this.version++;
      }
      this._sheen = value;
    }
    get clearcoat() {
      return this._clearcoat;
    }
    set clearcoat(value) {
      if (this._clearcoat > 0 !== value > 0) {
        this.version++;
      }
      this._clearcoat = value;
    }
    get transmission() {
      return this._transmission;
    }
    set transmission(value) {
      if (this._transmission > 0 !== value > 0) {
        this.version++;
      }
      this._transmission = value;
    }
    copy(source) {
      super.copy(source);
      this.defines = {
        "STANDARD": "",
        "PHYSICAL": ""
      };
      this.clearcoat = source.clearcoat;
      this.clearcoatMap = source.clearcoatMap;
      this.clearcoatRoughness = source.clearcoatRoughness;
      this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
      this.clearcoatNormalMap = source.clearcoatNormalMap;
      this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
      this.ior = source.ior;
      this.sheen = source.sheen;
      this.sheenTint.copy(source.sheenTint);
      this.sheenRoughness = source.sheenRoughness;
      this.transmission = source.transmission;
      this.transmissionMap = source.transmissionMap;
      this.thickness = source.thickness;
      this.thicknessMap = source.thicknessMap;
      this.attenuationDistance = source.attenuationDistance;
      this.attenuationTint.copy(source.attenuationTint);
      this.specularIntensity = source.specularIntensity;
      this.specularIntensityMap = source.specularIntensityMap;
      this.specularTint.copy(source.specularTint);
      this.specularTintMap = source.specularTintMap;
      return this;
    }
  };
  MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
  var MeshPhongMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.type = "MeshPhongMaterial";
      this.color = new Color(16777215);
      this.specular = new Color(1118481);
      this.shininess = 30;
      this.map = null;
      this.lightMap = null;
      this.lightMapIntensity = 1;
      this.aoMap = null;
      this.aoMapIntensity = 1;
      this.emissive = new Color(0);
      this.emissiveIntensity = 1;
      this.emissiveMap = null;
      this.bumpMap = null;
      this.bumpScale = 1;
      this.normalMap = null;
      this.normalMapType = TangentSpaceNormalMap;
      this.normalScale = new Vector2(1, 1);
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.specularMap = null;
      this.alphaMap = null;
      this.envMap = null;
      this.combine = MultiplyOperation;
      this.reflectivity = 1;
      this.refractionRatio = 0.98;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = "round";
      this.wireframeLinejoin = "round";
      this.flatShading = false;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.specular.copy(source.specular);
      this.shininess = source.shininess;
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.specularMap = source.specularMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      this.flatShading = source.flatShading;
      return this;
    }
  };
  MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
  var MeshToonMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.defines = { "TOON": "" };
      this.type = "MeshToonMaterial";
      this.color = new Color(16777215);
      this.map = null;
      this.gradientMap = null;
      this.lightMap = null;
      this.lightMapIntensity = 1;
      this.aoMap = null;
      this.aoMapIntensity = 1;
      this.emissive = new Color(0);
      this.emissiveIntensity = 1;
      this.emissiveMap = null;
      this.bumpMap = null;
      this.bumpScale = 1;
      this.normalMap = null;
      this.normalMapType = TangentSpaceNormalMap;
      this.normalScale = new Vector2(1, 1);
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.alphaMap = null;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = "round";
      this.wireframeLinejoin = "round";
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.map = source.map;
      this.gradientMap = source.gradientMap;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.alphaMap = source.alphaMap;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      return this;
    }
  };
  MeshToonMaterial.prototype.isMeshToonMaterial = true;
  var MeshNormalMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.type = "MeshNormalMaterial";
      this.bumpMap = null;
      this.bumpScale = 1;
      this.normalMap = null;
      this.normalMapType = TangentSpaceNormalMap;
      this.normalScale = new Vector2(1, 1);
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.fog = false;
      this.flatShading = false;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.flatShading = source.flatShading;
      return this;
    }
  };
  MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
  var MeshLambertMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.type = "MeshLambertMaterial";
      this.color = new Color(16777215);
      this.map = null;
      this.lightMap = null;
      this.lightMapIntensity = 1;
      this.aoMap = null;
      this.aoMapIntensity = 1;
      this.emissive = new Color(0);
      this.emissiveIntensity = 1;
      this.emissiveMap = null;
      this.specularMap = null;
      this.alphaMap = null;
      this.envMap = null;
      this.combine = MultiplyOperation;
      this.reflectivity = 1;
      this.refractionRatio = 0.98;
      this.wireframe = false;
      this.wireframeLinewidth = 1;
      this.wireframeLinecap = "round";
      this.wireframeLinejoin = "round";
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.map = source.map;
      this.lightMap = source.lightMap;
      this.lightMapIntensity = source.lightMapIntensity;
      this.aoMap = source.aoMap;
      this.aoMapIntensity = source.aoMapIntensity;
      this.emissive.copy(source.emissive);
      this.emissiveMap = source.emissiveMap;
      this.emissiveIntensity = source.emissiveIntensity;
      this.specularMap = source.specularMap;
      this.alphaMap = source.alphaMap;
      this.envMap = source.envMap;
      this.combine = source.combine;
      this.reflectivity = source.reflectivity;
      this.refractionRatio = source.refractionRatio;
      this.wireframe = source.wireframe;
      this.wireframeLinewidth = source.wireframeLinewidth;
      this.wireframeLinecap = source.wireframeLinecap;
      this.wireframeLinejoin = source.wireframeLinejoin;
      return this;
    }
  };
  MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
  var MeshMatcapMaterial = class extends Material {
    constructor(parameters) {
      super();
      this.defines = { "MATCAP": "" };
      this.type = "MeshMatcapMaterial";
      this.color = new Color(16777215);
      this.matcap = null;
      this.map = null;
      this.bumpMap = null;
      this.bumpScale = 1;
      this.normalMap = null;
      this.normalMapType = TangentSpaceNormalMap;
      this.normalScale = new Vector2(1, 1);
      this.displacementMap = null;
      this.displacementScale = 1;
      this.displacementBias = 0;
      this.alphaMap = null;
      this.flatShading = false;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.defines = { "MATCAP": "" };
      this.color.copy(source.color);
      this.matcap = source.matcap;
      this.map = source.map;
      this.bumpMap = source.bumpMap;
      this.bumpScale = source.bumpScale;
      this.normalMap = source.normalMap;
      this.normalMapType = source.normalMapType;
      this.normalScale.copy(source.normalScale);
      this.displacementMap = source.displacementMap;
      this.displacementScale = source.displacementScale;
      this.displacementBias = source.displacementBias;
      this.alphaMap = source.alphaMap;
      this.flatShading = source.flatShading;
      return this;
    }
  };
  MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
  var LineDashedMaterial = class extends LineBasicMaterial {
    constructor(parameters) {
      super();
      this.type = "LineDashedMaterial";
      this.scale = 1;
      this.dashSize = 3;
      this.gapSize = 1;
      this.setValues(parameters);
    }
    copy(source) {
      super.copy(source);
      this.scale = source.scale;
      this.dashSize = source.dashSize;
      this.gapSize = source.gapSize;
      return this;
    }
  };
  LineDashedMaterial.prototype.isLineDashedMaterial = true;
  var AnimationUtils = {
    arraySlice: function(array, from, to) {
      if (AnimationUtils.isTypedArray(array)) {
        return new array.constructor(array.subarray(from, to !== void 0 ? to : array.length));
      }
      return array.slice(from, to);
    },
    convertArray: function(array, type, forceClone) {
      if (!array || !forceClone && array.constructor === type)
        return array;
      if (typeof type.BYTES_PER_ELEMENT === "number") {
        return new type(array);
      }
      return Array.prototype.slice.call(array);
    },
    isTypedArray: function(object) {
      return ArrayBuffer.isView(object) && !(object instanceof DataView);
    },
    getKeyframeOrder: function(times) {
      function compareTime(i2, j2) {
        return times[i2] - times[j2];
      }
      const n2 = times.length;
      const result = new Array(n2);
      for (let i2 = 0; i2 !== n2; ++i2)
        result[i2] = i2;
      result.sort(compareTime);
      return result;
    },
    sortedArray: function(values, stride, order) {
      const nValues = values.length;
      const result = new values.constructor(nValues);
      for (let i2 = 0, dstOffset = 0; dstOffset !== nValues; ++i2) {
        const srcOffset = order[i2] * stride;
        for (let j2 = 0; j2 !== stride; ++j2) {
          result[dstOffset++] = values[srcOffset + j2];
        }
      }
      return result;
    },
    flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
      let i2 = 1, key = jsonKeys[0];
      while (key !== void 0 && key[valuePropertyName] === void 0) {
        key = jsonKeys[i2++];
      }
      if (key === void 0)
        return;
      let value = key[valuePropertyName];
      if (value === void 0)
        return;
      if (Array.isArray(value)) {
        do {
          value = key[valuePropertyName];
          if (value !== void 0) {
            times.push(key.time);
            values.push.apply(values, value);
          }
          key = jsonKeys[i2++];
        } while (key !== void 0);
      } else if (value.toArray !== void 0) {
        do {
          value = key[valuePropertyName];
          if (value !== void 0) {
            times.push(key.time);
            value.toArray(values, values.length);
          }
          key = jsonKeys[i2++];
        } while (key !== void 0);
      } else {
        do {
          value = key[valuePropertyName];
          if (value !== void 0) {
            times.push(key.time);
            values.push(value);
          }
          key = jsonKeys[i2++];
        } while (key !== void 0);
      }
    },
    subclip: function(sourceClip, name, startFrame, endFrame, fps = 30) {
      const clip = sourceClip.clone();
      clip.name = name;
      const tracks = [];
      for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
        const track = clip.tracks[i2];
        const valueSize = track.getValueSize();
        const times = [];
        const values = [];
        for (let j2 = 0; j2 < track.times.length; ++j2) {
          const frame = track.times[j2] * fps;
          if (frame < startFrame || frame >= endFrame)
            continue;
          times.push(track.times[j2]);
          for (let k2 = 0; k2 < valueSize; ++k2) {
            values.push(track.values[j2 * valueSize + k2]);
          }
        }
        if (times.length === 0)
          continue;
        track.times = AnimationUtils.convertArray(times, track.times.constructor);
        track.values = AnimationUtils.convertArray(values, track.values.constructor);
        tracks.push(track);
      }
      clip.tracks = tracks;
      let minStartTime = Infinity;
      for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
        if (minStartTime > clip.tracks[i2].times[0]) {
          minStartTime = clip.tracks[i2].times[0];
        }
      }
      for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
        clip.tracks[i2].shift(-1 * minStartTime);
      }
      clip.resetDuration();
      return clip;
    },
    makeClipAdditive: function(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
      if (fps <= 0)
        fps = 30;
      const numTracks = referenceClip.tracks.length;
      const referenceTime = referenceFrame / fps;
      for (let i2 = 0; i2 < numTracks; ++i2) {
        const referenceTrack = referenceClip.tracks[i2];
        const referenceTrackType = referenceTrack.ValueTypeName;
        if (referenceTrackType === "bool" || referenceTrackType === "string")
          continue;
        const targetTrack = targetClip.tracks.find(function(track) {
          return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
        });
        if (targetTrack === void 0)
          continue;
        let referenceOffset = 0;
        const referenceValueSize = referenceTrack.getValueSize();
        if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
          referenceOffset = referenceValueSize / 3;
        }
        let targetOffset = 0;
        const targetValueSize = targetTrack.getValueSize();
        if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
          targetOffset = targetValueSize / 3;
        }
        const lastIndex = referenceTrack.times.length - 1;
        let referenceValue;
        if (referenceTime <= referenceTrack.times[0]) {
          const startIndex = referenceOffset;
          const endIndex = referenceValueSize - referenceOffset;
          referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
        } else if (referenceTime >= referenceTrack.times[lastIndex]) {
          const startIndex = lastIndex * referenceValueSize + referenceOffset;
          const endIndex = startIndex + referenceValueSize - referenceOffset;
          referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
        } else {
          const interpolant = referenceTrack.createInterpolant();
          const startIndex = referenceOffset;
          const endIndex = referenceValueSize - referenceOffset;
          interpolant.evaluate(referenceTime);
          referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
        }
        if (referenceTrackType === "quaternion") {
          const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
          referenceQuat.toArray(referenceValue);
        }
        const numTimes = targetTrack.times.length;
        for (let j2 = 0; j2 < numTimes; ++j2) {
          const valueStart = j2 * targetValueSize + targetOffset;
          if (referenceTrackType === "quaternion") {
            Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
          } else {
            const valueEnd = targetValueSize - targetOffset * 2;
            for (let k2 = 0; k2 < valueEnd; ++k2) {
              targetTrack.values[valueStart + k2] -= referenceValue[k2];
            }
          }
        }
      }
      targetClip.blendMode = AdditiveAnimationBlendMode;
      return targetClip;
    }
  };
  var Interpolant = class {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      this.parameterPositions = parameterPositions;
      this._cachedIndex = 0;
      this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
      this.sampleValues = sampleValues;
      this.valueSize = sampleSize;
      this.settings = null;
      this.DefaultSettings_ = {};
    }
    evaluate(t2) {
      const pp = this.parameterPositions;
      let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
      validate_interval: {
        seek: {
          let right;
          linear_scan: {
            forward_scan:
              if (!(t2 < t1)) {
                for (let giveUpAt = i1 + 2; ; ) {
                  if (t1 === void 0) {
                    if (t2 < t0)
                      break forward_scan;
                    i1 = pp.length;
                    this._cachedIndex = i1;
                    return this.afterEnd_(i1 - 1, t2, t0);
                  }
                  if (i1 === giveUpAt)
                    break;
                  t0 = t1;
                  t1 = pp[++i1];
                  if (t2 < t1) {
                    break seek;
                  }
                }
                right = pp.length;
                break linear_scan;
              }
            if (!(t2 >= t0)) {
              const t1global = pp[1];
              if (t2 < t1global) {
                i1 = 2;
                t0 = t1global;
              }
              for (let giveUpAt = i1 - 2; ; ) {
                if (t0 === void 0) {
                  this._cachedIndex = 0;
                  return this.beforeStart_(0, t2, t1);
                }
                if (i1 === giveUpAt)
                  break;
                t1 = t0;
                t0 = pp[--i1 - 1];
                if (t2 >= t0) {
                  break seek;
                }
              }
              right = i1;
              i1 = 0;
              break linear_scan;
            }
            break validate_interval;
          }
          while (i1 < right) {
            const mid = i1 + right >>> 1;
            if (t2 < pp[mid]) {
              right = mid;
            } else {
              i1 = mid + 1;
            }
          }
          t1 = pp[i1];
          t0 = pp[i1 - 1];
          if (t0 === void 0) {
            this._cachedIndex = 0;
            return this.beforeStart_(0, t2, t1);
          }
          if (t1 === void 0) {
            i1 = pp.length;
            this._cachedIndex = i1;
            return this.afterEnd_(i1 - 1, t0, t2);
          }
        }
        this._cachedIndex = i1;
        this.intervalChanged_(i1, t0, t1);
      }
      return this.interpolate_(i1, t0, t2, t1);
    }
    getSettings_() {
      return this.settings || this.DefaultSettings_;
    }
    copySampleValue_(index) {
      const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
      for (let i2 = 0; i2 !== stride; ++i2) {
        result[i2] = values[offset + i2];
      }
      return result;
    }
    interpolate_() {
      throw new Error("call to abstract method");
    }
    intervalChanged_() {
    }
  };
  Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;
  Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;
  var CubicInterpolant = class extends Interpolant {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      super(parameterPositions, sampleValues, sampleSize, resultBuffer);
      this._weightPrev = -0;
      this._offsetPrev = -0;
      this._weightNext = -0;
      this._offsetNext = -0;
      this.DefaultSettings_ = {
        endingStart: ZeroCurvatureEnding,
        endingEnd: ZeroCurvatureEnding
      };
    }
    intervalChanged_(i1, t0, t1) {
      const pp = this.parameterPositions;
      let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
      if (tPrev === void 0) {
        switch (this.getSettings_().endingStart) {
          case ZeroSlopeEnding:
            iPrev = i1;
            tPrev = 2 * t0 - t1;
            break;
          case WrapAroundEnding:
            iPrev = pp.length - 2;
            tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
            break;
          default:
            iPrev = i1;
            tPrev = t1;
        }
      }
      if (tNext === void 0) {
        switch (this.getSettings_().endingEnd) {
          case ZeroSlopeEnding:
            iNext = i1;
            tNext = 2 * t1 - t0;
            break;
          case WrapAroundEnding:
            iNext = 1;
            tNext = t1 + pp[1] - pp[0];
            break;
          default:
            iNext = i1 - 1;
            tNext = t0;
        }
      }
      const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
      this._weightPrev = halfDt / (t0 - tPrev);
      this._weightNext = halfDt / (tNext - t1);
      this._offsetPrev = iPrev * stride;
      this._offsetNext = iNext * stride;
    }
    interpolate_(i1, t0, t2, t1) {
      const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p2 = (t2 - t0) / (t1 - t0), pp = p2 * p2, ppp = pp * p2;
      const sP = -wP * ppp + 2 * wP * pp - wP * p2;
      const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p2 + 1;
      const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p2;
      const sN = wN * ppp - wN * pp;
      for (let i2 = 0; i2 !== stride; ++i2) {
        result[i2] = sP * values[oP + i2] + s0 * values[o0 + i2] + s1 * values[o1 + i2] + sN * values[oN + i2];
      }
      return result;
    }
  };
  var LinearInterpolant = class extends Interpolant {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    interpolate_(i1, t0, t2, t1) {
      const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t2 - t0) / (t1 - t0), weight0 = 1 - weight1;
      for (let i2 = 0; i2 !== stride; ++i2) {
        result[i2] = values[offset0 + i2] * weight0 + values[offset1 + i2] * weight1;
      }
      return result;
    }
  };
  var DiscreteInterpolant = class extends Interpolant {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    interpolate_(i1) {
      return this.copySampleValue_(i1 - 1);
    }
  };
  var KeyframeTrack = class {
    constructor(name, times, values, interpolation) {
      if (name === void 0)
        throw new Error("THREE.KeyframeTrack: track name is undefined");
      if (times === void 0 || times.length === 0)
        throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
      this.name = name;
      this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
      this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
      this.setInterpolation(interpolation || this.DefaultInterpolation);
    }
    static toJSON(track) {
      const trackType = track.constructor;
      let json;
      if (trackType.toJSON !== this.toJSON) {
        json = trackType.toJSON(track);
      } else {
        json = {
          "name": track.name,
          "times": AnimationUtils.convertArray(track.times, Array),
          "values": AnimationUtils.convertArray(track.values, Array)
        };
        const interpolation = track.getInterpolation();
        if (interpolation !== track.DefaultInterpolation) {
          json.interpolation = interpolation;
        }
      }
      json.type = track.ValueTypeName;
      return json;
    }
    InterpolantFactoryMethodDiscrete(result) {
      return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
    }
    InterpolantFactoryMethodLinear(result) {
      return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
    }
    InterpolantFactoryMethodSmooth(result) {
      return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
    }
    setInterpolation(interpolation) {
      let factoryMethod;
      switch (interpolation) {
        case InterpolateDiscrete:
          factoryMethod = this.InterpolantFactoryMethodDiscrete;
          break;
        case InterpolateLinear:
          factoryMethod = this.InterpolantFactoryMethodLinear;
          break;
        case InterpolateSmooth:
          factoryMethod = this.InterpolantFactoryMethodSmooth;
          break;
      }
      if (factoryMethod === void 0) {
        const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
        if (this.createInterpolant === void 0) {
          if (interpolation !== this.DefaultInterpolation) {
            this.setInterpolation(this.DefaultInterpolation);
          } else {
            throw new Error(message);
          }
        }
        console.warn("THREE.KeyframeTrack:", message);
        return this;
      }
      this.createInterpolant = factoryMethod;
      return this;
    }
    getInterpolation() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return InterpolateDiscrete;
        case this.InterpolantFactoryMethodLinear:
          return InterpolateLinear;
        case this.InterpolantFactoryMethodSmooth:
          return InterpolateSmooth;
      }
    }
    getValueSize() {
      return this.values.length / this.times.length;
    }
    shift(timeOffset) {
      if (timeOffset !== 0) {
        const times = this.times;
        for (let i2 = 0, n2 = times.length; i2 !== n2; ++i2) {
          times[i2] += timeOffset;
        }
      }
      return this;
    }
    scale(timeScale) {
      if (timeScale !== 1) {
        const times = this.times;
        for (let i2 = 0, n2 = times.length; i2 !== n2; ++i2) {
          times[i2] *= timeScale;
        }
      }
      return this;
    }
    trim(startTime, endTime) {
      const times = this.times, nKeys = times.length;
      let from = 0, to = nKeys - 1;
      while (from !== nKeys && times[from] < startTime) {
        ++from;
      }
      while (to !== -1 && times[to] > endTime) {
        --to;
      }
      ++to;
      if (from !== 0 || to !== nKeys) {
        if (from >= to) {
          to = Math.max(to, 1);
          from = to - 1;
        }
        const stride = this.getValueSize();
        this.times = AnimationUtils.arraySlice(times, from, to);
        this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
      }
      return this;
    }
    validate() {
      let valid = true;
      const valueSize = this.getValueSize();
      if (valueSize - Math.floor(valueSize) !== 0) {
        console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
        valid = false;
      }
      const times = this.times, values = this.values, nKeys = times.length;
      if (nKeys === 0) {
        console.error("THREE.KeyframeTrack: Track is empty.", this);
        valid = false;
      }
      let prevTime = null;
      for (let i2 = 0; i2 !== nKeys; i2++) {
        const currTime = times[i2];
        if (typeof currTime === "number" && isNaN(currTime)) {
          console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i2, currTime);
          valid = false;
          break;
        }
        if (prevTime !== null && prevTime > currTime) {
          console.error("THREE.KeyframeTrack: Out of order keys.", this, i2, currTime, prevTime);
          valid = false;
          break;
        }
        prevTime = currTime;
      }
      if (values !== void 0) {
        if (AnimationUtils.isTypedArray(values)) {
          for (let i2 = 0, n2 = values.length; i2 !== n2; ++i2) {
            const value = values[i2];
            if (isNaN(value)) {
              console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i2, value);
              valid = false;
              break;
            }
          }
        }
      }
      return valid;
    }
    optimize() {
      const times = AnimationUtils.arraySlice(this.times), values = AnimationUtils.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
      let writeIndex = 1;
      for (let i2 = 1; i2 < lastIndex; ++i2) {
        let keep = false;
        const time = times[i2];
        const timeNext = times[i2 + 1];
        if (time !== timeNext && (i2 !== 1 || time !== times[0])) {
          if (!smoothInterpolation) {
            const offset = i2 * stride, offsetP = offset - stride, offsetN = offset + stride;
            for (let j2 = 0; j2 !== stride; ++j2) {
              const value = values[offset + j2];
              if (value !== values[offsetP + j2] || value !== values[offsetN + j2]) {
                keep = true;
                break;
              }
            }
          } else {
            keep = true;
          }
        }
        if (keep) {
          if (i2 !== writeIndex) {
            times[writeIndex] = times[i2];
            const readOffset = i2 * stride, writeOffset = writeIndex * stride;
            for (let j2 = 0; j2 !== stride; ++j2) {
              values[writeOffset + j2] = values[readOffset + j2];
            }
          }
          ++writeIndex;
        }
      }
      if (lastIndex > 0) {
        times[writeIndex] = times[lastIndex];
        for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j2 = 0; j2 !== stride; ++j2) {
          values[writeOffset + j2] = values[readOffset + j2];
        }
        ++writeIndex;
      }
      if (writeIndex !== times.length) {
        this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
        this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
      } else {
        this.times = times;
        this.values = values;
      }
      return this;
    }
    clone() {
      const times = AnimationUtils.arraySlice(this.times, 0);
      const values = AnimationUtils.arraySlice(this.values, 0);
      const TypedKeyframeTrack = this.constructor;
      const track = new TypedKeyframeTrack(this.name, times, values);
      track.createInterpolant = this.createInterpolant;
      return track;
    }
  };
  KeyframeTrack.prototype.TimeBufferType = Float32Array;
  KeyframeTrack.prototype.ValueBufferType = Float32Array;
  KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
  var BooleanKeyframeTrack = class extends KeyframeTrack {
  };
  BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
  BooleanKeyframeTrack.prototype.ValueBufferType = Array;
  BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
  BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
  BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
  var ColorKeyframeTrack = class extends KeyframeTrack {
  };
  ColorKeyframeTrack.prototype.ValueTypeName = "color";
  var NumberKeyframeTrack = class extends KeyframeTrack {
  };
  NumberKeyframeTrack.prototype.ValueTypeName = "number";
  var QuaternionLinearInterpolant = class extends Interpolant {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    interpolate_(i1, t0, t2, t1) {
      const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t2 - t0) / (t1 - t0);
      let offset = i1 * stride;
      for (let end = offset + stride; offset !== end; offset += 4) {
        Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
      }
      return result;
    }
  };
  var QuaternionKeyframeTrack = class extends KeyframeTrack {
    InterpolantFactoryMethodLinear(result) {
      return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
    }
  };
  QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
  QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
  QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
  var StringKeyframeTrack = class extends KeyframeTrack {
  };
  StringKeyframeTrack.prototype.ValueTypeName = "string";
  StringKeyframeTrack.prototype.ValueBufferType = Array;
  StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
  StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
  StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
  var VectorKeyframeTrack = class extends KeyframeTrack {
  };
  VectorKeyframeTrack.prototype.ValueTypeName = "vector";
  var AnimationClip = class {
    constructor(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {
      this.name = name;
      this.tracks = tracks;
      this.duration = duration;
      this.blendMode = blendMode;
      this.uuid = generateUUID();
      if (this.duration < 0) {
        this.resetDuration();
      }
    }
    static parse(json) {
      const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
      for (let i2 = 0, n2 = jsonTracks.length; i2 !== n2; ++i2) {
        tracks.push(parseKeyframeTrack(jsonTracks[i2]).scale(frameTime));
      }
      const clip = new this(json.name, json.duration, tracks, json.blendMode);
      clip.uuid = json.uuid;
      return clip;
    }
    static toJSON(clip) {
      const tracks = [], clipTracks = clip.tracks;
      const json = {
        "name": clip.name,
        "duration": clip.duration,
        "tracks": tracks,
        "uuid": clip.uuid,
        "blendMode": clip.blendMode
      };
      for (let i2 = 0, n2 = clipTracks.length; i2 !== n2; ++i2) {
        tracks.push(KeyframeTrack.toJSON(clipTracks[i2]));
      }
      return json;
    }
    static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
      const numMorphTargets = morphTargetSequence.length;
      const tracks = [];
      for (let i2 = 0; i2 < numMorphTargets; i2++) {
        let times = [];
        let values = [];
        times.push((i2 + numMorphTargets - 1) % numMorphTargets, i2, (i2 + 1) % numMorphTargets);
        values.push(0, 1, 0);
        const order = AnimationUtils.getKeyframeOrder(times);
        times = AnimationUtils.sortedArray(times, 1, order);
        values = AnimationUtils.sortedArray(values, 1, order);
        if (!noLoop && times[0] === 0) {
          times.push(numMorphTargets);
          values.push(values[0]);
        }
        tracks.push(new NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetSequence[i2].name + "]", times, values).scale(1 / fps));
      }
      return new this(name, -1, tracks);
    }
    static findByName(objectOrClipArray, name) {
      let clipArray = objectOrClipArray;
      if (!Array.isArray(objectOrClipArray)) {
        const o2 = objectOrClipArray;
        clipArray = o2.geometry && o2.geometry.animations || o2.animations;
      }
      for (let i2 = 0; i2 < clipArray.length; i2++) {
        if (clipArray[i2].name === name) {
          return clipArray[i2];
        }
      }
      return null;
    }
    static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
      const animationToMorphTargets = {};
      const pattern = /^([\w-]*?)([\d]+)$/;
      for (let i2 = 0, il = morphTargets.length; i2 < il; i2++) {
        const morphTarget = morphTargets[i2];
        const parts = morphTarget.name.match(pattern);
        if (parts && parts.length > 1) {
          const name = parts[1];
          let animationMorphTargets = animationToMorphTargets[name];
          if (!animationMorphTargets) {
            animationToMorphTargets[name] = animationMorphTargets = [];
          }
          animationMorphTargets.push(morphTarget);
        }
      }
      const clips = [];
      for (const name in animationToMorphTargets) {
        clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
      }
      return clips;
    }
    static parseAnimation(animation, bones) {
      if (!animation) {
        console.error("THREE.AnimationClip: No animation in JSONLoader data.");
        return null;
      }
      const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
        if (animationKeys.length !== 0) {
          const times = [];
          const values = [];
          AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
          if (times.length !== 0) {
            destTracks.push(new trackType(trackName, times, values));
          }
        }
      };
      const tracks = [];
      const clipName = animation.name || "default";
      const fps = animation.fps || 30;
      const blendMode = animation.blendMode;
      let duration = animation.length || -1;
      const hierarchyTracks = animation.hierarchy || [];
      for (let h2 = 0; h2 < hierarchyTracks.length; h2++) {
        const animationKeys = hierarchyTracks[h2].keys;
        if (!animationKeys || animationKeys.length === 0)
          continue;
        if (animationKeys[0].morphTargets) {
          const morphTargetNames = {};
          let k2;
          for (k2 = 0; k2 < animationKeys.length; k2++) {
            if (animationKeys[k2].morphTargets) {
              for (let m2 = 0; m2 < animationKeys[k2].morphTargets.length; m2++) {
                morphTargetNames[animationKeys[k2].morphTargets[m2]] = -1;
              }
            }
          }
          for (const morphTargetName in morphTargetNames) {
            const times = [];
            const values = [];
            for (let m2 = 0; m2 !== animationKeys[k2].morphTargets.length; ++m2) {
              const animationKey = animationKeys[k2];
              times.push(animationKey.time);
              values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
            }
            tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
          }
          duration = morphTargetNames.length * (fps || 1);
        } else {
          const boneName = ".bones[" + bones[h2].name + "]";
          addNonemptyTrack(VectorKeyframeTrack, boneName + ".position", animationKeys, "pos", tracks);
          addNonemptyTrack(QuaternionKeyframeTrack, boneName + ".quaternion", animationKeys, "rot", tracks);
          addNonemptyTrack(VectorKeyframeTrack, boneName + ".scale", animationKeys, "scl", tracks);
        }
      }
      if (tracks.length === 0) {
        return null;
      }
      const clip = new this(clipName, duration, tracks, blendMode);
      return clip;
    }
    resetDuration() {
      const tracks = this.tracks;
      let duration = 0;
      for (let i2 = 0, n2 = tracks.length; i2 !== n2; ++i2) {
        const track = this.tracks[i2];
        duration = Math.max(duration, track.times[track.times.length - 1]);
      }
      this.duration = duration;
      return this;
    }
    trim() {
      for (let i2 = 0; i2 < this.tracks.length; i2++) {
        this.tracks[i2].trim(0, this.duration);
      }
      return this;
    }
    validate() {
      let valid = true;
      for (let i2 = 0; i2 < this.tracks.length; i2++) {
        valid = valid && this.tracks[i2].validate();
      }
      return valid;
    }
    optimize() {
      for (let i2 = 0; i2 < this.tracks.length; i2++) {
        this.tracks[i2].optimize();
      }
      return this;
    }
    clone() {
      const tracks = [];
      for (let i2 = 0; i2 < this.tracks.length; i2++) {
        tracks.push(this.tracks[i2].clone());
      }
      return new this.constructor(this.name, this.duration, tracks, this.blendMode);
    }
    toJSON() {
      return this.constructor.toJSON(this);
    }
  };
  function getTrackTypeForValueTypeName(typeName) {
    switch (typeName.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return NumberKeyframeTrack;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return VectorKeyframeTrack;
      case "color":
        return ColorKeyframeTrack;
      case "quaternion":
        return QuaternionKeyframeTrack;
      case "bool":
      case "boolean":
        return BooleanKeyframeTrack;
      case "string":
        return StringKeyframeTrack;
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
  }
  function parseKeyframeTrack(json) {
    if (json.type === void 0) {
      throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    }
    const trackType = getTrackTypeForValueTypeName(json.type);
    if (json.times === void 0) {
      const times = [], values = [];
      AnimationUtils.flattenJSON(json.keys, times, values, "value");
      json.times = times;
      json.values = values;
    }
    if (trackType.parse !== void 0) {
      return trackType.parse(json);
    } else {
      return new trackType(json.name, json.times, json.values, json.interpolation);
    }
  }
  var Cache = {
    enabled: false,
    files: {},
    add: function(key, file) {
      if (this.enabled === false)
        return;
      this.files[key] = file;
    },
    get: function(key) {
      if (this.enabled === false)
        return;
      return this.files[key];
    },
    remove: function(key) {
      delete this.files[key];
    },
    clear: function() {
      this.files = {};
    }
  };
  var LoadingManager = class {
    constructor(onLoad, onProgress, onError) {
      const scope = this;
      let isLoading = false;
      let itemsLoaded = 0;
      let itemsTotal = 0;
      let urlModifier = void 0;
      const handlers = [];
      this.onStart = void 0;
      this.onLoad = onLoad;
      this.onProgress = onProgress;
      this.onError = onError;
      this.itemStart = function(url) {
        itemsTotal++;
        if (isLoading === false) {
          if (scope.onStart !== void 0) {
            scope.onStart(url, itemsLoaded, itemsTotal);
          }
        }
        isLoading = true;
      };
      this.itemEnd = function(url) {
        itemsLoaded++;
        if (scope.onProgress !== void 0) {
          scope.onProgress(url, itemsLoaded, itemsTotal);
        }
        if (itemsLoaded === itemsTotal) {
          isLoading = false;
          if (scope.onLoad !== void 0) {
            scope.onLoad();
          }
        }
      };
      this.itemError = function(url) {
        if (scope.onError !== void 0) {
          scope.onError(url);
        }
      };
      this.resolveURL = function(url) {
        if (urlModifier) {
          return urlModifier(url);
        }
        return url;
      };
      this.setURLModifier = function(transform) {
        urlModifier = transform;
        return this;
      };
      this.addHandler = function(regex, loader2) {
        handlers.push(regex, loader2);
        return this;
      };
      this.removeHandler = function(regex) {
        const index = handlers.indexOf(regex);
        if (index !== -1) {
          handlers.splice(index, 2);
        }
        return this;
      };
      this.getHandler = function(file) {
        for (let i2 = 0, l2 = handlers.length; i2 < l2; i2 += 2) {
          const regex = handlers[i2];
          const loader2 = handlers[i2 + 1];
          if (regex.global)
            regex.lastIndex = 0;
          if (regex.test(file)) {
            return loader2;
          }
        }
        return null;
      };
    }
  };
  var DefaultLoadingManager = new LoadingManager();
  var Loader = class {
    constructor(manager) {
      this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
      this.crossOrigin = "anonymous";
      this.withCredentials = false;
      this.path = "";
      this.resourcePath = "";
      this.requestHeader = {};
    }
    load() {
    }
    loadAsync(url, onProgress) {
      const scope = this;
      return new Promise(function(resolve, reject) {
        scope.load(url, resolve, onProgress, reject);
      });
    }
    parse() {
    }
    setCrossOrigin(crossOrigin) {
      this.crossOrigin = crossOrigin;
      return this;
    }
    setWithCredentials(value) {
      this.withCredentials = value;
      return this;
    }
    setPath(path) {
      this.path = path;
      return this;
    }
    setResourcePath(resourcePath) {
      this.resourcePath = resourcePath;
      return this;
    }
    setRequestHeader(requestHeader) {
      this.requestHeader = requestHeader;
      return this;
    }
  };
  var loading = {};
  var FileLoader = class extends Loader {
    constructor(manager) {
      super(manager);
    }
    load(url, onLoad, onProgress, onError) {
      if (url === void 0)
        url = "";
      if (this.path !== void 0)
        url = this.path + url;
      url = this.manager.resolveURL(url);
      const scope = this;
      const cached = Cache.get(url);
      if (cached !== void 0) {
        scope.manager.itemStart(url);
        setTimeout(function() {
          if (onLoad)
            onLoad(cached);
          scope.manager.itemEnd(url);
        }, 0);
        return cached;
      }
      if (loading[url] !== void 0) {
        loading[url].push({
          onLoad,
          onProgress,
          onError
        });
        return;
      }
      const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
      const dataUriRegexResult = url.match(dataUriRegex);
      let request;
      if (dataUriRegexResult) {
        const mimeType = dataUriRegexResult[1];
        const isBase64 = !!dataUriRegexResult[2];
        let data = dataUriRegexResult[3];
        data = decodeURIComponent(data);
        if (isBase64)
          data = atob(data);
        try {
          let response;
          const responseType = (this.responseType || "").toLowerCase();
          switch (responseType) {
            case "arraybuffer":
            case "blob":
              const view = new Uint8Array(data.length);
              for (let i2 = 0; i2 < data.length; i2++) {
                view[i2] = data.charCodeAt(i2);
              }
              if (responseType === "blob") {
                response = new Blob([view.buffer], { type: mimeType });
              } else {
                response = view.buffer;
              }
              break;
            case "document":
              const parser = new DOMParser();
              response = parser.parseFromString(data, mimeType);
              break;
            case "json":
              response = JSON.parse(data);
              break;
            default:
              response = data;
              break;
          }
          setTimeout(function() {
            if (onLoad)
              onLoad(response);
            scope.manager.itemEnd(url);
          }, 0);
        } catch (error) {
          setTimeout(function() {
            if (onError)
              onError(error);
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          }, 0);
        }
      } else {
        loading[url] = [];
        loading[url].push({
          onLoad,
          onProgress,
          onError
        });
        request = new XMLHttpRequest();
        request.open("GET", url, true);
        request.addEventListener("load", function(event) {
          const response = this.response;
          const callbacks = loading[url];
          delete loading[url];
          if (this.status === 200 || this.status === 0) {
            if (this.status === 0)
              console.warn("THREE.FileLoader: HTTP Status 0 received.");
            Cache.add(url, response);
            for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
              const callback = callbacks[i2];
              if (callback.onLoad)
                callback.onLoad(response);
            }
            scope.manager.itemEnd(url);
          } else {
            for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
              const callback = callbacks[i2];
              if (callback.onError)
                callback.onError(event);
            }
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          }
        }, false);
        request.addEventListener("progress", function(event) {
          const callbacks = loading[url];
          for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
            const callback = callbacks[i2];
            if (callback.onProgress)
              callback.onProgress(event);
          }
        }, false);
        request.addEventListener("error", function(event) {
          const callbacks = loading[url];
          delete loading[url];
          for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
            const callback = callbacks[i2];
            if (callback.onError)
              callback.onError(event);
          }
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }, false);
        request.addEventListener("abort", function(event) {
          const callbacks = loading[url];
          delete loading[url];
          for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
            const callback = callbacks[i2];
            if (callback.onError)
              callback.onError(event);
          }
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }, false);
        if (this.responseType !== void 0)
          request.responseType = this.responseType;
        if (this.withCredentials !== void 0)
          request.withCredentials = this.withCredentials;
        if (request.overrideMimeType)
          request.overrideMimeType(this.mimeType !== void 0 ? this.mimeType : "text/plain");
        for (const header in this.requestHeader) {
          request.setRequestHeader(header, this.requestHeader[header]);
        }
        request.send(null);
      }
      scope.manager.itemStart(url);
      return request;
    }
    setResponseType(value) {
      this.responseType = value;
      return this;
    }
    setMimeType(value) {
      this.mimeType = value;
      return this;
    }
  };
  var ImageLoader = class extends Loader {
    constructor(manager) {
      super(manager);
    }
    load(url, onLoad, onProgress, onError) {
      if (this.path !== void 0)
        url = this.path + url;
      url = this.manager.resolveURL(url);
      const scope = this;
      const cached = Cache.get(url);
      if (cached !== void 0) {
        scope.manager.itemStart(url);
        setTimeout(function() {
          if (onLoad)
            onLoad(cached);
          scope.manager.itemEnd(url);
        }, 0);
        return cached;
      }
      const image = createElementNS("img");
      function onImageLoad() {
        image.removeEventListener("load", onImageLoad, false);
        image.removeEventListener("error", onImageError, false);
        Cache.add(url, this);
        if (onLoad)
          onLoad(this);
        scope.manager.itemEnd(url);
      }
      function onImageError(event) {
        image.removeEventListener("load", onImageLoad, false);
        image.removeEventListener("error", onImageError, false);
        if (onError)
          onError(event);
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }
      image.addEventListener("load", onImageLoad, false);
      image.addEventListener("error", onImageError, false);
      if (url.substr(0, 5) !== "data:") {
        if (this.crossOrigin !== void 0)
          image.crossOrigin = this.crossOrigin;
      }
      scope.manager.itemStart(url);
      image.src = url;
      return image;
    }
  };
  var CubeTextureLoader = class extends Loader {
    constructor(manager) {
      super(manager);
    }
    load(urls, onLoad, onProgress, onError) {
      const texture = new CubeTexture();
      const loader2 = new ImageLoader(this.manager);
      loader2.setCrossOrigin(this.crossOrigin);
      loader2.setPath(this.path);
      let loaded = 0;
      function loadTexture(i2) {
        loader2.load(urls[i2], function(image) {
          texture.images[i2] = image;
          loaded++;
          if (loaded === 6) {
            texture.needsUpdate = true;
            if (onLoad)
              onLoad(texture);
          }
        }, void 0, onError);
      }
      for (let i2 = 0; i2 < urls.length; ++i2) {
        loadTexture(i2);
      }
      return texture;
    }
  };
  var TextureLoader = class extends Loader {
    constructor(manager) {
      super(manager);
    }
    load(url, onLoad, onProgress, onError) {
      const texture = new Texture();
      const loader2 = new ImageLoader(this.manager);
      loader2.setCrossOrigin(this.crossOrigin);
      loader2.setPath(this.path);
      loader2.load(url, function(image) {
        texture.image = image;
        texture.needsUpdate = true;
        if (onLoad !== void 0) {
          onLoad(texture);
        }
      }, onProgress, onError);
      return texture;
    }
  };
  var Light = class extends Object3D {
    constructor(color, intensity = 1) {
      super();
      this.type = "Light";
      this.color = new Color(color);
      this.intensity = intensity;
    }
    dispose() {
    }
    copy(source) {
      super.copy(source);
      this.color.copy(source.color);
      this.intensity = source.intensity;
      return this;
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      data.object.color = this.color.getHex();
      data.object.intensity = this.intensity;
      if (this.groundColor !== void 0)
        data.object.groundColor = this.groundColor.getHex();
      if (this.distance !== void 0)
        data.object.distance = this.distance;
      if (this.angle !== void 0)
        data.object.angle = this.angle;
      if (this.decay !== void 0)
        data.object.decay = this.decay;
      if (this.penumbra !== void 0)
        data.object.penumbra = this.penumbra;
      if (this.shadow !== void 0)
        data.object.shadow = this.shadow.toJSON();
      return data;
    }
  };
  Light.prototype.isLight = true;
  var HemisphereLight = class extends Light {
    constructor(skyColor, groundColor, intensity) {
      super(skyColor, intensity);
      this.type = "HemisphereLight";
      this.position.copy(Object3D.DefaultUp);
      this.updateMatrix();
      this.groundColor = new Color(groundColor);
    }
    copy(source) {
      Light.prototype.copy.call(this, source);
      this.groundColor.copy(source.groundColor);
      return this;
    }
  };
  HemisphereLight.prototype.isHemisphereLight = true;
  var _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4();
  var _lightPositionWorld$1 = /* @__PURE__ */ new Vector3();
  var _lookTarget$1 = /* @__PURE__ */ new Vector3();
  var LightShadow = class {
    constructor(camera2) {
      this.camera = camera2;
      this.bias = 0;
      this.normalBias = 0;
      this.radius = 1;
      this.blurSamples = 8;
      this.mapSize = new Vector2(512, 512);
      this.map = null;
      this.mapPass = null;
      this.matrix = new Matrix4();
      this.autoUpdate = true;
      this.needsUpdate = false;
      this._frustum = new Frustum();
      this._frameExtents = new Vector2(1, 1);
      this._viewportCount = 1;
      this._viewports = [
        new Vector4(0, 0, 1, 1)
      ];
    }
    getViewportCount() {
      return this._viewportCount;
    }
    getFrustum() {
      return this._frustum;
    }
    updateMatrices(light2) {
      const shadowCamera = this.camera;
      const shadowMatrix = this.matrix;
      _lightPositionWorld$1.setFromMatrixPosition(light2.matrixWorld);
      shadowCamera.position.copy(_lightPositionWorld$1);
      _lookTarget$1.setFromMatrixPosition(light2.target.matrixWorld);
      shadowCamera.lookAt(_lookTarget$1);
      shadowCamera.updateMatrixWorld();
      _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
      this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
      shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
      shadowMatrix.multiply(shadowCamera.projectionMatrix);
      shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
    }
    getViewport(viewportIndex) {
      return this._viewports[viewportIndex];
    }
    getFrameExtents() {
      return this._frameExtents;
    }
    dispose() {
      if (this.map) {
        this.map.dispose();
      }
      if (this.mapPass) {
        this.mapPass.dispose();
      }
    }
    copy(source) {
      this.camera = source.camera.clone();
      this.bias = source.bias;
      this.radius = source.radius;
      this.mapSize.copy(source.mapSize);
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    toJSON() {
      const object = {};
      if (this.bias !== 0)
        object.bias = this.bias;
      if (this.normalBias !== 0)
        object.normalBias = this.normalBias;
      if (this.radius !== 1)
        object.radius = this.radius;
      if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
        object.mapSize = this.mapSize.toArray();
      object.camera = this.camera.toJSON(false).object;
      delete object.camera.matrix;
      return object;
    }
  };
  var SpotLightShadow = class extends LightShadow {
    constructor() {
      super(new PerspectiveCamera(50, 1, 0.5, 500));
      this.focus = 1;
    }
    updateMatrices(light2) {
      const camera2 = this.camera;
      const fov2 = RAD2DEG * 2 * light2.angle * this.focus;
      const aspect2 = this.mapSize.width / this.mapSize.height;
      const far = light2.distance || camera2.far;
      if (fov2 !== camera2.fov || aspect2 !== camera2.aspect || far !== camera2.far) {
        camera2.fov = fov2;
        camera2.aspect = aspect2;
        camera2.far = far;
        camera2.updateProjectionMatrix();
      }
      super.updateMatrices(light2);
    }
    copy(source) {
      super.copy(source);
      this.focus = source.focus;
      return this;
    }
  };
  SpotLightShadow.prototype.isSpotLightShadow = true;
  var SpotLight = class extends Light {
    constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1) {
      super(color, intensity);
      this.type = "SpotLight";
      this.position.copy(Object3D.DefaultUp);
      this.updateMatrix();
      this.target = new Object3D();
      this.distance = distance;
      this.angle = angle;
      this.penumbra = penumbra;
      this.decay = decay;
      this.shadow = new SpotLightShadow();
    }
    get power() {
      return this.intensity * Math.PI;
    }
    set power(power) {
      this.intensity = power / Math.PI;
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(source) {
      super.copy(source);
      this.distance = source.distance;
      this.angle = source.angle;
      this.penumbra = source.penumbra;
      this.decay = source.decay;
      this.target = source.target.clone();
      this.shadow = source.shadow.clone();
      return this;
    }
  };
  SpotLight.prototype.isSpotLight = true;
  var _projScreenMatrix = /* @__PURE__ */ new Matrix4();
  var _lightPositionWorld = /* @__PURE__ */ new Vector3();
  var _lookTarget = /* @__PURE__ */ new Vector3();
  var PointLightShadow = class extends LightShadow {
    constructor() {
      super(new PerspectiveCamera(90, 1, 0.5, 500));
      this._frameExtents = new Vector2(4, 2);
      this._viewportCount = 6;
      this._viewports = [
        new Vector4(2, 1, 1, 1),
        new Vector4(0, 1, 1, 1),
        new Vector4(3, 1, 1, 1),
        new Vector4(1, 1, 1, 1),
        new Vector4(3, 0, 1, 1),
        new Vector4(1, 0, 1, 1)
      ];
      this._cubeDirections = [
        new Vector3(1, 0, 0),
        new Vector3(-1, 0, 0),
        new Vector3(0, 0, 1),
        new Vector3(0, 0, -1),
        new Vector3(0, 1, 0),
        new Vector3(0, -1, 0)
      ];
      this._cubeUps = [
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 0, 1),
        new Vector3(0, 0, -1)
      ];
    }
    updateMatrices(light2, viewportIndex = 0) {
      const camera2 = this.camera;
      const shadowMatrix = this.matrix;
      const far = light2.distance || camera2.far;
      if (far !== camera2.far) {
        camera2.far = far;
        camera2.updateProjectionMatrix();
      }
      _lightPositionWorld.setFromMatrixPosition(light2.matrixWorld);
      camera2.position.copy(_lightPositionWorld);
      _lookTarget.copy(camera2.position);
      _lookTarget.add(this._cubeDirections[viewportIndex]);
      camera2.up.copy(this._cubeUps[viewportIndex]);
      camera2.lookAt(_lookTarget);
      camera2.updateMatrixWorld();
      shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
      _projScreenMatrix.multiplyMatrices(camera2.projectionMatrix, camera2.matrixWorldInverse);
      this._frustum.setFromProjectionMatrix(_projScreenMatrix);
    }
  };
  PointLightShadow.prototype.isPointLightShadow = true;
  var PointLight = class extends Light {
    constructor(color, intensity, distance = 0, decay = 1) {
      super(color, intensity);
      this.type = "PointLight";
      this.distance = distance;
      this.decay = decay;
      this.shadow = new PointLightShadow();
    }
    get power() {
      return this.intensity * 4 * Math.PI;
    }
    set power(power) {
      this.intensity = power / (4 * Math.PI);
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(source) {
      super.copy(source);
      this.distance = source.distance;
      this.decay = source.decay;
      this.shadow = source.shadow.clone();
      return this;
    }
  };
  PointLight.prototype.isPointLight = true;
  var DirectionalLightShadow = class extends LightShadow {
    constructor() {
      super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
    }
  };
  DirectionalLightShadow.prototype.isDirectionalLightShadow = true;
  var DirectionalLight = class extends Light {
    constructor(color, intensity) {
      super(color, intensity);
      this.type = "DirectionalLight";
      this.position.copy(Object3D.DefaultUp);
      this.updateMatrix();
      this.target = new Object3D();
      this.shadow = new DirectionalLightShadow();
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(source) {
      super.copy(source);
      this.target = source.target.clone();
      this.shadow = source.shadow.clone();
      return this;
    }
  };
  DirectionalLight.prototype.isDirectionalLight = true;
  var AmbientLight = class extends Light {
    constructor(color, intensity) {
      super(color, intensity);
      this.type = "AmbientLight";
    }
  };
  AmbientLight.prototype.isAmbientLight = true;
  var RectAreaLight = class extends Light {
    constructor(color, intensity, width2 = 10, height2 = 10) {
      super(color, intensity);
      this.type = "RectAreaLight";
      this.width = width2;
      this.height = height2;
    }
    get power() {
      return this.intensity * this.width * this.height * Math.PI;
    }
    set power(power) {
      this.intensity = power / (this.width * this.height * Math.PI);
    }
    copy(source) {
      super.copy(source);
      this.width = source.width;
      this.height = source.height;
      return this;
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      data.object.width = this.width;
      data.object.height = this.height;
      return data;
    }
  };
  RectAreaLight.prototype.isRectAreaLight = true;
  var SphericalHarmonics3 = class {
    constructor() {
      this.coefficients = [];
      for (let i2 = 0; i2 < 9; i2++) {
        this.coefficients.push(new Vector3());
      }
    }
    set(coefficients) {
      for (let i2 = 0; i2 < 9; i2++) {
        this.coefficients[i2].copy(coefficients[i2]);
      }
      return this;
    }
    zero() {
      for (let i2 = 0; i2 < 9; i2++) {
        this.coefficients[i2].set(0, 0, 0);
      }
      return this;
    }
    getAt(normal, target) {
      const x2 = normal.x, y2 = normal.y, z2 = normal.z;
      const coeff = this.coefficients;
      target.copy(coeff[0]).multiplyScalar(0.282095);
      target.addScaledVector(coeff[1], 0.488603 * y2);
      target.addScaledVector(coeff[2], 0.488603 * z2);
      target.addScaledVector(coeff[3], 0.488603 * x2);
      target.addScaledVector(coeff[4], 1.092548 * (x2 * y2));
      target.addScaledVector(coeff[5], 1.092548 * (y2 * z2));
      target.addScaledVector(coeff[6], 0.315392 * (3 * z2 * z2 - 1));
      target.addScaledVector(coeff[7], 1.092548 * (x2 * z2));
      target.addScaledVector(coeff[8], 0.546274 * (x2 * x2 - y2 * y2));
      return target;
    }
    getIrradianceAt(normal, target) {
      const x2 = normal.x, y2 = normal.y, z2 = normal.z;
      const coeff = this.coefficients;
      target.copy(coeff[0]).multiplyScalar(0.886227);
      target.addScaledVector(coeff[1], 2 * 0.511664 * y2);
      target.addScaledVector(coeff[2], 2 * 0.511664 * z2);
      target.addScaledVector(coeff[3], 2 * 0.511664 * x2);
      target.addScaledVector(coeff[4], 2 * 0.429043 * x2 * y2);
      target.addScaledVector(coeff[5], 2 * 0.429043 * y2 * z2);
      target.addScaledVector(coeff[6], 0.743125 * z2 * z2 - 0.247708);
      target.addScaledVector(coeff[7], 2 * 0.429043 * x2 * z2);
      target.addScaledVector(coeff[8], 0.429043 * (x2 * x2 - y2 * y2));
      return target;
    }
    add(sh) {
      for (let i2 = 0; i2 < 9; i2++) {
        this.coefficients[i2].add(sh.coefficients[i2]);
      }
      return this;
    }
    addScaledSH(sh, s2) {
      for (let i2 = 0; i2 < 9; i2++) {
        this.coefficients[i2].addScaledVector(sh.coefficients[i2], s2);
      }
      return this;
    }
    scale(s2) {
      for (let i2 = 0; i2 < 9; i2++) {
        this.coefficients[i2].multiplyScalar(s2);
      }
      return this;
    }
    lerp(sh, alpha) {
      for (let i2 = 0; i2 < 9; i2++) {
        this.coefficients[i2].lerp(sh.coefficients[i2], alpha);
      }
      return this;
    }
    equals(sh) {
      for (let i2 = 0; i2 < 9; i2++) {
        if (!this.coefficients[i2].equals(sh.coefficients[i2])) {
          return false;
        }
      }
      return true;
    }
    copy(sh) {
      return this.set(sh.coefficients);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    fromArray(array, offset = 0) {
      const coefficients = this.coefficients;
      for (let i2 = 0; i2 < 9; i2++) {
        coefficients[i2].fromArray(array, offset + i2 * 3);
      }
      return this;
    }
    toArray(array = [], offset = 0) {
      const coefficients = this.coefficients;
      for (let i2 = 0; i2 < 9; i2++) {
        coefficients[i2].toArray(array, offset + i2 * 3);
      }
      return array;
    }
    static getBasisAt(normal, shBasis) {
      const x2 = normal.x, y2 = normal.y, z2 = normal.z;
      shBasis[0] = 0.282095;
      shBasis[1] = 0.488603 * y2;
      shBasis[2] = 0.488603 * z2;
      shBasis[3] = 0.488603 * x2;
      shBasis[4] = 1.092548 * x2 * y2;
      shBasis[5] = 1.092548 * y2 * z2;
      shBasis[6] = 0.315392 * (3 * z2 * z2 - 1);
      shBasis[7] = 1.092548 * x2 * z2;
      shBasis[8] = 0.546274 * (x2 * x2 - y2 * y2);
    }
  };
  SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;
  var LightProbe = class extends Light {
    constructor(sh = new SphericalHarmonics3(), intensity = 1) {
      super(void 0, intensity);
      this.sh = sh;
    }
    copy(source) {
      super.copy(source);
      this.sh.copy(source.sh);
      return this;
    }
    fromJSON(json) {
      this.intensity = json.intensity;
      this.sh.fromArray(json.sh);
      return this;
    }
    toJSON(meta) {
      const data = super.toJSON(meta);
      data.object.sh = this.sh.toArray();
      return data;
    }
  };
  LightProbe.prototype.isLightProbe = true;
  var LoaderUtils = class {
    static decodeText(array) {
      if (typeof TextDecoder !== "undefined") {
        return new TextDecoder().decode(array);
      }
      let s2 = "";
      for (let i2 = 0, il = array.length; i2 < il; i2++) {
        s2 += String.fromCharCode(array[i2]);
      }
      try {
        return decodeURIComponent(escape(s2));
      } catch (e2) {
        return s2;
      }
    }
    static extractUrlBase(url) {
      const index = url.lastIndexOf("/");
      if (index === -1)
        return "./";
      return url.substr(0, index + 1);
    }
  };
  var InstancedBufferGeometry = class extends BufferGeometry {
    constructor() {
      super();
      this.type = "InstancedBufferGeometry";
      this.instanceCount = Infinity;
    }
    copy(source) {
      super.copy(source);
      this.instanceCount = source.instanceCount;
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    toJSON() {
      const data = super.toJSON(this);
      data.instanceCount = this.instanceCount;
      data.isInstancedBufferGeometry = true;
      return data;
    }
  };
  InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;
  var ImageBitmapLoader = class extends Loader {
    constructor(manager) {
      super(manager);
      if (typeof createImageBitmap === "undefined") {
        console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
      }
      if (typeof fetch === "undefined") {
        console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
      }
      this.options = { premultiplyAlpha: "none" };
    }
    setOptions(options) {
      this.options = options;
      return this;
    }
    load(url, onLoad, onProgress, onError) {
      if (url === void 0)
        url = "";
      if (this.path !== void 0)
        url = this.path + url;
      url = this.manager.resolveURL(url);
      const scope = this;
      const cached = Cache.get(url);
      if (cached !== void 0) {
        scope.manager.itemStart(url);
        setTimeout(function() {
          if (onLoad)
            onLoad(cached);
          scope.manager.itemEnd(url);
        }, 0);
        return cached;
      }
      const fetchOptions = {};
      fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include";
      fetchOptions.headers = this.requestHeader;
      fetch(url, fetchOptions).then(function(res) {
        return res.blob();
      }).then(function(blob) {
        return createImageBitmap(blob, Object.assign(scope.options, { colorSpaceConversion: "none" }));
      }).then(function(imageBitmap) {
        Cache.add(url, imageBitmap);
        if (onLoad)
          onLoad(imageBitmap);
        scope.manager.itemEnd(url);
      }).catch(function(e2) {
        if (onError)
          onError(e2);
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      });
      scope.manager.itemStart(url);
    }
  };
  ImageBitmapLoader.prototype.isImageBitmapLoader = true;
  var _context;
  var AudioContext = {
    getContext: function() {
      if (_context === void 0) {
        _context = new (window.AudioContext || window.webkitAudioContext)();
      }
      return _context;
    },
    setContext: function(value) {
      _context = value;
    }
  };
  var AudioLoader = class extends Loader {
    constructor(manager) {
      super(manager);
    }
    load(url, onLoad, onProgress, onError) {
      const scope = this;
      const loader2 = new FileLoader(this.manager);
      loader2.setResponseType("arraybuffer");
      loader2.setPath(this.path);
      loader2.setRequestHeader(this.requestHeader);
      loader2.setWithCredentials(this.withCredentials);
      loader2.load(url, function(buffer) {
        try {
          const bufferCopy = buffer.slice(0);
          const context = AudioContext.getContext();
          context.decodeAudioData(bufferCopy, function(audioBuffer) {
            onLoad(audioBuffer);
          });
        } catch (e2) {
          if (onError) {
            onError(e2);
          } else {
            console.error(e2);
          }
          scope.manager.itemError(url);
        }
      }, onProgress, onError);
    }
  };
  var HemisphereLightProbe = class extends LightProbe {
    constructor(skyColor, groundColor, intensity = 1) {
      super(void 0, intensity);
      const color1 = new Color().set(skyColor);
      const color2 = new Color().set(groundColor);
      const sky = new Vector3(color1.r, color1.g, color1.b);
      const ground = new Vector3(color2.r, color2.g, color2.b);
      const c0 = Math.sqrt(Math.PI);
      const c1 = c0 * Math.sqrt(0.75);
      this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
      this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
    }
  };
  HemisphereLightProbe.prototype.isHemisphereLightProbe = true;
  var AmbientLightProbe = class extends LightProbe {
    constructor(color, intensity = 1) {
      super(void 0, intensity);
      const color1 = new Color().set(color);
      this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
    }
  };
  AmbientLightProbe.prototype.isAmbientLightProbe = true;
  var Clock = class {
    constructor(autoStart = true) {
      this.autoStart = autoStart;
      this.startTime = 0;
      this.oldTime = 0;
      this.elapsedTime = 0;
      this.running = false;
    }
    start() {
      this.startTime = now();
      this.oldTime = this.startTime;
      this.elapsedTime = 0;
      this.running = true;
    }
    stop() {
      this.getElapsedTime();
      this.running = false;
      this.autoStart = false;
    }
    getElapsedTime() {
      this.getDelta();
      return this.elapsedTime;
    }
    getDelta() {
      let diff = 0;
      if (this.autoStart && !this.running) {
        this.start();
        return 0;
      }
      if (this.running) {
        const newTime = now();
        diff = (newTime - this.oldTime) / 1e3;
        this.oldTime = newTime;
        this.elapsedTime += diff;
      }
      return diff;
    }
  };
  function now() {
    return (typeof performance === "undefined" ? Date : performance).now();
  }
  var Audio = class extends Object3D {
    constructor(listener) {
      super();
      this.type = "Audio";
      this.listener = listener;
      this.context = listener.context;
      this.gain = this.context.createGain();
      this.gain.connect(listener.getInput());
      this.autoplay = false;
      this.buffer = null;
      this.detune = 0;
      this.loop = false;
      this.loopStart = 0;
      this.loopEnd = 0;
      this.offset = 0;
      this.duration = void 0;
      this.playbackRate = 1;
      this.isPlaying = false;
      this.hasPlaybackControl = true;
      this.source = null;
      this.sourceType = "empty";
      this._startedAt = 0;
      this._progress = 0;
      this._connected = false;
      this.filters = [];
    }
    getOutput() {
      return this.gain;
    }
    setNodeSource(audioNode) {
      this.hasPlaybackControl = false;
      this.sourceType = "audioNode";
      this.source = audioNode;
      this.connect();
      return this;
    }
    setMediaElementSource(mediaElement) {
      this.hasPlaybackControl = false;
      this.sourceType = "mediaNode";
      this.source = this.context.createMediaElementSource(mediaElement);
      this.connect();
      return this;
    }
    setMediaStreamSource(mediaStream) {
      this.hasPlaybackControl = false;
      this.sourceType = "mediaStreamNode";
      this.source = this.context.createMediaStreamSource(mediaStream);
      this.connect();
      return this;
    }
    setBuffer(audioBuffer) {
      this.buffer = audioBuffer;
      this.sourceType = "buffer";
      if (this.autoplay)
        this.play();
      return this;
    }
    play(delay = 0) {
      if (this.isPlaying === true) {
        console.warn("THREE.Audio: Audio is already playing.");
        return;
      }
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      this._startedAt = this.context.currentTime + delay;
      const source = this.context.createBufferSource();
      source.buffer = this.buffer;
      source.loop = this.loop;
      source.loopStart = this.loopStart;
      source.loopEnd = this.loopEnd;
      source.onended = this.onEnded.bind(this);
      source.start(this._startedAt, this._progress + this.offset, this.duration);
      this.isPlaying = true;
      this.source = source;
      this.setDetune(this.detune);
      this.setPlaybackRate(this.playbackRate);
      return this.connect();
    }
    pause() {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      if (this.isPlaying === true) {
        this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
        if (this.loop === true) {
          this._progress = this._progress % (this.duration || this.buffer.duration);
        }
        this.source.stop();
        this.source.onended = null;
        this.isPlaying = false;
      }
      return this;
    }
    stop() {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      this._progress = 0;
      this.source.stop();
      this.source.onended = null;
      this.isPlaying = false;
      return this;
    }
    connect() {
      if (this.filters.length > 0) {
        this.source.connect(this.filters[0]);
        for (let i2 = 1, l2 = this.filters.length; i2 < l2; i2++) {
          this.filters[i2 - 1].connect(this.filters[i2]);
        }
        this.filters[this.filters.length - 1].connect(this.getOutput());
      } else {
        this.source.connect(this.getOutput());
      }
      this._connected = true;
      return this;
    }
    disconnect() {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let i2 = 1, l2 = this.filters.length; i2 < l2; i2++) {
          this.filters[i2 - 1].disconnect(this.filters[i2]);
        }
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else {
        this.source.disconnect(this.getOutput());
      }
      this._connected = false;
      return this;
    }
    getFilters() {
      return this.filters;
    }
    setFilters(value) {
      if (!value)
        value = [];
      if (this._connected === true) {
        this.disconnect();
        this.filters = value.slice();
        this.connect();
      } else {
        this.filters = value.slice();
      }
      return this;
    }
    setDetune(value) {
      this.detune = value;
      if (this.source.detune === void 0)
        return;
      if (this.isPlaying === true) {
        this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
      }
      return this;
    }
    getDetune() {
      return this.detune;
    }
    getFilter() {
      return this.getFilters()[0];
    }
    setFilter(filter) {
      return this.setFilters(filter ? [filter] : []);
    }
    setPlaybackRate(value) {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      this.playbackRate = value;
      if (this.isPlaying === true) {
        this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
      }
      return this;
    }
    getPlaybackRate() {
      return this.playbackRate;
    }
    onEnded() {
      this.isPlaying = false;
    }
    getLoop() {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return false;
      }
      return this.loop;
    }
    setLoop(value) {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      this.loop = value;
      if (this.isPlaying === true) {
        this.source.loop = this.loop;
      }
      return this;
    }
    setLoopStart(value) {
      this.loopStart = value;
      return this;
    }
    setLoopEnd(value) {
      this.loopEnd = value;
      return this;
    }
    getVolume() {
      return this.gain.gain.value;
    }
    setVolume(value) {
      this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
      return this;
    }
  };
  var AudioAnalyser = class {
    constructor(audio, fftSize = 2048) {
      this.analyser = audio.context.createAnalyser();
      this.analyser.fftSize = fftSize;
      this.data = new Uint8Array(this.analyser.frequencyBinCount);
      audio.getOutput().connect(this.analyser);
    }
    getFrequencyData() {
      this.analyser.getByteFrequencyData(this.data);
      return this.data;
    }
    getAverageFrequency() {
      let value = 0;
      const data = this.getFrequencyData();
      for (let i2 = 0; i2 < data.length; i2++) {
        value += data[i2];
      }
      return value / data.length;
    }
  };
  var PropertyMixer = class {
    constructor(binding, typeName, valueSize) {
      this.binding = binding;
      this.valueSize = valueSize;
      let mixFunction, mixFunctionAdditive, setIdentity;
      switch (typeName) {
        case "quaternion":
          mixFunction = this._slerp;
          mixFunctionAdditive = this._slerpAdditive;
          setIdentity = this._setAdditiveIdentityQuaternion;
          this.buffer = new Float64Array(valueSize * 6);
          this._workIndex = 5;
          break;
        case "string":
        case "bool":
          mixFunction = this._select;
          mixFunctionAdditive = this._select;
          setIdentity = this._setAdditiveIdentityOther;
          this.buffer = new Array(valueSize * 5);
          break;
        default:
          mixFunction = this._lerp;
          mixFunctionAdditive = this._lerpAdditive;
          setIdentity = this._setAdditiveIdentityNumeric;
          this.buffer = new Float64Array(valueSize * 5);
      }
      this._mixBufferRegion = mixFunction;
      this._mixBufferRegionAdditive = mixFunctionAdditive;
      this._setIdentity = setIdentity;
      this._origIndex = 3;
      this._addIndex = 4;
      this.cumulativeWeight = 0;
      this.cumulativeWeightAdditive = 0;
      this.useCount = 0;
      this.referenceCount = 0;
    }
    accumulate(accuIndex, weight) {
      const buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
      let currentWeight = this.cumulativeWeight;
      if (currentWeight === 0) {
        for (let i2 = 0; i2 !== stride; ++i2) {
          buffer[offset + i2] = buffer[i2];
        }
        currentWeight = weight;
      } else {
        currentWeight += weight;
        const mix = weight / currentWeight;
        this._mixBufferRegion(buffer, offset, 0, mix, stride);
      }
      this.cumulativeWeight = currentWeight;
    }
    accumulateAdditive(weight) {
      const buffer = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
      if (this.cumulativeWeightAdditive === 0) {
        this._setIdentity();
      }
      this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
      this.cumulativeWeightAdditive += weight;
    }
    apply(accuIndex) {
      const stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
      this.cumulativeWeight = 0;
      this.cumulativeWeightAdditive = 0;
      if (weight < 1) {
        const originalValueOffset = stride * this._origIndex;
        this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
      }
      if (weightAdditive > 0) {
        this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
      }
      for (let i2 = stride, e2 = stride + stride; i2 !== e2; ++i2) {
        if (buffer[i2] !== buffer[i2 + stride]) {
          binding.setValue(buffer, offset);
          break;
        }
      }
    }
    saveOriginalState() {
      const binding = this.binding;
      const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
      binding.getValue(buffer, originalValueOffset);
      for (let i2 = stride, e2 = originalValueOffset; i2 !== e2; ++i2) {
        buffer[i2] = buffer[originalValueOffset + i2 % stride];
      }
      this._setIdentity();
      this.cumulativeWeight = 0;
      this.cumulativeWeightAdditive = 0;
    }
    restoreOriginalState() {
      const originalValueOffset = this.valueSize * 3;
      this.binding.setValue(this.buffer, originalValueOffset);
    }
    _setAdditiveIdentityNumeric() {
      const startIndex = this._addIndex * this.valueSize;
      const endIndex = startIndex + this.valueSize;
      for (let i2 = startIndex; i2 < endIndex; i2++) {
        this.buffer[i2] = 0;
      }
    }
    _setAdditiveIdentityQuaternion() {
      this._setAdditiveIdentityNumeric();
      this.buffer[this._addIndex * this.valueSize + 3] = 1;
    }
    _setAdditiveIdentityOther() {
      const startIndex = this._origIndex * this.valueSize;
      const targetIndex = this._addIndex * this.valueSize;
      for (let i2 = 0; i2 < this.valueSize; i2++) {
        this.buffer[targetIndex + i2] = this.buffer[startIndex + i2];
      }
    }
    _select(buffer, dstOffset, srcOffset, t2, stride) {
      if (t2 >= 0.5) {
        for (let i2 = 0; i2 !== stride; ++i2) {
          buffer[dstOffset + i2] = buffer[srcOffset + i2];
        }
      }
    }
    _slerp(buffer, dstOffset, srcOffset, t2) {
      Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t2);
    }
    _slerpAdditive(buffer, dstOffset, srcOffset, t2, stride) {
      const workOffset = this._workIndex * stride;
      Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
      Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t2);
    }
    _lerp(buffer, dstOffset, srcOffset, t2, stride) {
      const s2 = 1 - t2;
      for (let i2 = 0; i2 !== stride; ++i2) {
        const j2 = dstOffset + i2;
        buffer[j2] = buffer[j2] * s2 + buffer[srcOffset + i2] * t2;
      }
    }
    _lerpAdditive(buffer, dstOffset, srcOffset, t2, stride) {
      for (let i2 = 0; i2 !== stride; ++i2) {
        const j2 = dstOffset + i2;
        buffer[j2] = buffer[j2] + buffer[srcOffset + i2] * t2;
      }
    }
  };
  var _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
  var _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
  var _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
  var _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
  var _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
  var _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
  var _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
  var _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
  var _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$");
  var _supportedObjectNames = ["material", "materials", "bones"];
  var Composite = class {
    constructor(targetGroup, path, optionalParsedPath) {
      const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
      this._targetGroup = targetGroup;
      this._bindings = targetGroup.subscribe_(path, parsedPath);
    }
    getValue(array, offset) {
      this.bind();
      const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
      if (binding !== void 0)
        binding.getValue(array, offset);
    }
    setValue(array, offset) {
      const bindings = this._bindings;
      for (let i2 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i2 !== n2; ++i2) {
        bindings[i2].setValue(array, offset);
      }
    }
    bind() {
      const bindings = this._bindings;
      for (let i2 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i2 !== n2; ++i2) {
        bindings[i2].bind();
      }
    }
    unbind() {
      const bindings = this._bindings;
      for (let i2 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i2 !== n2; ++i2) {
        bindings[i2].unbind();
      }
    }
  };
  var PropertyBinding = class {
    constructor(rootNode, path, parsedPath) {
      this.path = path;
      this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
      this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
      this.rootNode = rootNode;
      this.getValue = this._getValue_unbound;
      this.setValue = this._setValue_unbound;
    }
    static create(root, path, parsedPath) {
      if (!(root && root.isAnimationObjectGroup)) {
        return new PropertyBinding(root, path, parsedPath);
      } else {
        return new PropertyBinding.Composite(root, path, parsedPath);
      }
    }
    static sanitizeNodeName(name) {
      return name.replace(/\s/g, "_").replace(_reservedRe, "");
    }
    static parseTrackName(trackName) {
      const matches = _trackRe.exec(trackName);
      if (!matches) {
        throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
      }
      const results = {
        nodeName: matches[2],
        objectName: matches[3],
        objectIndex: matches[4],
        propertyName: matches[5],
        propertyIndex: matches[6]
      };
      const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
      if (lastDot !== void 0 && lastDot !== -1) {
        const objectName = results.nodeName.substring(lastDot + 1);
        if (_supportedObjectNames.indexOf(objectName) !== -1) {
          results.nodeName = results.nodeName.substring(0, lastDot);
          results.objectName = objectName;
        }
      }
      if (results.propertyName === null || results.propertyName.length === 0) {
        throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
      }
      return results;
    }
    static findNode(root, nodeName) {
      if (!nodeName || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
        return root;
      }
      if (root.skeleton) {
        const bone = root.skeleton.getBoneByName(nodeName);
        if (bone !== void 0) {
          return bone;
        }
      }
      if (root.children) {
        const searchNodeSubtree = function(children) {
          for (let i2 = 0; i2 < children.length; i2++) {
            const childNode = children[i2];
            if (childNode.name === nodeName || childNode.uuid === nodeName) {
              return childNode;
            }
            const result = searchNodeSubtree(childNode.children);
            if (result)
              return result;
          }
          return null;
        };
        const subTreeNode = searchNodeSubtree(root.children);
        if (subTreeNode) {
          return subTreeNode;
        }
      }
      return null;
    }
    _getValue_unavailable() {
    }
    _setValue_unavailable() {
    }
    _getValue_direct(buffer, offset) {
      buffer[offset] = this.targetObject[this.propertyName];
    }
    _getValue_array(buffer, offset) {
      const source = this.resolvedProperty;
      for (let i2 = 0, n2 = source.length; i2 !== n2; ++i2) {
        buffer[offset++] = source[i2];
      }
    }
    _getValue_arrayElement(buffer, offset) {
      buffer[offset] = this.resolvedProperty[this.propertyIndex];
    }
    _getValue_toArray(buffer, offset) {
      this.resolvedProperty.toArray(buffer, offset);
    }
    _setValue_direct(buffer, offset) {
      this.targetObject[this.propertyName] = buffer[offset];
    }
    _setValue_direct_setNeedsUpdate(buffer, offset) {
      this.targetObject[this.propertyName] = buffer[offset];
      this.targetObject.needsUpdate = true;
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
      this.targetObject[this.propertyName] = buffer[offset];
      this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _setValue_array(buffer, offset) {
      const dest = this.resolvedProperty;
      for (let i2 = 0, n2 = dest.length; i2 !== n2; ++i2) {
        dest[i2] = buffer[offset++];
      }
    }
    _setValue_array_setNeedsUpdate(buffer, offset) {
      const dest = this.resolvedProperty;
      for (let i2 = 0, n2 = dest.length; i2 !== n2; ++i2) {
        dest[i2] = buffer[offset++];
      }
      this.targetObject.needsUpdate = true;
    }
    _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
      const dest = this.resolvedProperty;
      for (let i2 = 0, n2 = dest.length; i2 !== n2; ++i2) {
        dest[i2] = buffer[offset++];
      }
      this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _setValue_arrayElement(buffer, offset) {
      this.resolvedProperty[this.propertyIndex] = buffer[offset];
    }
    _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
      this.resolvedProperty[this.propertyIndex] = buffer[offset];
      this.targetObject.needsUpdate = true;
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
      this.resolvedProperty[this.propertyIndex] = buffer[offset];
      this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _setValue_fromArray(buffer, offset) {
      this.resolvedProperty.fromArray(buffer, offset);
    }
    _setValue_fromArray_setNeedsUpdate(buffer, offset) {
      this.resolvedProperty.fromArray(buffer, offset);
      this.targetObject.needsUpdate = true;
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
      this.resolvedProperty.fromArray(buffer, offset);
      this.targetObject.matrixWorldNeedsUpdate = true;
    }
    _getValue_unbound(targetArray, offset) {
      this.bind();
      this.getValue(targetArray, offset);
    }
    _setValue_unbound(sourceArray, offset) {
      this.bind();
      this.setValue(sourceArray, offset);
    }
    bind() {
      let targetObject = this.node;
      const parsedPath = this.parsedPath;
      const objectName = parsedPath.objectName;
      const propertyName = parsedPath.propertyName;
      let propertyIndex = parsedPath.propertyIndex;
      if (!targetObject) {
        targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
        this.node = targetObject;
      }
      this.getValue = this._getValue_unavailable;
      this.setValue = this._setValue_unavailable;
      if (!targetObject) {
        console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
        return;
      }
      if (objectName) {
        let objectIndex = parsedPath.objectIndex;
        switch (objectName) {
          case "materials":
            if (!targetObject.material) {
              console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
              return;
            }
            if (!targetObject.material.materials) {
              console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
              return;
            }
            targetObject = targetObject.material.materials;
            break;
          case "bones":
            if (!targetObject.skeleton) {
              console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
              return;
            }
            targetObject = targetObject.skeleton.bones;
            for (let i2 = 0; i2 < targetObject.length; i2++) {
              if (targetObject[i2].name === objectIndex) {
                objectIndex = i2;
                break;
              }
            }
            break;
          default:
            if (targetObject[objectName] === void 0) {
              console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
              return;
            }
            targetObject = targetObject[objectName];
        }
        if (objectIndex !== void 0) {
          if (targetObject[objectIndex] === void 0) {
            console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
            return;
          }
          targetObject = targetObject[objectIndex];
        }
      }
      const nodeProperty = targetObject[propertyName];
      if (nodeProperty === void 0) {
        const nodeName = parsedPath.nodeName;
        console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
        return;
      }
      let versioning = this.Versioning.None;
      this.targetObject = targetObject;
      if (targetObject.needsUpdate !== void 0) {
        versioning = this.Versioning.NeedsUpdate;
      } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
        versioning = this.Versioning.MatrixWorldNeedsUpdate;
      }
      let bindingType = this.BindingType.Direct;
      if (propertyIndex !== void 0) {
        if (propertyName === "morphTargetInfluences") {
          if (!targetObject.geometry) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
            return;
          }
          if (targetObject.geometry.isBufferGeometry) {
            if (!targetObject.geometry.morphAttributes) {
              console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
              return;
            }
            if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
              propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
            }
          } else {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
            return;
          }
        }
        bindingType = this.BindingType.ArrayElement;
        this.resolvedProperty = nodeProperty;
        this.propertyIndex = propertyIndex;
      } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
        bindingType = this.BindingType.HasFromToArray;
        this.resolvedProperty = nodeProperty;
      } else if (Array.isArray(nodeProperty)) {
        bindingType = this.BindingType.EntireArray;
        this.resolvedProperty = nodeProperty;
      } else {
        this.propertyName = propertyName;
      }
      this.getValue = this.GetterByBindingType[bindingType];
      this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
    }
    unbind() {
      this.node = null;
      this.getValue = this._getValue_unbound;
      this.setValue = this._setValue_unbound;
    }
  };
  PropertyBinding.Composite = Composite;
  PropertyBinding.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
  };
  PropertyBinding.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
  };
  PropertyBinding.prototype.GetterByBindingType = [
    PropertyBinding.prototype._getValue_direct,
    PropertyBinding.prototype._getValue_array,
    PropertyBinding.prototype._getValue_arrayElement,
    PropertyBinding.prototype._getValue_toArray
  ];
  PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
    [
      PropertyBinding.prototype._setValue_direct,
      PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
      PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
    ],
    [
      PropertyBinding.prototype._setValue_array,
      PropertyBinding.prototype._setValue_array_setNeedsUpdate,
      PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
    ],
    [
      PropertyBinding.prototype._setValue_arrayElement,
      PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
      PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
    ],
    [
      PropertyBinding.prototype._setValue_fromArray,
      PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
      PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
    ]
  ];
  var AnimationObjectGroup = class {
    constructor() {
      this.uuid = generateUUID();
      this._objects = Array.prototype.slice.call(arguments);
      this.nCachedObjects_ = 0;
      const indices = {};
      this._indicesByUUID = indices;
      for (let i2 = 0, n2 = arguments.length; i2 !== n2; ++i2) {
        indices[arguments[i2].uuid] = i2;
      }
      this._paths = [];
      this._parsedPaths = [];
      this._bindings = [];
      this._bindingsIndicesByPath = {};
      const scope = this;
      this.stats = {
        objects: {
          get total() {
            return scope._objects.length;
          },
          get inUse() {
            return this.total - scope.nCachedObjects_;
          }
        },
        get bindingsPerObject() {
          return scope._bindings.length;
        }
      };
    }
    add() {
      const objects = this._objects, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
      let knownObject = void 0, nObjects = objects.length, nCachedObjects = this.nCachedObjects_;
      for (let i2 = 0, n2 = arguments.length; i2 !== n2; ++i2) {
        const object = arguments[i2], uuid = object.uuid;
        let index = indicesByUUID[uuid];
        if (index === void 0) {
          index = nObjects++;
          indicesByUUID[uuid] = index;
          objects.push(object);
          for (let j2 = 0, m2 = nBindings; j2 !== m2; ++j2) {
            bindings[j2].push(new PropertyBinding(object, paths[j2], parsedPaths[j2]));
          }
        } else if (index < nCachedObjects) {
          knownObject = objects[index];
          const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
          indicesByUUID[lastCachedObject.uuid] = index;
          objects[index] = lastCachedObject;
          indicesByUUID[uuid] = firstActiveIndex;
          objects[firstActiveIndex] = object;
          for (let j2 = 0, m2 = nBindings; j2 !== m2; ++j2) {
            const bindingsForPath = bindings[j2], lastCached = bindingsForPath[firstActiveIndex];
            let binding = bindingsForPath[index];
            bindingsForPath[index] = lastCached;
            if (binding === void 0) {
              binding = new PropertyBinding(object, paths[j2], parsedPaths[j2]);
            }
            bindingsForPath[firstActiveIndex] = binding;
          }
        } else if (objects[index] !== knownObject) {
          console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
        }
      }
      this.nCachedObjects_ = nCachedObjects;
    }
    remove() {
      const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
      let nCachedObjects = this.nCachedObjects_;
      for (let i2 = 0, n2 = arguments.length; i2 !== n2; ++i2) {
        const object = arguments[i2], uuid = object.uuid, index = indicesByUUID[uuid];
        if (index !== void 0 && index >= nCachedObjects) {
          const lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
          indicesByUUID[firstActiveObject.uuid] = index;
          objects[index] = firstActiveObject;
          indicesByUUID[uuid] = lastCachedIndex;
          objects[lastCachedIndex] = object;
          for (let j2 = 0, m2 = nBindings; j2 !== m2; ++j2) {
            const bindingsForPath = bindings[j2], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
            bindingsForPath[index] = firstActive;
            bindingsForPath[lastCachedIndex] = binding;
          }
        }
      }
      this.nCachedObjects_ = nCachedObjects;
    }
    uncache() {
      const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
      let nCachedObjects = this.nCachedObjects_, nObjects = objects.length;
      for (let i2 = 0, n2 = arguments.length; i2 !== n2; ++i2) {
        const object = arguments[i2], uuid = object.uuid, index = indicesByUUID[uuid];
        if (index !== void 0) {
          delete indicesByUUID[uuid];
          if (index < nCachedObjects) {
            const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
            indicesByUUID[lastCachedObject.uuid] = index;
            objects[index] = lastCachedObject;
            indicesByUUID[lastObject.uuid] = firstActiveIndex;
            objects[firstActiveIndex] = lastObject;
            objects.pop();
            for (let j2 = 0, m2 = nBindings; j2 !== m2; ++j2) {
              const bindingsForPath = bindings[j2], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
              bindingsForPath[index] = lastCached;
              bindingsForPath[firstActiveIndex] = last;
              bindingsForPath.pop();
            }
          } else {
            const lastIndex = --nObjects, lastObject = objects[lastIndex];
            if (lastIndex > 0) {
              indicesByUUID[lastObject.uuid] = index;
            }
            objects[index] = lastObject;
            objects.pop();
            for (let j2 = 0, m2 = nBindings; j2 !== m2; ++j2) {
              const bindingsForPath = bindings[j2];
              bindingsForPath[index] = bindingsForPath[lastIndex];
              bindingsForPath.pop();
            }
          }
        }
      }
      this.nCachedObjects_ = nCachedObjects;
    }
    subscribe_(path, parsedPath) {
      const indicesByPath = this._bindingsIndicesByPath;
      let index = indicesByPath[path];
      const bindings = this._bindings;
      if (index !== void 0)
        return bindings[index];
      const paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
      index = bindings.length;
      indicesByPath[path] = index;
      paths.push(path);
      parsedPaths.push(parsedPath);
      bindings.push(bindingsForPath);
      for (let i2 = nCachedObjects, n2 = objects.length; i2 !== n2; ++i2) {
        const object = objects[i2];
        bindingsForPath[i2] = new PropertyBinding(object, path, parsedPath);
      }
      return bindingsForPath;
    }
    unsubscribe_(path) {
      const indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
      if (index !== void 0) {
        const paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
        indicesByPath[lastBindingsPath] = index;
        bindings[index] = lastBindings;
        bindings.pop();
        parsedPaths[index] = parsedPaths[lastBindingsIndex];
        parsedPaths.pop();
        paths[index] = paths[lastBindingsIndex];
        paths.pop();
      }
    }
  };
  AnimationObjectGroup.prototype.isAnimationObjectGroup = true;
  var AnimationAction = class {
    constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
      this._mixer = mixer;
      this._clip = clip;
      this._localRoot = localRoot;
      this.blendMode = blendMode;
      const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
      const interpolantSettings = {
        endingStart: ZeroCurvatureEnding,
        endingEnd: ZeroCurvatureEnding
      };
      for (let i2 = 0; i2 !== nTracks; ++i2) {
        const interpolant = tracks[i2].createInterpolant(null);
        interpolants[i2] = interpolant;
        interpolant.settings = interpolantSettings;
      }
      this._interpolantSettings = interpolantSettings;
      this._interpolants = interpolants;
      this._propertyBindings = new Array(nTracks);
      this._cacheIndex = null;
      this._byClipCacheIndex = null;
      this._timeScaleInterpolant = null;
      this._weightInterpolant = null;
      this.loop = LoopRepeat;
      this._loopCount = -1;
      this._startTime = null;
      this.time = 0;
      this.timeScale = 1;
      this._effectiveTimeScale = 1;
      this.weight = 1;
      this._effectiveWeight = 1;
      this.repetitions = Infinity;
      this.paused = false;
      this.enabled = true;
      this.clampWhenFinished = false;
      this.zeroSlopeAtStart = true;
      this.zeroSlopeAtEnd = true;
    }
    play() {
      this._mixer._activateAction(this);
      return this;
    }
    stop() {
      this._mixer._deactivateAction(this);
      return this.reset();
    }
    reset() {
      this.paused = false;
      this.enabled = true;
      this.time = 0;
      this._loopCount = -1;
      this._startTime = null;
      return this.stopFading().stopWarping();
    }
    isRunning() {
      return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
    }
    isScheduled() {
      return this._mixer._isActiveAction(this);
    }
    startAt(time) {
      this._startTime = time;
      return this;
    }
    setLoop(mode, repetitions) {
      this.loop = mode;
      this.repetitions = repetitions;
      return this;
    }
    setEffectiveWeight(weight) {
      this.weight = weight;
      this._effectiveWeight = this.enabled ? weight : 0;
      return this.stopFading();
    }
    getEffectiveWeight() {
      return this._effectiveWeight;
    }
    fadeIn(duration) {
      return this._scheduleFading(duration, 0, 1);
    }
    fadeOut(duration) {
      return this._scheduleFading(duration, 1, 0);
    }
    crossFadeFrom(fadeOutAction, duration, warp) {
      fadeOutAction.fadeOut(duration);
      this.fadeIn(duration);
      if (warp) {
        const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
        fadeOutAction.warp(1, startEndRatio, duration);
        this.warp(endStartRatio, 1, duration);
      }
      return this;
    }
    crossFadeTo(fadeInAction, duration, warp) {
      return fadeInAction.crossFadeFrom(this, duration, warp);
    }
    stopFading() {
      const weightInterpolant = this._weightInterpolant;
      if (weightInterpolant !== null) {
        this._weightInterpolant = null;
        this._mixer._takeBackControlInterpolant(weightInterpolant);
      }
      return this;
    }
    setEffectiveTimeScale(timeScale) {
      this.timeScale = timeScale;
      this._effectiveTimeScale = this.paused ? 0 : timeScale;
      return this.stopWarping();
    }
    getEffectiveTimeScale() {
      return this._effectiveTimeScale;
    }
    setDuration(duration) {
      this.timeScale = this._clip.duration / duration;
      return this.stopWarping();
    }
    syncWith(action) {
      this.time = action.time;
      this.timeScale = action.timeScale;
      return this.stopWarping();
    }
    halt(duration) {
      return this.warp(this._effectiveTimeScale, 0, duration);
    }
    warp(startTimeScale, endTimeScale, duration) {
      const mixer = this._mixer, now2 = mixer.time, timeScale = this.timeScale;
      let interpolant = this._timeScaleInterpolant;
      if (interpolant === null) {
        interpolant = mixer._lendControlInterpolant();
        this._timeScaleInterpolant = interpolant;
      }
      const times = interpolant.parameterPositions, values = interpolant.sampleValues;
      times[0] = now2;
      times[1] = now2 + duration;
      values[0] = startTimeScale / timeScale;
      values[1] = endTimeScale / timeScale;
      return this;
    }
    stopWarping() {
      const timeScaleInterpolant = this._timeScaleInterpolant;
      if (timeScaleInterpolant !== null) {
        this._timeScaleInterpolant = null;
        this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
      }
      return this;
    }
    getMixer() {
      return this._mixer;
    }
    getClip() {
      return this._clip;
    }
    getRoot() {
      return this._localRoot || this._mixer._root;
    }
    _update(time, deltaTime, timeDirection, accuIndex) {
      if (!this.enabled) {
        this._updateWeight(time);
        return;
      }
      const startTime = this._startTime;
      if (startTime !== null) {
        const timeRunning = (time - startTime) * timeDirection;
        if (timeRunning < 0 || timeDirection === 0) {
          return;
        }
        this._startTime = null;
        deltaTime = timeDirection * timeRunning;
      }
      deltaTime *= this._updateTimeScale(time);
      const clipTime = this._updateTime(deltaTime);
      const weight = this._updateWeight(time);
      if (weight > 0) {
        const interpolants = this._interpolants;
        const propertyMixers = this._propertyBindings;
        switch (this.blendMode) {
          case AdditiveAnimationBlendMode:
            for (let j2 = 0, m2 = interpolants.length; j2 !== m2; ++j2) {
              interpolants[j2].evaluate(clipTime);
              propertyMixers[j2].accumulateAdditive(weight);
            }
            break;
          case NormalAnimationBlendMode:
          default:
            for (let j2 = 0, m2 = interpolants.length; j2 !== m2; ++j2) {
              interpolants[j2].evaluate(clipTime);
              propertyMixers[j2].accumulate(accuIndex, weight);
            }
        }
      }
    }
    _updateWeight(time) {
      let weight = 0;
      if (this.enabled) {
        weight = this.weight;
        const interpolant = this._weightInterpolant;
        if (interpolant !== null) {
          const interpolantValue = interpolant.evaluate(time)[0];
          weight *= interpolantValue;
          if (time > interpolant.parameterPositions[1]) {
            this.stopFading();
            if (interpolantValue === 0) {
              this.enabled = false;
            }
          }
        }
      }
      this._effectiveWeight = weight;
      return weight;
    }
    _updateTimeScale(time) {
      let timeScale = 0;
      if (!this.paused) {
        timeScale = this.timeScale;
        const interpolant = this._timeScaleInterpolant;
        if (interpolant !== null) {
          const interpolantValue = interpolant.evaluate(time)[0];
          timeScale *= interpolantValue;
          if (time > interpolant.parameterPositions[1]) {
            this.stopWarping();
            if (timeScale === 0) {
              this.paused = true;
            } else {
              this.timeScale = timeScale;
            }
          }
        }
      }
      this._effectiveTimeScale = timeScale;
      return timeScale;
    }
    _updateTime(deltaTime) {
      const duration = this._clip.duration;
      const loop = this.loop;
      let time = this.time + deltaTime;
      let loopCount = this._loopCount;
      const pingPong = loop === LoopPingPong;
      if (deltaTime === 0) {
        if (loopCount === -1)
          return time;
        return pingPong && (loopCount & 1) === 1 ? duration - time : time;
      }
      if (loop === LoopOnce) {
        if (loopCount === -1) {
          this._loopCount = 0;
          this._setEndings(true, true, false);
        }
        handle_stop: {
          if (time >= duration) {
            time = duration;
          } else if (time < 0) {
            time = 0;
          } else {
            this.time = time;
            break handle_stop;
          }
          if (this.clampWhenFinished)
            this.paused = true;
          else
            this.enabled = false;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: deltaTime < 0 ? -1 : 1
          });
        }
      } else {
        if (loopCount === -1) {
          if (deltaTime >= 0) {
            loopCount = 0;
            this._setEndings(true, this.repetitions === 0, pingPong);
          } else {
            this._setEndings(this.repetitions === 0, true, pingPong);
          }
        }
        if (time >= duration || time < 0) {
          const loopDelta = Math.floor(time / duration);
          time -= duration * loopDelta;
          loopCount += Math.abs(loopDelta);
          const pending = this.repetitions - loopCount;
          if (pending <= 0) {
            if (this.clampWhenFinished)
              this.paused = true;
            else
              this.enabled = false;
            time = deltaTime > 0 ? duration : 0;
            this.time = time;
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: deltaTime > 0 ? 1 : -1
            });
          } else {
            if (pending === 1) {
              const atStart = deltaTime < 0;
              this._setEndings(atStart, !atStart, pingPong);
            } else {
              this._setEndings(false, false, pingPong);
            }
            this._loopCount = loopCount;
            this.time = time;
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta
            });
          }
        } else {
          this.time = time;
        }
        if (pingPong && (loopCount & 1) === 1) {
          return duration - time;
        }
      }
      return time;
    }
    _setEndings(atStart, atEnd, pingPong) {
      const settings = this._interpolantSettings;
      if (pingPong) {
        settings.endingStart = ZeroSlopeEnding;
        settings.endingEnd = ZeroSlopeEnding;
      } else {
        if (atStart) {
          settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
        } else {
          settings.endingStart = WrapAroundEnding;
        }
        if (atEnd) {
          settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
        } else {
          settings.endingEnd = WrapAroundEnding;
        }
      }
    }
    _scheduleFading(duration, weightNow, weightThen) {
      const mixer = this._mixer, now2 = mixer.time;
      let interpolant = this._weightInterpolant;
      if (interpolant === null) {
        interpolant = mixer._lendControlInterpolant();
        this._weightInterpolant = interpolant;
      }
      const times = interpolant.parameterPositions, values = interpolant.sampleValues;
      times[0] = now2;
      values[0] = weightNow;
      times[1] = now2 + duration;
      values[1] = weightThen;
      return this;
    }
  };
  var AnimationMixer = class extends EventDispatcher {
    constructor(root) {
      super();
      this._root = root;
      this._initMemoryManager();
      this._accuIndex = 0;
      this.time = 0;
      this.timeScale = 1;
    }
    _bindAction(action, prototypeAction) {
      const root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
      let bindingsByName = bindingsByRoot[rootUuid];
      if (bindingsByName === void 0) {
        bindingsByName = {};
        bindingsByRoot[rootUuid] = bindingsByName;
      }
      for (let i2 = 0; i2 !== nTracks; ++i2) {
        const track = tracks[i2], trackName = track.name;
        let binding = bindingsByName[trackName];
        if (binding !== void 0) {
          bindings[i2] = binding;
        } else {
          binding = bindings[i2];
          if (binding !== void 0) {
            if (binding._cacheIndex === null) {
              ++binding.referenceCount;
              this._addInactiveBinding(binding, rootUuid, trackName);
            }
            continue;
          }
          const path = prototypeAction && prototypeAction._propertyBindings[i2].binding.parsedPath;
          binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
          ++binding.referenceCount;
          this._addInactiveBinding(binding, rootUuid, trackName);
          bindings[i2] = binding;
        }
        interpolants[i2].resultBuffer = binding.buffer;
      }
    }
    _activateAction(action) {
      if (!this._isActiveAction(action)) {
        if (action._cacheIndex === null) {
          const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
          this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
          this._addInactiveAction(action, clipUuid, rootUuid);
        }
        const bindings = action._propertyBindings;
        for (let i2 = 0, n2 = bindings.length; i2 !== n2; ++i2) {
          const binding = bindings[i2];
          if (binding.useCount++ === 0) {
            this._lendBinding(binding);
            binding.saveOriginalState();
          }
        }
        this._lendAction(action);
      }
    }
    _deactivateAction(action) {
      if (this._isActiveAction(action)) {
        const bindings = action._propertyBindings;
        for (let i2 = 0, n2 = bindings.length; i2 !== n2; ++i2) {
          const binding = bindings[i2];
          if (--binding.useCount === 0) {
            binding.restoreOriginalState();
            this._takeBackBinding(binding);
          }
        }
        this._takeBackAction(action);
      }
    }
    _initMemoryManager() {
      this._actions = [];
      this._nActiveActions = 0;
      this._actionsByClip = {};
      this._bindings = [];
      this._nActiveBindings = 0;
      this._bindingsByRootAndName = {};
      this._controlInterpolants = [];
      this._nActiveControlInterpolants = 0;
      const scope = this;
      this.stats = {
        actions: {
          get total() {
            return scope._actions.length;
          },
          get inUse() {
            return scope._nActiveActions;
          }
        },
        bindings: {
          get total() {
            return scope._bindings.length;
          },
          get inUse() {
            return scope._nActiveBindings;
          }
        },
        controlInterpolants: {
          get total() {
            return scope._controlInterpolants.length;
          },
          get inUse() {
            return scope._nActiveControlInterpolants;
          }
        }
      };
    }
    _isActiveAction(action) {
      const index = action._cacheIndex;
      return index !== null && index < this._nActiveActions;
    }
    _addInactiveAction(action, clipUuid, rootUuid) {
      const actions = this._actions, actionsByClip = this._actionsByClip;
      let actionsForClip = actionsByClip[clipUuid];
      if (actionsForClip === void 0) {
        actionsForClip = {
          knownActions: [action],
          actionByRoot: {}
        };
        action._byClipCacheIndex = 0;
        actionsByClip[clipUuid] = actionsForClip;
      } else {
        const knownActions = actionsForClip.knownActions;
        action._byClipCacheIndex = knownActions.length;
        knownActions.push(action);
      }
      action._cacheIndex = actions.length;
      actions.push(action);
      actionsForClip.actionByRoot[rootUuid] = action;
    }
    _removeInactiveAction(action) {
      const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
      lastInactiveAction._cacheIndex = cacheIndex;
      actions[cacheIndex] = lastInactiveAction;
      actions.pop();
      action._cacheIndex = null;
      const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
      lastKnownAction._byClipCacheIndex = byClipCacheIndex;
      knownActionsForClip[byClipCacheIndex] = lastKnownAction;
      knownActionsForClip.pop();
      action._byClipCacheIndex = null;
      const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
      delete actionByRoot[rootUuid];
      if (knownActionsForClip.length === 0) {
        delete actionsByClip[clipUuid];
      }
      this._removeInactiveBindingsForAction(action);
    }
    _removeInactiveBindingsForAction(action) {
      const bindings = action._propertyBindings;
      for (let i2 = 0, n2 = bindings.length; i2 !== n2; ++i2) {
        const binding = bindings[i2];
        if (--binding.referenceCount === 0) {
          this._removeInactiveBinding(binding);
        }
      }
    }
    _lendAction(action) {
      const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
      action._cacheIndex = lastActiveIndex;
      actions[lastActiveIndex] = action;
      firstInactiveAction._cacheIndex = prevIndex;
      actions[prevIndex] = firstInactiveAction;
    }
    _takeBackAction(action) {
      const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
      action._cacheIndex = firstInactiveIndex;
      actions[firstInactiveIndex] = action;
      lastActiveAction._cacheIndex = prevIndex;
      actions[prevIndex] = lastActiveAction;
    }
    _addInactiveBinding(binding, rootUuid, trackName) {
      const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
      let bindingByName = bindingsByRoot[rootUuid];
      if (bindingByName === void 0) {
        bindingByName = {};
        bindingsByRoot[rootUuid] = bindingByName;
      }
      bindingByName[trackName] = binding;
      binding._cacheIndex = bindings.length;
      bindings.push(binding);
    }
    _removeInactiveBinding(binding) {
      const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
      lastInactiveBinding._cacheIndex = cacheIndex;
      bindings[cacheIndex] = lastInactiveBinding;
      bindings.pop();
      delete bindingByName[trackName];
      if (Object.keys(bindingByName).length === 0) {
        delete bindingsByRoot[rootUuid];
      }
    }
    _lendBinding(binding) {
      const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
      binding._cacheIndex = lastActiveIndex;
      bindings[lastActiveIndex] = binding;
      firstInactiveBinding._cacheIndex = prevIndex;
      bindings[prevIndex] = firstInactiveBinding;
    }
    _takeBackBinding(binding) {
      const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
      binding._cacheIndex = firstInactiveIndex;
      bindings[firstInactiveIndex] = binding;
      lastActiveBinding._cacheIndex = prevIndex;
      bindings[prevIndex] = lastActiveBinding;
    }
    _lendControlInterpolant() {
      const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
      let interpolant = interpolants[lastActiveIndex];
      if (interpolant === void 0) {
        interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
        interpolant.__cacheIndex = lastActiveIndex;
        interpolants[lastActiveIndex] = interpolant;
      }
      return interpolant;
    }
    _takeBackControlInterpolant(interpolant) {
      const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
      interpolant.__cacheIndex = firstInactiveIndex;
      interpolants[firstInactiveIndex] = interpolant;
      lastActiveInterpolant.__cacheIndex = prevIndex;
      interpolants[prevIndex] = lastActiveInterpolant;
    }
    clipAction(clip, optionalRoot, blendMode) {
      const root = optionalRoot || this._root, rootUuid = root.uuid;
      let clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip;
      const clipUuid = clipObject !== null ? clipObject.uuid : clip;
      const actionsForClip = this._actionsByClip[clipUuid];
      let prototypeAction = null;
      if (blendMode === void 0) {
        if (clipObject !== null) {
          blendMode = clipObject.blendMode;
        } else {
          blendMode = NormalAnimationBlendMode;
        }
      }
      if (actionsForClip !== void 0) {
        const existingAction = actionsForClip.actionByRoot[rootUuid];
        if (existingAction !== void 0 && existingAction.blendMode === blendMode) {
          return existingAction;
        }
        prototypeAction = actionsForClip.knownActions[0];
        if (clipObject === null)
          clipObject = prototypeAction._clip;
      }
      if (clipObject === null)
        return null;
      const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
      this._bindAction(newAction, prototypeAction);
      this._addInactiveAction(newAction, clipUuid, rootUuid);
      return newAction;
    }
    existingAction(clip, optionalRoot) {
      const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
      if (actionsForClip !== void 0) {
        return actionsForClip.actionByRoot[rootUuid] || null;
      }
      return null;
    }
    stopAllAction() {
      const actions = this._actions, nActions = this._nActiveActions;
      for (let i2 = nActions - 1; i2 >= 0; --i2) {
        actions[i2].stop();
      }
      return this;
    }
    update(deltaTime) {
      deltaTime *= this.timeScale;
      const actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
      for (let i2 = 0; i2 !== nActions; ++i2) {
        const action = actions[i2];
        action._update(time, deltaTime, timeDirection, accuIndex);
      }
      const bindings = this._bindings, nBindings = this._nActiveBindings;
      for (let i2 = 0; i2 !== nBindings; ++i2) {
        bindings[i2].apply(accuIndex);
      }
      return this;
    }
    setTime(timeInSeconds) {
      this.time = 0;
      for (let i2 = 0; i2 < this._actions.length; i2++) {
        this._actions[i2].time = 0;
      }
      return this.update(timeInSeconds);
    }
    getRoot() {
      return this._root;
    }
    uncacheClip(clip) {
      const actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
      if (actionsForClip !== void 0) {
        const actionsToRemove = actionsForClip.knownActions;
        for (let i2 = 0, n2 = actionsToRemove.length; i2 !== n2; ++i2) {
          const action = actionsToRemove[i2];
          this._deactivateAction(action);
          const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
          action._cacheIndex = null;
          action._byClipCacheIndex = null;
          lastInactiveAction._cacheIndex = cacheIndex;
          actions[cacheIndex] = lastInactiveAction;
          actions.pop();
          this._removeInactiveBindingsForAction(action);
        }
        delete actionsByClip[clipUuid];
      }
    }
    uncacheRoot(root) {
      const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
      for (const clipUuid in actionsByClip) {
        const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
        if (action !== void 0) {
          this._deactivateAction(action);
          this._removeInactiveAction(action);
        }
      }
      const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
      if (bindingByName !== void 0) {
        for (const trackName in bindingByName) {
          const binding = bindingByName[trackName];
          binding.restoreOriginalState();
          this._removeInactiveBinding(binding);
        }
      }
    }
    uncacheAction(clip, optionalRoot) {
      const action = this.existingAction(clip, optionalRoot);
      if (action !== null) {
        this._deactivateAction(action);
        this._removeInactiveAction(action);
      }
    }
  };
  AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
  var Uniform = class {
    constructor(value) {
      if (typeof value === "string") {
        console.warn("THREE.Uniform: Type parameter is no longer needed.");
        value = arguments[1];
      }
      this.value = value;
    }
    clone() {
      return new Uniform(this.value.clone === void 0 ? this.value : this.value.clone());
    }
  };
  var InstancedInterleavedBuffer = class extends InterleavedBuffer {
    constructor(array, stride, meshPerAttribute = 1) {
      super(array, stride);
      this.meshPerAttribute = meshPerAttribute;
    }
    copy(source) {
      super.copy(source);
      this.meshPerAttribute = source.meshPerAttribute;
      return this;
    }
    clone(data) {
      const ib = super.clone(data);
      ib.meshPerAttribute = this.meshPerAttribute;
      return ib;
    }
    toJSON(data) {
      const json = super.toJSON(data);
      json.isInstancedInterleavedBuffer = true;
      json.meshPerAttribute = this.meshPerAttribute;
      return json;
    }
  };
  InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;
  var GLBufferAttribute = class {
    constructor(buffer, type, itemSize, elementSize, count) {
      this.buffer = buffer;
      this.type = type;
      this.itemSize = itemSize;
      this.elementSize = elementSize;
      this.count = count;
      this.version = 0;
    }
    set needsUpdate(value) {
      if (value === true)
        this.version++;
    }
    setBuffer(buffer) {
      this.buffer = buffer;
      return this;
    }
    setType(type, elementSize) {
      this.type = type;
      this.elementSize = elementSize;
      return this;
    }
    setItemSize(itemSize) {
      this.itemSize = itemSize;
      return this;
    }
    setCount(count) {
      this.count = count;
      return this;
    }
  };
  GLBufferAttribute.prototype.isGLBufferAttribute = true;
  var Spherical = class {
    constructor(radius = 1, phi = 0, theta = 0) {
      this.radius = radius;
      this.phi = phi;
      this.theta = theta;
      return this;
    }
    set(radius, phi, theta) {
      this.radius = radius;
      this.phi = phi;
      this.theta = theta;
      return this;
    }
    copy(other) {
      this.radius = other.radius;
      this.phi = other.phi;
      this.theta = other.theta;
      return this;
    }
    makeSafe() {
      const EPS = 1e-6;
      this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
      return this;
    }
    setFromVector3(v2) {
      return this.setFromCartesianCoords(v2.x, v2.y, v2.z);
    }
    setFromCartesianCoords(x2, y2, z2) {
      this.radius = Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2);
      if (this.radius === 0) {
        this.theta = 0;
        this.phi = 0;
      } else {
        this.theta = Math.atan2(x2, z2);
        this.phi = Math.acos(clamp(y2 / this.radius, -1, 1));
      }
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  var _vector$4 = /* @__PURE__ */ new Vector2();
  var Box2 = class {
    constructor(min = new Vector2(Infinity, Infinity), max = new Vector2(-Infinity, -Infinity)) {
      this.min = min;
      this.max = max;
    }
    set(min, max) {
      this.min.copy(min);
      this.max.copy(max);
      return this;
    }
    setFromPoints(points) {
      this.makeEmpty();
      for (let i2 = 0, il = points.length; i2 < il; i2++) {
        this.expandByPoint(points[i2]);
      }
      return this;
    }
    setFromCenterAndSize(center, size) {
      const halfSize = _vector$4.copy(size).multiplyScalar(0.5);
      this.min.copy(center).sub(halfSize);
      this.max.copy(center).add(halfSize);
      return this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(box) {
      this.min.copy(box.min);
      this.max.copy(box.max);
      return this;
    }
    makeEmpty() {
      this.min.x = this.min.y = Infinity;
      this.max.x = this.max.y = -Infinity;
      return this;
    }
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y;
    }
    getCenter(target) {
      return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(target) {
      return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
    }
    expandByPoint(point) {
      this.min.min(point);
      this.max.max(point);
      return this;
    }
    expandByVector(vector) {
      this.min.sub(vector);
      this.max.add(vector);
      return this;
    }
    expandByScalar(scalar) {
      this.min.addScalar(-scalar);
      this.max.addScalar(scalar);
      return this;
    }
    containsPoint(point) {
      return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
    }
    containsBox(box) {
      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
    }
    getParameter(point, target) {
      return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
    }
    intersectsBox(box) {
      return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
    }
    clampPoint(point, target) {
      return target.copy(point).clamp(this.min, this.max);
    }
    distanceToPoint(point) {
      const clampedPoint = _vector$4.copy(point).clamp(this.min, this.max);
      return clampedPoint.sub(point).length();
    }
    intersect(box) {
      this.min.max(box.min);
      this.max.min(box.max);
      return this;
    }
    union(box) {
      this.min.min(box.min);
      this.max.max(box.max);
      return this;
    }
    translate(offset) {
      this.min.add(offset);
      this.max.add(offset);
      return this;
    }
    equals(box) {
      return box.min.equals(this.min) && box.max.equals(this.max);
    }
  };
  Box2.prototype.isBox2 = true;
  var _startP = /* @__PURE__ */ new Vector3();
  var _startEnd = /* @__PURE__ */ new Vector3();
  var Line3 = class {
    constructor(start = new Vector3(), end = new Vector3()) {
      this.start = start;
      this.end = end;
    }
    set(start, end) {
      this.start.copy(start);
      this.end.copy(end);
      return this;
    }
    copy(line) {
      this.start.copy(line.start);
      this.end.copy(line.end);
      return this;
    }
    getCenter(target) {
      return target.addVectors(this.start, this.end).multiplyScalar(0.5);
    }
    delta(target) {
      return target.subVectors(this.end, this.start);
    }
    distanceSq() {
      return this.start.distanceToSquared(this.end);
    }
    distance() {
      return this.start.distanceTo(this.end);
    }
    at(t2, target) {
      return this.delta(target).multiplyScalar(t2).add(this.start);
    }
    closestPointToPointParameter(point, clampToLine) {
      _startP.subVectors(point, this.start);
      _startEnd.subVectors(this.end, this.start);
      const startEnd2 = _startEnd.dot(_startEnd);
      const startEnd_startP = _startEnd.dot(_startP);
      let t2 = startEnd_startP / startEnd2;
      if (clampToLine) {
        t2 = clamp(t2, 0, 1);
      }
      return t2;
    }
    closestPointToPoint(point, clampToLine, target) {
      const t2 = this.closestPointToPointParameter(point, clampToLine);
      return this.delta(target).multiplyScalar(t2).add(this.start);
    }
    applyMatrix4(matrix) {
      this.start.applyMatrix4(matrix);
      this.end.applyMatrix4(matrix);
      return this;
    }
    equals(line) {
      return line.start.equals(this.start) && line.end.equals(this.end);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  var ImmediateRenderObject = class extends Object3D {
    constructor(material) {
      super();
      this.material = material;
      this.render = function() {
      };
      this.hasPositions = false;
      this.hasNormals = false;
      this.hasColors = false;
      this.hasUvs = false;
      this.positionArray = null;
      this.normalArray = null;
      this.colorArray = null;
      this.uvArray = null;
      this.count = 0;
    }
  };
  ImmediateRenderObject.prototype.isImmediateRenderObject = true;
  var _vector$2 = /* @__PURE__ */ new Vector3();
  var _boneMatrix = /* @__PURE__ */ new Matrix4();
  var _matrixWorldInv = /* @__PURE__ */ new Matrix4();
  var SkeletonHelper = class extends LineSegments {
    constructor(object) {
      const bones = getBoneList(object);
      const geometry = new BufferGeometry();
      const vertices = [];
      const colors = [];
      const color1 = new Color(0, 0, 1);
      const color2 = new Color(0, 1, 0);
      for (let i2 = 0; i2 < bones.length; i2++) {
        const bone = bones[i2];
        if (bone.parent && bone.parent.isBone) {
          vertices.push(0, 0, 0);
          vertices.push(0, 0, 0);
          colors.push(color1.r, color1.g, color1.b);
          colors.push(color2.r, color2.g, color2.b);
        }
      }
      geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
      const material = new LineBasicMaterial({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true });
      super(geometry, material);
      this.type = "SkeletonHelper";
      this.isSkeletonHelper = true;
      this.root = object;
      this.bones = bones;
      this.matrix = object.matrixWorld;
      this.matrixAutoUpdate = false;
    }
    updateMatrixWorld(force) {
      const bones = this.bones;
      const geometry = this.geometry;
      const position = geometry.getAttribute("position");
      _matrixWorldInv.copy(this.root.matrixWorld).invert();
      for (let i2 = 0, j2 = 0; i2 < bones.length; i2++) {
        const bone = bones[i2];
        if (bone.parent && bone.parent.isBone) {
          _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
          _vector$2.setFromMatrixPosition(_boneMatrix);
          position.setXYZ(j2, _vector$2.x, _vector$2.y, _vector$2.z);
          _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
          _vector$2.setFromMatrixPosition(_boneMatrix);
          position.setXYZ(j2 + 1, _vector$2.x, _vector$2.y, _vector$2.z);
          j2 += 2;
        }
      }
      geometry.getAttribute("position").needsUpdate = true;
      super.updateMatrixWorld(force);
    }
  };
  function getBoneList(object) {
    const boneList = [];
    if (object && object.isBone) {
      boneList.push(object);
    }
    for (let i2 = 0; i2 < object.children.length; i2++) {
      boneList.push.apply(boneList, getBoneList(object.children[i2]));
    }
    return boneList;
  }
  var GridHelper = class extends LineSegments {
    constructor(size = 10, divisions = 10, color1 = 4473924, color2 = 8947848) {
      color1 = new Color(color1);
      color2 = new Color(color2);
      const center = divisions / 2;
      const step = size / divisions;
      const halfSize = size / 2;
      const vertices = [], colors = [];
      for (let i2 = 0, j2 = 0, k2 = -halfSize; i2 <= divisions; i2++, k2 += step) {
        vertices.push(-halfSize, 0, k2, halfSize, 0, k2);
        vertices.push(k2, 0, -halfSize, k2, 0, halfSize);
        const color = i2 === center ? color1 : color2;
        color.toArray(colors, j2);
        j2 += 3;
        color.toArray(colors, j2);
        j2 += 3;
        color.toArray(colors, j2);
        j2 += 3;
        color.toArray(colors, j2);
        j2 += 3;
      }
      const geometry = new BufferGeometry();
      geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
      const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
      super(geometry, material);
      this.type = "GridHelper";
    }
  };
  var AxesHelper = class extends LineSegments {
    constructor(size = 1) {
      const vertices = [
        0,
        0,
        0,
        size,
        0,
        0,
        0,
        0,
        0,
        0,
        size,
        0,
        0,
        0,
        0,
        0,
        0,
        size
      ];
      const colors = [
        1,
        0,
        0,
        1,
        0.6,
        0,
        0,
        1,
        0,
        0.6,
        1,
        0,
        0,
        0,
        1,
        0,
        0.6,
        1
      ];
      const geometry = new BufferGeometry();
      geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
      geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
      const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
      super(geometry, material);
      this.type = "AxesHelper";
    }
    setColors(xAxisColor, yAxisColor, zAxisColor) {
      const color = new Color();
      const array = this.geometry.attributes.color.array;
      color.set(xAxisColor);
      color.toArray(array, 0);
      color.toArray(array, 3);
      color.set(yAxisColor);
      color.toArray(array, 6);
      color.toArray(array, 9);
      color.set(zAxisColor);
      color.toArray(array, 12);
      color.toArray(array, 15);
      this.geometry.attributes.color.needsUpdate = true;
      return this;
    }
    dispose() {
      this.geometry.dispose();
      this.material.dispose();
    }
  };
  var _floatView = new Float32Array(1);
  var _int32View = new Int32Array(_floatView.buffer);
  Curve.create = function(construct, getPoint) {
    console.log("THREE.Curve.create() has been deprecated");
    construct.prototype = Object.create(Curve.prototype);
    construct.prototype.constructor = construct;
    construct.prototype.getPoint = getPoint;
    return construct;
  };
  Path.prototype.fromPoints = function(points) {
    console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
    return this.setFromPoints(points);
  };
  GridHelper.prototype.setColors = function() {
    console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
  };
  SkeletonHelper.prototype.update = function() {
    console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
  };
  Loader.prototype.extractUrlBase = function(url) {
    console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
    return LoaderUtils.extractUrlBase(url);
  };
  Loader.Handlers = {
    add: function() {
      console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
    },
    get: function() {
      console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
    }
  };
  Box2.prototype.center = function(optionalTarget) {
    console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
    return this.getCenter(optionalTarget);
  };
  Box2.prototype.empty = function() {
    console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
    return this.isEmpty();
  };
  Box2.prototype.isIntersectionBox = function(box) {
    console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
    return this.intersectsBox(box);
  };
  Box2.prototype.size = function(optionalTarget) {
    console.warn("THREE.Box2: .size() has been renamed to .getSize().");
    return this.getSize(optionalTarget);
  };
  Box3.prototype.center = function(optionalTarget) {
    console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
    return this.getCenter(optionalTarget);
  };
  Box3.prototype.empty = function() {
    console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
    return this.isEmpty();
  };
  Box3.prototype.isIntersectionBox = function(box) {
    console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
    return this.intersectsBox(box);
  };
  Box3.prototype.isIntersectionSphere = function(sphere) {
    console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
    return this.intersectsSphere(sphere);
  };
  Box3.prototype.size = function(optionalTarget) {
    console.warn("THREE.Box3: .size() has been renamed to .getSize().");
    return this.getSize(optionalTarget);
  };
  Sphere.prototype.empty = function() {
    console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty().");
    return this.isEmpty();
  };
  Frustum.prototype.setFromMatrix = function(m2) {
    console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().");
    return this.setFromProjectionMatrix(m2);
  };
  Line3.prototype.center = function(optionalTarget) {
    console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
    return this.getCenter(optionalTarget);
  };
  Matrix3.prototype.flattenToArrayOffset = function(array, offset) {
    console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
    return this.toArray(array, offset);
  };
  Matrix3.prototype.multiplyVector3 = function(vector) {
    console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
    return vector.applyMatrix3(this);
  };
  Matrix3.prototype.multiplyVector3Array = function() {
    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
  };
  Matrix3.prototype.applyToBufferAttribute = function(attribute) {
    console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.");
    return attribute.applyMatrix3(this);
  };
  Matrix3.prototype.applyToVector3Array = function() {
    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
  };
  Matrix3.prototype.getInverse = function(matrix) {
    console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
    return this.copy(matrix).invert();
  };
  Matrix4.prototype.extractPosition = function(m2) {
    console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
    return this.copyPosition(m2);
  };
  Matrix4.prototype.flattenToArrayOffset = function(array, offset) {
    console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
    return this.toArray(array, offset);
  };
  Matrix4.prototype.getPosition = function() {
    console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
    return new Vector3().setFromMatrixColumn(this, 3);
  };
  Matrix4.prototype.setRotationFromQuaternion = function(q2) {
    console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
    return this.makeRotationFromQuaternion(q2);
  };
  Matrix4.prototype.multiplyToArray = function() {
    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
  };
  Matrix4.prototype.multiplyVector3 = function(vector) {
    console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
    return vector.applyMatrix4(this);
  };
  Matrix4.prototype.multiplyVector4 = function(vector) {
    console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
    return vector.applyMatrix4(this);
  };
  Matrix4.prototype.multiplyVector3Array = function() {
    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
  };
  Matrix4.prototype.rotateAxis = function(v2) {
    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
    v2.transformDirection(this);
  };
  Matrix4.prototype.crossVector = function(vector) {
    console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
    return vector.applyMatrix4(this);
  };
  Matrix4.prototype.translate = function() {
    console.error("THREE.Matrix4: .translate() has been removed.");
  };
  Matrix4.prototype.rotateX = function() {
    console.error("THREE.Matrix4: .rotateX() has been removed.");
  };
  Matrix4.prototype.rotateY = function() {
    console.error("THREE.Matrix4: .rotateY() has been removed.");
  };
  Matrix4.prototype.rotateZ = function() {
    console.error("THREE.Matrix4: .rotateZ() has been removed.");
  };
  Matrix4.prototype.rotateByAxis = function() {
    console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
  };
  Matrix4.prototype.applyToBufferAttribute = function(attribute) {
    console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.");
    return attribute.applyMatrix4(this);
  };
  Matrix4.prototype.applyToVector3Array = function() {
    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
  };
  Matrix4.prototype.makeFrustum = function(left, right, bottom, top, near, far) {
    console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
    return this.makePerspective(left, right, top, bottom, near, far);
  };
  Matrix4.prototype.getInverse = function(matrix) {
    console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
    return this.copy(matrix).invert();
  };
  Plane.prototype.isIntersectionLine = function(line) {
    console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
    return this.intersectsLine(line);
  };
  Quaternion.prototype.multiplyVector3 = function(vector) {
    console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
    return vector.applyQuaternion(this);
  };
  Quaternion.prototype.inverse = function() {
    console.warn("THREE.Quaternion: .inverse() has been renamed to invert().");
    return this.invert();
  };
  Ray.prototype.isIntersectionBox = function(box) {
    console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
    return this.intersectsBox(box);
  };
  Ray.prototype.isIntersectionPlane = function(plane) {
    console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
    return this.intersectsPlane(plane);
  };
  Ray.prototype.isIntersectionSphere = function(sphere) {
    console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
    return this.intersectsSphere(sphere);
  };
  Triangle.prototype.area = function() {
    console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
    return this.getArea();
  };
  Triangle.prototype.barycoordFromPoint = function(point, target) {
    console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
    return this.getBarycoord(point, target);
  };
  Triangle.prototype.midpoint = function(target) {
    console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
    return this.getMidpoint(target);
  };
  Triangle.prototypenormal = function(target) {
    console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
    return this.getNormal(target);
  };
  Triangle.prototype.plane = function(target) {
    console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
    return this.getPlane(target);
  };
  Triangle.barycoordFromPoint = function(point, a2, b2, c2, target) {
    console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
    return Triangle.getBarycoord(point, a2, b2, c2, target);
  };
  Triangle.normal = function(a2, b2, c2, target) {
    console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
    return Triangle.getNormal(a2, b2, c2, target);
  };
  Shape.prototype.extractAllPoints = function(divisions) {
    console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
    return this.extractPoints(divisions);
  };
  Shape.prototype.extrude = function(options) {
    console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
    return new ExtrudeGeometry(this, options);
  };
  Shape.prototype.makeGeometry = function(options) {
    console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
    return new ShapeGeometry(this, options);
  };
  Vector2.prototype.fromAttribute = function(attribute, index, offset) {
    console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
    return this.fromBufferAttribute(attribute, index, offset);
  };
  Vector2.prototype.distanceToManhattan = function(v2) {
    console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
    return this.manhattanDistanceTo(v2);
  };
  Vector2.prototype.lengthManhattan = function() {
    console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
    return this.manhattanLength();
  };
  Vector3.prototype.setEulerFromRotationMatrix = function() {
    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
  };
  Vector3.prototype.setEulerFromQuaternion = function() {
    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
  };
  Vector3.prototype.getPositionFromMatrix = function(m2) {
    console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
    return this.setFromMatrixPosition(m2);
  };
  Vector3.prototype.getScaleFromMatrix = function(m2) {
    console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
    return this.setFromMatrixScale(m2);
  };
  Vector3.prototype.getColumnFromMatrix = function(index, matrix) {
    console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
    return this.setFromMatrixColumn(matrix, index);
  };
  Vector3.prototype.applyProjection = function(m2) {
    console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
    return this.applyMatrix4(m2);
  };
  Vector3.prototype.fromAttribute = function(attribute, index, offset) {
    console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
    return this.fromBufferAttribute(attribute, index, offset);
  };
  Vector3.prototype.distanceToManhattan = function(v2) {
    console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
    return this.manhattanDistanceTo(v2);
  };
  Vector3.prototype.lengthManhattan = function() {
    console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
    return this.manhattanLength();
  };
  Vector4.prototype.fromAttribute = function(attribute, index, offset) {
    console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
    return this.fromBufferAttribute(attribute, index, offset);
  };
  Vector4.prototype.lengthManhattan = function() {
    console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
    return this.manhattanLength();
  };
  Object3D.prototype.getChildByName = function(name) {
    console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
    return this.getObjectByName(name);
  };
  Object3D.prototype.renderDepth = function() {
    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
  };
  Object3D.prototype.translate = function(distance, axis) {
    console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
    return this.translateOnAxis(axis, distance);
  };
  Object3D.prototype.getWorldRotation = function() {
    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
  };
  Object3D.prototype.applyMatrix = function(matrix) {
    console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().");
    return this.applyMatrix4(matrix);
  };
  Object.defineProperties(Object3D.prototype, {
    eulerOrder: {
      get: function() {
        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
        return this.rotation.order;
      },
      set: function(value) {
        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
        this.rotation.order = value;
      }
    },
    useQuaternion: {
      get: function() {
        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
      },
      set: function() {
        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
      }
    }
  });
  Mesh.prototype.setDrawMode = function() {
    console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
  };
  Object.defineProperties(Mesh.prototype, {
    drawMode: {
      get: function() {
        console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.");
        return TrianglesDrawMode;
      },
      set: function() {
        console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
      }
    }
  });
  SkinnedMesh.prototype.initBones = function() {
    console.error("THREE.SkinnedMesh: initBones() has been removed.");
  };
  PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
    if (filmGauge !== void 0)
      this.filmGauge = filmGauge;
    this.setFocalLength(focalLength);
  };
  Object.defineProperties(Light.prototype, {
    onlyShadow: {
      set: function() {
        console.warn("THREE.Light: .onlyShadow has been removed.");
      }
    },
    shadowCameraFov: {
      set: function(value) {
        console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
        this.shadow.camera.fov = value;
      }
    },
    shadowCameraLeft: {
      set: function(value) {
        console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
        this.shadow.camera.left = value;
      }
    },
    shadowCameraRight: {
      set: function(value) {
        console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
        this.shadow.camera.right = value;
      }
    },
    shadowCameraTop: {
      set: function(value) {
        console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
        this.shadow.camera.top = value;
      }
    },
    shadowCameraBottom: {
      set: function(value) {
        console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
        this.shadow.camera.bottom = value;
      }
    },
    shadowCameraNear: {
      set: function(value) {
        console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
        this.shadow.camera.near = value;
      }
    },
    shadowCameraFar: {
      set: function(value) {
        console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
        this.shadow.camera.far = value;
      }
    },
    shadowCameraVisible: {
      set: function() {
        console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
      }
    },
    shadowBias: {
      set: function(value) {
        console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
        this.shadow.bias = value;
      }
    },
    shadowDarkness: {
      set: function() {
        console.warn("THREE.Light: .shadowDarkness has been removed.");
      }
    },
    shadowMapWidth: {
      set: function(value) {
        console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
        this.shadow.mapSize.width = value;
      }
    },
    shadowMapHeight: {
      set: function(value) {
        console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
        this.shadow.mapSize.height = value;
      }
    }
  });
  Object.defineProperties(BufferAttribute.prototype, {
    length: {
      get: function() {
        console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
        return this.array.length;
      }
    },
    dynamic: {
      get: function() {
        console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
        return this.usage === DynamicDrawUsage;
      },
      set: function() {
        console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
        this.setUsage(DynamicDrawUsage);
      }
    }
  });
  BufferAttribute.prototype.setDynamic = function(value) {
    console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.");
    this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
    return this;
  };
  BufferAttribute.prototype.copyIndicesArray = function() {
    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
  }, BufferAttribute.prototype.setArray = function() {
    console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
  };
  BufferGeometry.prototype.addIndex = function(index) {
    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
    this.setIndex(index);
  };
  BufferGeometry.prototype.addAttribute = function(name, attribute) {
    console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().");
    if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
      console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
      return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
    }
    if (name === "index") {
      console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
      this.setIndex(attribute);
      return this;
    }
    return this.setAttribute(name, attribute);
  };
  BufferGeometry.prototype.addDrawCall = function(start, count, indexOffset) {
    if (indexOffset !== void 0) {
      console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
    }
    console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
    this.addGroup(start, count);
  };
  BufferGeometry.prototype.clearDrawCalls = function() {
    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
    this.clearGroups();
  };
  BufferGeometry.prototype.computeOffsets = function() {
    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
  };
  BufferGeometry.prototype.removeAttribute = function(name) {
    console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().");
    return this.deleteAttribute(name);
  };
  BufferGeometry.prototype.applyMatrix = function(matrix) {
    console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().");
    return this.applyMatrix4(matrix);
  };
  Object.defineProperties(BufferGeometry.prototype, {
    drawcalls: {
      get: function() {
        console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
        return this.groups;
      }
    },
    offsets: {
      get: function() {
        console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
        return this.groups;
      }
    }
  });
  InterleavedBuffer.prototype.setDynamic = function(value) {
    console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.");
    this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
    return this;
  };
  InterleavedBuffer.prototype.setArray = function() {
    console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
  };
  ExtrudeGeometry.prototype.getArrays = function() {
    console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
  };
  ExtrudeGeometry.prototype.addShapeList = function() {
    console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
  };
  ExtrudeGeometry.prototype.addShape = function() {
    console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
  };
  Scene.prototype.dispose = function() {
    console.error("THREE.Scene: .dispose() has been removed.");
  };
  Uniform.prototype.onUpdate = function() {
    console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
    return this;
  };
  Object.defineProperties(Material.prototype, {
    wrapAround: {
      get: function() {
        console.warn("THREE.Material: .wrapAround has been removed.");
      },
      set: function() {
        console.warn("THREE.Material: .wrapAround has been removed.");
      }
    },
    overdraw: {
      get: function() {
        console.warn("THREE.Material: .overdraw has been removed.");
      },
      set: function() {
        console.warn("THREE.Material: .overdraw has been removed.");
      }
    },
    wrapRGB: {
      get: function() {
        console.warn("THREE.Material: .wrapRGB has been removed.");
        return new Color();
      }
    },
    shading: {
      get: function() {
        console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
      },
      set: function(value) {
        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
        this.flatShading = value === FlatShading;
      }
    },
    stencilMask: {
      get: function() {
        console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
        return this.stencilFuncMask;
      },
      set: function(value) {
        console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
        this.stencilFuncMask = value;
      }
    },
    vertexTangents: {
      get: function() {
        console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
      },
      set: function() {
        console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
      }
    }
  });
  Object.defineProperties(ShaderMaterial.prototype, {
    derivatives: {
      get: function() {
        console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
        return this.extensions.derivatives;
      },
      set: function(value) {
        console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
        this.extensions.derivatives = value;
      }
    }
  });
  WebGLRenderer.prototype.clearTarget = function(renderTarget, color, depth, stencil) {
    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
    this.setRenderTarget(renderTarget);
    this.clear(color, depth, stencil);
  };
  WebGLRenderer.prototype.animate = function(callback) {
    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
    this.setAnimationLoop(callback);
  };
  WebGLRenderer.prototype.getCurrentRenderTarget = function() {
    console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
    return this.getRenderTarget();
  };
  WebGLRenderer.prototype.getMaxAnisotropy = function() {
    console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
    return this.capabilities.getMaxAnisotropy();
  };
  WebGLRenderer.prototype.getPrecision = function() {
    console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
    return this.capabilities.precision;
  };
  WebGLRenderer.prototype.resetGLState = function() {
    console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
    return this.state.reset();
  };
  WebGLRenderer.prototype.supportsFloatTextures = function() {
    console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
    return this.extensions.get("OES_texture_float");
  };
  WebGLRenderer.prototype.supportsHalfFloatTextures = function() {
    console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
    return this.extensions.get("OES_texture_half_float");
  };
  WebGLRenderer.prototype.supportsStandardDerivatives = function() {
    console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
    return this.extensions.get("OES_standard_derivatives");
  };
  WebGLRenderer.prototype.supportsCompressedTextureS3TC = function() {
    console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
    return this.extensions.get("WEBGL_compressed_texture_s3tc");
  };
  WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function() {
    console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
    return this.extensions.get("WEBGL_compressed_texture_pvrtc");
  };
  WebGLRenderer.prototype.supportsBlendMinMax = function() {
    console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
    return this.extensions.get("EXT_blend_minmax");
  };
  WebGLRenderer.prototype.supportsVertexTextures = function() {
    console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
    return this.capabilities.vertexTextures;
  };
  WebGLRenderer.prototype.supportsInstancedArrays = function() {
    console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
    return this.extensions.get("ANGLE_instanced_arrays");
  };
  WebGLRenderer.prototype.enableScissorTest = function(boolean) {
    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
    this.setScissorTest(boolean);
  };
  WebGLRenderer.prototype.initMaterial = function() {
    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
  };
  WebGLRenderer.prototype.addPrePlugin = function() {
    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
  };
  WebGLRenderer.prototype.addPostPlugin = function() {
    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
  };
  WebGLRenderer.prototype.updateShadowMap = function() {
    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
  };
  WebGLRenderer.prototype.setFaceCulling = function() {
    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
  };
  WebGLRenderer.prototype.allocTextureUnit = function() {
    console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
  };
  WebGLRenderer.prototype.setTexture = function() {
    console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
  };
  WebGLRenderer.prototype.setTexture2D = function() {
    console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
  };
  WebGLRenderer.prototype.setTextureCube = function() {
    console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
  };
  WebGLRenderer.prototype.getActiveMipMapLevel = function() {
    console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().");
    return this.getActiveMipmapLevel();
  };
  Object.defineProperties(WebGLRenderer.prototype, {
    shadowMapEnabled: {
      get: function() {
        return this.shadowMap.enabled;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
        this.shadowMap.enabled = value;
      }
    },
    shadowMapType: {
      get: function() {
        return this.shadowMap.type;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
        this.shadowMap.type = value;
      }
    },
    shadowMapCullFace: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
        return void 0;
      },
      set: function() {
        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
      }
    },
    context: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.");
        return this.getContext();
      }
    },
    vr: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr");
        return this.xr;
      }
    },
    gammaInput: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
        return false;
      },
      set: function() {
        console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
      }
    },
    gammaOutput: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
        return false;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
        this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
      }
    },
    toneMappingWhitePoint: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
        return 1;
      },
      set: function() {
        console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
      }
    }
  });
  Object.defineProperties(WebGLShadowMap.prototype, {
    cullFace: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
        return void 0;
      },
      set: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
      }
    },
    renderReverseSided: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
        return void 0;
      },
      set: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
      }
    },
    renderSingleSided: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
        return void 0;
      },
      set: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
      }
    }
  });
  Object.defineProperties(WebGLRenderTarget.prototype, {
    wrapS: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
        return this.texture.wrapS;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
        this.texture.wrapS = value;
      }
    },
    wrapT: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
        return this.texture.wrapT;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
        this.texture.wrapT = value;
      }
    },
    magFilter: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
        return this.texture.magFilter;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
        this.texture.magFilter = value;
      }
    },
    minFilter: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
        return this.texture.minFilter;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
        this.texture.minFilter = value;
      }
    },
    anisotropy: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
        return this.texture.anisotropy;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
        this.texture.anisotropy = value;
      }
    },
    offset: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
        return this.texture.offset;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
        this.texture.offset = value;
      }
    },
    repeat: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
        return this.texture.repeat;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
        this.texture.repeat = value;
      }
    },
    format: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
        return this.texture.format;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
        this.texture.format = value;
      }
    },
    type: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
        return this.texture.type;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
        this.texture.type = value;
      }
    },
    generateMipmaps: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
        return this.texture.generateMipmaps;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
        this.texture.generateMipmaps = value;
      }
    }
  });
  Audio.prototype.load = function(file) {
    console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
    const scope = this;
    const audioLoader = new AudioLoader();
    audioLoader.load(file, function(buffer) {
      scope.setBuffer(buffer);
    });
    return this;
  };
  AudioAnalyser.prototype.getData = function() {
    console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
    return this.getFrequencyData();
  };
  CubeCamera.prototype.updateCubeMap = function(renderer2, scene2) {
    console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
    return this.update(renderer2, scene2);
  };
  CubeCamera.prototype.clear = function(renderer2, color, depth, stencil) {
    console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear().");
    return this.renderTarget.clear(renderer2, color, depth, stencil);
  };
  ImageUtils.crossOrigin = void 0;
  ImageUtils.loadTexture = function(url, mapping, onLoad, onError) {
    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
    const loader2 = new TextureLoader();
    loader2.setCrossOrigin(this.crossOrigin);
    const texture = loader2.load(url, onLoad, void 0, onError);
    if (mapping)
      texture.mapping = mapping;
    return texture;
  };
  ImageUtils.loadTextureCube = function(urls, mapping, onLoad, onError) {
    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
    const loader2 = new CubeTextureLoader();
    loader2.setCrossOrigin(this.crossOrigin);
    const texture = loader2.load(urls, onLoad, void 0, onError);
    if (mapping)
      texture.mapping = mapping;
    return texture;
  };
  ImageUtils.loadCompressedTexture = function() {
    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
  };
  ImageUtils.loadCompressedTextureCube = function() {
    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
  };
  if (typeof __THREE_DEVTOOLS__ !== "undefined") {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
      revision: REVISION
    } }));
  }
  if (typeof window !== "undefined") {
    if (window.__THREE__) {
      console.warn("WARNING: Multiple instances of Three.js being imported.");
    } else {
      window.__THREE__ = REVISION;
    }
  }

  // node_modules/three/examples/jsm/loaders/GLTFLoader.js
  var GLTFLoader = class extends Loader {
    constructor(manager) {
      super(manager);
      this.dracoLoader = null;
      this.ktx2Loader = null;
      this.meshoptDecoder = null;
      this.pluginCallbacks = [];
      this.register(function(parser) {
        return new GLTFMaterialsClearcoatExtension(parser);
      });
      this.register(function(parser) {
        return new GLTFTextureBasisUExtension(parser);
      });
      this.register(function(parser) {
        return new GLTFTextureWebPExtension(parser);
      });
      this.register(function(parser) {
        return new GLTFMaterialsTransmissionExtension(parser);
      });
      this.register(function(parser) {
        return new GLTFMaterialsVolumeExtension(parser);
      });
      this.register(function(parser) {
        return new GLTFMaterialsIorExtension(parser);
      });
      this.register(function(parser) {
        return new GLTFMaterialsSpecularExtension(parser);
      });
      this.register(function(parser) {
        return new GLTFLightsExtension(parser);
      });
      this.register(function(parser) {
        return new GLTFMeshoptCompression(parser);
      });
    }
    load(url, onLoad, onProgress, onError) {
      const scope = this;
      let resourcePath;
      if (this.resourcePath !== "") {
        resourcePath = this.resourcePath;
      } else if (this.path !== "") {
        resourcePath = this.path;
      } else {
        resourcePath = LoaderUtils.extractUrlBase(url);
      }
      this.manager.itemStart(url);
      const _onError = function(e2) {
        if (onError) {
          onError(e2);
        } else {
          console.error(e2);
        }
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      };
      const loader2 = new FileLoader(this.manager);
      loader2.setPath(this.path);
      loader2.setResponseType("arraybuffer");
      loader2.setRequestHeader(this.requestHeader);
      loader2.setWithCredentials(this.withCredentials);
      loader2.load(url, function(data) {
        try {
          scope.parse(data, resourcePath, function(gltf) {
            onLoad(gltf);
            scope.manager.itemEnd(url);
          }, _onError);
        } catch (e2) {
          _onError(e2);
        }
      }, onProgress, _onError);
    }
    setDRACOLoader(dracoLoader) {
      this.dracoLoader = dracoLoader;
      return this;
    }
    setDDSLoader() {
      throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".');
    }
    setKTX2Loader(ktx2Loader) {
      this.ktx2Loader = ktx2Loader;
      return this;
    }
    setMeshoptDecoder(meshoptDecoder) {
      this.meshoptDecoder = meshoptDecoder;
      return this;
    }
    register(callback) {
      if (this.pluginCallbacks.indexOf(callback) === -1) {
        this.pluginCallbacks.push(callback);
      }
      return this;
    }
    unregister(callback) {
      if (this.pluginCallbacks.indexOf(callback) !== -1) {
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
      }
      return this;
    }
    parse(data, path, onLoad, onError) {
      let content;
      const extensions = {};
      const plugins = {};
      if (typeof data === "string") {
        content = data;
      } else {
        const magic = LoaderUtils.decodeText(new Uint8Array(data, 0, 4));
        if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
          try {
            extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
          } catch (error) {
            if (onError)
              onError(error);
            return;
          }
          content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;
        } else {
          content = LoaderUtils.decodeText(new Uint8Array(data));
        }
      }
      const json = JSON.parse(content);
      if (json.asset === void 0 || json.asset.version[0] < 2) {
        if (onError)
          onError(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
        return;
      }
      const parser = new GLTFParser(json, {
        path: path || this.resourcePath || "",
        crossOrigin: this.crossOrigin,
        requestHeader: this.requestHeader,
        manager: this.manager,
        ktx2Loader: this.ktx2Loader,
        meshoptDecoder: this.meshoptDecoder
      });
      parser.fileLoader.setRequestHeader(this.requestHeader);
      for (let i2 = 0; i2 < this.pluginCallbacks.length; i2++) {
        const plugin = this.pluginCallbacks[i2](parser);
        plugins[plugin.name] = plugin;
        extensions[plugin.name] = true;
      }
      if (json.extensionsUsed) {
        for (let i2 = 0; i2 < json.extensionsUsed.length; ++i2) {
          const extensionName = json.extensionsUsed[i2];
          const extensionsRequired = json.extensionsRequired || [];
          switch (extensionName) {
            case EXTENSIONS.KHR_MATERIALS_UNLIT:
              extensions[extensionName] = new GLTFMaterialsUnlitExtension();
              break;
            case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
              extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();
              break;
            case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
              extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
              break;
            case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
              extensions[extensionName] = new GLTFTextureTransformExtension();
              break;
            case EXTENSIONS.KHR_MESH_QUANTIZATION:
              extensions[extensionName] = new GLTFMeshQuantizationExtension();
              break;
            default:
              if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {
                console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
              }
          }
        }
      }
      parser.setExtensions(extensions);
      parser.setPlugins(plugins);
      parser.parse(onLoad, onError);
    }
  };
  function GLTFRegistry() {
    let objects = {};
    return {
      get: function(key) {
        return objects[key];
      },
      add: function(key, object) {
        objects[key] = object;
      },
      remove: function(key) {
        delete objects[key];
      },
      removeAll: function() {
        objects = {};
      }
    };
  }
  var EXTENSIONS = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
  };
  var GLTFLightsExtension = class {
    constructor(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;
      this.cache = { refs: {}, uses: {} };
    }
    _markDefs() {
      const parser = this.parser;
      const nodeDefs = this.parser.json.nodes || [];
      for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
        const nodeDef = nodeDefs[nodeIndex];
        if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {
          parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);
        }
      }
    }
    _loadLight(lightIndex) {
      const parser = this.parser;
      const cacheKey = "light:" + lightIndex;
      let dependency = parser.cache.get(cacheKey);
      if (dependency)
        return dependency;
      const json = parser.json;
      const extensions = json.extensions && json.extensions[this.name] || {};
      const lightDefs = extensions.lights || [];
      const lightDef = lightDefs[lightIndex];
      let lightNode;
      const color = new Color(16777215);
      if (lightDef.color !== void 0)
        color.fromArray(lightDef.color);
      const range = lightDef.range !== void 0 ? lightDef.range : 0;
      switch (lightDef.type) {
        case "directional":
          lightNode = new DirectionalLight(color);
          lightNode.target.position.set(0, 0, -1);
          lightNode.add(lightNode.target);
          break;
        case "point":
          lightNode = new PointLight(color);
          lightNode.distance = range;
          break;
        case "spot":
          lightNode = new SpotLight(color);
          lightNode.distance = range;
          lightDef.spot = lightDef.spot || {};
          lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;
          lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;
          lightNode.angle = lightDef.spot.outerConeAngle;
          lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
          lightNode.target.position.set(0, 0, -1);
          lightNode.add(lightNode.target);
          break;
        default:
          throw new Error("THREE.GLTFLoader: Unexpected light type: " + lightDef.type);
      }
      lightNode.position.set(0, 0, 0);
      lightNode.decay = 2;
      if (lightDef.intensity !== void 0)
        lightNode.intensity = lightDef.intensity;
      lightNode.name = parser.createUniqueName(lightDef.name || "light_" + lightIndex);
      dependency = Promise.resolve(lightNode);
      parser.cache.add(cacheKey, dependency);
      return dependency;
    }
    createNodeAttachment(nodeIndex) {
      const self2 = this;
      const parser = this.parser;
      const json = parser.json;
      const nodeDef = json.nodes[nodeIndex];
      const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};
      const lightIndex = lightDef.light;
      if (lightIndex === void 0)
        return null;
      return this._loadLight(lightIndex).then(function(light2) {
        return parser._getNodeRef(self2.cache, lightIndex, light2);
      });
    }
  };
  var GLTFMaterialsUnlitExtension = class {
    constructor() {
      this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
    }
    getMaterialType() {
      return MeshBasicMaterial;
    }
    extendParams(materialParams, materialDef, parser) {
      const pending = [];
      materialParams.color = new Color(1, 1, 1);
      materialParams.opacity = 1;
      const metallicRoughness = materialDef.pbrMetallicRoughness;
      if (metallicRoughness) {
        if (Array.isArray(metallicRoughness.baseColorFactor)) {
          const array = metallicRoughness.baseColorFactor;
          materialParams.color.fromArray(array);
          materialParams.opacity = array[3];
        }
        if (metallicRoughness.baseColorTexture !== void 0) {
          pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture));
        }
      }
      return Promise.all(pending);
    }
  };
  var GLTFMaterialsClearcoatExtension = class {
    constructor(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
    }
    getMaterialType(materialIndex) {
      const parser = this.parser;
      const materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name])
        return null;
      return MeshPhysicalMaterial;
    }
    extendMaterialParams(materialIndex, materialParams) {
      const parser = this.parser;
      const materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) {
        return Promise.resolve();
      }
      const pending = [];
      const extension = materialDef.extensions[this.name];
      if (extension.clearcoatFactor !== void 0) {
        materialParams.clearcoat = extension.clearcoatFactor;
      }
      if (extension.clearcoatTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "clearcoatMap", extension.clearcoatTexture));
      }
      if (extension.clearcoatRoughnessFactor !== void 0) {
        materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;
      }
      if (extension.clearcoatRoughnessTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "clearcoatRoughnessMap", extension.clearcoatRoughnessTexture));
      }
      if (extension.clearcoatNormalTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "clearcoatNormalMap", extension.clearcoatNormalTexture));
        if (extension.clearcoatNormalTexture.scale !== void 0) {
          const scale = extension.clearcoatNormalTexture.scale;
          materialParams.clearcoatNormalScale = new Vector2(scale, scale);
        }
      }
      return Promise.all(pending);
    }
  };
  var GLTFMaterialsTransmissionExtension = class {
    constructor(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
    }
    getMaterialType(materialIndex) {
      const parser = this.parser;
      const materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name])
        return null;
      return MeshPhysicalMaterial;
    }
    extendMaterialParams(materialIndex, materialParams) {
      const parser = this.parser;
      const materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) {
        return Promise.resolve();
      }
      const pending = [];
      const extension = materialDef.extensions[this.name];
      if (extension.transmissionFactor !== void 0) {
        materialParams.transmission = extension.transmissionFactor;
      }
      if (extension.transmissionTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "transmissionMap", extension.transmissionTexture));
      }
      return Promise.all(pending);
    }
  };
  var GLTFMaterialsVolumeExtension = class {
    constructor(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;
    }
    getMaterialType(materialIndex) {
      const parser = this.parser;
      const materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name])
        return null;
      return MeshPhysicalMaterial;
    }
    extendMaterialParams(materialIndex, materialParams) {
      const parser = this.parser;
      const materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) {
        return Promise.resolve();
      }
      const pending = [];
      const extension = materialDef.extensions[this.name];
      materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;
      if (extension.thicknessTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "thicknessMap", extension.thicknessTexture));
      }
      materialParams.attenuationDistance = extension.attenuationDistance || 0;
      const colorArray = extension.attenuationColor || [1, 1, 1];
      materialParams.attenuationTint = new Color(colorArray[0], colorArray[1], colorArray[2]);
      return Promise.all(pending);
    }
  };
  var GLTFMaterialsIorExtension = class {
    constructor(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.KHR_MATERIALS_IOR;
    }
    getMaterialType(materialIndex) {
      const parser = this.parser;
      const materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name])
        return null;
      return MeshPhysicalMaterial;
    }
    extendMaterialParams(materialIndex, materialParams) {
      const parser = this.parser;
      const materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) {
        return Promise.resolve();
      }
      const extension = materialDef.extensions[this.name];
      materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;
      return Promise.resolve();
    }
  };
  var GLTFMaterialsSpecularExtension = class {
    constructor(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;
    }
    getMaterialType(materialIndex) {
      const parser = this.parser;
      const materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name])
        return null;
      return MeshPhysicalMaterial;
    }
    extendMaterialParams(materialIndex, materialParams) {
      const parser = this.parser;
      const materialDef = parser.json.materials[materialIndex];
      if (!materialDef.extensions || !materialDef.extensions[this.name]) {
        return Promise.resolve();
      }
      const pending = [];
      const extension = materialDef.extensions[this.name];
      materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;
      if (extension.specularTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "specularIntensityMap", extension.specularTexture));
      }
      const colorArray = extension.specularColorFactor || [1, 1, 1];
      materialParams.specularTint = new Color(colorArray[0], colorArray[1], colorArray[2]);
      if (extension.specularColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "specularTintMap", extension.specularColorTexture).then(function(texture) {
          texture.encoding = sRGBEncoding;
        }));
      }
      return Promise.all(pending);
    }
  };
  var GLTFTextureBasisUExtension = class {
    constructor(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
    }
    loadTexture(textureIndex) {
      const parser = this.parser;
      const json = parser.json;
      const textureDef = json.textures[textureIndex];
      if (!textureDef.extensions || !textureDef.extensions[this.name]) {
        return null;
      }
      const extension = textureDef.extensions[this.name];
      const source = json.images[extension.source];
      const loader2 = parser.options.ktx2Loader;
      if (!loader2) {
        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
          throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
        } else {
          return null;
        }
      }
      return parser.loadTextureImage(textureIndex, source, loader2);
    }
  };
  var GLTFTextureWebPExtension = class {
    constructor(parser) {
      this.parser = parser;
      this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
      this.isSupported = null;
    }
    loadTexture(textureIndex) {
      const name = this.name;
      const parser = this.parser;
      const json = parser.json;
      const textureDef = json.textures[textureIndex];
      if (!textureDef.extensions || !textureDef.extensions[name]) {
        return null;
      }
      const extension = textureDef.extensions[name];
      const source = json.images[extension.source];
      let loader2 = parser.textureLoader;
      if (source.uri) {
        const handler = parser.options.manager.getHandler(source.uri);
        if (handler !== null)
          loader2 = handler;
      }
      return this.detectSupport().then(function(isSupported) {
        if (isSupported)
          return parser.loadTextureImage(textureIndex, source, loader2);
        if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
          throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
        }
        return parser.loadTexture(textureIndex);
      });
    }
    detectSupport() {
      if (!this.isSupported) {
        this.isSupported = new Promise(function(resolve) {
          const image = new Image();
          image.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA";
          image.onload = image.onerror = function() {
            resolve(image.height === 1);
          };
        });
      }
      return this.isSupported;
    }
  };
  var GLTFMeshoptCompression = class {
    constructor(parser) {
      this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
      this.parser = parser;
    }
    loadBufferView(index) {
      const json = this.parser.json;
      const bufferView = json.bufferViews[index];
      if (bufferView.extensions && bufferView.extensions[this.name]) {
        const extensionDef = bufferView.extensions[this.name];
        const buffer = this.parser.getDependency("buffer", extensionDef.buffer);
        const decoder = this.parser.options.meshoptDecoder;
        if (!decoder || !decoder.supported) {
          if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
            throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
          } else {
            return null;
          }
        }
        return Promise.all([buffer, decoder.ready]).then(function(res) {
          const byteOffset = extensionDef.byteOffset || 0;
          const byteLength = extensionDef.byteLength || 0;
          const count = extensionDef.count;
          const stride = extensionDef.byteStride;
          const result = new ArrayBuffer(count * stride);
          const source = new Uint8Array(res[0], byteOffset, byteLength);
          decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);
          return result;
        });
      } else {
        return null;
      }
    }
  };
  var BINARY_EXTENSION_HEADER_MAGIC = "glTF";
  var BINARY_EXTENSION_HEADER_LENGTH = 12;
  var BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };
  var GLTFBinaryExtension = class {
    constructor(data) {
      this.name = EXTENSIONS.KHR_BINARY_GLTF;
      this.content = null;
      this.body = null;
      const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
      this.header = {
        magic: LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),
        version: headerView.getUint32(4, true),
        length: headerView.getUint32(8, true)
      };
      if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
        throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
      } else if (this.header.version < 2) {
        throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
      }
      const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
      const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
      let chunkIndex = 0;
      while (chunkIndex < chunkContentsLength) {
        const chunkLength = chunkView.getUint32(chunkIndex, true);
        chunkIndex += 4;
        const chunkType = chunkView.getUint32(chunkIndex, true);
        chunkIndex += 4;
        if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
          const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
          this.content = LoaderUtils.decodeText(contentArray);
        } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
          const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
          this.body = data.slice(byteOffset, byteOffset + chunkLength);
        }
        chunkIndex += chunkLength;
      }
      if (this.content === null) {
        throw new Error("THREE.GLTFLoader: JSON content not found.");
      }
    }
  };
  var GLTFDracoMeshCompressionExtension = class {
    constructor(json, dracoLoader) {
      if (!dracoLoader) {
        throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
      }
      this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
      this.json = json;
      this.dracoLoader = dracoLoader;
      this.dracoLoader.preload();
    }
    decodePrimitive(primitive, parser) {
      const json = this.json;
      const dracoLoader = this.dracoLoader;
      const bufferViewIndex = primitive.extensions[this.name].bufferView;
      const gltfAttributeMap = primitive.extensions[this.name].attributes;
      const threeAttributeMap = {};
      const attributeNormalizedMap = {};
      const attributeTypeMap = {};
      for (const attributeName in gltfAttributeMap) {
        const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
        threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
      }
      for (const attributeName in primitive.attributes) {
        const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
        if (gltfAttributeMap[attributeName] !== void 0) {
          const accessorDef = json.accessors[primitive.attributes[attributeName]];
          const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
          attributeTypeMap[threeAttributeName] = componentType;
          attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;
        }
      }
      return parser.getDependency("bufferView", bufferViewIndex).then(function(bufferView) {
        return new Promise(function(resolve) {
          dracoLoader.decodeDracoFile(bufferView, function(geometry) {
            for (const attributeName in geometry.attributes) {
              const attribute = geometry.attributes[attributeName];
              const normalized = attributeNormalizedMap[attributeName];
              if (normalized !== void 0)
                attribute.normalized = normalized;
            }
            resolve(geometry);
          }, threeAttributeMap, attributeTypeMap);
        });
      });
    }
  };
  var GLTFTextureTransformExtension = class {
    constructor() {
      this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
    }
    extendTexture(texture, transform) {
      if (transform.texCoord !== void 0) {
        console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.');
      }
      if (transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0) {
        return texture;
      }
      texture = texture.clone();
      if (transform.offset !== void 0) {
        texture.offset.fromArray(transform.offset);
      }
      if (transform.rotation !== void 0) {
        texture.rotation = transform.rotation;
      }
      if (transform.scale !== void 0) {
        texture.repeat.fromArray(transform.scale);
      }
      texture.needsUpdate = true;
      return texture;
    }
  };
  var GLTFMeshStandardSGMaterial = class extends MeshStandardMaterial {
    constructor(params) {
      super();
      this.isGLTFSpecularGlossinessMaterial = true;
      const specularMapParsFragmentChunk = [
        "#ifdef USE_SPECULARMAP",
        "	uniform sampler2D specularMap;",
        "#endif"
      ].join("\n");
      const glossinessMapParsFragmentChunk = [
        "#ifdef USE_GLOSSINESSMAP",
        "	uniform sampler2D glossinessMap;",
        "#endif"
      ].join("\n");
      const specularMapFragmentChunk = [
        "vec3 specularFactor = specular;",
        "#ifdef USE_SPECULARMAP",
        "	vec4 texelSpecular = texture2D( specularMap, vUv );",
        "	texelSpecular = sRGBToLinear( texelSpecular );",
        "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
        "	specularFactor *= texelSpecular.rgb;",
        "#endif"
      ].join("\n");
      const glossinessMapFragmentChunk = [
        "float glossinessFactor = glossiness;",
        "#ifdef USE_GLOSSINESSMAP",
        "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );",
        "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
        "	glossinessFactor *= texelGlossiness.a;",
        "#endif"
      ].join("\n");
      const lightPhysicalFragmentChunk = [
        "PhysicalMaterial material;",
        "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );",
        "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
        "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
        "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.",
        "material.roughness += geometryRoughness;",
        "material.roughness = min( material.roughness, 1.0 );",
        "material.specularColor = specularFactor;"
      ].join("\n");
      const uniforms = {
        specular: { value: new Color().setHex(16777215) },
        glossiness: { value: 1 },
        specularMap: { value: null },
        glossinessMap: { value: null }
      };
      this._extraUniforms = uniforms;
      this.onBeforeCompile = function(shader) {
        for (const uniformName in uniforms) {
          shader.uniforms[uniformName] = uniforms[uniformName];
        }
        shader.fragmentShader = shader.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", specularMapParsFragmentChunk).replace("#include <metalnessmap_pars_fragment>", glossinessMapParsFragmentChunk).replace("#include <roughnessmap_fragment>", specularMapFragmentChunk).replace("#include <metalnessmap_fragment>", glossinessMapFragmentChunk).replace("#include <lights_physical_fragment>", lightPhysicalFragmentChunk);
      };
      Object.defineProperties(this, {
        specular: {
          get: function() {
            return uniforms.specular.value;
          },
          set: function(v2) {
            uniforms.specular.value = v2;
          }
        },
        specularMap: {
          get: function() {
            return uniforms.specularMap.value;
          },
          set: function(v2) {
            uniforms.specularMap.value = v2;
            if (v2) {
              this.defines.USE_SPECULARMAP = "";
            } else {
              delete this.defines.USE_SPECULARMAP;
            }
          }
        },
        glossiness: {
          get: function() {
            return uniforms.glossiness.value;
          },
          set: function(v2) {
            uniforms.glossiness.value = v2;
          }
        },
        glossinessMap: {
          get: function() {
            return uniforms.glossinessMap.value;
          },
          set: function(v2) {
            uniforms.glossinessMap.value = v2;
            if (v2) {
              this.defines.USE_GLOSSINESSMAP = "";
              this.defines.USE_UV = "";
            } else {
              delete this.defines.USE_GLOSSINESSMAP;
              delete this.defines.USE_UV;
            }
          }
        }
      });
      delete this.metalness;
      delete this.roughness;
      delete this.metalnessMap;
      delete this.roughnessMap;
      this.setValues(params);
    }
    copy(source) {
      super.copy(source);
      this.specularMap = source.specularMap;
      this.specular.copy(source.specular);
      this.glossinessMap = source.glossinessMap;
      this.glossiness = source.glossiness;
      delete this.metalness;
      delete this.roughness;
      delete this.metalnessMap;
      delete this.roughnessMap;
      return this;
    }
  };
  var GLTFMaterialsPbrSpecularGlossinessExtension = class {
    constructor() {
      this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;
      this.specularGlossinessParams = [
        "color",
        "map",
        "lightMap",
        "lightMapIntensity",
        "aoMap",
        "aoMapIntensity",
        "emissive",
        "emissiveIntensity",
        "emissiveMap",
        "bumpMap",
        "bumpScale",
        "normalMap",
        "normalMapType",
        "displacementMap",
        "displacementScale",
        "displacementBias",
        "specularMap",
        "specular",
        "glossinessMap",
        "glossiness",
        "alphaMap",
        "envMap",
        "envMapIntensity",
        "refractionRatio"
      ];
    }
    getMaterialType() {
      return GLTFMeshStandardSGMaterial;
    }
    extendParams(materialParams, materialDef, parser) {
      const pbrSpecularGlossiness = materialDef.extensions[this.name];
      materialParams.color = new Color(1, 1, 1);
      materialParams.opacity = 1;
      const pending = [];
      if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {
        const array = pbrSpecularGlossiness.diffuseFactor;
        materialParams.color.fromArray(array);
        materialParams.opacity = array[3];
      }
      if (pbrSpecularGlossiness.diffuseTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", pbrSpecularGlossiness.diffuseTexture));
      }
      materialParams.emissive = new Color(0, 0, 0);
      materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== void 0 ? pbrSpecularGlossiness.glossinessFactor : 1;
      materialParams.specular = new Color(1, 1, 1);
      if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {
        materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);
      }
      if (pbrSpecularGlossiness.specularGlossinessTexture !== void 0) {
        const specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
        pending.push(parser.assignTexture(materialParams, "glossinessMap", specGlossMapDef));
        pending.push(parser.assignTexture(materialParams, "specularMap", specGlossMapDef));
      }
      return Promise.all(pending);
    }
    createMaterial(materialParams) {
      const material = new GLTFMeshStandardSGMaterial(materialParams);
      material.fog = true;
      material.color = materialParams.color;
      material.map = materialParams.map === void 0 ? null : materialParams.map;
      material.lightMap = null;
      material.lightMapIntensity = 1;
      material.aoMap = materialParams.aoMap === void 0 ? null : materialParams.aoMap;
      material.aoMapIntensity = 1;
      material.emissive = materialParams.emissive;
      material.emissiveIntensity = 1;
      material.emissiveMap = materialParams.emissiveMap === void 0 ? null : materialParams.emissiveMap;
      material.bumpMap = materialParams.bumpMap === void 0 ? null : materialParams.bumpMap;
      material.bumpScale = 1;
      material.normalMap = materialParams.normalMap === void 0 ? null : materialParams.normalMap;
      material.normalMapType = TangentSpaceNormalMap;
      if (materialParams.normalScale)
        material.normalScale = materialParams.normalScale;
      material.displacementMap = null;
      material.displacementScale = 1;
      material.displacementBias = 0;
      material.specularMap = materialParams.specularMap === void 0 ? null : materialParams.specularMap;
      material.specular = materialParams.specular;
      material.glossinessMap = materialParams.glossinessMap === void 0 ? null : materialParams.glossinessMap;
      material.glossiness = materialParams.glossiness;
      material.alphaMap = null;
      material.envMap = materialParams.envMap === void 0 ? null : materialParams.envMap;
      material.envMapIntensity = 1;
      material.refractionRatio = 0.98;
      return material;
    }
  };
  var GLTFMeshQuantizationExtension = class {
    constructor() {
      this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
    }
  };
  var GLTFCubicSplineInterpolant = class extends Interpolant {
    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    }
    copySampleValue_(index) {
      const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;
      for (let i2 = 0; i2 !== valueSize; i2++) {
        result[i2] = values[offset + i2];
      }
      return result;
    }
  };
  GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
  GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
  GLTFCubicSplineInterpolant.prototype.interpolate_ = function(i1, t0, t2, t1) {
    const result = this.resultBuffer;
    const values = this.sampleValues;
    const stride = this.valueSize;
    const stride2 = stride * 2;
    const stride3 = stride * 3;
    const td = t1 - t0;
    const p2 = (t2 - t0) / td;
    const pp = p2 * p2;
    const ppp = pp * p2;
    const offset1 = i1 * stride3;
    const offset0 = offset1 - stride3;
    const s2 = -2 * ppp + 3 * pp;
    const s3 = ppp - pp;
    const s0 = 1 - s2;
    const s1 = s3 - pp + p2;
    for (let i2 = 0; i2 !== stride; i2++) {
      const p0 = values[offset0 + i2 + stride];
      const m0 = values[offset0 + i2 + stride2] * td;
      const p1 = values[offset1 + i2 + stride];
      const m1 = values[offset1 + i2] * td;
      result[i2] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
    }
    return result;
  };
  var _q = new Quaternion();
  var GLTFCubicSplineQuaternionInterpolant = class extends GLTFCubicSplineInterpolant {
    interpolate_(i1, t0, t2, t1) {
      const result = super.interpolate_(i1, t0, t2, t1);
      _q.fromArray(result).normalize().toArray(result);
      return result;
    }
  };
  var WEBGL_CONSTANTS = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123
  };
  var WEBGL_COMPONENT_TYPES = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
  };
  var WEBGL_FILTERS = {
    9728: NearestFilter,
    9729: LinearFilter,
    9984: NearestMipmapNearestFilter,
    9985: LinearMipmapNearestFilter,
    9986: NearestMipmapLinearFilter,
    9987: LinearMipmapLinearFilter
  };
  var WEBGL_WRAPPINGS = {
    33071: ClampToEdgeWrapping,
    33648: MirroredRepeatWrapping,
    10497: RepeatWrapping
  };
  var WEBGL_TYPE_SIZES = {
    "SCALAR": 1,
    "VEC2": 2,
    "VEC3": 3,
    "VEC4": 4,
    "MAT2": 4,
    "MAT3": 9,
    "MAT4": 16
  };
  var ATTRIBUTES = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv2",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex"
  };
  var PATH_PROPERTIES = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences"
  };
  var INTERPOLATION = {
    CUBICSPLINE: void 0,
    LINEAR: InterpolateLinear,
    STEP: InterpolateDiscrete
  };
  var ALPHA_MODES = {
    OPAQUE: "OPAQUE",
    MASK: "MASK",
    BLEND: "BLEND"
  };
  function resolveURL(url, path) {
    if (typeof url !== "string" || url === "")
      return "";
    if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
      path = path.replace(/(^https?:\/\/[^\/]+).*/i, "$1");
    }
    if (/^(https?:)?\/\//i.test(url))
      return url;
    if (/^data:.*,.*$/i.test(url))
      return url;
    if (/^blob:.*$/i.test(url))
      return url;
    return path + url;
  }
  function createDefaultMaterial(cache) {
    if (cache["DefaultMaterial"] === void 0) {
      cache["DefaultMaterial"] = new MeshStandardMaterial({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: false,
        depthTest: true,
        side: FrontSide
      });
    }
    return cache["DefaultMaterial"];
  }
  function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
    for (const name in objectDef.extensions) {
      if (knownExtensions[name] === void 0) {
        object.userData.gltfExtensions = object.userData.gltfExtensions || {};
        object.userData.gltfExtensions[name] = objectDef.extensions[name];
      }
    }
  }
  function assignExtrasToUserData(object, gltfDef) {
    if (gltfDef.extras !== void 0) {
      if (typeof gltfDef.extras === "object") {
        Object.assign(object.userData, gltfDef.extras);
      } else {
        console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + gltfDef.extras);
      }
    }
  }
  function addMorphTargets(geometry, targets, parser) {
    let hasMorphPosition = false;
    let hasMorphNormal = false;
    for (let i2 = 0, il = targets.length; i2 < il; i2++) {
      const target = targets[i2];
      if (target.POSITION !== void 0)
        hasMorphPosition = true;
      if (target.NORMAL !== void 0)
        hasMorphNormal = true;
      if (hasMorphPosition && hasMorphNormal)
        break;
    }
    if (!hasMorphPosition && !hasMorphNormal)
      return Promise.resolve(geometry);
    const pendingPositionAccessors = [];
    const pendingNormalAccessors = [];
    for (let i2 = 0, il = targets.length; i2 < il; i2++) {
      const target = targets[i2];
      if (hasMorphPosition) {
        const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency("accessor", target.POSITION) : geometry.attributes.position;
        pendingPositionAccessors.push(pendingAccessor);
      }
      if (hasMorphNormal) {
        const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency("accessor", target.NORMAL) : geometry.attributes.normal;
        pendingNormalAccessors.push(pendingAccessor);
      }
    }
    return Promise.all([
      Promise.all(pendingPositionAccessors),
      Promise.all(pendingNormalAccessors)
    ]).then(function(accessors) {
      const morphPositions = accessors[0];
      const morphNormals = accessors[1];
      if (hasMorphPosition)
        geometry.morphAttributes.position = morphPositions;
      if (hasMorphNormal)
        geometry.morphAttributes.normal = morphNormals;
      geometry.morphTargetsRelative = true;
      return geometry;
    });
  }
  function updateMorphTargets(mesh, meshDef) {
    mesh.updateMorphTargets();
    if (meshDef.weights !== void 0) {
      for (let i2 = 0, il = meshDef.weights.length; i2 < il; i2++) {
        mesh.morphTargetInfluences[i2] = meshDef.weights[i2];
      }
    }
    if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
      const targetNames = meshDef.extras.targetNames;
      if (mesh.morphTargetInfluences.length === targetNames.length) {
        mesh.morphTargetDictionary = {};
        for (let i2 = 0, il = targetNames.length; i2 < il; i2++) {
          mesh.morphTargetDictionary[targetNames[i2]] = i2;
        }
      } else {
        console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
      }
    }
  }
  function createPrimitiveKey(primitiveDef) {
    const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
    let geometryKey;
    if (dracoExtension) {
      geometryKey = "draco:" + dracoExtension.bufferView + ":" + dracoExtension.indices + ":" + createAttributesKey(dracoExtension.attributes);
    } else {
      geometryKey = primitiveDef.indices + ":" + createAttributesKey(primitiveDef.attributes) + ":" + primitiveDef.mode;
    }
    return geometryKey;
  }
  function createAttributesKey(attributes) {
    let attributesKey = "";
    const keys = Object.keys(attributes).sort();
    for (let i2 = 0, il = keys.length; i2 < il; i2++) {
      attributesKey += keys[i2] + ":" + attributes[keys[i2]] + ";";
    }
    return attributesKey;
  }
  function getNormalizedComponentScale(constructor) {
    switch (constructor) {
      case Int8Array:
        return 1 / 127;
      case Uint8Array:
        return 1 / 255;
      case Int16Array:
        return 1 / 32767;
      case Uint16Array:
        return 1 / 65535;
      default:
        throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
    }
  }
  var GLTFParser = class {
    constructor(json = {}, options = {}) {
      this.json = json;
      this.extensions = {};
      this.plugins = {};
      this.options = options;
      this.cache = new GLTFRegistry();
      this.associations = new Map();
      this.primitiveCache = {};
      this.meshCache = { refs: {}, uses: {} };
      this.cameraCache = { refs: {}, uses: {} };
      this.lightCache = { refs: {}, uses: {} };
      this.textureCache = {};
      this.nodeNamesUsed = {};
      if (typeof createImageBitmap !== "undefined" && /Firefox/.test(navigator.userAgent) === false) {
        this.textureLoader = new ImageBitmapLoader(this.options.manager);
      } else {
        this.textureLoader = new TextureLoader(this.options.manager);
      }
      this.textureLoader.setCrossOrigin(this.options.crossOrigin);
      this.textureLoader.setRequestHeader(this.options.requestHeader);
      this.fileLoader = new FileLoader(this.options.manager);
      this.fileLoader.setResponseType("arraybuffer");
      if (this.options.crossOrigin === "use-credentials") {
        this.fileLoader.setWithCredentials(true);
      }
    }
    setExtensions(extensions) {
      this.extensions = extensions;
    }
    setPlugins(plugins) {
      this.plugins = plugins;
    }
    parse(onLoad, onError) {
      const parser = this;
      const json = this.json;
      const extensions = this.extensions;
      this.cache.removeAll();
      this._invokeAll(function(ext) {
        return ext._markDefs && ext._markDefs();
      });
      Promise.all(this._invokeAll(function(ext) {
        return ext.beforeRoot && ext.beforeRoot();
      })).then(function() {
        return Promise.all([
          parser.getDependencies("scene"),
          parser.getDependencies("animation"),
          parser.getDependencies("camera")
        ]);
      }).then(function(dependencies) {
        const result = {
          scene: dependencies[0][json.scene || 0],
          scenes: dependencies[0],
          animations: dependencies[1],
          cameras: dependencies[2],
          asset: json.asset,
          parser,
          userData: {}
        };
        addUnknownExtensionsToUserData(extensions, result, json);
        assignExtrasToUserData(result, json);
        Promise.all(parser._invokeAll(function(ext) {
          return ext.afterRoot && ext.afterRoot(result);
        })).then(function() {
          onLoad(result);
        });
      }).catch(onError);
    }
    _markDefs() {
      const nodeDefs = this.json.nodes || [];
      const skinDefs = this.json.skins || [];
      const meshDefs = this.json.meshes || [];
      for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
        const joints = skinDefs[skinIndex].joints;
        for (let i2 = 0, il = joints.length; i2 < il; i2++) {
          nodeDefs[joints[i2]].isBone = true;
        }
      }
      for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
        const nodeDef = nodeDefs[nodeIndex];
        if (nodeDef.mesh !== void 0) {
          this._addNodeRef(this.meshCache, nodeDef.mesh);
          if (nodeDef.skin !== void 0) {
            meshDefs[nodeDef.mesh].isSkinnedMesh = true;
          }
        }
        if (nodeDef.camera !== void 0) {
          this._addNodeRef(this.cameraCache, nodeDef.camera);
        }
      }
    }
    _addNodeRef(cache, index) {
      if (index === void 0)
        return;
      if (cache.refs[index] === void 0) {
        cache.refs[index] = cache.uses[index] = 0;
      }
      cache.refs[index]++;
    }
    _getNodeRef(cache, index, object) {
      if (cache.refs[index] <= 1)
        return object;
      const ref = object.clone();
      const updateMappings = (original, clone) => {
        const mappings = this.associations.get(original);
        if (mappings != null) {
          this.associations.set(clone, mappings);
        }
        for (const [i2, child] of original.children.entries()) {
          updateMappings(child, clone.children[i2]);
        }
      };
      updateMappings(object, ref);
      ref.name += "_instance_" + cache.uses[index]++;
      return ref;
    }
    _invokeOne(func) {
      const extensions = Object.values(this.plugins);
      extensions.push(this);
      for (let i2 = 0; i2 < extensions.length; i2++) {
        const result = func(extensions[i2]);
        if (result)
          return result;
      }
      return null;
    }
    _invokeAll(func) {
      const extensions = Object.values(this.plugins);
      extensions.unshift(this);
      const pending = [];
      for (let i2 = 0; i2 < extensions.length; i2++) {
        const result = func(extensions[i2]);
        if (result)
          pending.push(result);
      }
      return pending;
    }
    getDependency(type, index) {
      const cacheKey = type + ":" + index;
      let dependency = this.cache.get(cacheKey);
      if (!dependency) {
        switch (type) {
          case "scene":
            dependency = this.loadScene(index);
            break;
          case "node":
            dependency = this.loadNode(index);
            break;
          case "mesh":
            dependency = this._invokeOne(function(ext) {
              return ext.loadMesh && ext.loadMesh(index);
            });
            break;
          case "accessor":
            dependency = this.loadAccessor(index);
            break;
          case "bufferView":
            dependency = this._invokeOne(function(ext) {
              return ext.loadBufferView && ext.loadBufferView(index);
            });
            break;
          case "buffer":
            dependency = this.loadBuffer(index);
            break;
          case "material":
            dependency = this._invokeOne(function(ext) {
              return ext.loadMaterial && ext.loadMaterial(index);
            });
            break;
          case "texture":
            dependency = this._invokeOne(function(ext) {
              return ext.loadTexture && ext.loadTexture(index);
            });
            break;
          case "skin":
            dependency = this.loadSkin(index);
            break;
          case "animation":
            dependency = this.loadAnimation(index);
            break;
          case "camera":
            dependency = this.loadCamera(index);
            break;
          default:
            throw new Error("Unknown type: " + type);
        }
        this.cache.add(cacheKey, dependency);
      }
      return dependency;
    }
    getDependencies(type) {
      let dependencies = this.cache.get(type);
      if (!dependencies) {
        const parser = this;
        const defs = this.json[type + (type === "mesh" ? "es" : "s")] || [];
        dependencies = Promise.all(defs.map(function(def, index) {
          return parser.getDependency(type, index);
        }));
        this.cache.add(type, dependencies);
      }
      return dependencies;
    }
    loadBuffer(bufferIndex) {
      const bufferDef = this.json.buffers[bufferIndex];
      const loader2 = this.fileLoader;
      if (bufferDef.type && bufferDef.type !== "arraybuffer") {
        throw new Error("THREE.GLTFLoader: " + bufferDef.type + " buffer type is not supported.");
      }
      if (bufferDef.uri === void 0 && bufferIndex === 0) {
        return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
      }
      const options = this.options;
      return new Promise(function(resolve, reject) {
        loader2.load(resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {
          reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
        });
      });
    }
    loadBufferView(bufferViewIndex) {
      const bufferViewDef = this.json.bufferViews[bufferViewIndex];
      return this.getDependency("buffer", bufferViewDef.buffer).then(function(buffer) {
        const byteLength = bufferViewDef.byteLength || 0;
        const byteOffset = bufferViewDef.byteOffset || 0;
        return buffer.slice(byteOffset, byteOffset + byteLength);
      });
    }
    loadAccessor(accessorIndex) {
      const parser = this;
      const json = this.json;
      const accessorDef = this.json.accessors[accessorIndex];
      if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {
        return Promise.resolve(null);
      }
      const pendingBufferViews = [];
      if (accessorDef.bufferView !== void 0) {
        pendingBufferViews.push(this.getDependency("bufferView", accessorDef.bufferView));
      } else {
        pendingBufferViews.push(null);
      }
      if (accessorDef.sparse !== void 0) {
        pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.indices.bufferView));
        pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.values.bufferView));
      }
      return Promise.all(pendingBufferViews).then(function(bufferViews) {
        const bufferView = bufferViews[0];
        const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
        const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
        const elementBytes = TypedArray.BYTES_PER_ELEMENT;
        const itemBytes = elementBytes * itemSize;
        const byteOffset = accessorDef.byteOffset || 0;
        const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;
        const normalized = accessorDef.normalized === true;
        let array, bufferAttribute;
        if (byteStride && byteStride !== itemBytes) {
          const ibSlice = Math.floor(byteOffset / byteStride);
          const ibCacheKey = "InterleavedBuffer:" + accessorDef.bufferView + ":" + accessorDef.componentType + ":" + ibSlice + ":" + accessorDef.count;
          let ib = parser.cache.get(ibCacheKey);
          if (!ib) {
            array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);
            ib = new InterleavedBuffer(array, byteStride / elementBytes);
            parser.cache.add(ibCacheKey, ib);
          }
          bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);
        } else {
          if (bufferView === null) {
            array = new TypedArray(accessorDef.count * itemSize);
          } else {
            array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
          }
          bufferAttribute = new BufferAttribute(array, itemSize, normalized);
        }
        if (accessorDef.sparse !== void 0) {
          const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
          const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
          const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
          const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
          const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
          const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);
          if (bufferView !== null) {
            bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
          }
          for (let i2 = 0, il = sparseIndices.length; i2 < il; i2++) {
            const index = sparseIndices[i2];
            bufferAttribute.setX(index, sparseValues[i2 * itemSize]);
            if (itemSize >= 2)
              bufferAttribute.setY(index, sparseValues[i2 * itemSize + 1]);
            if (itemSize >= 3)
              bufferAttribute.setZ(index, sparseValues[i2 * itemSize + 2]);
            if (itemSize >= 4)
              bufferAttribute.setW(index, sparseValues[i2 * itemSize + 3]);
            if (itemSize >= 5)
              throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
          }
        }
        return bufferAttribute;
      });
    }
    loadTexture(textureIndex) {
      const json = this.json;
      const options = this.options;
      const textureDef = json.textures[textureIndex];
      const source = json.images[textureDef.source];
      let loader2 = this.textureLoader;
      if (source.uri) {
        const handler = options.manager.getHandler(source.uri);
        if (handler !== null)
          loader2 = handler;
      }
      return this.loadTextureImage(textureIndex, source, loader2);
    }
    loadTextureImage(textureIndex, source, loader2) {
      const parser = this;
      const json = this.json;
      const options = this.options;
      const textureDef = json.textures[textureIndex];
      const cacheKey = (source.uri || source.bufferView) + ":" + textureDef.sampler;
      if (this.textureCache[cacheKey]) {
        return this.textureCache[cacheKey];
      }
      const URL2 = self.URL || self.webkitURL;
      let sourceURI = source.uri || "";
      let isObjectURL = false;
      if (source.bufferView !== void 0) {
        sourceURI = parser.getDependency("bufferView", source.bufferView).then(function(bufferView) {
          isObjectURL = true;
          const blob = new Blob([bufferView], { type: source.mimeType });
          sourceURI = URL2.createObjectURL(blob);
          return sourceURI;
        });
      } else if (source.uri === void 0) {
        throw new Error("THREE.GLTFLoader: Image " + textureIndex + " is missing URI and bufferView");
      }
      const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {
        return new Promise(function(resolve, reject) {
          let onLoad = resolve;
          if (loader2.isImageBitmapLoader === true) {
            onLoad = function(imageBitmap) {
              const texture = new Texture(imageBitmap);
              texture.needsUpdate = true;
              resolve(texture);
            };
          }
          loader2.load(resolveURL(sourceURI2, options.path), onLoad, void 0, reject);
        });
      }).then(function(texture) {
        if (isObjectURL === true) {
          URL2.revokeObjectURL(sourceURI);
        }
        texture.flipY = false;
        if (textureDef.name)
          texture.name = textureDef.name;
        const samplers = json.samplers || {};
        const sampler = samplers[textureDef.sampler] || {};
        texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;
        texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;
        texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;
        texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;
        parser.associations.set(texture, { textures: textureIndex });
        return texture;
      }).catch(function() {
        console.error("THREE.GLTFLoader: Couldn't load texture", sourceURI);
        return null;
      });
      this.textureCache[cacheKey] = promise;
      return promise;
    }
    assignTexture(materialParams, mapName, mapDef) {
      const parser = this;
      return this.getDependency("texture", mapDef.index).then(function(texture) {
        if (mapDef.texCoord !== void 0 && mapDef.texCoord != 0 && !(mapName === "aoMap" && mapDef.texCoord == 1)) {
          console.warn("THREE.GLTFLoader: Custom UV set " + mapDef.texCoord + " for texture " + mapName + " not yet supported.");
        }
        if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
          const transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;
          if (transform) {
            const gltfReference = parser.associations.get(texture);
            texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);
            parser.associations.set(texture, gltfReference);
          }
        }
        materialParams[mapName] = texture;
        return texture;
      });
    }
    assignFinalMaterial(mesh) {
      const geometry = mesh.geometry;
      let material = mesh.material;
      const useDerivativeTangents = geometry.attributes.tangent === void 0;
      const useVertexColors = geometry.attributes.color !== void 0;
      const useFlatShading = geometry.attributes.normal === void 0;
      if (mesh.isPoints) {
        const cacheKey = "PointsMaterial:" + material.uuid;
        let pointsMaterial = this.cache.get(cacheKey);
        if (!pointsMaterial) {
          pointsMaterial = new PointsMaterial();
          Material.prototype.copy.call(pointsMaterial, material);
          pointsMaterial.color.copy(material.color);
          pointsMaterial.map = material.map;
          pointsMaterial.sizeAttenuation = false;
          this.cache.add(cacheKey, pointsMaterial);
        }
        material = pointsMaterial;
      } else if (mesh.isLine) {
        const cacheKey = "LineBasicMaterial:" + material.uuid;
        let lineMaterial = this.cache.get(cacheKey);
        if (!lineMaterial) {
          lineMaterial = new LineBasicMaterial();
          Material.prototype.copy.call(lineMaterial, material);
          lineMaterial.color.copy(material.color);
          this.cache.add(cacheKey, lineMaterial);
        }
        material = lineMaterial;
      }
      if (useDerivativeTangents || useVertexColors || useFlatShading) {
        let cacheKey = "ClonedMaterial:" + material.uuid + ":";
        if (material.isGLTFSpecularGlossinessMaterial)
          cacheKey += "specular-glossiness:";
        if (useDerivativeTangents)
          cacheKey += "derivative-tangents:";
        if (useVertexColors)
          cacheKey += "vertex-colors:";
        if (useFlatShading)
          cacheKey += "flat-shading:";
        let cachedMaterial = this.cache.get(cacheKey);
        if (!cachedMaterial) {
          cachedMaterial = material.clone();
          if (useVertexColors)
            cachedMaterial.vertexColors = true;
          if (useFlatShading)
            cachedMaterial.flatShading = true;
          if (useDerivativeTangents) {
            if (cachedMaterial.normalScale)
              cachedMaterial.normalScale.y *= -1;
            if (cachedMaterial.clearcoatNormalScale)
              cachedMaterial.clearcoatNormalScale.y *= -1;
          }
          this.cache.add(cacheKey, cachedMaterial);
          this.associations.set(cachedMaterial, this.associations.get(material));
        }
        material = cachedMaterial;
      }
      if (material.aoMap && geometry.attributes.uv2 === void 0 && geometry.attributes.uv !== void 0) {
        geometry.setAttribute("uv2", geometry.attributes.uv);
      }
      mesh.material = material;
    }
    getMaterialType() {
      return MeshStandardMaterial;
    }
    loadMaterial(materialIndex) {
      const parser = this;
      const json = this.json;
      const extensions = this.extensions;
      const materialDef = json.materials[materialIndex];
      let materialType;
      const materialParams = {};
      const materialExtensions = materialDef.extensions || {};
      const pending = [];
      if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
        const sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
        materialType = sgExtension.getMaterialType();
        pending.push(sgExtension.extendParams(materialParams, materialDef, parser));
      } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
        const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
        materialType = kmuExtension.getMaterialType();
        pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
      } else {
        const metallicRoughness = materialDef.pbrMetallicRoughness || {};
        materialParams.color = new Color(1, 1, 1);
        materialParams.opacity = 1;
        if (Array.isArray(metallicRoughness.baseColorFactor)) {
          const array = metallicRoughness.baseColorFactor;
          materialParams.color.fromArray(array);
          materialParams.opacity = array[3];
        }
        if (metallicRoughness.baseColorTexture !== void 0) {
          pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture));
        }
        materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;
        materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;
        if (metallicRoughness.metallicRoughnessTexture !== void 0) {
          pending.push(parser.assignTexture(materialParams, "metalnessMap", metallicRoughness.metallicRoughnessTexture));
          pending.push(parser.assignTexture(materialParams, "roughnessMap", metallicRoughness.metallicRoughnessTexture));
        }
        materialType = this._invokeOne(function(ext) {
          return ext.getMaterialType && ext.getMaterialType(materialIndex);
        });
        pending.push(Promise.all(this._invokeAll(function(ext) {
          return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);
        })));
      }
      if (materialDef.doubleSided === true) {
        materialParams.side = DoubleSide;
      }
      const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;
      if (alphaMode === ALPHA_MODES.BLEND) {
        materialParams.transparent = true;
        materialParams.depthWrite = false;
      } else {
        materialParams.format = RGBFormat;
        materialParams.transparent = false;
        if (alphaMode === ALPHA_MODES.MASK) {
          materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;
        }
      }
      if (materialDef.normalTexture !== void 0 && materialType !== MeshBasicMaterial) {
        pending.push(parser.assignTexture(materialParams, "normalMap", materialDef.normalTexture));
        materialParams.normalScale = new Vector2(1, 1);
        if (materialDef.normalTexture.scale !== void 0) {
          const scale = materialDef.normalTexture.scale;
          materialParams.normalScale.set(scale, scale);
        }
      }
      if (materialDef.occlusionTexture !== void 0 && materialType !== MeshBasicMaterial) {
        pending.push(parser.assignTexture(materialParams, "aoMap", materialDef.occlusionTexture));
        if (materialDef.occlusionTexture.strength !== void 0) {
          materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
        }
      }
      if (materialDef.emissiveFactor !== void 0 && materialType !== MeshBasicMaterial) {
        materialParams.emissive = new Color().fromArray(materialDef.emissiveFactor);
      }
      if (materialDef.emissiveTexture !== void 0 && materialType !== MeshBasicMaterial) {
        pending.push(parser.assignTexture(materialParams, "emissiveMap", materialDef.emissiveTexture));
      }
      return Promise.all(pending).then(function() {
        let material;
        if (materialType === GLTFMeshStandardSGMaterial) {
          material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);
        } else {
          material = new materialType(materialParams);
        }
        if (materialDef.name)
          material.name = materialDef.name;
        if (material.map)
          material.map.encoding = sRGBEncoding;
        if (material.emissiveMap)
          material.emissiveMap.encoding = sRGBEncoding;
        assignExtrasToUserData(material, materialDef);
        parser.associations.set(material, { materials: materialIndex });
        if (materialDef.extensions)
          addUnknownExtensionsToUserData(extensions, material, materialDef);
        return material;
      });
    }
    createUniqueName(originalName) {
      const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || "");
      let name = sanitizedName;
      for (let i2 = 1; this.nodeNamesUsed[name]; ++i2) {
        name = sanitizedName + "_" + i2;
      }
      this.nodeNamesUsed[name] = true;
      return name;
    }
    loadGeometries(primitives) {
      const parser = this;
      const extensions = this.extensions;
      const cache = this.primitiveCache;
      function createDracoPrimitive(primitive) {
        return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {
          return addPrimitiveAttributes(geometry, primitive, parser);
        });
      }
      const pending = [];
      for (let i2 = 0, il = primitives.length; i2 < il; i2++) {
        const primitive = primitives[i2];
        const cacheKey = createPrimitiveKey(primitive);
        const cached = cache[cacheKey];
        if (cached) {
          pending.push(cached.promise);
        } else {
          let geometryPromise;
          if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
            geometryPromise = createDracoPrimitive(primitive);
          } else {
            geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);
          }
          cache[cacheKey] = { primitive, promise: geometryPromise };
          pending.push(geometryPromise);
        }
      }
      return Promise.all(pending);
    }
    loadMesh(meshIndex) {
      const parser = this;
      const json = this.json;
      const extensions = this.extensions;
      const meshDef = json.meshes[meshIndex];
      const primitives = meshDef.primitives;
      const pending = [];
      for (let i2 = 0, il = primitives.length; i2 < il; i2++) {
        const material = primitives[i2].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency("material", primitives[i2].material);
        pending.push(material);
      }
      pending.push(parser.loadGeometries(primitives));
      return Promise.all(pending).then(function(results) {
        const materials = results.slice(0, results.length - 1);
        const geometries = results[results.length - 1];
        const meshes = [];
        for (let i2 = 0, il = geometries.length; i2 < il; i2++) {
          const geometry = geometries[i2];
          const primitive = primitives[i2];
          let mesh;
          const material = materials[i2];
          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {
            mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);
            if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {
              mesh.normalizeSkinWeights();
            }
            if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
              mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);
            } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
              mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);
            }
          } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
            mesh = new LineSegments(geometry, material);
          } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
            mesh = new Line(geometry, material);
          } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
            mesh = new LineLoop(geometry, material);
          } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
            mesh = new Points(geometry, material);
          } else {
            throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + primitive.mode);
          }
          if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
            updateMorphTargets(mesh, meshDef);
          }
          mesh.name = parser.createUniqueName(meshDef.name || "mesh_" + meshIndex);
          assignExtrasToUserData(mesh, meshDef);
          if (primitive.extensions)
            addUnknownExtensionsToUserData(extensions, mesh, primitive);
          parser.assignFinalMaterial(mesh);
          meshes.push(mesh);
        }
        for (let i2 = 0, il = meshes.length; i2 < il; i2++) {
          parser.associations.set(meshes[i2], {
            meshes: meshIndex,
            primitives: i2
          });
        }
        if (meshes.length === 1) {
          return meshes[0];
        }
        const group = new Group();
        parser.associations.set(group, { meshes: meshIndex });
        for (let i2 = 0, il = meshes.length; i2 < il; i2++) {
          group.add(meshes[i2]);
        }
        return group;
      });
    }
    loadCamera(cameraIndex) {
      let camera2;
      const cameraDef = this.json.cameras[cameraIndex];
      const params = cameraDef[cameraDef.type];
      if (!params) {
        console.warn("THREE.GLTFLoader: Missing camera parameters.");
        return;
      }
      if (cameraDef.type === "perspective") {
        camera2 = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
      } else if (cameraDef.type === "orthographic") {
        camera2 = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);
      }
      if (cameraDef.name)
        camera2.name = this.createUniqueName(cameraDef.name);
      assignExtrasToUserData(camera2, cameraDef);
      return Promise.resolve(camera2);
    }
    loadSkin(skinIndex) {
      const skinDef = this.json.skins[skinIndex];
      const skinEntry = { joints: skinDef.joints };
      if (skinDef.inverseBindMatrices === void 0) {
        return Promise.resolve(skinEntry);
      }
      return this.getDependency("accessor", skinDef.inverseBindMatrices).then(function(accessor) {
        skinEntry.inverseBindMatrices = accessor;
        return skinEntry;
      });
    }
    loadAnimation(animationIndex) {
      const json = this.json;
      const animationDef = json.animations[animationIndex];
      const pendingNodes = [];
      const pendingInputAccessors = [];
      const pendingOutputAccessors = [];
      const pendingSamplers = [];
      const pendingTargets = [];
      for (let i2 = 0, il = animationDef.channels.length; i2 < il; i2++) {
        const channel = animationDef.channels[i2];
        const sampler = animationDef.samplers[channel.sampler];
        const target = channel.target;
        const name = target.node !== void 0 ? target.node : target.id;
        const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;
        const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;
        pendingNodes.push(this.getDependency("node", name));
        pendingInputAccessors.push(this.getDependency("accessor", input));
        pendingOutputAccessors.push(this.getDependency("accessor", output));
        pendingSamplers.push(sampler);
        pendingTargets.push(target);
      }
      return Promise.all([
        Promise.all(pendingNodes),
        Promise.all(pendingInputAccessors),
        Promise.all(pendingOutputAccessors),
        Promise.all(pendingSamplers),
        Promise.all(pendingTargets)
      ]).then(function(dependencies) {
        const nodes = dependencies[0];
        const inputAccessors = dependencies[1];
        const outputAccessors = dependencies[2];
        const samplers = dependencies[3];
        const targets = dependencies[4];
        const tracks = [];
        for (let i2 = 0, il = nodes.length; i2 < il; i2++) {
          const node = nodes[i2];
          const inputAccessor = inputAccessors[i2];
          const outputAccessor = outputAccessors[i2];
          const sampler = samplers[i2];
          const target = targets[i2];
          if (node === void 0)
            continue;
          node.updateMatrix();
          node.matrixAutoUpdate = true;
          let TypedKeyframeTrack;
          switch (PATH_PROPERTIES[target.path]) {
            case PATH_PROPERTIES.weights:
              TypedKeyframeTrack = NumberKeyframeTrack;
              break;
            case PATH_PROPERTIES.rotation:
              TypedKeyframeTrack = QuaternionKeyframeTrack;
              break;
            case PATH_PROPERTIES.position:
            case PATH_PROPERTIES.scale:
            default:
              TypedKeyframeTrack = VectorKeyframeTrack;
              break;
          }
          const targetName = node.name ? node.name : node.uuid;
          const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;
          const targetNames = [];
          if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {
            node.traverse(function(object) {
              if (object.isMesh === true && object.morphTargetInfluences) {
                targetNames.push(object.name ? object.name : object.uuid);
              }
            });
          } else {
            targetNames.push(targetName);
          }
          let outputArray = outputAccessor.array;
          if (outputAccessor.normalized) {
            const scale = getNormalizedComponentScale(outputArray.constructor);
            const scaled = new Float32Array(outputArray.length);
            for (let j2 = 0, jl = outputArray.length; j2 < jl; j2++) {
              scaled[j2] = outputArray[j2] * scale;
            }
            outputArray = scaled;
          }
          for (let j2 = 0, jl = targetNames.length; j2 < jl; j2++) {
            const track = new TypedKeyframeTrack(targetNames[j2] + "." + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation);
            if (sampler.interpolation === "CUBICSPLINE") {
              track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
                const interpolantType = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;
                return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);
              };
              track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
            }
            tracks.push(track);
          }
        }
        const name = animationDef.name ? animationDef.name : "animation_" + animationIndex;
        return new AnimationClip(name, void 0, tracks);
      });
    }
    createNodeMesh(nodeIndex) {
      const json = this.json;
      const parser = this;
      const nodeDef = json.nodes[nodeIndex];
      if (nodeDef.mesh === void 0)
        return null;
      return parser.getDependency("mesh", nodeDef.mesh).then(function(mesh) {
        const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);
        if (nodeDef.weights !== void 0) {
          node.traverse(function(o2) {
            if (!o2.isMesh)
              return;
            for (let i2 = 0, il = nodeDef.weights.length; i2 < il; i2++) {
              o2.morphTargetInfluences[i2] = nodeDef.weights[i2];
            }
          });
        }
        return node;
      });
    }
    loadNode(nodeIndex) {
      const json = this.json;
      const extensions = this.extensions;
      const parser = this;
      const nodeDef = json.nodes[nodeIndex];
      const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : "";
      return function() {
        const pending = [];
        const meshPromise = parser._invokeOne(function(ext) {
          return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);
        });
        if (meshPromise) {
          pending.push(meshPromise);
        }
        if (nodeDef.camera !== void 0) {
          pending.push(parser.getDependency("camera", nodeDef.camera).then(function(camera2) {
            return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera2);
          }));
        }
        parser._invokeAll(function(ext) {
          return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);
        }).forEach(function(promise) {
          pending.push(promise);
        });
        return Promise.all(pending);
      }().then(function(objects) {
        let node;
        if (nodeDef.isBone === true) {
          node = new Bone();
        } else if (objects.length > 1) {
          node = new Group();
        } else if (objects.length === 1) {
          node = objects[0];
        } else {
          node = new Object3D();
        }
        if (node !== objects[0]) {
          for (let i2 = 0, il = objects.length; i2 < il; i2++) {
            node.add(objects[i2]);
          }
        }
        if (nodeDef.name) {
          node.userData.name = nodeDef.name;
          node.name = nodeName;
        }
        assignExtrasToUserData(node, nodeDef);
        if (nodeDef.extensions)
          addUnknownExtensionsToUserData(extensions, node, nodeDef);
        if (nodeDef.matrix !== void 0) {
          const matrix = new Matrix4();
          matrix.fromArray(nodeDef.matrix);
          node.applyMatrix4(matrix);
        } else {
          if (nodeDef.translation !== void 0) {
            node.position.fromArray(nodeDef.translation);
          }
          if (nodeDef.rotation !== void 0) {
            node.quaternion.fromArray(nodeDef.rotation);
          }
          if (nodeDef.scale !== void 0) {
            node.scale.fromArray(nodeDef.scale);
          }
        }
        if (!parser.associations.has(node)) {
          parser.associations.set(node, {});
        }
        parser.associations.get(node).nodes = nodeIndex;
        return node;
      });
    }
    loadScene(sceneIndex) {
      const json = this.json;
      const extensions = this.extensions;
      const sceneDef = this.json.scenes[sceneIndex];
      const parser = this;
      const scene2 = new Group();
      if (sceneDef.name)
        scene2.name = parser.createUniqueName(sceneDef.name);
      assignExtrasToUserData(scene2, sceneDef);
      if (sceneDef.extensions)
        addUnknownExtensionsToUserData(extensions, scene2, sceneDef);
      const nodeIds = sceneDef.nodes || [];
      const pending = [];
      for (let i2 = 0, il = nodeIds.length; i2 < il; i2++) {
        pending.push(buildNodeHierarchy(nodeIds[i2], scene2, json, parser));
      }
      return Promise.all(pending).then(function() {
        const reduceAssociations = (node) => {
          const reducedAssociations = new Map();
          for (const [key, value] of parser.associations) {
            if (key instanceof Material || key instanceof Texture) {
              reducedAssociations.set(key, value);
            }
          }
          node.traverse((node2) => {
            const mappings = parser.associations.get(node2);
            if (mappings != null) {
              reducedAssociations.set(node2, mappings);
            }
          });
          return reducedAssociations;
        };
        parser.associations = reduceAssociations(scene2);
        return scene2;
      });
    }
  };
  function buildNodeHierarchy(nodeId, parentObject, json, parser) {
    const nodeDef = json.nodes[nodeId];
    return parser.getDependency("node", nodeId).then(function(node) {
      if (nodeDef.skin === void 0)
        return node;
      let skinEntry;
      return parser.getDependency("skin", nodeDef.skin).then(function(skin) {
        skinEntry = skin;
        const pendingJoints = [];
        for (let i2 = 0, il = skinEntry.joints.length; i2 < il; i2++) {
          pendingJoints.push(parser.getDependency("node", skinEntry.joints[i2]));
        }
        return Promise.all(pendingJoints);
      }).then(function(jointNodes) {
        node.traverse(function(mesh) {
          if (!mesh.isMesh)
            return;
          const bones = [];
          const boneInverses = [];
          for (let j2 = 0, jl = jointNodes.length; j2 < jl; j2++) {
            const jointNode = jointNodes[j2];
            if (jointNode) {
              bones.push(jointNode);
              const mat = new Matrix4();
              if (skinEntry.inverseBindMatrices !== void 0) {
                mat.fromArray(skinEntry.inverseBindMatrices.array, j2 * 16);
              }
              boneInverses.push(mat);
            } else {
              console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[j2]);
            }
          }
          mesh.bind(new Skeleton(bones, boneInverses), mesh.matrixWorld);
        });
        return node;
      });
    }).then(function(node) {
      parentObject.add(node);
      const pending = [];
      if (nodeDef.children) {
        const children = nodeDef.children;
        for (let i2 = 0, il = children.length; i2 < il; i2++) {
          const child = children[i2];
          pending.push(buildNodeHierarchy(child, node, json, parser));
        }
      }
      return Promise.all(pending);
    });
  }
  function computeBounds(geometry, primitiveDef, parser) {
    const attributes = primitiveDef.attributes;
    const box = new Box3();
    if (attributes.POSITION !== void 0) {
      const accessor = parser.json.accessors[attributes.POSITION];
      const min = accessor.min;
      const max = accessor.max;
      if (min !== void 0 && max !== void 0) {
        box.set(new Vector3(min[0], min[1], min[2]), new Vector3(max[0], max[1], max[2]));
        if (accessor.normalized) {
          const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
          box.min.multiplyScalar(boxScale);
          box.max.multiplyScalar(boxScale);
        }
      } else {
        console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        return;
      }
    } else {
      return;
    }
    const targets = primitiveDef.targets;
    if (targets !== void 0) {
      const maxDisplacement = new Vector3();
      const vector = new Vector3();
      for (let i2 = 0, il = targets.length; i2 < il; i2++) {
        const target = targets[i2];
        if (target.POSITION !== void 0) {
          const accessor = parser.json.accessors[target.POSITION];
          const min = accessor.min;
          const max = accessor.max;
          if (min !== void 0 && max !== void 0) {
            vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));
            vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));
            vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));
            if (accessor.normalized) {
              const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
              vector.multiplyScalar(boxScale);
            }
            maxDisplacement.max(vector);
          } else {
            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
          }
        }
      }
      box.expandByVector(maxDisplacement);
    }
    geometry.boundingBox = box;
    const sphere = new Sphere();
    box.getCenter(sphere.center);
    sphere.radius = box.min.distanceTo(box.max) / 2;
    geometry.boundingSphere = sphere;
  }
  function addPrimitiveAttributes(geometry, primitiveDef, parser) {
    const attributes = primitiveDef.attributes;
    const pending = [];
    function assignAttributeAccessor(accessorIndex, attributeName) {
      return parser.getDependency("accessor", accessorIndex).then(function(accessor) {
        geometry.setAttribute(attributeName, accessor);
      });
    }
    for (const gltfAttributeName in attributes) {
      const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();
      if (threeAttributeName in geometry.attributes)
        continue;
      pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
    }
    if (primitiveDef.indices !== void 0 && !geometry.index) {
      const accessor = parser.getDependency("accessor", primitiveDef.indices).then(function(accessor2) {
        geometry.setIndex(accessor2);
      });
      pending.push(accessor);
    }
    assignExtrasToUserData(geometry, primitiveDef);
    computeBounds(geometry, primitiveDef, parser);
    return Promise.all(pending).then(function() {
      return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
    });
  }
  function toTrianglesDrawMode(geometry, drawMode) {
    let index = geometry.getIndex();
    if (index === null) {
      const indices = [];
      const position = geometry.getAttribute("position");
      if (position !== void 0) {
        for (let i2 = 0; i2 < position.count; i2++) {
          indices.push(i2);
        }
        geometry.setIndex(indices);
        index = geometry.getIndex();
      } else {
        console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");
        return geometry;
      }
    }
    const numberOfTriangles = index.count - 2;
    const newIndices = [];
    if (drawMode === TriangleFanDrawMode) {
      for (let i2 = 1; i2 <= numberOfTriangles; i2++) {
        newIndices.push(index.getX(0));
        newIndices.push(index.getX(i2));
        newIndices.push(index.getX(i2 + 1));
      }
    } else {
      for (let i2 = 0; i2 < numberOfTriangles; i2++) {
        if (i2 % 2 === 0) {
          newIndices.push(index.getX(i2));
          newIndices.push(index.getX(i2 + 1));
          newIndices.push(index.getX(i2 + 2));
        } else {
          newIndices.push(index.getX(i2 + 2));
          newIndices.push(index.getX(i2 + 1));
          newIndices.push(index.getX(i2));
        }
      }
    }
    if (newIndices.length / 3 !== numberOfTriangles) {
      console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    }
    const newGeometry = geometry.clone();
    newGeometry.setIndex(newIndices);
    return newGeometry;
  }

  // node_modules/three/examples/jsm/controls/OrbitControls.js
  var _changeEvent = { type: "change" };
  var _startEvent = { type: "start" };
  var _endEvent = { type: "end" };
  var OrbitControls = class extends EventDispatcher {
    constructor(object, domElement) {
      super();
      if (domElement === void 0)
        console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.');
      if (domElement === document)
        console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.');
      this.object = object;
      this.domElement = domElement;
      this.domElement.style.touchAction = "none";
      this.enabled = true;
      this.target = new Vector3();
      this.minDistance = 0;
      this.maxDistance = Infinity;
      this.minZoom = 0;
      this.maxZoom = Infinity;
      this.minPolarAngle = 0;
      this.maxPolarAngle = Math.PI;
      this.minAzimuthAngle = -Infinity;
      this.maxAzimuthAngle = Infinity;
      this.enableDamping = false;
      this.dampingFactor = 0.05;
      this.enableZoom = true;
      this.zoomSpeed = 1;
      this.enableRotate = true;
      this.rotateSpeed = 1;
      this.enablePan = true;
      this.panSpeed = 1;
      this.screenSpacePanning = true;
      this.keyPanSpeed = 7;
      this.autoRotate = false;
      this.autoRotateSpeed = 2;
      this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" };
      this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };
      this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };
      this.target0 = this.target.clone();
      this.position0 = this.object.position.clone();
      this.zoom0 = this.object.zoom;
      this._domElementKeyEvents = null;
      this.getPolarAngle = function() {
        return spherical.phi;
      };
      this.getAzimuthalAngle = function() {
        return spherical.theta;
      };
      this.getDistance = function() {
        return this.object.position.distanceTo(this.target);
      };
      this.listenToKeyEvents = function(domElement2) {
        domElement2.addEventListener("keydown", onKeyDown);
        this._domElementKeyEvents = domElement2;
      };
      this.saveState = function() {
        scope.target0.copy(scope.target);
        scope.position0.copy(scope.object.position);
        scope.zoom0 = scope.object.zoom;
      };
      this.reset = function() {
        scope.target.copy(scope.target0);
        scope.object.position.copy(scope.position0);
        scope.object.zoom = scope.zoom0;
        scope.object.updateProjectionMatrix();
        scope.dispatchEvent(_changeEvent);
        scope.update();
        state2 = STATE.NONE;
      };
      this.update = function() {
        const offset = new Vector3();
        const quat = new Quaternion().setFromUnitVectors(object.up, new Vector3(0, 1, 0));
        const quatInverse = quat.clone().invert();
        const lastPosition = new Vector3();
        const lastQuaternion = new Quaternion();
        const twoPI = 2 * Math.PI;
        return function update2() {
          const position = scope.object.position;
          offset.copy(position).sub(scope.target);
          offset.applyQuaternion(quat);
          spherical.setFromVector3(offset);
          if (scope.autoRotate && state2 === STATE.NONE) {
            rotateLeft(getAutoRotationAngle());
          }
          if (scope.enableDamping) {
            spherical.theta += sphericalDelta.theta * scope.dampingFactor;
            spherical.phi += sphericalDelta.phi * scope.dampingFactor;
          } else {
            spherical.theta += sphericalDelta.theta;
            spherical.phi += sphericalDelta.phi;
          }
          let min = scope.minAzimuthAngle;
          let max = scope.maxAzimuthAngle;
          if (isFinite(min) && isFinite(max)) {
            if (min < -Math.PI)
              min += twoPI;
            else if (min > Math.PI)
              min -= twoPI;
            if (max < -Math.PI)
              max += twoPI;
            else if (max > Math.PI)
              max -= twoPI;
            if (min <= max) {
              spherical.theta = Math.max(min, Math.min(max, spherical.theta));
            } else {
              spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);
            }
          }
          spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
          spherical.makeSafe();
          spherical.radius *= scale;
          spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));
          if (scope.enableDamping === true) {
            scope.target.addScaledVector(panOffset, scope.dampingFactor);
          } else {
            scope.target.add(panOffset);
          }
          offset.setFromSpherical(spherical);
          offset.applyQuaternion(quatInverse);
          position.copy(scope.target).add(offset);
          scope.object.lookAt(scope.target);
          if (scope.enableDamping === true) {
            sphericalDelta.theta *= 1 - scope.dampingFactor;
            sphericalDelta.phi *= 1 - scope.dampingFactor;
            panOffset.multiplyScalar(1 - scope.dampingFactor);
          } else {
            sphericalDelta.set(0, 0, 0);
            panOffset.set(0, 0, 0);
          }
          scale = 1;
          if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
            scope.dispatchEvent(_changeEvent);
            lastPosition.copy(scope.object.position);
            lastQuaternion.copy(scope.object.quaternion);
            zoomChanged = false;
            return true;
          }
          return false;
        };
      }();
      this.dispose = function() {
        scope.domElement.removeEventListener("contextmenu", onContextMenu);
        scope.domElement.removeEventListener("pointerdown", onPointerDown);
        scope.domElement.removeEventListener("pointercancel", onPointerCancel);
        scope.domElement.removeEventListener("wheel", onMouseWheel);
        scope.domElement.removeEventListener("pointermove", onPointerMove);
        scope.domElement.removeEventListener("pointerup", onPointerUp);
        if (scope._domElementKeyEvents !== null) {
          scope._domElementKeyEvents.removeEventListener("keydown", onKeyDown);
        }
      };
      const scope = this;
      const STATE = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6
      };
      let state2 = STATE.NONE;
      const EPS = 1e-6;
      const spherical = new Spherical();
      const sphericalDelta = new Spherical();
      let scale = 1;
      const panOffset = new Vector3();
      let zoomChanged = false;
      const rotateStart = new Vector2();
      const rotateEnd = new Vector2();
      const rotateDelta = new Vector2();
      const panStart = new Vector2();
      const panEnd = new Vector2();
      const panDelta = new Vector2();
      const dollyStart = new Vector2();
      const dollyEnd = new Vector2();
      const dollyDelta = new Vector2();
      const pointers = [];
      const pointerPositions = {};
      function getAutoRotationAngle() {
        return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
      }
      function getZoomScale() {
        return Math.pow(0.95, scope.zoomSpeed);
      }
      function rotateLeft(angle) {
        sphericalDelta.theta -= angle;
      }
      function rotateUp(angle) {
        sphericalDelta.phi -= angle;
      }
      const panLeft = function() {
        const v2 = new Vector3();
        return function panLeft2(distance, objectMatrix) {
          v2.setFromMatrixColumn(objectMatrix, 0);
          v2.multiplyScalar(-distance);
          panOffset.add(v2);
        };
      }();
      const panUp = function() {
        const v2 = new Vector3();
        return function panUp2(distance, objectMatrix) {
          if (scope.screenSpacePanning === true) {
            v2.setFromMatrixColumn(objectMatrix, 1);
          } else {
            v2.setFromMatrixColumn(objectMatrix, 0);
            v2.crossVectors(scope.object.up, v2);
          }
          v2.multiplyScalar(distance);
          panOffset.add(v2);
        };
      }();
      const pan = function() {
        const offset = new Vector3();
        return function pan2(deltaX, deltaY) {
          const element = scope.domElement;
          if (scope.object.isPerspectiveCamera) {
            const position = scope.object.position;
            offset.copy(position).sub(scope.target);
            let targetDistance = offset.length();
            targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180);
            panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
            panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
          } else if (scope.object.isOrthographicCamera) {
            panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
            panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
          } else {
            console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.");
            scope.enablePan = false;
          }
        };
      }();
      function dollyOut(dollyScale) {
        if (scope.object.isPerspectiveCamera) {
          scale /= dollyScale;
        } else if (scope.object.isOrthographicCamera) {
          scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
          scope.object.updateProjectionMatrix();
          zoomChanged = true;
        } else {
          console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
          scope.enableZoom = false;
        }
      }
      function dollyIn(dollyScale) {
        if (scope.object.isPerspectiveCamera) {
          scale *= dollyScale;
        } else if (scope.object.isOrthographicCamera) {
          scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
          scope.object.updateProjectionMatrix();
          zoomChanged = true;
        } else {
          console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.");
          scope.enableZoom = false;
        }
      }
      function handleMouseDownRotate(event) {
        rotateStart.set(event.clientX, event.clientY);
      }
      function handleMouseDownDolly(event) {
        dollyStart.set(event.clientX, event.clientY);
      }
      function handleMouseDownPan(event) {
        panStart.set(event.clientX, event.clientY);
      }
      function handleMouseMoveRotate(event) {
        rotateEnd.set(event.clientX, event.clientY);
        rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
        const element = scope.domElement;
        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
        rotateStart.copy(rotateEnd);
        scope.update();
      }
      function handleMouseMoveDolly(event) {
        dollyEnd.set(event.clientX, event.clientY);
        dollyDelta.subVectors(dollyEnd, dollyStart);
        if (dollyDelta.y > 0) {
          dollyOut(getZoomScale());
        } else if (dollyDelta.y < 0) {
          dollyIn(getZoomScale());
        }
        dollyStart.copy(dollyEnd);
        scope.update();
      }
      function handleMouseMovePan(event) {
        panEnd.set(event.clientX, event.clientY);
        panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
        pan(panDelta.x, panDelta.y);
        panStart.copy(panEnd);
        scope.update();
      }
      function handleMouseUp() {
      }
      function handleMouseWheel(event) {
        if (event.deltaY < 0) {
          dollyIn(getZoomScale());
        } else if (event.deltaY > 0) {
          dollyOut(getZoomScale());
        }
        scope.update();
      }
      function handleKeyDown(event) {
        let needsUpdate = false;
        switch (event.code) {
          case scope.keys.UP:
            pan(0, scope.keyPanSpeed);
            needsUpdate = true;
            break;
          case scope.keys.BOTTOM:
            pan(0, -scope.keyPanSpeed);
            needsUpdate = true;
            break;
          case scope.keys.LEFT:
            pan(scope.keyPanSpeed, 0);
            needsUpdate = true;
            break;
          case scope.keys.RIGHT:
            pan(-scope.keyPanSpeed, 0);
            needsUpdate = true;
            break;
        }
        if (needsUpdate) {
          event.preventDefault();
          scope.update();
        }
      }
      function handleTouchStartRotate() {
        if (pointers.length === 1) {
          rotateStart.set(pointers[0].pageX, pointers[0].pageY);
        } else {
          const x2 = 0.5 * (pointers[0].pageX + pointers[1].pageX);
          const y2 = 0.5 * (pointers[0].pageY + pointers[1].pageY);
          rotateStart.set(x2, y2);
        }
      }
      function handleTouchStartPan() {
        if (pointers.length === 1) {
          panStart.set(pointers[0].pageX, pointers[0].pageY);
        } else {
          const x2 = 0.5 * (pointers[0].pageX + pointers[1].pageX);
          const y2 = 0.5 * (pointers[0].pageY + pointers[1].pageY);
          panStart.set(x2, y2);
        }
      }
      function handleTouchStartDolly() {
        const dx = pointers[0].pageX - pointers[1].pageX;
        const dy = pointers[0].pageY - pointers[1].pageY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        dollyStart.set(0, distance);
      }
      function handleTouchStartDollyPan() {
        if (scope.enableZoom)
          handleTouchStartDolly();
        if (scope.enablePan)
          handleTouchStartPan();
      }
      function handleTouchStartDollyRotate() {
        if (scope.enableZoom)
          handleTouchStartDolly();
        if (scope.enableRotate)
          handleTouchStartRotate();
      }
      function handleTouchMoveRotate(event) {
        if (pointers.length == 1) {
          rotateEnd.set(event.pageX, event.pageY);
        } else {
          const position = getSecondPointerPosition(event);
          const x2 = 0.5 * (event.pageX + position.x);
          const y2 = 0.5 * (event.pageY + position.y);
          rotateEnd.set(x2, y2);
        }
        rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
        const element = scope.domElement;
        rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);
        rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
        rotateStart.copy(rotateEnd);
      }
      function handleTouchMovePan(event) {
        if (pointers.length === 1) {
          panEnd.set(event.pageX, event.pageY);
        } else {
          const position = getSecondPointerPosition(event);
          const x2 = 0.5 * (event.pageX + position.x);
          const y2 = 0.5 * (event.pageY + position.y);
          panEnd.set(x2, y2);
        }
        panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
        pan(panDelta.x, panDelta.y);
        panStart.copy(panEnd);
      }
      function handleTouchMoveDolly(event) {
        const position = getSecondPointerPosition(event);
        const dx = event.pageX - position.x;
        const dy = event.pageY - position.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        dollyEnd.set(0, distance);
        dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
        dollyOut(dollyDelta.y);
        dollyStart.copy(dollyEnd);
      }
      function handleTouchMoveDollyPan(event) {
        if (scope.enableZoom)
          handleTouchMoveDolly(event);
        if (scope.enablePan)
          handleTouchMovePan(event);
      }
      function handleTouchMoveDollyRotate(event) {
        if (scope.enableZoom)
          handleTouchMoveDolly(event);
        if (scope.enableRotate)
          handleTouchMoveRotate(event);
      }
      function handleTouchEnd() {
      }
      function onPointerDown(event) {
        if (scope.enabled === false)
          return;
        if (pointers.length === 0) {
          scope.domElement.setPointerCapture(event.pointerId);
          scope.domElement.addEventListener("pointermove", onPointerMove);
          scope.domElement.addEventListener("pointerup", onPointerUp);
        }
        addPointer(event);
        if (event.pointerType === "touch") {
          onTouchStart(event);
        } else {
          onMouseDown(event);
        }
      }
      function onPointerMove(event) {
        if (scope.enabled === false)
          return;
        if (event.pointerType === "touch") {
          onTouchMove(event);
        } else {
          onMouseMove(event);
        }
      }
      function onPointerUp(event) {
        if (scope.enabled === false)
          return;
        if (event.pointerType === "touch") {
          onTouchEnd();
        } else {
          onMouseUp(event);
        }
        removePointer(event);
        if (pointers.length === 0) {
          scope.domElement.releasePointerCapture(event.pointerId);
          scope.domElement.removeEventListener("pointermove", onPointerMove);
          scope.domElement.removeEventListener("pointerup", onPointerUp);
        }
      }
      function onPointerCancel(event) {
        removePointer(event);
      }
      function onMouseDown(event) {
        let mouseAction;
        switch (event.button) {
          case 0:
            mouseAction = scope.mouseButtons.LEFT;
            break;
          case 1:
            mouseAction = scope.mouseButtons.MIDDLE;
            break;
          case 2:
            mouseAction = scope.mouseButtons.RIGHT;
            break;
          default:
            mouseAction = -1;
        }
        switch (mouseAction) {
          case MOUSE.DOLLY:
            if (scope.enableZoom === false)
              return;
            handleMouseDownDolly(event);
            state2 = STATE.DOLLY;
            break;
          case MOUSE.ROTATE:
            if (event.ctrlKey || event.metaKey || event.shiftKey) {
              if (scope.enablePan === false)
                return;
              handleMouseDownPan(event);
              state2 = STATE.PAN;
            } else {
              if (scope.enableRotate === false)
                return;
              handleMouseDownRotate(event);
              state2 = STATE.ROTATE;
            }
            break;
          case MOUSE.PAN:
            if (event.ctrlKey || event.metaKey || event.shiftKey) {
              if (scope.enableRotate === false)
                return;
              handleMouseDownRotate(event);
              state2 = STATE.ROTATE;
            } else {
              if (scope.enablePan === false)
                return;
              handleMouseDownPan(event);
              state2 = STATE.PAN;
            }
            break;
          default:
            state2 = STATE.NONE;
        }
        if (state2 !== STATE.NONE) {
          scope.dispatchEvent(_startEvent);
        }
      }
      function onMouseMove(event) {
        if (scope.enabled === false)
          return;
        switch (state2) {
          case STATE.ROTATE:
            if (scope.enableRotate === false)
              return;
            handleMouseMoveRotate(event);
            break;
          case STATE.DOLLY:
            if (scope.enableZoom === false)
              return;
            handleMouseMoveDolly(event);
            break;
          case STATE.PAN:
            if (scope.enablePan === false)
              return;
            handleMouseMovePan(event);
            break;
        }
      }
      function onMouseUp(event) {
        handleMouseUp(event);
        scope.dispatchEvent(_endEvent);
        state2 = STATE.NONE;
      }
      function onMouseWheel(event) {
        if (scope.enabled === false || scope.enableZoom === false || state2 !== STATE.NONE && state2 !== STATE.ROTATE)
          return;
        event.preventDefault();
        scope.dispatchEvent(_startEvent);
        handleMouseWheel(event);
        scope.dispatchEvent(_endEvent);
      }
      function onKeyDown(event) {
        if (scope.enabled === false || scope.enablePan === false)
          return;
        handleKeyDown(event);
      }
      function onTouchStart(event) {
        trackPointer(event);
        switch (pointers.length) {
          case 1:
            switch (scope.touches.ONE) {
              case TOUCH.ROTATE:
                if (scope.enableRotate === false)
                  return;
                handleTouchStartRotate();
                state2 = STATE.TOUCH_ROTATE;
                break;
              case TOUCH.PAN:
                if (scope.enablePan === false)
                  return;
                handleTouchStartPan();
                state2 = STATE.TOUCH_PAN;
                break;
              default:
                state2 = STATE.NONE;
            }
            break;
          case 2:
            switch (scope.touches.TWO) {
              case TOUCH.DOLLY_PAN:
                if (scope.enableZoom === false && scope.enablePan === false)
                  return;
                handleTouchStartDollyPan();
                state2 = STATE.TOUCH_DOLLY_PAN;
                break;
              case TOUCH.DOLLY_ROTATE:
                if (scope.enableZoom === false && scope.enableRotate === false)
                  return;
                handleTouchStartDollyRotate();
                state2 = STATE.TOUCH_DOLLY_ROTATE;
                break;
              default:
                state2 = STATE.NONE;
            }
            break;
          default:
            state2 = STATE.NONE;
        }
        if (state2 !== STATE.NONE) {
          scope.dispatchEvent(_startEvent);
        }
      }
      function onTouchMove(event) {
        trackPointer(event);
        switch (state2) {
          case STATE.TOUCH_ROTATE:
            if (scope.enableRotate === false)
              return;
            handleTouchMoveRotate(event);
            scope.update();
            break;
          case STATE.TOUCH_PAN:
            if (scope.enablePan === false)
              return;
            handleTouchMovePan(event);
            scope.update();
            break;
          case STATE.TOUCH_DOLLY_PAN:
            if (scope.enableZoom === false && scope.enablePan === false)
              return;
            handleTouchMoveDollyPan(event);
            scope.update();
            break;
          case STATE.TOUCH_DOLLY_ROTATE:
            if (scope.enableZoom === false && scope.enableRotate === false)
              return;
            handleTouchMoveDollyRotate(event);
            scope.update();
            break;
          default:
            state2 = STATE.NONE;
        }
      }
      function onTouchEnd(event) {
        handleTouchEnd(event);
        scope.dispatchEvent(_endEvent);
        state2 = STATE.NONE;
      }
      function onContextMenu(event) {
        if (scope.enabled === false)
          return;
        event.preventDefault();
      }
      function addPointer(event) {
        pointers.push(event);
      }
      function removePointer(event) {
        delete pointerPositions[event.pointerId];
        for (let i2 = 0; i2 < pointers.length; i2++) {
          if (pointers[i2].pointerId == event.pointerId) {
            pointers.splice(i2, 1);
            return;
          }
        }
      }
      function trackPointer(event) {
        let position = pointerPositions[event.pointerId];
        if (position === void 0) {
          position = new Vector2();
          pointerPositions[event.pointerId] = position;
        }
        position.set(event.pageX, event.pageY);
      }
      function getSecondPointerPosition(event) {
        const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];
        return pointerPositions[pointer.pointerId];
      }
      scope.domElement.addEventListener("contextmenu", onContextMenu);
      scope.domElement.addEventListener("pointerdown", onPointerDown);
      scope.domElement.addEventListener("pointercancel", onPointerCancel);
      scope.domElement.addEventListener("wheel", onMouseWheel, { passive: false });
      this.update();
    }
  };

  // node_modules/@pixiv/three-vrm/lib/three-vrm.module.min.js
  function t(e2, t2, n2, i2) {
    return new (n2 || (n2 = Promise))(function(r2, o2) {
      function s2(e3) {
        try {
          l2(i2.next(e3));
        } catch (e4) {
          o2(e4);
        }
      }
      function a2(e3) {
        try {
          l2(i2.throw(e3));
        } catch (e4) {
          o2(e4);
        }
      }
      function l2(e3) {
        var t3;
        e3.done ? r2(e3.value) : (t3 = e3.value, t3 instanceof n2 ? t3 : new n2(function(e4) {
          e4(t3);
        })).then(s2, a2);
      }
      l2((i2 = i2.apply(e2, t2 || [])).next());
    });
  }
  function n(e2) {
    Object.keys(e2).forEach((t2) => {
      const n2 = e2[t2];
      if (n2 == null ? void 0 : n2.isTexture) {
        n2.dispose();
      }
    }), e2.dispose();
  }
  function i(e2) {
    const t2 = e2.geometry;
    t2 && t2.dispose();
    const i2 = e2.material;
    i2 && (Array.isArray(i2) ? i2.forEach((e3) => n(e3)) : i2 && n(i2));
  }
  var r;
  !function(e2) {
    e2[e2.NUMBER = 0] = "NUMBER", e2[e2.VECTOR2 = 1] = "VECTOR2", e2[e2.VECTOR3 = 2] = "VECTOR3", e2[e2.VECTOR4 = 3] = "VECTOR4", e2[e2.COLOR = 4] = "COLOR";
  }(r || (r = {}));
  var o = new Vector2();
  var s = new Vector3();
  var a = new Vector4();
  var l = new Color();
  var d = class extends Object3D {
    constructor(e2) {
      super(), this.weight = 0, this.isBinary = false, this._binds = [], this._materialValues = [], this.name = `BlendShapeController_${e2}`, this.type = "BlendShapeController", this.visible = false;
    }
    addBind(e2) {
      const t2 = e2.weight / 100;
      this._binds.push({ meshes: e2.meshes, morphTargetIndex: e2.morphTargetIndex, weight: t2 });
    }
    addMaterialValue(t2) {
      const n2 = t2.material, i2 = t2.propertyName;
      let o2, s2, a2, l2, d2 = n2[i2];
      d2 && (d2 = t2.defaultValue || d2, d2.isVector2 ? (o2 = r.VECTOR2, s2 = d2.clone(), a2 = new Vector2().fromArray(t2.targetValue), l2 = a2.clone().sub(s2)) : d2.isVector3 ? (o2 = r.VECTOR3, s2 = d2.clone(), a2 = new Vector3().fromArray(t2.targetValue), l2 = a2.clone().sub(s2)) : d2.isVector4 ? (o2 = r.VECTOR4, s2 = d2.clone(), a2 = new Vector4().fromArray([t2.targetValue[2], t2.targetValue[3], t2.targetValue[0], t2.targetValue[1]]), l2 = a2.clone().sub(s2)) : d2.isColor ? (o2 = r.COLOR, s2 = d2.clone(), a2 = new Color().fromArray(t2.targetValue), l2 = a2.clone().sub(s2)) : (o2 = r.NUMBER, s2 = d2, a2 = t2.targetValue[0], l2 = a2 - s2), this._materialValues.push({ material: n2, propertyName: i2, defaultValue: s2, targetValue: a2, deltaValue: l2, type: o2 }));
    }
    applyWeight() {
      const e2 = this.isBinary ? this.weight < 0.5 ? 0 : 1 : this.weight;
      this._binds.forEach((t2) => {
        t2.meshes.forEach((n2) => {
          n2.morphTargetInfluences && (n2.morphTargetInfluences[t2.morphTargetIndex] += e2 * t2.weight);
        });
      }), this._materialValues.forEach((t2) => {
        if (t2.material[t2.propertyName] !== void 0) {
          if (t2.type === r.NUMBER) {
            const n2 = t2.deltaValue;
            t2.material[t2.propertyName] += n2 * e2;
          } else if (t2.type === r.VECTOR2) {
            const n2 = t2.deltaValue;
            t2.material[t2.propertyName].add(o.copy(n2).multiplyScalar(e2));
          } else if (t2.type === r.VECTOR3) {
            const n2 = t2.deltaValue;
            t2.material[t2.propertyName].add(s.copy(n2).multiplyScalar(e2));
          } else if (t2.type === r.VECTOR4) {
            const n2 = t2.deltaValue;
            t2.material[t2.propertyName].add(a.copy(n2).multiplyScalar(e2));
          } else if (t2.type === r.COLOR) {
            const n2 = t2.deltaValue;
            t2.material[t2.propertyName].add(l.copy(n2).multiplyScalar(e2));
          }
          typeof t2.material.shouldApplyUniforms == "boolean" && (t2.material.shouldApplyUniforms = true);
        }
      });
    }
    clearAppliedWeight() {
      this._binds.forEach((e2) => {
        e2.meshes.forEach((t2) => {
          t2.morphTargetInfluences && (t2.morphTargetInfluences[e2.morphTargetIndex] = 0);
        });
      }), this._materialValues.forEach((e2) => {
        if (e2.material[e2.propertyName] !== void 0) {
          if (e2.type === r.NUMBER) {
            const t2 = e2.defaultValue;
            e2.material[e2.propertyName] = t2;
          } else if (e2.type === r.VECTOR2) {
            const t2 = e2.defaultValue;
            e2.material[e2.propertyName].copy(t2);
          } else if (e2.type === r.VECTOR3) {
            const t2 = e2.defaultValue;
            e2.material[e2.propertyName].copy(t2);
          } else if (e2.type === r.VECTOR4) {
            const t2 = e2.defaultValue;
            e2.material[e2.propertyName].copy(t2);
          } else if (e2.type === r.COLOR) {
            const t2 = e2.defaultValue;
            e2.material[e2.propertyName].copy(t2);
          }
          typeof e2.material.shouldApplyUniforms == "boolean" && (e2.material.shouldApplyUniforms = true);
        }
      });
    }
  };
  var h;
  function u(e2, t2, n2) {
    const i2 = e2.parser.json.nodes[t2].mesh;
    if (i2 == null)
      return null;
    const r2 = e2.parser.json.meshes[i2].primitives.length, o2 = [];
    return n2.traverse((e3) => {
      o2.length < r2 && e3.isMesh && o2.push(e3);
    }), o2;
  }
  function c(e2) {
    return t(this, void 0, void 0, function* () {
      const t2 = yield e2.parser.getDependencies("node"), n2 = new Map();
      return t2.forEach((t3, i2) => {
        const r2 = u(e2, i2, t3);
        r2 != null && n2.set(i2, r2);
      }), n2;
    });
  }
  function p(e2) {
    return e2[0] !== "_" ? (console.warn(`renameMaterialProperty: Given property name "${e2}" might be invalid`), e2) : (e2 = e2.substring(1), /[A-Z]/.test(e2[0]) ? e2[0].toLowerCase() + e2.substring(1) : (console.warn(`renameMaterialProperty: Given property name "${e2}" might be invalid`), e2));
  }
  !function(e2) {
    var t2, n2, i2, r2, o2, s2;
    (t2 = e2.BlendShapePresetName || (e2.BlendShapePresetName = {})).A = "a", t2.Angry = "angry", t2.Blink = "blink", t2.BlinkL = "blink_l", t2.BlinkR = "blink_r", t2.E = "e", t2.Fun = "fun", t2.I = "i", t2.Joy = "joy", t2.Lookdown = "lookdown", t2.Lookleft = "lookleft", t2.Lookright = "lookright", t2.Lookup = "lookup", t2.Neutral = "neutral", t2.O = "o", t2.Sorrow = "sorrow", t2.U = "u", t2.Unknown = "unknown", (n2 = e2.FirstPersonLookAtTypeName || (e2.FirstPersonLookAtTypeName = {})).BlendShape = "BlendShape", n2.Bone = "Bone", (i2 = e2.HumanoidBoneName || (e2.HumanoidBoneName = {})).Chest = "chest", i2.Head = "head", i2.Hips = "hips", i2.Jaw = "jaw", i2.LeftEye = "leftEye", i2.LeftFoot = "leftFoot", i2.LeftHand = "leftHand", i2.LeftIndexDistal = "leftIndexDistal", i2.LeftIndexIntermediate = "leftIndexIntermediate", i2.LeftIndexProximal = "leftIndexProximal", i2.LeftLittleDistal = "leftLittleDistal", i2.LeftLittleIntermediate = "leftLittleIntermediate", i2.LeftLittleProximal = "leftLittleProximal", i2.LeftLowerArm = "leftLowerArm", i2.LeftLowerLeg = "leftLowerLeg", i2.LeftMiddleDistal = "leftMiddleDistal", i2.LeftMiddleIntermediate = "leftMiddleIntermediate", i2.LeftMiddleProximal = "leftMiddleProximal", i2.LeftRingDistal = "leftRingDistal", i2.LeftRingIntermediate = "leftRingIntermediate", i2.LeftRingProximal = "leftRingProximal", i2.LeftShoulder = "leftShoulder", i2.LeftThumbDistal = "leftThumbDistal", i2.LeftThumbIntermediate = "leftThumbIntermediate", i2.LeftThumbProximal = "leftThumbProximal", i2.LeftToes = "leftToes", i2.LeftUpperArm = "leftUpperArm", i2.LeftUpperLeg = "leftUpperLeg", i2.Neck = "neck", i2.RightEye = "rightEye", i2.RightFoot = "rightFoot", i2.RightHand = "rightHand", i2.RightIndexDistal = "rightIndexDistal", i2.RightIndexIntermediate = "rightIndexIntermediate", i2.RightIndexProximal = "rightIndexProximal", i2.RightLittleDistal = "rightLittleDistal", i2.RightLittleIntermediate = "rightLittleIntermediate", i2.RightLittleProximal = "rightLittleProximal", i2.RightLowerArm = "rightLowerArm", i2.RightLowerLeg = "rightLowerLeg", i2.RightMiddleDistal = "rightMiddleDistal", i2.RightMiddleIntermediate = "rightMiddleIntermediate", i2.RightMiddleProximal = "rightMiddleProximal", i2.RightRingDistal = "rightRingDistal", i2.RightRingIntermediate = "rightRingIntermediate", i2.RightRingProximal = "rightRingProximal", i2.RightShoulder = "rightShoulder", i2.RightThumbDistal = "rightThumbDistal", i2.RightThumbIntermediate = "rightThumbIntermediate", i2.RightThumbProximal = "rightThumbProximal", i2.RightToes = "rightToes", i2.RightUpperArm = "rightUpperArm", i2.RightUpperLeg = "rightUpperLeg", i2.Spine = "spine", i2.UpperChest = "upperChest", (r2 = e2.MetaAllowedUserName || (e2.MetaAllowedUserName = {})).Everyone = "Everyone", r2.ExplicitlyLicensedPerson = "ExplicitlyLicensedPerson", r2.OnlyAuthor = "OnlyAuthor", (o2 = e2.MetaUssageName || (e2.MetaUssageName = {})).Allow = "Allow", o2.Disallow = "Disallow", (s2 = e2.MetaLicenseName || (e2.MetaLicenseName = {})).Cc0 = "CC0", s2.CcBy = "CC_BY", s2.CcByNc = "CC_BY_NC", s2.CcByNcNd = "CC_BY_NC_ND", s2.CcByNcSa = "CC_BY_NC_SA", s2.CcByNd = "CC_BY_ND", s2.CcBySa = "CC_BY_SA", s2.Other = "Other", s2.RedistributionProhibited = "Redistribution_Prohibited";
  }(h || (h = {}));
  var m = new Vector3();
  var f = new Vector3();
  function g(e2, t2) {
    return e2.matrixWorld.decompose(m, t2, f), t2;
  }
  new Quaternion();
  var _ = class {
    constructor() {
      this._blendShapeGroups = {}, this._blendShapePresetMap = {}, this._unknownGroupNames = [];
    }
    get expressions() {
      return Object.keys(this._blendShapeGroups);
    }
    get blendShapePresetMap() {
      return this._blendShapePresetMap;
    }
    get unknownGroupNames() {
      return this._unknownGroupNames;
    }
    getBlendShapeGroup(e2) {
      const t2 = this._blendShapePresetMap[e2], n2 = t2 ? this._blendShapeGroups[t2] : this._blendShapeGroups[e2];
      if (n2)
        return n2;
      console.warn(`no blend shape found by ${e2}`);
    }
    registerBlendShapeGroup(e2, t2, n2) {
      this._blendShapeGroups[e2] = n2, t2 ? this._blendShapePresetMap[t2] = e2 : this._unknownGroupNames.push(e2);
    }
    getValue(e2) {
      var t2;
      const n2 = this.getBlendShapeGroup(e2);
      return (t2 = n2 == null ? void 0 : n2.weight) !== null && t2 !== void 0 ? t2 : null;
    }
    setValue(e2, t2) {
      const n2 = this.getBlendShapeGroup(e2);
      var i2;
      n2 && (n2.weight = (i2 = t2, Math.max(Math.min(i2, 1), 0)));
    }
    getBlendShapeTrackName(e2) {
      const t2 = this.getBlendShapeGroup(e2);
      return t2 ? `${t2.name}.weight` : null;
    }
    update() {
      Object.keys(this._blendShapeGroups).forEach((e2) => {
        this._blendShapeGroups[e2].clearAppliedWeight();
      }), Object.keys(this._blendShapeGroups).forEach((e2) => {
        this._blendShapeGroups[e2].applyWeight();
      });
    }
  };
  var v = class {
    import(e2) {
      var n2;
      return t(this, void 0, void 0, function* () {
        const i2 = (n2 = e2.parser.json.extensions) === null || n2 === void 0 ? void 0 : n2.VRM;
        if (!i2)
          return null;
        const r2 = i2.blendShapeMaster;
        if (!r2)
          return null;
        const o2 = new _(), s2 = r2.blendShapeGroups;
        if (!s2)
          return o2;
        const a2 = {};
        return yield Promise.all(s2.map((n3) => t(this, void 0, void 0, function* () {
          const i3 = n3.name;
          if (i3 === void 0)
            return void console.warn("VRMBlendShapeImporter: One of blendShapeGroups has no name");
          let r3;
          n3.presetName && n3.presetName !== h.BlendShapePresetName.Unknown && !a2[n3.presetName] && (r3 = n3.presetName, a2[n3.presetName] = i3);
          const s3 = new d(i3);
          e2.scene.add(s3), s3.isBinary = n3.isBinary || false, n3.binds && n3.binds.forEach((i4) => t(this, void 0, void 0, function* () {
            if (i4.mesh === void 0 || i4.index === void 0)
              return;
            const r4 = [];
            e2.parser.json.nodes.forEach((e3, t2) => {
              e3.mesh === i4.mesh && r4.push(t2);
            });
            const o3 = i4.index;
            yield Promise.all(r4.map((r5) => t(this, void 0, void 0, function* () {
              var a3;
              const l3 = yield function(e3, n4) {
                return t(this, void 0, void 0, function* () {
                  const t2 = yield e3.parser.getDependency("node", n4);
                  return u(e3, n4, t2);
                });
              }(e2, r5);
              l3.every((e3) => Array.isArray(e3.morphTargetInfluences) && o3 < e3.morphTargetInfluences.length) ? s3.addBind({ meshes: l3, morphTargetIndex: o3, weight: (a3 = i4.weight) !== null && a3 !== void 0 ? a3 : 100 }) : console.warn(`VRMBlendShapeImporter: ${n3.name} attempts to index ${o3}th morph but not found.`);
            })));
          }));
          const l2 = n3.materialValues;
          l2 && l2.forEach((t2) => {
            if (t2.materialName === void 0 || t2.propertyName === void 0 || t2.targetValue === void 0)
              return;
            const n4 = [];
            e2.scene.traverse((e3) => {
              if (e3.material) {
                const i4 = e3.material;
                Array.isArray(i4) ? n4.push(...i4.filter((e4) => e4.name === t2.materialName && n4.indexOf(e4) === -1)) : i4.name === t2.materialName && n4.indexOf(i4) === -1 && n4.push(i4);
              }
            }), n4.forEach((e3) => {
              s3.addMaterialValue({ material: e3, propertyName: p(t2.propertyName), targetValue: t2.targetValue });
            });
          }), o2.registerBlendShapeGroup(i3, r3, s3);
        }))), o2;
      });
    }
  };
  var y = Object.freeze(new Vector3(0, 0, -1));
  var T = new Quaternion();
  var x;
  !function(e2) {
    e2[e2.Auto = 0] = "Auto", e2[e2.Both = 1] = "Both", e2[e2.ThirdPersonOnly = 2] = "ThirdPersonOnly", e2[e2.FirstPersonOnly = 3] = "FirstPersonOnly";
  }(x || (x = {}));
  var S = class {
    constructor(e2, t2) {
      this.firstPersonFlag = S._parseFirstPersonFlag(e2), this.primitives = t2;
    }
    static _parseFirstPersonFlag(e2) {
      switch (e2) {
        case "Both":
          return x.Both;
        case "ThirdPersonOnly":
          return x.ThirdPersonOnly;
        case "FirstPersonOnly":
          return x.FirstPersonOnly;
        default:
          return x.Auto;
      }
    }
  };
  var M = class {
    constructor(e2, t2, n2) {
      this._meshAnnotations = [], this._firstPersonOnlyLayer = M._DEFAULT_FIRSTPERSON_ONLY_LAYER, this._thirdPersonOnlyLayer = M._DEFAULT_THIRDPERSON_ONLY_LAYER, this._initialized = false, this._firstPersonBone = e2, this._firstPersonBoneOffset = t2, this._meshAnnotations = n2;
    }
    get firstPersonBone() {
      return this._firstPersonBone;
    }
    get meshAnnotations() {
      return this._meshAnnotations;
    }
    getFirstPersonWorldDirection(e2) {
      return e2.copy(y).applyQuaternion(g(this._firstPersonBone, T));
    }
    get firstPersonOnlyLayer() {
      return this._firstPersonOnlyLayer;
    }
    get thirdPersonOnlyLayer() {
      return this._thirdPersonOnlyLayer;
    }
    getFirstPersonBoneOffset(e2) {
      return e2.copy(this._firstPersonBoneOffset);
    }
    getFirstPersonWorldPosition(t2) {
      const n2 = this._firstPersonBoneOffset, i2 = new Vector4(n2.x, n2.y, n2.z, 1);
      return i2.applyMatrix4(this._firstPersonBone.matrixWorld), t2.set(i2.x, i2.y, i2.z);
    }
    setup({ firstPersonOnlyLayer: e2 = M._DEFAULT_FIRSTPERSON_ONLY_LAYER, thirdPersonOnlyLayer: t2 = M._DEFAULT_THIRDPERSON_ONLY_LAYER } = {}) {
      this._initialized || (this._initialized = true, this._firstPersonOnlyLayer = e2, this._thirdPersonOnlyLayer = t2, this._meshAnnotations.forEach((e3) => {
        e3.firstPersonFlag === x.FirstPersonOnly ? e3.primitives.forEach((e4) => {
          e4.layers.set(this._firstPersonOnlyLayer);
        }) : e3.firstPersonFlag === x.ThirdPersonOnly ? e3.primitives.forEach((e4) => {
          e4.layers.set(this._thirdPersonOnlyLayer);
        }) : e3.firstPersonFlag === x.Auto && this._createHeadlessModel(e3.primitives);
      }));
    }
    _excludeTriangles(e2, t2, n2, i2) {
      let r2 = 0;
      if (t2 != null && t2.length > 0)
        for (let o2 = 0; o2 < e2.length; o2 += 3) {
          const s2 = e2[o2], a2 = e2[o2 + 1], l2 = e2[o2 + 2], d2 = t2[s2], h2 = n2[s2];
          if (d2[0] > 0 && i2.includes(h2[0]))
            continue;
          if (d2[1] > 0 && i2.includes(h2[1]))
            continue;
          if (d2[2] > 0 && i2.includes(h2[2]))
            continue;
          if (d2[3] > 0 && i2.includes(h2[3]))
            continue;
          const u2 = t2[a2], c2 = n2[a2];
          if (u2[0] > 0 && i2.includes(c2[0]))
            continue;
          if (u2[1] > 0 && i2.includes(c2[1]))
            continue;
          if (u2[2] > 0 && i2.includes(c2[2]))
            continue;
          if (u2[3] > 0 && i2.includes(c2[3]))
            continue;
          const p2 = t2[l2], m2 = n2[l2];
          p2[0] > 0 && i2.includes(m2[0]) || (p2[1] > 0 && i2.includes(m2[1]) || p2[2] > 0 && i2.includes(m2[2]) || p2[3] > 0 && i2.includes(m2[3]) || (e2[r2++] = s2, e2[r2++] = a2, e2[r2++] = l2));
        }
      return r2;
    }
    _createErasedMesh(t2, n2) {
      const i2 = new SkinnedMesh(t2.geometry.clone(), t2.material);
      i2.name = `${t2.name}(erase)`, i2.frustumCulled = t2.frustumCulled, i2.layers.set(this._firstPersonOnlyLayer);
      const r2 = i2.geometry, o2 = r2.getAttribute("skinIndex").array, s2 = [];
      for (let e2 = 0; e2 < o2.length; e2 += 4)
        s2.push([o2[e2], o2[e2 + 1], o2[e2 + 2], o2[e2 + 3]]);
      const a2 = r2.getAttribute("skinWeight").array, l2 = [];
      for (let e2 = 0; e2 < a2.length; e2 += 4)
        l2.push([a2[e2], a2[e2 + 1], a2[e2 + 2], a2[e2 + 3]]);
      const d2 = r2.getIndex();
      if (!d2)
        throw new Error("The geometry doesn't have an index buffer");
      const h2 = Array.from(d2.array), u2 = this._excludeTriangles(h2, l2, s2, n2), c2 = [];
      for (let e2 = 0; e2 < u2; e2++)
        c2[e2] = h2[e2];
      return r2.setIndex(c2), t2.onBeforeRender && (i2.onBeforeRender = t2.onBeforeRender), i2.bind(new Skeleton(t2.skeleton.bones, t2.skeleton.boneInverses), new Matrix4()), i2;
    }
    _createHeadlessModelForSkinnedMesh(e2, t2) {
      const n2 = [];
      if (t2.skeleton.bones.forEach((e3, t3) => {
        this._isEraseTarget(e3) && n2.push(t3);
      }), !n2.length)
        return t2.layers.enable(this._thirdPersonOnlyLayer), void t2.layers.enable(this._firstPersonOnlyLayer);
      t2.layers.set(this._thirdPersonOnlyLayer);
      const i2 = this._createErasedMesh(t2, n2);
      e2.add(i2);
    }
    _createHeadlessModel(e2) {
      e2.forEach((e3) => {
        if (e3.type === "SkinnedMesh") {
          const t2 = e3;
          this._createHeadlessModelForSkinnedMesh(t2.parent, t2);
        } else
          this._isEraseTarget(e3) && e3.layers.set(this._thirdPersonOnlyLayer);
      });
    }
    _isEraseTarget(e2) {
      return e2 === this._firstPersonBone || !!e2.parent && this._isEraseTarget(e2.parent);
    }
  };
  M._DEFAULT_FIRSTPERSON_ONLY_LAYER = 9, M._DEFAULT_THIRDPERSON_ONLY_LAYER = 10;
  var E = class {
    import(n2, i2) {
      var r2;
      return t(this, void 0, void 0, function* () {
        const t2 = (r2 = n2.parser.json.extensions) === null || r2 === void 0 ? void 0 : r2.VRM;
        if (!t2)
          return null;
        const o2 = t2.firstPerson;
        if (!o2)
          return null;
        const s2 = o2.firstPersonBone;
        let a2;
        if (a2 = s2 === void 0 || s2 === -1 ? i2.getBoneNode(h.HumanoidBoneName.Head) : yield n2.parser.getDependency("node", s2), !a2)
          return console.warn("VRMFirstPersonImporter: Could not find firstPersonBone of the VRM"), null;
        const l2 = o2.firstPersonBoneOffset ? new Vector3(o2.firstPersonBoneOffset.x, o2.firstPersonBoneOffset.y, -o2.firstPersonBoneOffset.z) : new Vector3(0, 0.06, 0), d2 = [], u2 = yield c(n2);
        return Array.from(u2.entries()).forEach(([e2, t3]) => {
          const i3 = n2.parser.json.nodes[e2], r3 = o2.meshAnnotations ? o2.meshAnnotations.find((e3) => e3.mesh === i3.mesh) : void 0;
          d2.push(new S(r3 == null ? void 0 : r3.firstPersonFlag, t3));
        }), new M(a2, l2, d2);
      });
    }
  };
  var L = class {
    constructor(e2, t2) {
      this.node = e2, this.humanLimit = t2;
    }
  };
  function w(e2) {
    return e2.invert ? e2.invert() : e2.inverse(), e2;
  }
  var R = new Vector3();
  var P = new Quaternion();
  var A = class {
    constructor(e2, t2) {
      this.restPose = {}, this.humanBones = this._createHumanBones(e2), this.humanDescription = t2, this.restPose = this.getPose();
    }
    getPose() {
      const e2 = {};
      return Object.keys(this.humanBones).forEach((t2) => {
        const n2 = this.getBoneNode(t2);
        if (!n2)
          return;
        if (e2[t2])
          return;
        R.set(0, 0, 0), P.identity();
        const i2 = this.restPose[t2];
        (i2 == null ? void 0 : i2.position) && R.fromArray(i2.position).negate(), (i2 == null ? void 0 : i2.rotation) && w(P.fromArray(i2.rotation)), R.add(n2.position), P.premultiply(n2.quaternion), e2[t2] = { position: R.toArray(), rotation: P.toArray() };
      }, {}), e2;
    }
    setPose(e2) {
      Object.keys(e2).forEach((t2) => {
        const n2 = e2[t2], i2 = this.getBoneNode(t2);
        if (!i2)
          return;
        const r2 = this.restPose[t2];
        r2 && (n2.position && (i2.position.fromArray(n2.position), r2.position && i2.position.add(R.fromArray(r2.position))), n2.rotation && (i2.quaternion.fromArray(n2.rotation), r2.rotation && i2.quaternion.multiply(P.fromArray(r2.rotation))));
      });
    }
    resetPose() {
      Object.entries(this.restPose).forEach(([e2, t2]) => {
        const n2 = this.getBoneNode(e2);
        n2 && ((t2 == null ? void 0 : t2.position) && n2.position.fromArray(t2.position), (t2 == null ? void 0 : t2.rotation) && n2.quaternion.fromArray(t2.rotation));
      });
    }
    getBone(e2) {
      var t2;
      return (t2 = this.humanBones[e2][0]) !== null && t2 !== void 0 ? t2 : void 0;
    }
    getBones(e2) {
      var t2;
      return (t2 = this.humanBones[e2]) !== null && t2 !== void 0 ? t2 : [];
    }
    getBoneNode(e2) {
      var t2, n2;
      return (n2 = (t2 = this.humanBones[e2][0]) === null || t2 === void 0 ? void 0 : t2.node) !== null && n2 !== void 0 ? n2 : null;
    }
    getBoneNodes(e2) {
      var t2, n2;
      return (n2 = (t2 = this.humanBones[e2]) === null || t2 === void 0 ? void 0 : t2.map((e3) => e3.node)) !== null && n2 !== void 0 ? n2 : [];
    }
    _createHumanBones(e2) {
      const t2 = Object.values(h.HumanoidBoneName).reduce((e3, t3) => (e3[t3] = [], e3), {});
      return e2.forEach((e3) => {
        t2[e3.name].push(e3.bone);
      }), t2;
    }
  };
  var C = class {
    import(n2) {
      var i2;
      return t(this, void 0, void 0, function* () {
        const r2 = (i2 = n2.parser.json.extensions) === null || i2 === void 0 ? void 0 : i2.VRM;
        if (!r2)
          return null;
        const o2 = r2.humanoid;
        if (!o2)
          return null;
        const s2 = [];
        o2.humanBones && (yield Promise.all(o2.humanBones.map((i3) => t(this, void 0, void 0, function* () {
          if (!i3.bone || i3.node == null)
            return;
          const t2 = yield n2.parser.getDependency("node", i3.node);
          s2.push({ name: i3.bone, bone: new L(t2, { axisLength: i3.axisLength, center: i3.center && new Vector3(i3.center.x, i3.center.y, i3.center.z), max: i3.max && new Vector3(i3.max.x, i3.max.y, i3.max.z), min: i3.min && new Vector3(i3.min.x, i3.min.y, i3.min.z), useDefaultValues: i3.useDefaultValues }) });
        }))));
        const a2 = { armStretch: o2.armStretch, legStretch: o2.legStretch, upperArmTwist: o2.upperArmTwist, lowerArmTwist: o2.lowerArmTwist, upperLegTwist: o2.upperLegTwist, lowerLegTwist: o2.lowerLegTwist, feetSpacing: o2.feetSpacing, hasTranslationDoF: o2.hasTranslationDoF };
        return new A(s2, a2);
      });
    }
  };
  var O = class {
    constructor(e2, t2, n2) {
      this.curve = [0, 0, 0, 1, 1, 1, 1, 0], this.curveXRangeDegree = 90, this.curveYRangeDegree = 10, e2 !== void 0 && (this.curveXRangeDegree = e2), t2 !== void 0 && (this.curveYRangeDegree = t2), n2 !== void 0 && (this.curve = n2);
    }
    map(e2) {
      const t2 = Math.min(Math.max(e2, 0), this.curveXRangeDegree) / this.curveXRangeDegree;
      return this.curveYRangeDegree * ((e3, t3) => {
        if (e3.length < 8)
          throw new Error("evaluateCurve: Invalid curve detected! (Array length must be 8 at least)");
        if (e3.length % 4 != 0)
          throw new Error("evaluateCurve: Invalid curve detected! (Array length must be multiples of 4");
        let n2;
        for (n2 = 0; ; n2++) {
          if (e3.length <= 4 * n2)
            return e3[4 * n2 - 3];
          if (t3 <= e3[4 * n2])
            break;
        }
        const i2 = n2 - 1;
        if (i2 < 0)
          return e3[4 * i2 + 5];
        const r2 = e3[4 * i2], o2 = (t3 - r2) / (e3[4 * n2] - r2);
        return ((e4, t4, n3, i3, r3) => {
          const o3 = r3 * r3 * r3, s2 = r3 * r3;
          return e4 + (t4 - e4) * (-2 * o3 + 3 * s2) + n3 * (o3 - 2 * s2 + r3) + i3 * (o3 - s2);
        })(e3[4 * i2 + 1], e3[4 * n2 + 1], e3[4 * i2 + 3], e3[4 * n2 + 2], o2);
      })(this.curve, t2);
    }
  };
  var b = class {
  };
  var I = class extends b {
    constructor(e2, t2, n2, i2) {
      super(), this.type = h.FirstPersonLookAtTypeName.BlendShape, this._curveHorizontal = t2, this._curveVerticalDown = n2, this._curveVerticalUp = i2, this._blendShapeProxy = e2;
    }
    name() {
      return h.FirstPersonLookAtTypeName.BlendShape;
    }
    lookAt(e2) {
      const t2 = e2.x, n2 = e2.y;
      t2 < 0 ? (this._blendShapeProxy.setValue(h.BlendShapePresetName.Lookup, 0), this._blendShapeProxy.setValue(h.BlendShapePresetName.Lookdown, this._curveVerticalDown.map(-t2))) : (this._blendShapeProxy.setValue(h.BlendShapePresetName.Lookdown, 0), this._blendShapeProxy.setValue(h.BlendShapePresetName.Lookup, this._curveVerticalUp.map(t2))), n2 < 0 ? (this._blendShapeProxy.setValue(h.BlendShapePresetName.Lookleft, 0), this._blendShapeProxy.setValue(h.BlendShapePresetName.Lookright, this._curveHorizontal.map(-n2))) : (this._blendShapeProxy.setValue(h.BlendShapePresetName.Lookright, 0), this._blendShapeProxy.setValue(h.BlendShapePresetName.Lookleft, this._curveHorizontal.map(n2)));
    }
  };
  var N = Object.freeze(new Vector3(0, 0, -1));
  var D = new Vector3();
  var U = new Vector3();
  var B = new Vector3();
  var V = new Quaternion();
  var G = class {
    constructor(t2, n2) {
      this.autoUpdate = true, this._euler = new Euler(0, 0, 0, G.EULER_ORDER), this.firstPerson = t2, this.applyer = n2;
    }
    getLookAtWorldDirection(e2) {
      const t2 = g(this.firstPerson.firstPersonBone, V);
      return e2.copy(N).applyEuler(this._euler).applyQuaternion(t2);
    }
    lookAt(e2) {
      this._calcEuler(this._euler, e2), this.applyer && this.applyer.lookAt(this._euler);
    }
    update(e2) {
      this.target && this.autoUpdate && (this.lookAt(this.target.getWorldPosition(D)), this.applyer && this.applyer.lookAt(this._euler));
    }
    _calcEuler(e2, t2) {
      const n2 = this.firstPerson.getFirstPersonWorldPosition(U), i2 = B.copy(t2).sub(n2).normalize();
      return i2.applyQuaternion(w(g(this.firstPerson.firstPersonBone, V))), e2.x = Math.atan2(i2.y, Math.sqrt(i2.x * i2.x + i2.z * i2.z)), e2.y = Math.atan2(-i2.x, -i2.z), e2;
    }
  };
  G.EULER_ORDER = "YXZ";
  var F = new Euler(0, 0, 0, G.EULER_ORDER);
  var k = class extends b {
    constructor(e2, t2, n2, i2, r2) {
      super(), this.type = h.FirstPersonLookAtTypeName.Bone, this._curveHorizontalInner = t2, this._curveHorizontalOuter = n2, this._curveVerticalDown = i2, this._curveVerticalUp = r2, this._leftEye = e2.getBoneNode(h.HumanoidBoneName.LeftEye), this._rightEye = e2.getBoneNode(h.HumanoidBoneName.RightEye);
    }
    lookAt(e2) {
      const t2 = e2.x, n2 = e2.y;
      this._leftEye && (F.x = t2 < 0 ? -this._curveVerticalDown.map(-t2) : this._curveVerticalUp.map(t2), F.y = n2 < 0 ? -this._curveHorizontalInner.map(-n2) : this._curveHorizontalOuter.map(n2), this._leftEye.quaternion.setFromEuler(F)), this._rightEye && (F.x = t2 < 0 ? -this._curveVerticalDown.map(-t2) : this._curveVerticalUp.map(t2), F.y = n2 < 0 ? -this._curveHorizontalOuter.map(-n2) : this._curveHorizontalInner.map(n2), this._rightEye.quaternion.setFromEuler(F));
    }
  };
  var H = Math.PI / 180;
  var W = class {
    import(e2, t2, n2, i2) {
      var r2;
      const o2 = (r2 = e2.parser.json.extensions) === null || r2 === void 0 ? void 0 : r2.VRM;
      if (!o2)
        return null;
      const s2 = o2.firstPerson;
      if (!s2)
        return null;
      const a2 = this._importApplyer(s2, n2, i2);
      return new G(t2, a2 || void 0);
    }
    _importApplyer(e2, t2, n2) {
      const i2 = e2.lookAtHorizontalInner, r2 = e2.lookAtHorizontalOuter, o2 = e2.lookAtVerticalDown, s2 = e2.lookAtVerticalUp;
      switch (e2.lookAtTypeName) {
        case h.FirstPersonLookAtTypeName.Bone:
          return i2 === void 0 || r2 === void 0 || o2 === void 0 || s2 === void 0 ? null : new k(n2, this._importCurveMapperBone(i2), this._importCurveMapperBone(r2), this._importCurveMapperBone(o2), this._importCurveMapperBone(s2));
        case h.FirstPersonLookAtTypeName.BlendShape:
          return r2 === void 0 || o2 === void 0 || s2 === void 0 ? null : new I(t2, this._importCurveMapperBlendShape(r2), this._importCurveMapperBlendShape(o2), this._importCurveMapperBlendShape(s2));
        default:
          return null;
      }
    }
    _importCurveMapperBone(e2) {
      return new O(typeof e2.xRange == "number" ? H * e2.xRange : void 0, typeof e2.yRange == "number" ? H * e2.yRange : void 0, e2.curve);
    }
    _importCurveMapperBlendShape(e2) {
      return new O(typeof e2.xRange == "number" ? H * e2.xRange : void 0, e2.yRange, e2.curve);
    }
  };
  var z = (t2, n2) => {
    const i2 = ((t3) => {
      switch (t3) {
        case LinearEncoding:
          return ["Linear", "( value )"];
        case sRGBEncoding:
          return ["sRGB", "( value )"];
        case RGBEEncoding:
          return ["RGBE", "( value )"];
        case RGBM7Encoding:
          return ["RGBM", "( value, 7.0 )"];
        case RGBM16Encoding:
          return ["RGBM", "( value, 16.0 )"];
        case RGBDEncoding:
          return ["RGBD", "( value, 256.0 )"];
        case GammaEncoding:
          return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
        default:
          throw new Error("unsupported encoding: " + t3);
      }
    })(n2);
    return "vec4 " + t2 + "( vec4 value ) { return " + i2[0] + "ToLinear" + i2[1] + "; }";
  };
  var j = 2 * Math.PI;
  var Y;
  var X;
  var q;
  var Q;
  var Z;
  !function(e2) {
    e2[e2.Off = 0] = "Off", e2[e2.Front = 1] = "Front", e2[e2.Back = 2] = "Back";
  }(Y || (Y = {})), function(e2) {
    e2[e2.None = 0] = "None", e2[e2.Normal = 1] = "Normal", e2[e2.LitShadeRate = 2] = "LitShadeRate", e2[e2.UV = 3] = "UV";
  }(X || (X = {})), function(e2) {
    e2[e2.FixedColor = 0] = "FixedColor", e2[e2.MixedLighting = 1] = "MixedLighting";
  }(q || (q = {})), function(e2) {
    e2[e2.None = 0] = "None", e2[e2.WorldCoordinates = 1] = "WorldCoordinates", e2[e2.ScreenCoordinates = 2] = "ScreenCoordinates";
  }(Q || (Q = {})), function(e2) {
    e2[e2.Opaque = 0] = "Opaque", e2[e2.Cutout = 1] = "Cutout", e2[e2.Transparent = 2] = "Transparent", e2[e2.TransparentWithZWrite = 3] = "TransparentWithZWrite";
  }(Z || (Z = {}));
  var $ = class extends ShaderMaterial {
    constructor(t2 = {}) {
      super(), this.isMToonMaterial = true, this.cutoff = 0.5, this.color = new Vector4(1, 1, 1, 1), this.shadeColor = new Vector4(0.97, 0.81, 0.86, 1), this.map = null, this.mainTex_ST = new Vector4(0, 0, 1, 1), this.shadeTexture = null, this.normalMap = null, this.normalMapType = TangentSpaceNormalMap, this.normalScale = new Vector2(1, 1), this.receiveShadowRate = 1, this.receiveShadowTexture = null, this.shadingGradeRate = 1, this.shadingGradeTexture = null, this.shadeShift = 0, this.shadeToony = 0.9, this.lightColorAttenuation = 0, this.indirectLightIntensity = 0.1, this.rimTexture = null, this.rimColor = new Vector4(0, 0, 0, 1), this.rimLightingMix = 0, this.rimFresnelPower = 1, this.rimLift = 0, this.sphereAdd = null, this.emissionColor = new Vector4(0, 0, 0, 1), this.emissiveMap = null, this.outlineWidthTexture = null, this.outlineWidth = 0.5, this.outlineScaledMaxDistance = 1, this.outlineColor = new Vector4(0, 0, 0, 1), this.outlineLightingMix = 1, this.uvAnimMaskTexture = null, this.uvAnimScrollX = 0, this.uvAnimScrollY = 0, this.uvAnimRotation = 0, this.shouldApplyUniforms = true, this._debugMode = X.None, this._blendMode = Z.Opaque, this._outlineWidthMode = Q.None, this._outlineColorMode = q.FixedColor, this._cullMode = Y.Back, this._outlineCullMode = Y.Front, this._isOutline = false, this._uvAnimOffsetX = 0, this._uvAnimOffsetY = 0, this._uvAnimPhase = 0, this.encoding = t2.encoding || LinearEncoding, this.encoding !== LinearEncoding && this.encoding !== sRGBEncoding && console.warn("The specified color encoding does not work properly with MToonMaterial. You might want to use THREE.sRGBEncoding instead."), ["mToonVersion", "shadeTexture_ST", "bumpMap_ST", "receiveShadowTexture_ST", "shadingGradeTexture_ST", "rimTexture_ST", "sphereAdd_ST", "emissionMap_ST", "outlineWidthTexture_ST", "uvAnimMaskTexture_ST", "srcBlend", "dstBlend"].forEach((e2) => {
        t2[e2] !== void 0 && delete t2[e2];
      }), t2.fog = true, t2.lights = true, t2.clipping = true, parseInt(REVISION, 10) < 129 && (t2.skinning = t2.skinning || false), parseInt(REVISION, 10) < 131 && (t2.morphTargets = t2.morphTargets || false, t2.morphNormals = t2.morphNormals || false), t2.uniforms = UniformsUtils.merge([UniformsLib.common, UniformsLib.normalmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, { cutoff: { value: 0.5 }, color: { value: new Color(1, 1, 1) }, colorAlpha: { value: 1 }, shadeColor: { value: new Color(0.97, 0.81, 0.86) }, mainTex_ST: { value: new Vector4(0, 0, 1, 1) }, shadeTexture: { value: null }, receiveShadowRate: { value: 1 }, receiveShadowTexture: { value: null }, shadingGradeRate: { value: 1 }, shadingGradeTexture: { value: null }, shadeShift: { value: 0 }, shadeToony: { value: 0.9 }, lightColorAttenuation: { value: 0 }, indirectLightIntensity: { value: 0.1 }, rimTexture: { value: null }, rimColor: { value: new Color(0, 0, 0) }, rimLightingMix: { value: 0 }, rimFresnelPower: { value: 1 }, rimLift: { value: 0 }, sphereAdd: { value: null }, emissionColor: { value: new Color(0, 0, 0) }, outlineWidthTexture: { value: null }, outlineWidth: { value: 0.5 }, outlineScaledMaxDistance: { value: 1 }, outlineColor: { value: new Color(0, 0, 0) }, outlineLightingMix: { value: 1 }, uvAnimMaskTexture: { value: null }, uvAnimOffsetX: { value: 0 }, uvAnimOffsetY: { value: 0 }, uvAnimTheta: { value: 0 } }]), this.setValues(t2), this._updateShaderCode(), this._applyUniforms();
    }
    get mainTex() {
      return this.map;
    }
    set mainTex(e2) {
      this.map = e2;
    }
    get bumpMap() {
      return this.normalMap;
    }
    set bumpMap(e2) {
      this.normalMap = e2;
    }
    get bumpScale() {
      return this.normalScale.x;
    }
    set bumpScale(e2) {
      this.normalScale.set(e2, e2);
    }
    get emissionMap() {
      return this.emissiveMap;
    }
    set emissionMap(e2) {
      this.emissiveMap = e2;
    }
    get blendMode() {
      return this._blendMode;
    }
    set blendMode(e2) {
      this._blendMode = e2, this.depthWrite = this._blendMode !== Z.Transparent, this.transparent = this._blendMode === Z.Transparent || this._blendMode === Z.TransparentWithZWrite, this._updateShaderCode();
    }
    get debugMode() {
      return this._debugMode;
    }
    set debugMode(e2) {
      this._debugMode = e2, this._updateShaderCode();
    }
    get outlineWidthMode() {
      return this._outlineWidthMode;
    }
    set outlineWidthMode(e2) {
      this._outlineWidthMode = e2, this._updateShaderCode();
    }
    get outlineColorMode() {
      return this._outlineColorMode;
    }
    set outlineColorMode(e2) {
      this._outlineColorMode = e2, this._updateShaderCode();
    }
    get cullMode() {
      return this._cullMode;
    }
    set cullMode(e2) {
      this._cullMode = e2, this._updateCullFace();
    }
    get outlineCullMode() {
      return this._outlineCullMode;
    }
    set outlineCullMode(e2) {
      this._outlineCullMode = e2, this._updateCullFace();
    }
    get zWrite() {
      return this.depthWrite ? 1 : 0;
    }
    set zWrite(e2) {
      this.depthWrite = 0.5 <= e2;
    }
    get isOutline() {
      return this._isOutline;
    }
    set isOutline(e2) {
      this._isOutline = e2, this._updateShaderCode(), this._updateCullFace();
    }
    updateVRMMaterials(e2) {
      this._uvAnimOffsetX = this._uvAnimOffsetX + e2 * this.uvAnimScrollX, this._uvAnimOffsetY = this._uvAnimOffsetY - e2 * this.uvAnimScrollY, this._uvAnimPhase = this._uvAnimPhase + e2 * this.uvAnimRotation, this._applyUniforms();
    }
    copy(e2) {
      return super.copy(e2), this.cutoff = e2.cutoff, this.color.copy(e2.color), this.shadeColor.copy(e2.shadeColor), this.map = e2.map, this.mainTex_ST.copy(e2.mainTex_ST), this.shadeTexture = e2.shadeTexture, this.normalMap = e2.normalMap, this.normalMapType = e2.normalMapType, this.normalScale.copy(this.normalScale), this.receiveShadowRate = e2.receiveShadowRate, this.receiveShadowTexture = e2.receiveShadowTexture, this.shadingGradeRate = e2.shadingGradeRate, this.shadingGradeTexture = e2.shadingGradeTexture, this.shadeShift = e2.shadeShift, this.shadeToony = e2.shadeToony, this.lightColorAttenuation = e2.lightColorAttenuation, this.indirectLightIntensity = e2.indirectLightIntensity, this.rimTexture = e2.rimTexture, this.rimColor.copy(e2.rimColor), this.rimLightingMix = e2.rimLightingMix, this.rimFresnelPower = e2.rimFresnelPower, this.rimLift = e2.rimLift, this.sphereAdd = e2.sphereAdd, this.emissionColor.copy(e2.emissionColor), this.emissiveMap = e2.emissiveMap, this.outlineWidthTexture = e2.outlineWidthTexture, this.outlineWidth = e2.outlineWidth, this.outlineScaledMaxDistance = e2.outlineScaledMaxDistance, this.outlineColor.copy(e2.outlineColor), this.outlineLightingMix = e2.outlineLightingMix, this.uvAnimMaskTexture = e2.uvAnimMaskTexture, this.uvAnimScrollX = e2.uvAnimScrollX, this.uvAnimScrollY = e2.uvAnimScrollY, this.uvAnimRotation = e2.uvAnimRotation, this.debugMode = e2.debugMode, this.blendMode = e2.blendMode, this.outlineWidthMode = e2.outlineWidthMode, this.outlineColorMode = e2.outlineColorMode, this.cullMode = e2.cullMode, this.outlineCullMode = e2.outlineCullMode, this.isOutline = e2.isOutline, this;
    }
    _applyUniforms() {
      this.uniforms.uvAnimOffsetX.value = this._uvAnimOffsetX, this.uniforms.uvAnimOffsetY.value = this._uvAnimOffsetY, this.uniforms.uvAnimTheta.value = j * this._uvAnimPhase, this.shouldApplyUniforms && (this.shouldApplyUniforms = false, this.uniforms.cutoff.value = this.cutoff, this.uniforms.color.value.setRGB(this.color.x, this.color.y, this.color.z), this.uniforms.colorAlpha.value = this.color.w, this.uniforms.shadeColor.value.setRGB(this.shadeColor.x, this.shadeColor.y, this.shadeColor.z), this.uniforms.map.value = this.map, this.uniforms.mainTex_ST.value.copy(this.mainTex_ST), this.uniforms.shadeTexture.value = this.shadeTexture, this.uniforms.normalMap.value = this.normalMap, this.uniforms.normalScale.value.copy(this.normalScale), this.uniforms.receiveShadowRate.value = this.receiveShadowRate, this.uniforms.receiveShadowTexture.value = this.receiveShadowTexture, this.uniforms.shadingGradeRate.value = this.shadingGradeRate, this.uniforms.shadingGradeTexture.value = this.shadingGradeTexture, this.uniforms.shadeShift.value = this.shadeShift, this.uniforms.shadeToony.value = this.shadeToony, this.uniforms.lightColorAttenuation.value = this.lightColorAttenuation, this.uniforms.indirectLightIntensity.value = this.indirectLightIntensity, this.uniforms.rimTexture.value = this.rimTexture, this.uniforms.rimColor.value.setRGB(this.rimColor.x, this.rimColor.y, this.rimColor.z), this.uniforms.rimLightingMix.value = this.rimLightingMix, this.uniforms.rimFresnelPower.value = this.rimFresnelPower, this.uniforms.rimLift.value = this.rimLift, this.uniforms.sphereAdd.value = this.sphereAdd, this.uniforms.emissionColor.value.setRGB(this.emissionColor.x, this.emissionColor.y, this.emissionColor.z), this.uniforms.emissiveMap.value = this.emissiveMap, this.uniforms.outlineWidthTexture.value = this.outlineWidthTexture, this.uniforms.outlineWidth.value = this.outlineWidth, this.uniforms.outlineScaledMaxDistance.value = this.outlineScaledMaxDistance, this.uniforms.outlineColor.value.setRGB(this.outlineColor.x, this.outlineColor.y, this.outlineColor.z), this.uniforms.outlineLightingMix.value = this.outlineLightingMix, this.uniforms.uvAnimMaskTexture.value = this.uvAnimMaskTexture, this.encoding === sRGBEncoding && (this.uniforms.color.value.convertSRGBToLinear(), this.uniforms.shadeColor.value.convertSRGBToLinear(), this.uniforms.rimColor.value.convertSRGBToLinear(), this.uniforms.emissionColor.value.convertSRGBToLinear(), this.uniforms.outlineColor.value.convertSRGBToLinear()), this._updateCullFace());
    }
    _updateShaderCode() {
      const t2 = this.outlineWidthTexture !== null, n2 = this.map !== null || this.shadeTexture !== null || this.receiveShadowTexture !== null || this.shadingGradeTexture !== null || this.rimTexture !== null || this.uvAnimMaskTexture !== null;
      this.defines = { THREE_VRM_THREE_REVISION: parseInt(REVISION, 10), OUTLINE: this._isOutline, BLENDMODE_OPAQUE: this._blendMode === Z.Opaque, BLENDMODE_CUTOUT: this._blendMode === Z.Cutout, BLENDMODE_TRANSPARENT: this._blendMode === Z.Transparent || this._blendMode === Z.TransparentWithZWrite, MTOON_USE_UV: t2 || n2, MTOON_UVS_VERTEX_ONLY: t2 && !n2, USE_SHADETEXTURE: this.shadeTexture !== null, USE_RECEIVESHADOWTEXTURE: this.receiveShadowTexture !== null, USE_SHADINGGRADETEXTURE: this.shadingGradeTexture !== null, USE_RIMTEXTURE: this.rimTexture !== null, USE_SPHEREADD: this.sphereAdd !== null, USE_OUTLINEWIDTHTEXTURE: this.outlineWidthTexture !== null, USE_UVANIMMASKTEXTURE: this.uvAnimMaskTexture !== null, DEBUG_NORMAL: this._debugMode === X.Normal, DEBUG_LITSHADERATE: this._debugMode === X.LitShadeRate, DEBUG_UV: this._debugMode === X.UV, OUTLINE_WIDTH_WORLD: this._outlineWidthMode === Q.WorldCoordinates, OUTLINE_WIDTH_SCREEN: this._outlineWidthMode === Q.ScreenCoordinates, OUTLINE_COLOR_FIXED: this._outlineColorMode === q.FixedColor, OUTLINE_COLOR_MIXED: this._outlineColorMode === q.MixedLighting };
      const i2 = (this.shadeTexture !== null ? z("shadeTextureTexelToLinear", this.shadeTexture.encoding) + "\n" : "") + (this.sphereAdd !== null ? z("sphereAddTexelToLinear", this.sphereAdd.encoding) + "\n" : "") + (this.rimTexture !== null ? z("rimTextureTexelToLinear", this.rimTexture.encoding) + "\n" : "");
      this.vertexShader = "// #define PHONG\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n  varying vec3 vNormal;\n#endif\n\n#include <common>\n\n// #include <uv_pars_vertex>\n#ifdef MTOON_USE_UV\n  #ifdef MTOON_UVS_VERTEX_ONLY\n    vec2 vUv;\n  #else\n    varying vec2 vUv;\n  #endif\n\n  uniform vec4 mainTex_ST;\n#endif\n\n#include <uv2_pars_vertex>\n// #include <displacementmap_pars_vertex>\n// #include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n#ifdef USE_OUTLINEWIDTHTEXTURE\n  uniform sampler2D outlineWidthTexture;\n#endif\n\nuniform float outlineWidth;\nuniform float outlineScaledMaxDistance;\n\nvoid main() {\n\n  // #include <uv_vertex>\n  #ifdef MTOON_USE_UV\n    vUv = uv;\n    vUv.y = 1.0 - vUv.y; // uv.y is opposite from UniVRM's\n    vUv = mainTex_ST.st + mainTex_ST.pq * vUv;\n    vUv.y = 1.0 - vUv.y; // reverting the previous flip\n  #endif\n\n  #include <uv2_vertex>\n  #include <color_vertex>\n\n  #include <beginnormal_vertex>\n  #include <morphnormal_vertex>\n  #include <skinbase_vertex>\n  #include <skinnormal_vertex>\n\n  // we need this to compute the outline properly\n  objectNormal = normalize( objectNormal );\n\n  #include <defaultnormal_vertex>\n\n  #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n    vNormal = normalize( transformedNormal );\n  #endif\n\n  #include <begin_vertex>\n\n  #include <morphtarget_vertex>\n  #include <skinning_vertex>\n  // #include <displacementmap_vertex>\n  #include <project_vertex>\n  #include <logdepthbuf_vertex>\n  #include <clipping_planes_vertex>\n\n  vViewPosition = - mvPosition.xyz;\n\n  float outlineTex = 1.0;\n\n  #ifdef OUTLINE\n    #ifdef USE_OUTLINEWIDTHTEXTURE\n      outlineTex = texture2D( outlineWidthTexture, vUv ).r;\n    #endif\n\n    #ifdef OUTLINE_WIDTH_WORLD\n      float worldNormalLength = length( transformedNormal );\n      vec3 outlineOffset = 0.01 * outlineWidth * outlineTex * worldNormalLength * objectNormal;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( outlineOffset + transformed, 1.0 );\n    #endif\n\n    #ifdef OUTLINE_WIDTH_SCREEN\n      vec3 clipNormal = ( projectionMatrix * modelViewMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n      vec2 projectedNormal = normalize( clipNormal.xy );\n      projectedNormal *= min( gl_Position.w, outlineScaledMaxDistance );\n      projectedNormal.x *= projectionMatrix[ 0 ].x / projectionMatrix[ 1 ].y;\n      gl_Position.xy += 0.01 * outlineWidth * outlineTex * projectedNormal.xy;\n    #endif\n\n    gl_Position.z += 1E-6 * gl_Position.w; // anti-artifact magic\n  #endif\n\n  #include <worldpos_vertex>\n  // #include <envmap_vertex>\n  #include <shadowmap_vertex>\n  #include <fog_vertex>\n\n}", this.fragmentShader = i2 + '// #define PHONG\n\n#ifdef BLENDMODE_CUTOUT\n  uniform float cutoff;\n#endif\n\nuniform vec3 color;\nuniform float colorAlpha;\nuniform vec3 shadeColor;\n#ifdef USE_SHADETEXTURE\n  uniform sampler2D shadeTexture;\n#endif\n\nuniform float receiveShadowRate;\n#ifdef USE_RECEIVESHADOWTEXTURE\n  uniform sampler2D receiveShadowTexture;\n#endif\n\nuniform float shadingGradeRate;\n#ifdef USE_SHADINGGRADETEXTURE\n  uniform sampler2D shadingGradeTexture;\n#endif\n\nuniform float shadeShift;\nuniform float shadeToony;\nuniform float lightColorAttenuation;\nuniform float indirectLightIntensity;\n\n#ifdef USE_RIMTEXTURE\n  uniform sampler2D rimTexture;\n#endif\nuniform vec3 rimColor;\nuniform float rimLightingMix;\nuniform float rimFresnelPower;\nuniform float rimLift;\n\n#ifdef USE_SPHEREADD\n  uniform sampler2D sphereAdd;\n#endif\n\nuniform vec3 emissionColor;\n\nuniform vec3 outlineColor;\nuniform float outlineLightingMix;\n\n#ifdef USE_UVANIMMASKTEXTURE\n  uniform sampler2D uvAnimMaskTexture;\n#endif\n\nuniform float uvAnimOffsetX;\nuniform float uvAnimOffsetY;\nuniform float uvAnimTheta;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n\n// #include <uv_pars_fragment>\n#if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )\n  varying vec2 vUv;\n#endif\n\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n// #include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n// #include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n// #include <envmap_common_pars_fragment>\n// #include <envmap_pars_fragment>\n// #include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n\n// #include <bsdfs>\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n    return RECIPROCAL_PI * diffuseColor;\n}\n\n#include <lights_pars_begin>\n\n// #include <lights_phong_pars_fragment>\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n  varying vec3 vNormal;\n#endif\n\nstruct MToonMaterial {\n  vec3 diffuseColor;\n  vec3 shadeColor;\n  float shadingGrade;\n  float receiveShadow;\n};\n\n#define Material_LightProbeLOD( material ) (0)\n\n#include <shadowmap_pars_fragment>\n// #include <bumpmap_pars_fragment>\n\n// #include <normalmap_pars_fragment>\n#ifdef USE_NORMALMAP\n\n  uniform sampler2D normalMap;\n  uniform vec2 normalScale;\n\n#endif\n\n#ifdef OBJECTSPACE_NORMALMAP\n\n  uniform mat3 normalMatrix;\n\n#endif\n\n#if ! defined ( USE_TANGENT ) && defined ( TANGENTSPACE_NORMALMAP )\n\n  // Per-Pixel Tangent Space Normal Mapping\n  // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n  // three-vrm specific change: it requires `uv` as an input in order to support uv scrolls\n\n  // Temporary compat against shader change @ Three.js r126\n  // See: #21205, #21307, #21299\n  #if THREE_VRM_THREE_REVISION >= 126\n\n    vec3 perturbNormal2Arb( vec2 uv, vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\n      vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n      vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n      vec2 st0 = dFdx( uv.st );\n      vec2 st1 = dFdy( uv.st );\n\n      vec3 N = normalize( surf_norm );\n\n      vec3 q1perp = cross( q1, N );\n      vec3 q0perp = cross( N, q0 );\n\n      vec3 T = q1perp * st0.x + q0perp * st1.x;\n      vec3 B = q1perp * st0.y + q0perp * st1.y;\n\n      // three-vrm specific change: Workaround for the issue that happens when delta of uv = 0.0\n      // TODO: Is this still required? Or shall I make a PR about it?\n      if ( length( T ) == 0.0 || length( B ) == 0.0 ) {\n        return surf_norm;\n      }\n\n      float det = max( dot( T, T ), dot( B, B ) );\n      float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\n      return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\n    }\n\n  #else\n\n    vec3 perturbNormal2Arb( vec2 uv, vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\n      // Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n      vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n      vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n      vec2 st0 = dFdx( uv.st );\n      vec2 st1 = dFdy( uv.st );\n\n      float scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude\n\n      vec3 S = ( q0 * st1.t - q1 * st0.t ) * scale;\n      vec3 T = ( - q0 * st1.s + q1 * st0.s ) * scale;\n\n      // three-vrm specific change: Workaround for the issue that happens when delta of uv = 0.0\n      // TODO: Is this still required? Or shall I make a PR about it?\n\n      if ( length( S ) == 0.0 || length( T ) == 0.0 ) {\n        return surf_norm;\n      }\n\n      S = normalize( S );\n      T = normalize( T );\n      vec3 N = normalize( surf_norm );\n\n      #ifdef DOUBLE_SIDED\n\n        // Workaround for Adreno GPUs gl_FrontFacing bug. See #15850 and #10331\n\n        bool frontFacing = dot( cross( S, T ), N ) > 0.0;\n\n        mapN.xy *= ( float( frontFacing ) * 2.0 - 1.0 );\n\n      #else\n\n        mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n      #endif\n\n      mat3 tsn = mat3( S, T, N );\n      return normalize( tsn * mapN );\n\n    }\n\n  #endif\n\n#endif\n\n// #include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\n// == lighting stuff ===========================================================\nfloat getLightIntensity(\n  const in IncidentLight directLight,\n  const in GeometricContext geometry,\n  const in float shadow,\n  const in float shadingGrade\n) {\n  float lightIntensity = dot( geometry.normal, directLight.direction );\n  lightIntensity = 0.5 + 0.5 * lightIntensity;\n  lightIntensity = lightIntensity * shadow;\n  lightIntensity = lightIntensity * shadingGrade;\n  lightIntensity = lightIntensity * 2.0 - 1.0;\n  return shadeToony == 1.0\n    ? step( shadeShift, lightIntensity )\n    : smoothstep( shadeShift, shadeShift + ( 1.0 - shadeToony ), lightIntensity );\n}\n\nvec3 getLighting( const in vec3 lightColor ) {\n  vec3 lighting = lightColor;\n  lighting = mix(\n    lighting,\n    vec3( max( 0.001, max( lighting.x, max( lighting.y, lighting.z ) ) ) ),\n    lightColorAttenuation\n  );\n\n  #ifndef PHYSICALLY_CORRECT_LIGHTS\n    lighting *= PI;\n  #endif\n\n  return lighting;\n}\n\nvec3 getDiffuse(\n  const in MToonMaterial material,\n  const in float lightIntensity,\n  const in vec3 lighting\n) {\n  #ifdef DEBUG_LITSHADERATE\n    return vec3( BRDF_Lambert( lightIntensity * lighting ) );\n  #endif\n\n  return lighting * BRDF_Lambert( mix( material.shadeColor, material.diffuseColor, lightIntensity ) );\n}\n\n// == post correction ==========================================================\nvoid postCorrection() {\n  #include <tonemapping_fragment>\n  #include <encodings_fragment>\n  #include <fog_fragment>\n  #include <premultiplied_alpha_fragment>\n  #include <dithering_fragment>\n}\n\n// == main procedure ===========================================================\nvoid main() {\n  #include <clipping_planes_fragment>\n\n  vec2 uv = vec2(0.5, 0.5);\n\n  #if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )\n    uv = vUv;\n\n    float uvAnimMask = 1.0;\n    #ifdef USE_UVANIMMASKTEXTURE\n      uvAnimMask = texture2D( uvAnimMaskTexture, uv ).x;\n    #endif\n\n    uv = uv + vec2( uvAnimOffsetX, uvAnimOffsetY ) * uvAnimMask;\n    float uvRotCos = cos( uvAnimTheta * uvAnimMask );\n    float uvRotSin = sin( uvAnimTheta * uvAnimMask );\n    uv = mat2( uvRotCos, uvRotSin, -uvRotSin, uvRotCos ) * ( uv - 0.5 ) + 0.5;\n  #endif\n\n  #ifdef DEBUG_UV\n    gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n    #if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )\n      gl_FragColor = vec4( uv, 0.0, 1.0 );\n    #endif\n    return;\n  #endif\n\n  vec4 diffuseColor = vec4( color, colorAlpha );\n  ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n  vec3 totalEmissiveRadiance = emissionColor;\n\n  #include <logdepthbuf_fragment>\n\n  // #include <map_fragment>\n  #ifdef USE_MAP\n    diffuseColor *= mapTexelToLinear( texture2D( map, uv ) );\n  #endif\n\n  #include <color_fragment>\n  // #include <alphamap_fragment>\n\n  // -- MToon: alpha -----------------------------------------------------------\n  // #include <alphatest_fragment>\n  #ifdef BLENDMODE_CUTOUT\n    if ( diffuseColor.a <= cutoff ) { discard; }\n    diffuseColor.a = 1.0;\n  #endif\n\n  #ifdef BLENDMODE_OPAQUE\n    diffuseColor.a = 1.0;\n  #endif\n\n  #if defined( OUTLINE ) && defined( OUTLINE_COLOR_FIXED ) // omitting DebugMode\n    gl_FragColor = vec4( outlineColor, diffuseColor.a );\n    postCorrection();\n    return;\n  #endif\n\n  // #include <specularmap_fragment>\n  #include <normal_fragment_begin>\n\n  #ifdef OUTLINE\n    normal *= -1.0;\n  #endif\n\n  // #include <normal_fragment_maps>\n\n  #ifdef OBJECTSPACE_NORMALMAP\n\n    normal = texture2D( normalMap, uv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals\n\n    #ifdef FLIP_SIDED\n\n      normal = - normal;\n\n    #endif\n\n    #ifdef DOUBLE_SIDED\n\n      // Temporary compat against shader change @ Three.js r126\n      // See: #21205, #21307, #21299\n      #if THREE_VRM_THREE_REVISION >= 126\n\n        normal = normal * faceDirection;\n\n      #else\n\n        normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n      #endif\n\n    #endif\n\n    normal = normalize( normalMatrix * normal );\n\n  #elif defined( TANGENTSPACE_NORMALMAP )\n\n    vec3 mapN = texture2D( normalMap, uv ).xyz * 2.0 - 1.0;\n    mapN.xy *= normalScale;\n\n    #ifdef USE_TANGENT\n\n      normal = normalize( vTBN * mapN );\n\n    #else\n\n      // Temporary compat against shader change @ Three.js r126\n      // See: #21205, #21307, #21299\n      #if THREE_VRM_THREE_REVISION >= 126\n\n        normal = perturbNormal2Arb( uv, -vViewPosition, normal, mapN, faceDirection );\n\n      #else\n\n        normal = perturbNormal2Arb( uv, -vViewPosition, normal, mapN );\n\n      #endif\n\n    #endif\n\n  #endif\n\n  // #include <emissivemap_fragment>\n  #ifdef USE_EMISSIVEMAP\n    totalEmissiveRadiance *= emissiveMapTexelToLinear( texture2D( emissiveMap, uv ) ).rgb;\n  #endif\n\n  #ifdef DEBUG_NORMAL\n    gl_FragColor = vec4( 0.5 + 0.5 * normal, 1.0 );\n    return;\n  #endif\n\n  // -- MToon: lighting --------------------------------------------------------\n  // accumulation\n  // #include <lights_phong_fragment>\n  MToonMaterial material;\n\n  material.diffuseColor = diffuseColor.rgb;\n\n  material.shadeColor = shadeColor;\n  #ifdef USE_SHADETEXTURE\n    material.shadeColor *= shadeTextureTexelToLinear( texture2D( shadeTexture, uv ) ).rgb;\n  #endif\n\n  material.shadingGrade = 1.0;\n  #ifdef USE_SHADINGGRADETEXTURE\n    material.shadingGrade = 1.0 - shadingGradeRate * ( 1.0 - texture2D( shadingGradeTexture, uv ).r );\n  #endif\n\n  material.receiveShadow = receiveShadowRate;\n  #ifdef USE_RECEIVESHADOWTEXTURE\n    material.receiveShadow *= texture2D( receiveShadowTexture, uv ).a;\n  #endif\n\n  // #include <lights_fragment_begin>\n  GeometricContext geometry;\n\n  geometry.position = - vViewPosition;\n  geometry.normal = normal;\n  geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\n  IncidentLight directLight;\n  vec3 lightingSum = vec3( 0.0 );\n\n  // since these variables will be used in unrolled loop, we have to define in prior\n  float atten, shadow, lightIntensity;\n  vec3 lighting;\n\n  #if ( NUM_POINT_LIGHTS > 0 )\n    PointLight pointLight;\n\n    #if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n    PointLightShadow pointLightShadow;\n    #endif\n\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n      pointLight = pointLights[ i ];\n\n      #if THREE_VRM_THREE_REVISION >= 132\n        getPointLightInfo( pointLight, geometry, directLight );\n      #else\n        getPointDirectLightIrradiance( pointLight, geometry, directLight );\n      #endif\n\n      atten = 1.0;\n      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n      pointLightShadow = pointLightShadows[ i ];\n      atten = all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n      #endif\n\n      shadow = 1.0 - material.receiveShadow * ( 1.0 - ( 0.5 + 0.5 * atten ) );\n      lightIntensity = getLightIntensity( directLight, geometry, shadow, material.shadingGrade );\n      lighting = getLighting( directLight.color );\n      reflectedLight.directDiffuse += getDiffuse( material, lightIntensity, lighting );\n      lightingSum += lighting;\n    }\n    #pragma unroll_loop_end\n  #endif\n\n  #if ( NUM_SPOT_LIGHTS > 0 )\n    SpotLight spotLight;\n\n    #if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n    SpotLightShadow spotLightShadow;\n    #endif\n\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n      spotLight = spotLights[ i ];\n\n      #if THREE_VRM_THREE_REVISION >= 132\n        getSpotLightInfo( spotLight, geometry, directLight );\n      #else\n        getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n      #endif\n\n      atten = 1.0;\n      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n      spotLightShadow = spotLightShadows[ i ];\n      atten = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n      #endif\n\n      shadow = 1.0 - material.receiveShadow * ( 1.0 - ( 0.5 + 0.5 * atten ) );\n      lightIntensity = getLightIntensity( directLight, geometry, shadow, material.shadingGrade );\n      lighting = getLighting( directLight.color );\n      reflectedLight.directDiffuse += getDiffuse( material, lightIntensity, lighting );\n      lightingSum += lighting;\n    }\n    #pragma unroll_loop_end\n  #endif\n\n  #if ( NUM_DIR_LIGHTS > 0 )\n    DirectionalLight directionalLight;\n\n    #if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n    DirectionalLightShadow directionalLightShadow;\n    #endif\n\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n      directionalLight = directionalLights[ i ];\n\n      #if THREE_VRM_THREE_REVISION >= 132\n        getDirectionalLightInfo( directionalLight, geometry, directLight );\n      #else\n        getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n      #endif\n\n      atten = 1.0;\n      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n      directionalLightShadow = directionalLightShadows[ i ];\n      atten = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n      #endif\n\n      shadow = 1.0 - material.receiveShadow * ( 1.0 - ( 0.5 + 0.5 * atten ) );\n      lightIntensity = getLightIntensity( directLight, geometry, shadow, material.shadingGrade );\n      lighting = getLighting( directLight.color );\n      reflectedLight.directDiffuse += getDiffuse( material, lightIntensity, lighting );\n      lightingSum += lighting;\n    }\n    #pragma unroll_loop_end\n  #endif\n\n  // #if defined( RE_IndirectDiffuse )\n  vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n  #if THREE_VRM_THREE_REVISION >= 133\n    irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n  #else\n    irradiance += getLightProbeIrradiance( lightProbe, geometry );\n  #endif\n  #if ( NUM_HEMI_LIGHTS > 0 )\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n      irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n    }\n    #pragma unroll_loop_end\n  #endif\n  // #endif\n\n  // #include <lights_fragment_maps>\n  #ifdef USE_LIGHTMAP\n    vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n    vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n    #ifndef PHYSICALLY_CORRECT_LIGHTS\n      lightMapIrradiance *= PI;\n    #endif\n    irradiance += lightMapIrradiance;\n  #endif\n\n  // #include <lights_fragment_end>\n  // RE_IndirectDiffuse here\n  reflectedLight.indirectDiffuse += indirectLightIntensity * irradiance * BRDF_Lambert( material.diffuseColor );\n\n  // modulation\n  #include <aomap_fragment>\n\n  vec3 col = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\n  // The "comment out if you want to PBR absolutely" line\n  #ifndef DEBUG_LITSHADERATE\n    col = min(col, material.diffuseColor);\n  #endif\n\n  #if defined( OUTLINE ) && defined( OUTLINE_COLOR_MIXED )\n    gl_FragColor = vec4(\n      outlineColor.rgb * mix( vec3( 1.0 ), col, outlineLightingMix ),\n      diffuseColor.a\n    );\n    postCorrection();\n    return;\n  #endif\n\n  #ifdef DEBUG_LITSHADERATE\n    gl_FragColor = vec4( col, diffuseColor.a );\n    postCorrection();\n    return;\n  #endif\n\n  // -- MToon: parametric rim lighting -----------------------------------------\n  vec3 viewDir = normalize( vViewPosition );\n  vec3 rimMix = mix( vec3( 1.0 ), lightingSum + indirectLightIntensity * irradiance, rimLightingMix );\n  vec3 rim = rimColor * pow( saturate( 1.0 - dot( viewDir, normal ) + rimLift ), rimFresnelPower );\n  #ifdef USE_RIMTEXTURE\n    rim *= rimTextureTexelToLinear( texture2D( rimTexture, uv ) ).rgb;\n  #endif\n  col += rim;\n\n  // -- MToon: additive matcap -------------------------------------------------\n  #ifdef USE_SPHEREADD\n    {\n      vec3 x = normalize( vec3( viewDir.z, 0.0, -viewDir.x ) );\n      vec3 y = cross( viewDir, x ); // guaranteed to be normalized\n      vec2 sphereUv = 0.5 + 0.5 * vec2( dot( x, normal ), -dot( y, normal ) );\n      vec3 matcap = sphereAddTexelToLinear( texture2D( sphereAdd, sphereUv ) ).xyz;\n      col += matcap;\n    }\n  #endif\n\n  // -- MToon: Emission --------------------------------------------------------\n  col += totalEmissiveRadiance;\n\n  // #include <envmap_fragment>\n\n  // -- Almost done! -----------------------------------------------------------\n  gl_FragColor = vec4( col, diffuseColor.a );\n  postCorrection();\n}', this.needsUpdate = true;
    }
    _updateCullFace() {
      this.isOutline ? this.outlineCullMode === Y.Off ? this.side = DoubleSide : this.outlineCullMode === Y.Front ? this.side = BackSide : this.outlineCullMode === Y.Back && (this.side = FrontSide) : this.cullMode === Y.Off ? this.side = DoubleSide : this.cullMode === Y.Front ? this.side = BackSide : this.cullMode === Y.Back && (this.side = FrontSide);
    }
  };
  var J;
  !function(e2) {
    e2[e2.Opaque = 0] = "Opaque", e2[e2.Cutout = 1] = "Cutout", e2[e2.Transparent = 2] = "Transparent", e2[e2.TransparentWithZWrite = 3] = "TransparentWithZWrite";
  }(J || (J = {}));
  var K = class extends ShaderMaterial {
    constructor(t2) {
      super(), this.isVRMUnlitMaterial = true, this.cutoff = 0.5, this.map = null, this.mainTex_ST = new Vector4(0, 0, 1, 1), this._renderType = J.Opaque, this.shouldApplyUniforms = true, t2 === void 0 && (t2 = {}), t2.fog = true, t2.clipping = true, parseInt(REVISION, 10) < 129 && (t2.skinning = t2.skinning || false), parseInt(REVISION, 10) < 131 && (t2.morphTargets = t2.morphTargets || false, t2.morphNormals = t2.morphNormals || false), t2.uniforms = UniformsUtils.merge([UniformsLib.common, UniformsLib.fog, { cutoff: { value: 0.5 }, mainTex_ST: { value: new Vector4(0, 0, 1, 1) } }]), this.setValues(t2), this._updateShaderCode(), this._applyUniforms();
    }
    get mainTex() {
      return this.map;
    }
    set mainTex(e2) {
      this.map = e2;
    }
    get renderType() {
      return this._renderType;
    }
    set renderType(e2) {
      this._renderType = e2, this.depthWrite = this._renderType !== J.Transparent, this.transparent = this._renderType === J.Transparent || this._renderType === J.TransparentWithZWrite, this._updateShaderCode();
    }
    updateVRMMaterials(e2) {
      this._applyUniforms();
    }
    copy(e2) {
      return super.copy(e2), this.cutoff = e2.cutoff, this.map = e2.map, this.mainTex_ST.copy(e2.mainTex_ST), this.renderType = e2.renderType, this;
    }
    _applyUniforms() {
      this.shouldApplyUniforms && (this.shouldApplyUniforms = false, this.uniforms.cutoff.value = this.cutoff, this.uniforms.map.value = this.map, this.uniforms.mainTex_ST.value.copy(this.mainTex_ST));
    }
    _updateShaderCode() {
      this.defines = { RENDERTYPE_OPAQUE: this._renderType === J.Opaque, RENDERTYPE_CUTOUT: this._renderType === J.Cutout, RENDERTYPE_TRANSPARENT: this._renderType === J.Transparent || this._renderType === J.TransparentWithZWrite }, this.vertexShader = "#include <common>\n\n// #include <uv_pars_vertex>\n#ifdef USE_MAP\n  varying vec2 vUv;\n  uniform vec4 mainTex_ST;\n#endif\n\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n  // #include <uv_vertex>\n  #ifdef USE_MAP\n    vUv = vec2( mainTex_ST.p * uv.x + mainTex_ST.s, mainTex_ST.q * uv.y + mainTex_ST.t );\n  #endif\n\n  #include <uv2_vertex>\n  #include <color_vertex>\n  #include <skinbase_vertex>\n\n  #ifdef USE_ENVMAP\n\n  #include <beginnormal_vertex>\n  #include <morphnormal_vertex>\n  #include <skinnormal_vertex>\n  #include <defaultnormal_vertex>\n\n  #endif\n\n  #include <begin_vertex>\n  #include <morphtarget_vertex>\n  #include <skinning_vertex>\n  #include <project_vertex>\n  #include <logdepthbuf_vertex>\n\n  #include <worldpos_vertex>\n  #include <clipping_planes_vertex>\n  #include <envmap_vertex>\n  #include <fog_vertex>\n\n}", this.fragmentShader = "#ifdef RENDERTYPE_CUTOUT\n  uniform float cutoff;\n#endif\n\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n// #include <alphamap_pars_fragment>\n// #include <aomap_pars_fragment>\n// #include <lightmap_pars_fragment>\n// #include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n// #include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\n// == main procedure ===========================================================\nvoid main() {\n  #include <clipping_planes_fragment>\n\n  vec4 diffuseColor = vec4( 1.0 );\n\n  #include <logdepthbuf_fragment>\n\n  // #include <map_fragment>\n  #ifdef USE_MAP\n    diffuseColor *= mapTexelToLinear( texture2D( map, vUv ) );\n  #endif\n\n  #include <color_fragment>\n  // #include <alphamap_fragment>\n\n  // MToon: alpha\n  // #include <alphatest_fragment>\n  #ifdef RENDERTYPE_CUTOUT\n    if ( diffuseColor.a <= cutoff ) { discard; }\n    diffuseColor.a = 1.0;\n  #endif\n\n  #ifdef RENDERTYPE_OPAQUE\n    diffuseColor.a = 1.0;\n  #endif\n\n  // #include <specularmap_fragment>\n\n  ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\n  // accumulation (baked indirect lighting only)\n  #ifdef USE_LIGHTMAP\n    reflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n  #else\n    reflectedLight.indirectDiffuse += vec3( 1.0 );\n  #endif\n\n  // modulation\n  // #include <aomap_fragment>\n\n  reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n  vec3 outgoingLight = reflectedLight.indirectDiffuse;\n\n  // #include <envmap_fragment>\n\n  gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n  #include <premultiplied_alpha_fragment>\n  #include <tonemapping_fragment>\n  #include <encodings_fragment>\n  #include <fog_fragment>\n}", this.needsUpdate = true;
    }
  };
  var ee = class {
    constructor(t2 = {}) {
      this._encoding = t2.encoding || LinearEncoding, this._encoding !== LinearEncoding && this._encoding !== sRGBEncoding && console.warn("The specified color encoding might not work properly with VRMMaterialImporter. You might want to use THREE.sRGBEncoding instead."), this._requestEnvMap = t2.requestEnvMap;
    }
    convertGLTFMaterials(e2) {
      var n2;
      return t(this, void 0, void 0, function* () {
        const i2 = (n2 = e2.parser.json.extensions) === null || n2 === void 0 ? void 0 : n2.VRM;
        if (!i2)
          return null;
        const r2 = i2.materialProperties;
        if (!r2)
          return null;
        const o2 = yield c(e2), s2 = {}, a2 = [];
        return yield Promise.all(Array.from(o2.entries()).map(([n3, i3]) => t(this, void 0, void 0, function* () {
          const o3 = e2.parser.json.nodes[n3], l2 = e2.parser.json.meshes[o3.mesh];
          yield Promise.all(i3.map((n4, i4) => t(this, void 0, void 0, function* () {
            const t2 = l2.primitives[i4];
            if (!t2)
              return;
            const o4 = n4.geometry, d2 = o4.index ? o4.index.count : o4.attributes.position.count / 3;
            Array.isArray(n4.material) || (n4.material = [n4.material], o4.addGroup(0, d2, 0));
            const h2 = t2.material;
            let u2, c2 = r2[h2];
            c2 || (console.warn(`VRMMaterialImporter: There are no material definition for material #${h2} on VRM extension.`), c2 = { shader: "VRM_USE_GLTFSHADER" }), s2[h2] ? u2 = s2[h2] : (u2 = yield this.createVRMMaterials(n4.material[0], c2, e2), s2[h2] = u2, a2.push(u2.surface), u2.outline && a2.push(u2.outline)), n4.material[0] = u2.surface, this._requestEnvMap && u2.surface.isMeshStandardMaterial && this._requestEnvMap().then((e3) => {
              u2.surface.envMap = e3, u2.surface.needsUpdate = true;
            }), n4.renderOrder = c2.renderQueue || 2e3, u2.outline && (n4.material[1] = u2.outline, o4.addGroup(0, d2, 1));
          })));
        }))), a2;
      });
    }
    createVRMMaterials(e2, n2, i2) {
      return t(this, void 0, void 0, function* () {
        let t2, r2;
        if (n2.shader === "VRM/MToon") {
          const o2 = yield this._extractMaterialProperties(e2, n2, i2);
          ["srcBlend", "dstBlend", "isFirstSetup"].forEach((e3) => {
            o2[e3] !== void 0 && delete o2[e3];
          }), ["mainTex", "shadeTexture", "emissionMap", "sphereAdd", "rimTexture"].forEach((e3) => {
            o2[e3] !== void 0 && (o2[e3].encoding = this._encoding);
          }), o2.encoding = this._encoding, t2 = new $(o2), o2.outlineWidthMode !== Q.None && (o2.isOutline = true, r2 = new $(o2));
        } else if (n2.shader === "VRM/UnlitTexture") {
          const r3 = yield this._extractMaterialProperties(e2, n2, i2);
          r3.renderType = J.Opaque, t2 = new K(r3);
        } else if (n2.shader === "VRM/UnlitCutout") {
          const r3 = yield this._extractMaterialProperties(e2, n2, i2);
          r3.renderType = J.Cutout, t2 = new K(r3);
        } else if (n2.shader === "VRM/UnlitTransparent") {
          const r3 = yield this._extractMaterialProperties(e2, n2, i2);
          r3.renderType = J.Transparent, t2 = new K(r3);
        } else if (n2.shader === "VRM/UnlitTransparentZWrite") {
          const r3 = yield this._extractMaterialProperties(e2, n2, i2);
          r3.renderType = J.TransparentWithZWrite, t2 = new K(r3);
        } else
          n2.shader !== "VRM_USE_GLTFSHADER" && console.warn(`Unknown shader detected: "${n2.shader}"`), t2 = this._convertGLTFMaterial(e2.clone());
        return t2.name = e2.name, t2.userData = JSON.parse(JSON.stringify(e2.userData)), t2.userData.vrmMaterialProperties = n2, r2 && (r2.name = e2.name + " (Outline)", r2.userData = JSON.parse(JSON.stringify(e2.userData)), r2.userData.vrmMaterialProperties = n2), { surface: t2, outline: r2 };
      });
    }
    _renameMaterialProperty(e2) {
      return e2[0] !== "_" ? (console.warn(`VRMMaterials: Given property name "${e2}" might be invalid`), e2) : (e2 = e2.substring(1), /[A-Z]/.test(e2[0]) ? e2[0].toLowerCase() + e2.substring(1) : (console.warn(`VRMMaterials: Given property name "${e2}" might be invalid`), e2));
    }
    _convertGLTFMaterial(t2) {
      if (t2.isMeshStandardMaterial) {
        const n2 = t2;
        n2.map && (n2.map.encoding = this._encoding), n2.emissiveMap && (n2.emissiveMap.encoding = this._encoding), this._encoding === LinearEncoding && (n2.color.convertLinearToSRGB(), n2.emissive.convertLinearToSRGB());
      }
      if (t2.isMeshBasicMaterial) {
        const n2 = t2;
        n2.map && (n2.map.encoding = this._encoding), this._encoding === LinearEncoding && n2.color.convertLinearToSRGB();
      }
      return t2;
    }
    _extractMaterialProperties(t2, n2, i2) {
      const r2 = [], o2 = {};
      if (n2.textureProperties)
        for (const e2 of Object.keys(n2.textureProperties)) {
          const t3 = this._renameMaterialProperty(e2), s2 = n2.textureProperties[e2];
          r2.push(i2.parser.getDependency("texture", s2).then((e3) => {
            o2[t3] = e3;
          }));
        }
      if (n2.floatProperties)
        for (const e2 of Object.keys(n2.floatProperties)) {
          const t3 = this._renameMaterialProperty(e2);
          o2[t3] = n2.floatProperties[e2];
        }
      if (n2.vectorProperties)
        for (const t3 of Object.keys(n2.vectorProperties)) {
          let i3 = this._renameMaterialProperty(t3);
          ["_MainTex", "_ShadeTexture", "_BumpMap", "_ReceiveShadowTexture", "_ShadingGradeTexture", "_RimTexture", "_SphereAdd", "_EmissionMap", "_OutlineWidthTexture", "_UvAnimMaskTexture"].some((e2) => t3 === e2) && (i3 += "_ST"), o2[i3] = new Vector4(...n2.vectorProperties[t3]);
        }
      return parseInt(REVISION, 10) < 129 && (o2.skinning = t2.skinning || false), parseInt(REVISION, 10) < 131 && (o2.morphTargets = t2.morphTargets || false, o2.morphNormals = t2.morphNormals || false), Promise.all(r2).then(() => o2);
    }
  };
  var te = class {
    constructor(e2) {
      var t2;
      this.ignoreTexture = (t2 = e2 == null ? void 0 : e2.ignoreTexture) !== null && t2 !== void 0 && t2;
    }
    import(e2) {
      var n2;
      return t(this, void 0, void 0, function* () {
        const t2 = (n2 = e2.parser.json.extensions) === null || n2 === void 0 ? void 0 : n2.VRM;
        if (!t2)
          return null;
        const i2 = t2.meta;
        if (!i2)
          return null;
        let r2;
        return this.ignoreTexture || i2.texture == null || i2.texture === -1 || (r2 = yield e2.parser.getDependency("texture", i2.texture)), { allowedUserName: i2.allowedUserName, author: i2.author, commercialUssageName: i2.commercialUssageName, contactInformation: i2.contactInformation, licenseName: i2.licenseName, otherLicenseUrl: i2.otherLicenseUrl, otherPermissionUrl: i2.otherPermissionUrl, reference: i2.reference, sexualUssageName: i2.sexualUssageName, texture: r2 != null ? r2 : void 0, title: i2.title, version: i2.version, violentUssageName: i2.violentUssageName };
      });
    }
  };
  var ne = new Matrix4();
  function ie(e2) {
    return e2.invert ? e2.invert() : e2.getInverse(ne.copy(e2)), e2;
  }
  var re = class {
    constructor(t2) {
      this._inverseCache = new Matrix4(), this._shouldUpdateInverse = true, this.matrix = t2;
      const n2 = { set: (e2, t3, n3) => (this._shouldUpdateInverse = true, e2[t3] = n3, true) };
      this._originalElements = t2.elements, t2.elements = new Proxy(t2.elements, n2);
    }
    get inverse() {
      return this._shouldUpdateInverse && (ie(this._inverseCache.copy(this.matrix)), this._shouldUpdateInverse = false), this._inverseCache;
    }
    revert() {
      this.matrix.elements = this._originalElements;
    }
  };
  var oe = Object.freeze(new Matrix4());
  var se = Object.freeze(new Quaternion());
  var ae = new Vector3();
  var le = new Vector3();
  var de = new Vector3();
  var he = new Quaternion();
  var ue = new Matrix4();
  var ce = new Matrix4();
  var pe = class {
    constructor(t2, n2 = {}) {
      var i2, r2, o2, s2, a2, l2;
      if (this._currentTail = new Vector3(), this._prevTail = new Vector3(), this._nextTail = new Vector3(), this._boneAxis = new Vector3(), this._centerSpacePosition = new Vector3(), this._center = null, this._parentWorldRotation = new Quaternion(), this._initialLocalMatrix = new Matrix4(), this._initialLocalRotation = new Quaternion(), this._initialLocalChildPosition = new Vector3(), this.bone = t2, this.bone.matrixAutoUpdate = false, this.radius = (i2 = n2.radius) !== null && i2 !== void 0 ? i2 : 0.02, this.stiffnessForce = (r2 = n2.stiffnessForce) !== null && r2 !== void 0 ? r2 : 1, this.gravityDir = n2.gravityDir ? new Vector3().copy(n2.gravityDir) : new Vector3().set(0, -1, 0), this.gravityPower = (o2 = n2.gravityPower) !== null && o2 !== void 0 ? o2 : 0, this.dragForce = (s2 = n2.dragForce) !== null && s2 !== void 0 ? s2 : 0.4, this.colliders = (a2 = n2.colliders) !== null && a2 !== void 0 ? a2 : [], this._centerSpacePosition.setFromMatrixPosition(this.bone.matrixWorld), this._initialLocalMatrix.copy(this.bone.matrix), this._initialLocalRotation.copy(this.bone.quaternion), this.bone.children.length === 0)
        this._initialLocalChildPosition.copy(this.bone.position).normalize().multiplyScalar(0.07);
      else {
        const e2 = this.bone.children[0];
        this._initialLocalChildPosition.copy(e2.position);
      }
      this.bone.localToWorld(this._currentTail.copy(this._initialLocalChildPosition)), this._prevTail.copy(this._currentTail), this._nextTail.copy(this._currentTail), this._boneAxis.copy(this._initialLocalChildPosition).normalize(), this._centerSpaceBoneLength = ae.copy(this._initialLocalChildPosition).applyMatrix4(this.bone.matrixWorld).sub(this._centerSpacePosition).length(), this.center = (l2 = n2.center) !== null && l2 !== void 0 ? l2 : null;
    }
    get center() {
      return this._center;
    }
    set center(e2) {
      var t2;
      this._getMatrixCenterToWorld(ue), this._currentTail.applyMatrix4(ue), this._prevTail.applyMatrix4(ue), this._nextTail.applyMatrix4(ue), ((t2 = this._center) === null || t2 === void 0 ? void 0 : t2.userData.inverseCacheProxy) && (this._center.userData.inverseCacheProxy.revert(), delete this._center.userData.inverseCacheProxy), this._center = e2, this._center && (this._center.userData.inverseCacheProxy || (this._center.userData.inverseCacheProxy = new re(this._center.matrixWorld))), this._getMatrixWorldToCenter(ue), this._currentTail.applyMatrix4(ue), this._prevTail.applyMatrix4(ue), this._nextTail.applyMatrix4(ue), ue.multiply(this.bone.matrixWorld), this._centerSpacePosition.setFromMatrixPosition(ue), this._centerSpaceBoneLength = ae.copy(this._initialLocalChildPosition).applyMatrix4(ue).sub(this._centerSpacePosition).length();
    }
    reset() {
      this.bone.quaternion.copy(this._initialLocalRotation), this.bone.updateMatrix(), this.bone.matrixWorld.multiplyMatrices(this._getParentMatrixWorld(), this.bone.matrix), this._centerSpacePosition.setFromMatrixPosition(this.bone.matrixWorld), this.bone.localToWorld(this._currentTail.copy(this._initialLocalChildPosition)), this._prevTail.copy(this._currentTail), this._nextTail.copy(this._currentTail);
    }
    update(e2) {
      if (e2 <= 0)
        return;
      this.bone.matrixWorld.multiplyMatrices(this._getParentMatrixWorld(), this.bone.matrix), this.bone.parent ? g(this.bone.parent, this._parentWorldRotation) : this._parentWorldRotation.copy(se), this._getMatrixWorldToCenter(ue), ue.multiply(this.bone.matrixWorld), this._centerSpacePosition.setFromMatrixPosition(ue), this._getMatrixWorldToCenter(ce), ce.multiply(this._getParentMatrixWorld());
      const t2 = this.stiffnessForce * e2, n2 = le.copy(this.gravityDir).multiplyScalar(this.gravityPower * e2);
      this._nextTail.copy(this._currentTail).add(ae.copy(this._currentTail).sub(this._prevTail).multiplyScalar(1 - this.dragForce)).add(ae.copy(this._boneAxis).applyMatrix4(this._initialLocalMatrix).applyMatrix4(ce).sub(this._centerSpacePosition).normalize().multiplyScalar(t2)).add(n2), this._nextTail.sub(this._centerSpacePosition).normalize().multiplyScalar(this._centerSpaceBoneLength).add(this._centerSpacePosition), this._collision(this._nextTail), this._prevTail.copy(this._currentTail), this._currentTail.copy(this._nextTail);
      const i2 = ie(ue.copy(ce.multiply(this._initialLocalMatrix))), r2 = he.setFromUnitVectors(this._boneAxis, ae.copy(this._nextTail).applyMatrix4(i2).normalize());
      this.bone.quaternion.copy(this._initialLocalRotation).multiply(r2), this.bone.updateMatrix(), this.bone.matrixWorld.multiplyMatrices(this._getParentMatrixWorld(), this.bone.matrix);
    }
    _collision(e2) {
      this.colliders.forEach((t2) => {
        this._getMatrixWorldToCenter(ue), ue.multiply(t2.matrixWorld);
        const n2 = ae.setFromMatrixPosition(ue), i2 = t2.geometry.boundingSphere.radius, r2 = this.radius + i2;
        if (e2.distanceToSquared(n2) <= r2 * r2) {
          const t3 = le.subVectors(e2, n2).normalize(), i3 = de.addVectors(n2, t3.multiplyScalar(r2));
          e2.copy(i3.sub(this._centerSpacePosition).normalize().multiplyScalar(this._centerSpaceBoneLength).add(this._centerSpacePosition));
        }
      });
    }
    _getMatrixCenterToWorld(e2) {
      return this._center ? e2.copy(this._center.matrixWorld) : e2.identity(), e2;
    }
    _getMatrixWorldToCenter(e2) {
      return this._center ? e2.copy(this._center.userData.inverseCacheProxy.inverse) : e2.identity(), e2;
    }
    _getParentMatrixWorld() {
      return this.bone.parent ? this.bone.parent.matrixWorld : oe;
    }
  };
  var me = class {
    constructor(e2, t2) {
      this.colliderGroups = [], this.springBoneGroupList = [], this.colliderGroups = e2, this.springBoneGroupList = t2;
    }
    setCenter(e2) {
      this.springBoneGroupList.forEach((t2) => {
        t2.forEach((t3) => {
          t3.center = e2;
        });
      });
    }
    lateUpdate(e2) {
      this.springBoneGroupList.forEach((t2) => {
        t2.forEach((t3) => {
          t3.update(e2);
        });
      });
    }
    reset() {
      this.springBoneGroupList.forEach((e2) => {
        e2.forEach((e3) => {
          e3.reset();
        });
      });
    }
  };
  var fe = new Vector3();
  var ge = new MeshBasicMaterial({ visible: false });
  var _e = class {
    import(e2) {
      var n2;
      return t(this, void 0, void 0, function* () {
        const t2 = (n2 = e2.parser.json.extensions) === null || n2 === void 0 ? void 0 : n2.VRM;
        if (!t2)
          return null;
        const i2 = t2.secondaryAnimation;
        if (!i2)
          return null;
        const r2 = yield this._importColliderMeshGroups(e2, i2), o2 = yield this._importSpringBoneGroupList(e2, i2, r2);
        return new me(r2, o2);
      });
    }
    _createSpringBone(e2, t2 = {}) {
      return new pe(e2, t2);
    }
    _importSpringBoneGroupList(n2, i2, r2) {
      return t(this, void 0, void 0, function* () {
        const o2 = i2.boneGroups || [], s2 = [];
        return yield Promise.all(o2.map((i3) => t(this, void 0, void 0, function* () {
          if (i3.stiffiness === void 0 || i3.gravityDir === void 0 || i3.gravityDir.x === void 0 || i3.gravityDir.y === void 0 || i3.gravityDir.z === void 0 || i3.gravityPower === void 0 || i3.dragForce === void 0 || i3.hitRadius === void 0 || i3.colliderGroups === void 0 || i3.bones === void 0 || i3.center === void 0)
            return;
          const o3 = i3.stiffiness, a2 = new Vector3(i3.gravityDir.x, i3.gravityDir.y, -i3.gravityDir.z), l2 = i3.gravityPower, d2 = i3.dragForce, h2 = i3.hitRadius, u2 = [];
          i3.colliderGroups.forEach((e2) => {
            u2.push(...r2[e2].colliders);
          });
          const c2 = [];
          yield Promise.all(i3.bones.map((e2) => t(this, void 0, void 0, function* () {
            const t2 = yield n2.parser.getDependency("node", e2), r3 = i3.center !== -1 ? yield n2.parser.getDependency("node", i3.center) : null;
            t2 && t2.traverse((e3) => {
              const t3 = this._createSpringBone(e3, { radius: h2, stiffnessForce: o3, gravityDir: a2, gravityPower: l2, dragForce: d2, colliders: u2, center: r3 });
              c2.push(t3);
            });
          }))), s2.push(c2);
        }))), s2;
      });
    }
    _importColliderMeshGroups(e2, n2) {
      return t(this, void 0, void 0, function* () {
        const i2 = n2.colliderGroups;
        if (i2 === void 0)
          return [];
        const r2 = [];
        return i2.forEach((n3) => t(this, void 0, void 0, function* () {
          if (n3.node === void 0 || n3.colliders === void 0)
            return;
          const t2 = yield e2.parser.getDependency("node", n3.node), i3 = [];
          n3.colliders.forEach((e3) => {
            if (e3.offset === void 0 || e3.offset.x === void 0 || e3.offset.y === void 0 || e3.offset.z === void 0 || e3.radius === void 0)
              return;
            const n4 = fe.set(e3.offset.x, e3.offset.y, -e3.offset.z), r3 = this._createColliderMesh(e3.radius, n4);
            t2.add(r3), i3.push(r3);
          });
          const o2 = { node: n3.node, colliders: i3 };
          r2.push(o2);
        })), r2;
      });
    }
    _createColliderMesh(t2, n2) {
      const i2 = new Mesh(new SphereGeometry(t2, 8, 4), ge);
      return i2.position.copy(n2), i2.name = "vrmColliderSphere", i2.geometry.computeBoundingSphere(), i2;
    }
  };
  var ve = class {
    constructor(e2 = {}) {
      this._metaImporter = e2.metaImporter || new te(), this._blendShapeImporter = e2.blendShapeImporter || new v(), this._lookAtImporter = e2.lookAtImporter || new W(), this._humanoidImporter = e2.humanoidImporter || new C(), this._firstPersonImporter = e2.firstPersonImporter || new E(), this._materialImporter = e2.materialImporter || new ee(), this._springBoneImporter = e2.springBoneImporter || new _e();
    }
    import(e2) {
      return t(this, void 0, void 0, function* () {
        if (e2.parser.json.extensions === void 0 || e2.parser.json.extensions.VRM === void 0)
          throw new Error("Could not find VRM extension on the GLTF");
        const t2 = e2.scene;
        t2.updateMatrixWorld(false), t2.traverse((e3) => {
          e3.isMesh && (e3.frustumCulled = false);
        });
        const n2 = (yield this._metaImporter.import(e2)) || void 0, i2 = (yield this._materialImporter.convertGLTFMaterials(e2)) || void 0, r2 = (yield this._humanoidImporter.import(e2)) || void 0, o2 = r2 && (yield this._firstPersonImporter.import(e2, r2)) || void 0, s2 = (yield this._blendShapeImporter.import(e2)) || void 0, a2 = o2 && s2 && r2 && (yield this._lookAtImporter.import(e2, o2, s2, r2)) || void 0, l2 = (yield this._springBoneImporter.import(e2)) || void 0;
        return new ye({ scene: e2.scene, meta: n2, materials: i2, humanoid: r2, firstPerson: o2, blendShapeProxy: s2, lookAt: a2, springBoneManager: l2 });
      });
    }
  };
  var ye = class {
    constructor(e2) {
      this.scene = e2.scene, this.humanoid = e2.humanoid, this.blendShapeProxy = e2.blendShapeProxy, this.firstPerson = e2.firstPerson, this.lookAt = e2.lookAt, this.materials = e2.materials, this.springBoneManager = e2.springBoneManager, this.meta = e2.meta;
    }
    static from(e2, n2 = {}) {
      return t(this, void 0, void 0, function* () {
        const t2 = new ve(n2);
        return yield t2.import(e2);
      });
    }
    update(e2) {
      this.lookAt && this.lookAt.update(e2), this.blendShapeProxy && this.blendShapeProxy.update(), this.springBoneManager && this.springBoneManager.lateUpdate(e2), this.materials && this.materials.forEach((t2) => {
        t2.updateVRMMaterials && t2.updateVRMMaterials(e2);
      });
    }
    dispose() {
      var e2, t2;
      const n2 = this.scene;
      n2 && n2.traverse(i), (t2 = (e2 = this.meta) === null || e2 === void 0 ? void 0 : e2.texture) === null || t2 === void 0 || t2.dispose();
    }
  };
  var Te = new Vector2();
  var xe = new OrthographicCamera(-1, 1, -1, 1, -1, 1);
  var Se = new MeshBasicMaterial({ color: 16777215, side: DoubleSide });
  var Me = new Mesh(new PlaneGeometry(2, 2), Se);
  var Ee = new Scene();
  Ee.add(Me);
  var Le = class {
    constructor() {
    }
  };
  Le.extractThumbnailBlob = function(e2, t2, n2 = 512) {
    var i2;
    const r2 = (i2 = t2.meta) === null || i2 === void 0 ? void 0 : i2.texture;
    if (!r2)
      throw new Error("extractThumbnailBlob: This VRM does not have a thumbnail");
    const o2 = e2.getContext().canvas;
    e2.getSize(Te);
    const s2 = Te.x, a2 = Te.y;
    return e2.setSize(n2, n2, false), Se.map = r2, e2.render(Ee, xe), Se.map = null, o2 instanceof OffscreenCanvas ? o2.convertToBlob().finally(() => {
      e2.setSize(s2, a2, false);
    }) : new Promise((t3, n3) => {
      o2.toBlob((i3) => {
        e2.setSize(s2, a2, false), i3 == null ? n3("extractThumbnailBlob: Failed to create a blob") : t3(i3);
      });
    });
  }, Le.removeUnnecessaryJoints = function(t2) {
    const n2 = new Map();
    t2.traverse((t3) => {
      if (t3.type !== "SkinnedMesh")
        return;
      const i2 = t3, r2 = i2.geometry.getAttribute("skinIndex");
      let o2 = n2.get(r2);
      if (!o2) {
        const t4 = [], s2 = [], a2 = {}, l2 = r2.array;
        for (let e2 = 0; e2 < l2.length; e2++) {
          const n3 = l2[e2];
          a2[n3] === void 0 && (a2[n3] = t4.length, t4.push(i2.skeleton.bones[n3]), s2.push(i2.skeleton.boneInverses[n3])), l2[e2] = a2[n3];
        }
        r2.copyArray(l2), r2.needsUpdate = true, o2 = new Skeleton(t4, s2), n2.set(r2, o2);
      }
      i2.bind(o2, new Matrix4());
    });
  };
  var we = new Vector3();
  var Ae = new MeshBasicMaterial({ color: 16711935, wireframe: true, transparent: true, depthTest: false });
  var Oe = new Vector3();

  // src/FaceFilterController.js
  var import_jeelizFaceFilter_module = __toModule(require_jeelizFaceFilter_module());
  var import_JeelizResizer = __toModule(require_JeelizResizer());

  // src/FaceExpressionsController.js
  var import_jeelizFaceExpressions_module = __toModule(require_jeelizFaceExpressions_module());

  // lib/jeelizWeboji/dist/jeelizFaceExpressionsNNC.json
  var layers = [{ preprocessing: "inputMix0", size: 128, nBlurPass: 1, varianceMin: 0.1, blurKernelSizePx: 5, type: "input", index: 0, mask: false, tilt: 0, customInputShader: false }, { size: 128, sparsity: 8, activation: "arctan", connectivity: { fromLayerSize: 128, toLayerSize: 128, toSparsity: 8, weights: { isPot: true, width: 32, isFloat: true, data: '{"ne":4,"nf":7,"n":4096,"data":"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"}' }, kernelsCount: 4, layerIndex: 1 }, bias: { isPot: true, width: 4, isFloat: true, data: '{"ne":4,"nf":7,"n":64,"data":"sKzLR7yjq7yYr8O8qBvgyuygKmvmuusVOtMOuJyoqbNJuGtqJPRTkryNpcSbjHtjFH0aw+R7uewGx0Pnq8wWzGy7sB0fR3tpspoew4vsm7uuuisrDAr5pjsCkWw6r1sC"}' }, index: 1, classesCount: false, connectivityUp: "conv", normalize: false, kernelsCount: 4, maxPooling: { size: 2 }, remap: { isEnabled: false }, isReorganize: true, dynPelu: false }, { size: 128, sparsity: 16, activation: "arctan", connectivity: { fromLayerSize: 64, toLayerSize: 128, toSparsity: 16, weights: { isPot: true, width: 256, isFloat: true, data: '{"ne":4,"nf":7,"n":262144,"data":"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"}' }, kernelsCount: 16, layerIndex: 2 }, bias: { isPot: true, width: 16, isFloat: true, data: '{"ne":4,"nf":7,"n":1024,"data":"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"}' }, index: 2, classesCount: false, connectivityUp: "conv", normalize: false, kernelsCount: 16, maxPooling: { size: 2 }, remap: { isEnabled: false }, isReorganize: true, dynPelu: false }, { size: 32, sparsity: 32, activation: "elu01", connectivity: { fromLayerSize: 64, toLayerSize: 32, toSparsity: 32, weights: { isPot: true, width: 128, isFloat: true, data: '{"ne":4,"nf":7,"n":65536,"data":"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"}' }, kernelsCount: 4, layerIndex: 3 }, bias: { isPot: true, width: 4, isFloat: true, data: '{"ne":4,"nf":7,"n":64,"data":"JXKXIJK2Ljn/LGLjLFm3LgMKLsJMKSJkLgoQEpKGMgAALOLXMNJwIkKiMMJLKyLDLQJNJtLqMRIJLlKZMQKJjfKtMGHflIgUL7pBK1KrJFAmJqIPMVKDKHKoLYErLNIi"}' }, index: 3, classesCount: false, connectivityUp: "conv", normalize: false, kernelsCount: 4, maxPooling: false, remap: { isEnabled: false }, isReorganize: true, dynPelu: false }, { size: 16, sparsity: 14, activation: "elu01", connectivity: { fromLayerSize: 32, toLayerSize: 16, toSparsity: 14, weightsFromTo: false, fromBindings: false, toBindings: false, squareFast: true, weights: { isPot: false, width: 224, isFloat: true, data: '{"ne":4,"nf":7,"n":200704,"data":"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"}' }, stride: 1 }, bias: { isPot: true, width: 16, isFloat: true, data: '{"ne":4,"nf":7,"n":1024,"data":"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"}' }, index: 4, classesCount: false, connectivityUp: "squareFast", normalize: false, kernelsCount: false, maxPooling: false, remap: { isEnabled: false }, isReorganize: false, dynPelu: false }, { size: 16, sparsity: 5, activation: "elu01", connectivity: { fromLayerSize: 16, toLayerSize: 16, toSparsity: 5, weightsFromTo: false, fromBindings: false, toBindings: false, squareFast: true, weights: { isPot: false, width: 80, isFloat: true, data: '{"ne":4,"nf":7,"n":25600,"data":"lKkNjfinAAmQAAEXkYnagTEDFNCdkwEzABAAkTjPgikWAAAAk5ltAAEjiThbAAHKEemsAAIGDBHwAAlwAMAAi3DhAAAAEDAADjAAEAkKBFAAFYITAAAAAAEiEMj/CKmLpYm2kfplHuHTDBkXmBmgCmERFAGGEvkNGWj9AVGajCnrCjHrkcBimGmbAypUERJUldA0AAnhAAC7iAHGkGijAAAAAZnKDeAdFZGSkJkXGenGlfAAoQlVIyINk5IVo0kmgHoAkWjMjGHEjFDQkNE4mEpPAAC3JBjwE1Eoi6DuiAGLAAGYjCAAAAiuAvItBxGEE9hhJBkkB5hxExGnpPnYiQG6FJlEAAAAFdC7meAAAFFHpIAQjtoxGInmkvHmmEAAkcC2HOCIB5mDnYjLAAlYEMFaFZHbFdiMAAg8AAGTEuoMCaAAAAAAGyCthKAAirCcDfAAAvG9GAldE6D0mVC5AAgmopjCmJEbEjkUAEBilYE3ICFVAAAAGGC1CQGGiwiokoCcD3j0GdoUAAFBmxo0AADXiHnHAAEvEXC4AAmLGmmYAAiiGLkGAAAADQG2AAAAAADdAAAAk8CzAAAACSlQAAALE2E9AAAAkaGLAAjrEEgNAAEFEFlZAAAAH1i0AAh+GAC/GPkHA2nSizjEinAAAAgpEnjUBjlDkZkKGtBmitDUAADXipAAAAHAgbHDAAmUCemBAAHjC6DCAAE4AAAAEYGHAAAAghgBAAAAGklLAAAACTk6CKAADiGLnJh8BSAADFCDEqDTAAE/k6CunCnSAAElHPF4FkB4jEG3hHFfkSmiAbpDmxnfkECTBvj8E0CLjhmrm+GYmFm/Bzm5AAmQHuAAitlaFkk6oikOjsDknKihjqC8koifG/lxG2AAnJI3m9o3BHlglkDNAAkumAnhkemHAAkCCLl1mZj3AAE5E3j6irgHjjlSAAAzlKG6ilESiRBcG5leAGG+JcAAmuk8GHAAISoAGDCREUnAk6lelLkflykrAApYi9GPmUBTkxluAAmMGSAAAAmilKGcnPkoFGAAAAm0B/AjmFAAD8iIE8pbkIAAAAlyAAAFkmCuEwEgAAAADWFFjViegPg7EHAAAAkQlmAAGGnIlsnTBVklFclTEfgUjFmzljDbgPJBFyAsAAk9nUE4FHDgAAGKmkISAAEEGfqNAAlVAAFNAAA3DgAEAAAAEbHIAAAAjMicAAAACWGQAAAAiGE5AAAABwlKAAAAEGCBAACzDwAAAAAejUlEAAB3GXDgAAFhAAmhAAkIj7GHiYA8lsAAAAlEAAK1EUFKi6CkFCooltAAD3oMivliAAG/iNmIAAAAFrIEAAAADrpyAAkQFGJpAAnsAAAACoAAAAAAlCF1AAAAp9mYAkAAnlifAAAAMAmyFSGsAAlXmesmKGEBGCMqqRnMFyN3NEg7jnm9lZmLjxoBgkAaGKqkL9GqIUI7NuoCFDodssgmnQnSLVAAGXlXnuD0oSJtIXE3nXHfHCoyK8E6oAoFnxgnAAJpH3JvM5n0KlH6rjmsAAEUqCAHAqGeAACZj9KGkQIpHoFJlmAamfjfDiAAI8naiXAAGlGRBKrJAAm1AAJaFlHHgrAAk9oNjnDcBBoDnkFXAAI1GolsojH+oOC+mSGcCoAAkmoghcAAkgFcAAFejynwAADWAAGiGICGAwCrE5EhkLCwHPBwBoi7GQGJDAAAEmhHA+gGnoFIAAFKGIH6ifEPFNFVE9hnjWnPIEmBFXAAAXEJkalkDgFpDuAAhqJmh4AAE0l7gKA2AAkYmaFHiEHFCUEAlYAAAAqQGxoHAAkmERAAAAC2iQELAAFsm/hkAAjVkAF9AAAAkjotAAAAFvG/AAAHEvEmAAAAGjmcAAh9AAGiAAJhAAE0AAGKCeIKAAIMi9D8AAFPlBAAAAGFF2omi2AAjaAADskkAAiDEFkPjLBSmMg9j+I/lCgNkXikAAnJkREWAAoCkwA/AAn+kYJKAAAABTnYAACGBXAAjZnUAAAAkiEJAAAAMgmCAAAADyHND4AAkrmTEJk0E1lhHsL8JMG8EyIAqXHsEokkKUAAiSpXHzmEhIF5GWipndqhMJmLJBnusGGiHSK7sZBglLJMNbE0B0nSGWkzqVEOEfnsK2CGJNGOpDGuHkmMoQlOoNo9DqoRLrmIEFr8rXD1JQm2LoimE2ikC+GZIJEUAAjfGcmXEpDIg0luFbEnhfD1k5AADUiwAAosIcAAEZmxI5nIoAluIYFWmFE7HrmCn9lvHqHomPkgi6GzmhjDl9nIhMmiKtoXhcFclIIPg8GGB8AADSilFXGZlhITAiF/kEgogBEVllk4lpAADaAAjmlrEPgiF3oPC+AAB8AAiOlVAAgwAAGxAAoMGIFUjGCXlAGCnwkxGgFWH+nhCvocGoCnIXGKCND1krC3goHqGkkXj4mjmpkJEzERAAmtAwAAAAAAm+JBAAoJD6HkAApAEZAAAAFRkUoSAAAAmfoiAAAAlnkaAAAAoNm/AAAAAAmQAAAAkVn3AAokAAE3AAFnCkB/AAA2B9mfAAAAiajCAAkPGtCqBlmClGioAAHuklk3lniJAAgxhiF0FzmgIDHyDNEiAAF8D2AAAAIhiCAAAAFElBmKAAgTFElGAAAAANAAENkkAAAADCGTAIAAEshaAAAAAAAEAAAAAACjFOnXEej5E7k1CjHmCMiwE9mXiKmhnvB/GWiRGLnAGmm7BnGJICF4K2GZBxm9AAJZnpG7lCozl6pCFjlMhGAUi/HHB6gqn6jDATCwkFm3AAm9HLEDJyEkFAIgm9EbAAFSjzmiMIE6jhmxAAiECoIQlZHio/mBJbAAHHBbGqGCk2CXFkGxntnzlhk5nODRETF1CnAAC8AAAAAAkOgTE9BhnQifmNoQiTCpkpGGi0mfHUIxFejnDBAAAAEal7m3ipAAi5mGDYDjifHDFLBzk0IZEXkejaoLG7AAm2EalllaAAmbF6AACRAXAADYHtBEEZAAF0rFgUhMmNDmDbliAAlFmZkoLZDIEZEKmOCOEWF7l7EIAAEbiLnrHzDVAAHSmxgcAAigD8FlGQEBHmHFnJkIAAjblRiYAAI+jIk4AAooIPlOAAnGAAHxAAkOAcnEAAAAAFm4AAAAJJijAAAADPjEAAAABPFhAAAAFXFsAAoPkikQAAA5F7kLAAFgmKmgAAjOD5mGAAi8AAgyIclrAAmtEaAAAAAAi1kJAAkpkJAAAAg0AAkjkfoVAAGClEpEAACdmAIpAADODZGmAAAAIomOAAAAEuE8AAIpAlAAGiAAC1AAjjGaAAAABSGTFkEEC6HZAAmNIFm+AAh7AAE2AAC6AAl5AAAAn9mHAAEMAAicAAAABikajxlZAAGImRk8AABkB3gJAAl2AAlcAAEJDwAAkFDIGFAHCMocElm4CFF4AAGZgQEBDbGKkPpRAAAAAAGJAABBgNkNAAg+jiAAmaDnmhljCnAAloAAkCGBEkDckHmyFqEIGioDFBhsC/EZHgEIEkHuD8AAFWiiIBiKjUlMHoCZi9nfERAAiwoUk+n6o3AAm1inkRAJj7EnjmlxnMAAjfAOkwhlizguEnC1ESoHjaEwAAHQIYAAAAGaEfAAAAAAFJAAAApZGIAAAAAAiMAAjAAAAAAABUnwDCDYmcprj7oOBaAAGYB/kxCVAAAAkXAAjYAkFelWkHGPFzldhRAAipBKAABYAADnAAkIhzmQAABRmLnoE7FfCTjumolLIYAKFOl3FQi7AAAAAAD9gGgKAAE0CDGEAAlEFlieAAGGBtBcAAIBCaAAibAAEPEhAAGOGnBTjeiJEwAAihlNkjGHAADyEAFkAADjEWEMAAhGlLDQAAhTAAkRAAjYGuHtAAAAkfCMAAAAAAAAhKoDAAkrHGLLAAmKkRocAAiIhnEEAAAAAAlUAAkYAAAvIEguluGenWIAAAFfC/AADQEsBthsAAltjNFSAAgDAAE0AADoDnmNAAiBk1BNAAHAgdHFDuCrl1AAnSpOAAAAlmAACmFZFUBSCsGLhInBh/ILAFAAmdgyAbiAGPDODTlrDwAAkrGXmjlmk5AAlsAAnWiSDLFemJCTg9lAjAmuAADeAAFzERAAmXHlmYAAkuEvk5DEk/FAk9DvB7mjFeEjCNkcknAAAAIZk0CxFqAAkviajJkPksAAn7FjFDkPGykJGUBjpKBMimAAlhGiE+GCk3m9AAAAAAmOEpCsjXmMIKiJE0IrkIl0AApjkvAAAAirESAAAAIbmeAAAAkqCtAAAAFvAFAAAAAAAAibAAlVkwn/h2iOjQDOm/AAmpgHBwD3AAAAGlGeCWD7AAkRE8B5B9mxDWjhEzHQGbAAmIAAEZDgDKEsEFAACzD9GrmpkIHeFckMjRAAAAEUAAikkhAAAAFJhkmVAAE2CpkhAAHxmOiCAAoBCiHjAAHfAADEjGkalNkHgrAAHNhWCOpSjKAfgQBOIHoMCSl3AMgAAADUEbDfAAHRhGIOAApNkcIoAAoyF2IjAACVE0CvjNl3AADfmIlYAAK5lKs5AAn9hsqcAAAFEuMzAAhNIikqlSC4AAAAnOHvqFI0LvEYGHnKhwGvkfKjmQljAAFVAAlOAAMipiHxAAsdIXD+AAtFozD4AAnchiHyDDBSkYJyEnkZgwoMsQFZEaoOjAjItymXFyLAkYHzl9EdmSAAn8rlgwA2pML/MLEyp+HUMEBImMlyr/mPk0EsniIlGiAAGQAACMFPosC0m6k/n/GwJninGKChlknJmIDSC0AAjSF0DQjmAAksH2l7AADTGWo8DPC2oSnel+mGsMHdAAEnMRCakIGPq0iwEZAFKEmpmQBiCAGDHDAAj1FRovGbGjD5BOoCEtEiEIkMCuHJIllAAAhsAAAAAAkbiuAAAAFiGXAAAAAAEpAAAAmKi5AAA2oNmWAAkrm9m2mSGFj/kTlgEToFGHCZEcCGGPEsH6oSFooBDgnvnYoklIAADJFOFvESmsGVjmIMDMCIBDgsjXKADgAAmklnlqG2DzAAiQDlDOktJiIFAAFOAAorIOKWAAMXAXHyAApxgVJdAAkPEqk4AAJgGCpRAAnbmJIDi7CnCyIYDKoAITIMEIo1AAFFAAmQjGIDAAjtmQGiAAC3l7CWAAo4IKAAAADIkVniAAInAAAADfoBAACUAIJtAAI9iqJYAApYAAAAAAAAAAMRAAlgEEjXiBCEmtFJJdiNiVMIDoFxlBGrKXA5osKlGajrAAm3nrhHAAsRHIlOAAMEIpGJAALmnMGMAArJFoGxgSnoEGEWELAAAfCikEjaBRqMAAiniboqkRgsgmlyFnAAIbjfFaJ6tHCVmOsUJSAcoJDmF+kSpPFPFIAUE1mMGTCADQFsHBCiqVmCDFF6p8KIFymRIuAeAABOAAInFYEAJhAAnZoLDwkuIaGdjYHdEoAAkBlRCrhNEOkZlhAAqMktIYHZqLm/AAohqyFmjhqlq/n6gQIZFgEyKBHzH7HdgDEsldD9huGXDWDfJgmWD6AAogGCAAjXiSAAAAAAkNAAAAi6FCAAAAFkAAAAAAiJEOAAgeJqJNAAAAl7AAi6j8CUlXHek+oTlKimCqEhIECKkMIepJokGSo/hSpUExmrEIGhFrERCEqLl+o7AAAAEkk8mOAAHPmNjtAdAAkAoRAAiEmrAAG7FJlEntJcAAqWnfAAAALOENifAAkBjPnFAAk+m4F8AAB2Hdq8ByqhFPnhhTp8lyGqqAMlo3GiB3GAEKHKiMHOE2GnAAESB1jVAADonJFSAAmvGumxAAo9FQkyAADoCxkWIynMAAhLHDE5AAlvikqBAAKIhVqDAAEFmKCTAADEBakrAAI0CsEomNkIlYAuqgEnDdBbk3BlFGAAlOilAAmagaDjAAolpMAAAAlFJwAAAAGvmUAAAAobAAGeHfFoAACgjPDsAAjqiHmGCmq+jGBQAAo4k+CPAAnKGNERCFkQFViDIPi4AyhTmOAAA2AADbjWg+mxAZiRAACjKKDlAADpGPIRCXjToPkYiPGzotkyG6m1mKJaAAlaKBgnCJmNjuiVF3FYFalNkGCih1kBkiH9FXAAiMpIAAGHAAJlDnpmKYAAF+J1DaJVgzGbjhktkUk7AZmQI0mPDzkUqfEDAAgToQmRhvCVIRGjEdFNJYlCAACOgGAAAAiBncAAAAAADHAAAAA/EjAAAAkFBeAAFKAAEYD0AAAAB2o4IzLChXIGIrHRmWIWniBxmpitAAoAKWoLGJC8F4Evl/ocAAnhleF1DlHdIzlQmdAYmRAAkjG8G5mBpdGKAAlCnXj4mumBHOBGAAm+l+nMAAAAjim0AAnxEcDKAArPEbDLAAEoImGFAACeBuqjkTkSlCHdiFifEzneFtozFTAAAAIWi7i4C9ERAAAAAAAmHxnfEaFrkNkvihAAGGmJG0BUBqFYFbgBBsh2j0k/BMl5AAFSAAFgAADkHTiRC9AckeGUAAEmH4E6lEAAFSDfj3AAoGE6kHB6oxkzG8EcKiilCNlBCrlhCcAAjWGekoESCPnSEOGEmhFaAUl0HGnDmEDEkjAAm8jGlqAAAAhJiMAAkgBGkmAAAAiQCpAAlEmPCbAAAAAAEFD5ktEJARAAAAFYj4BpAAFMAiG4oKBBkQAAAAC9GFFoAAG7HimMAAoaAAlfAApfEwnQAAIaFznOEUkbAAIgAAkmFpIMhYkvAAJdFrFJoYIaGJFMlICAD1kMGykMntlFGxAAnsAAmamIICAADEGdmtGvDFkMAAAaAEldDjkymgDximmcGmIdEFkSIIiAhmnmoJlHAAlbJBEaAAEcAAiwAAlKCamRAAm/laDVAAE5AAmfEyHfoFAAAAgLlNFLlbENlEmxAAl0oVElEZFEjQmOBiAAlEEWkUGHkSEeFIlBiKFhIAlcAAAAlMiyEmkUAAE7EQAAlTmOoTAAEoFxkEAABrAACNAAgHknCtAAESiZCcF5lNESAADTkkAAAABdBzB3C5FPjqGYGHAAD1ieiWljDrAAAAF/FvkSGSEUibi8EokjgSAAk3DWlRFfheDAAAjzm0kyAAjDD+osgxDlA2GGhSAAAxmhAAm3lxDiBuFFFlEQGhIpiPmzgbDLEDCJEcnYjpGYEHh0knG7FAEBHNAAlQAAk8G9GnHzlEAADMkgHHAAkjCUAAiZmaAAjRGbAAEdjtAAAAEviEDkEynFlvAAhxGFAAAAonn2CeAAmHH4BlAAFeCNEmAAmEmhgkAAAAFknHA0AAAPCnFCmrlYE3FWmRFVnvh0AAmSoJHEAAkBAAGbAAEnAmkFAAi/ERC8AAn9HElOAAEtl0pRDEDvEEF+AAGkGGmHGwmToWAAiMG5AAiFGaHjl4BXH1kIHMk1l3kAGNGsm5HTGbliIDlVGmHDIbFeCoGTG2C6g+gZI+gxk4AxCmk8kLmUnMAAE4AAAAnOjjmUAAHHGslgAAAAmkFiAAkkErm0AAoAhlksAACKDfi/gjAAlyDFEPiOCcEHlmAAmBE6Cok0AAFpAamPAAg/kTH1AAEhGZAAgiFGDXivjoG6GEIql2AAibhMEzE9DCIiJCAAlWEbinAAj+nXmNAAC1kjFwAAgGAAhiAAEBAhi4holmCgEgnCmKFHEtE3GEmaAAH8EPI1C1GECnFXAACXDUiEENDnitj9jKkmCbC+kcCqjtj5ioEYCwDLA8JBiSIwBpI+AAF4AAn3FVlcHKoJgHmTiTGKGAI4A/mUmDMtFEGGqptGCApkoGMwnLmFGMNzjHDPGqFHCgjnj9FpmjIFIuIiAAmdIkpCo7CVkEouDXAAEvDHAZIslXiknFqjjNFECXr3AuFUCanQE4mdlFjzDsI1AhAAGRkjH6AAiAGpIFAAoHmUq3AAKyIAGGAAH8GXAAGCmaH2mwiMCFHzHcAAAioVJXCkH9qUmhqlAAgokGHmAAGAAAJIAAAAmFJNAAB9FSrGAAocoOMMCKleoOHOAlAAophRo8lqJmFWIhkyqGHNE/GoipHTMMITEbAAMSmwlRIAK7HsEtiqqsCEDwlwKOlbAqhsIcDKGVngAACLDYmcGLjvlBmIo1DeGplXGBDIDIIoAAAAiPAAAAAAC8H8AAoPHjHGAAmHmRkrAAlrjSFlATFpkAGJitqfGlhJlQnDqEF1Gpg+p9namrEGjqEfEmjmiZGkoGoeG8AAmLBvnXIcFci2Kfk0AAiSAAHQIkCdAAAAofEDgIAAK8I0AAAAAAFEE6AAERkWkdAAl8sLihoBAAIxoDoYAAMWGWEOltpZDiIGDnlkgqJHAAIMh8AWBTDYkODKgtqvJJGCjEJdAAKSC4IDGDI4GholEVF+lKGPAtkLmDlfD+kDGRoHHChJkOInEzDLEHjQhSIYCbpTgCIXmqEBlUC0HHk4DaEAg9iLk7gvEnk9DiFAGdFQARJhIIl6mDmtnFiMLGkFiTmWAWEPFgiSnOI/GREKDmp9kekzDKGJFxjxAAEzCiFCq8n6DQnejlAAmnGxB0AAm5gTp8AACzAAAAAAIGinIsAAIXmPEYHPKtGICeCNipl3otCVAAGFo2lVFKmdnpKNAAAAERIKAAAAGSlXAAGhAAiFAADRraj3AAj8ImIAgkoAAAFHofoBIwjNnTojEVJdF1mmpannG9qCoJFGqPAAkymOIAo/qdHBG8CoAAAAlAhTotAAJvmlGqAADNi9FeAAFLEHD7HMJpi8GqjdGtlKkMjiGHkQjpAAAAIhC8oFAAGUjJovAAnFAAlXAApNnqiSAAm9FuE+nkFJCpDgm0IPnQlGEVo+htJniYmIphlRHpojkWBsEXJNjLEDKQi4rQpzAAAAG3IOpRJ2ndH3HigNCBEpAAKwkGAAHqlYiAAAoCFCm1AAEnmrGQAAAAljjUAAI8GXAAGfhRqPAAlFF7pfqGo2AAmIAAGpGPFCAAhBmFsPA8AAjakWGMDfIPscmcDNGRmEINAADpo3mWJVGEkqCDllCghemaDlkcAAm3CtAAGbn0AAHYHtkWAAAVmpDHAAjqETBuAAoXADG4nVkcr8AAj/AyHanDCnkViOmXEuAPJkA6EDGVldHTnvk+k9AAjQClCsHkk0AAgxFrHUg5oRjaAAAApwHBGmmICGoICGGLmBLsjJkhmFjMAAHHknAAAAlygBhIAAEcCVlVAAmAClDvAAo2mLntkkAAGBloJZBnmdFNAAkHlxkOHmAAqUF0mCAAoQoLmQAAlUnkGbAAnbm2AAAAKhI7lXAAJep4H1EbELAAETmRGpAAiABDDqG1KrkwILk9JcAAKWAAEQmJAADMGOA8KkiwlNAApikDDUADJQGlHtDrHzAAlgkHjslXHWFzKmhpEiAAK3AAAAHomhnPEgH5oBHckwAAAPFMD9AAEYgLnTAAG7jInXAAJAgLFOAAmdljhDl/lYEpjTjxkLAAhxlzGmAAINnPIjgxAAnNEYkqGqnrFmogiKojizJ3gzlEnUm3KVqqMEKKGQAUELD+nnBbECGKAAnUn/FcAAGnkcAAAAggkihyAAA7g2ASAAhECtAAm1IyFqEBAAIeJxoNAAAAkvEDHsAAjeAAiai0IuGKDoIIkfAADwiEg0m+Gmighwjwl4DzkIFYAAAAGXjqhwAAhTAAjjAABvlAlkAAlmAAAsAAkZjIC2kGEwktjgEaDVi+ldEoFtExEsh+BanBDSjPAAAAlIFKiLAADsFjAAAAFKEYGEAAlmhEE5AAAAE0B6AAB4hCAAi2FEmjAAkclVkhAAC8GZmDAACGm6FSAAF1jbAAAsBblYkroZGUHpmPkOGamZiokkAFDPisoRGHGeoAHEA0AAlDFbllAADfDJDUAAHvF2HFAAmXGHAAAAh7GhjRHblQh/ktIRmzp9CinTi2FvDJhlkUFbmDB0lyAAAAk2kPAAAAgxAAAAAAFIDVAAAAG4HoAAAAmchQoSJUmmAAIAniEQlXD1m7iQAAAAEKAAD7mFgYF7CzinmEl6EUpvEmj2AADsD1ihAAhngdjeAAlDClG2j3DSg7mWBvoHGxC3DRkzAAAAGToVj+BNGRAAmtEfBmFIB2AAD9CSEKAAkXiboEAAi8DdEPAAjsE8AAAAAAmcAoAAEHopAAAAD3ojEEAAAAq6mjAAi4mpDeAAhhAAAIk2FEAAggoIEAAADiGcEJAADYGqD9AACNj5ACHFFehQgrmslZAzgwAACLADAAmTCPAAlwByidi6EPGFHmi9CEhtDGkyEIHSB4BbBYE9AAFpmEmWHilEAAHCDkAjAAmgFrmaAAqmAAAAAAnRkLJjAAHaGuIDAAJDGrnMEoIQGvBukrrcBzGWh1MFBECaHLrkDJGTHYGjAAGoAAICAACkEQIRAAkxGUn1AAKCjzmzAAHlluAAHkmyknAAAACJLTAAoFCOkWAAGED3FSAAmvj0HXIsGNIGnumpAAoEGMJDFVnTAArSkwAAowsoDXIVCZIcG5AAqsJQGKAArUKojVAAKgFolZAArfmFISAACXl9gUobItlWjRl3C7HDFECym8oFFuAAi0E7n9DGqzAAAAprLHAAAAoLJUAAAAAIIlAAAAI4FsAAAAlnmgIGF8qrpBlImVryIIozAApZoKAAAAKVAAIUHPJJmHlogWmghlFpAAAAEDiCAAhvBXlAEomLAjkkAAjYgFgQFsIKHJjsCfhmraAAFKJPknE3GnkojnFpAAGzmwKPjAAADFHnk4AAmtIlhcAAJnogGjAAL3FiFKAAoEmMiZAAHXqWo0AAkIk7ifAApPq+LYAAkXI5m0AAFXAAAALgjLAAn+CaJHAAJHj2DJAAknpGEyAAAAnaiXG5FcEwlcoBkVpgHgHqjFmcAAAbCPGoChHkkMBiDhImAAocAAE8ARlLAAmcBxpyg4FElqBCAAGdIhKAAAKvgzhFAAibGCoJAAn3jtInAAiSjmnDAAqBgkjuGIHQGqEhHgHmH+qCAAqfhnLZBdqZiXo2HQLSEgkSEYEdAAnHncINAAoLg7FzAAAAlRG1AAAAGMokAADzGNAAIZCoALAAleglIBAAofm9ErAAm2nuoQAAC7D+FbGXGbjOptIZlZIMiKr5n6DbJUAAlYCVjCMLGIBmGDI2maAArEEDEfAAJXmfILAAqPmXJHAAsMlsilAAAAGciLjJG9ECisH7mmA/AAGDk+kXrJlxlck3iRkjriAAAAJgKUAAAAhzkVAAAACagjAAAAJDiIAAAAG9nlgvE6C0HMFrjcIinXouponNn2nTGHpSmIDnIOo1kwCLAAFvAAAAAAkWBYC0FQoDAACUCdoJAbISCHj7jjkYiEHbE3lgATBNo6kfkgHJLCAApxJ7FKIjDDkAGtk7ppAAEBHyIMAAh6mCinAAmDFOA8AAMJIIkNAAIFG9AAAAmjldnBAAHwmbAAAAKhrkpqAAiYIpE7AAIbAAAAGuAAAAoRAAkoAAmGIgEJAAjVKfHDAAjOogk6m8jZlom4o4FYEGGZoFmHoTkVINmLqNkqCilKlomNkIELGVgdA/EFpXIqGRCOpaAAIWAAEKESI0GGm/AAAADoAAAAAAAAidAAGOJTGoANAAAAGCAAIQDnhnDXFgEFoHIcoMC2n6DPEtDAE/ETklHDjpG2IxhCmuGkkdAAleFpnSAAnekADmAAhrDMoDAADGETJnAAkGnjAAAAF2JhAAB/FMBPAAi5lZIwAACICCAAAAG9FKIgi7E9oHFWgolOk0ihlDqHD/nQJpoCnHkULFIgjMEkmtFzAAIoASJdAAHigpG/AAigFSCWAAJjFJDxAAGTiwDMhPkbISk6lSm5lJi3AAmsGdC9CTAAEjI1EXEZAAAAk4m2AAAAmsiHAAAAGVhyAAAAoQF5AAAAD0BWESEyAAFHlTobEHAAmOlTCtG9G+jBAAEdIRkQHhuXIohCmnESAAhyjFBoAAKAAAhGA3oEJbFyGNmAkgkuKFFmHRlAAAJMC4AAFlm1IHmrJ6IIggIfAAFFAOG6hQH6AADWlqleAAlXiylFAAGlnzGDAAmvAAHZAAIfnYBZAAksIaGQAAhvnTGiAAAAKHIXAACCBbGsAADJAAG5C3GjAAiSocmfAADWIxkUAABlEFAAAAFKI4m8oZihmWAAGuCkJgIBnRkNHKDSFQAwgSkRhUmDAZhklImwHpAAF5khE3mUgYHBA1ijlyESAAGPh6GajOAAGuizFSAAkTkgAAAAiHJiGnAAlLmKomAADvmpFFgnmNAAHglmGMmQJWGckNknp0ggGPAAmeGBgQEmHsA3h6AAkABZnJAAAAG6nPAACbHbjoAAEBnNF6AABVmvAAoqk+nYAACTIuAAAAkNh1C9AAmMBiAAAAkEjLhYE3knDtGDiZFdKfiEhQj2mxhmDoGrCSAAE2i8mQlUA2lSAAIDFZGBAACNAAG8AAnXDSAAAAKBFhlgAAjvAAjdG2nKpOl9oMkfAAAAGWIhFACVoRiqpTosIVkkAAAAJLBFAAAAAAhAAAAAhfHmAAAAlXk1AAAAI0C1qznTA/A1AAJgAAh1G6ENjeGDiWGrATjaFBHOoWDrJ7jAAAC4AAoeKrkyjEKhorAAijmhG3AAKNHenkAAgvllGeAaqqnuiJG5KjFWHsj0pKlOmEhQhMkBICkOAAECAAGoDKlBAAgfDZiLAAntI6pPAAF+AHmTAAi0lClSAAAAhajGAAhoohlBAAlLJhkMAADskqhkAAAAAAoXhQmVAAj5iBD+AAjRhmmmAAgfFOjBAAAABXlEF8AAFpINk9isoTGcHpmVCegsktjJlyhblFlNELGCjim2pXisHxm3FDDEEjmYlMA0JaItk0lwDdoziDGXAAmTliEHCNkMk6GLkiAAhSkYhBCQGKlZAAAAAAozkvAECFAAEllEAtAAKKDpCHmaBVkvAAAkmCAHAAFzAAjQD1ozAAj1EjjHAAlsmrjuAAAfhyEcAAEcAAAAGMhLAAAAltgvmfAAGrh4iBAApPA+AAAAGqCODACnlYAAi+mfCIAAHOiJAAAAjHD7lEAAAAgDkQAAGGkLCtIMCnEkGGDHjMkGkijlgAmqEhHKjEAAjDocB9mMkhAAFnH5EbAAEEmCnAAAiomNAmAAjiBCGdAAmCBUliEeE0mVqCF4EDD7oRlJi3HYFWEACjjyIDBehQD8CCDQAAnUkyF1AAnLhuAAkdGVlNGoDDm/kQB9AAIgAAiBESmQmsAAC6DoixAAlnBvAAKCC2mMl+AAAZBqn5E4kcAAmiESAAFQkQAAj2CSnYGVl2AAhyAAF1nZAAiBhbldF/CpoBCvkFklC0AAAAgDjtlFGVDaEVIPE0AAguExibAAAAEmAAAAkvEZlHAAiEDsEFAAJEg3htDyAAjuGplUAAmZlimiAAhdAdDWAAiSE5EXAAhSmbCwijAAIoGWjwoRm4AfAAFXDJBzAAGNEmArDwFFHPGNkHCSGJFBlVEQCMgNAAjIHDhxIyE3AAjPlNkkhsAAionvg3ihAAJEAAkaCzlBF5HapJo6mdpIgkGXJhllAAHop1laAAEgqbAAAAJfLBkEAAm5J6h5AAiWAAAAG/CeAAi1AAHEAAEAlfAAAAi+mpkUAAFnknAAmbBCFTAAsIhSndAALzmpGwAALoIQjrAAE6mkllGlFzAAIHC7lAAAnzAAjtAAFyCagGAAm6CqoTAAKlmAlMIjkgmqD8jHoDoTm6o6lhK4i3mgnJEsg4BGAAiwjiAAJRg9AAAACNAJgwAAkFioEEAACpAAlCAAIZLLERI4GXjkhoIzoyq7gIlRI9LskWHkmSI6AAoaGsMRAwmnHlkODtEZoEKaFRHklFGXkaIdKmqJIrjWAeocmtmkgigTIRIkjZH0EmGkAAiYCokmlbl8meoEAAkPj7kZqJm5iRFNJwHcC3mKEgFHDaF0qAFkEQEHFKAAJLi9o3nsHOAAnwFJFkiXFdKDCwoOKKA0kFDVHWFCjTAAKrmIKIAAqxmZJ7AAr6AjIiAACnIkjpAAEDFfBYErAAK6m2CYAAKQkRlHAAAAFHlZAAlkGuCjAAAAGRGTHFE0K6leEdl7rqqFjQEso0Exkjm+ielMKAEBlpCgkhiWhOESl4IUKaHGJ9gJIAD6E5CDEdgeCeoAF/GAAAmOkyEmhPo6AmEECaApAAJ6o3AAFLlEHnmBJLAAAAE4CfGWAACtHpJWAAHVhqCZDkmkLLn6AAp5AAnIiHExAAIFFysAAAAyAADNAAAAmMHEAAF3jaAAj8CwGFAALfGRkdAArFoyiSAAn1ksl+AAIpkKjbnSHQAAEDDJAAAAqJoLGLAAkoAAmfAAAADbGdAAJvAAAACvDJF0FfJMDElMhGIhm/oYpIBBCDneCXgVmYGdCdAAFDmRkBAAlJihDlAAEMgAA5AAFtA4DUAAECMYnmpplWEWA9JGrAMBBKkBKHASmXKeAALNlirVlQG6G9pVgoq9FUGioGrvF9AAJlplg5CYIbG3KmAAj/AACYnTINLMGFnwidmek1k2kXi5CyFYiDhEihoTEFEKkwmEq+H+AAoNm8AAnrkwGWH5AAIZI0FPAAF+DyJeqLmPimIHnZDxAAoVAGCpDKldFAIzknAAFbA9GKGfjXAAKCHaB7AAJwAAGlAApZEIGEAAqbAAGmAAA2DHmWk8AAsClrl2AAAAJYI4AAiuAAJ3AAAADYlHAAD/prFCAAnaAADvmOAAqsKsg0CGJEAAiPBBlyGGmJHupanvA7loHtnpmxB8ncmto3AADcDSElApm9gvEsAmkiGAkcisAACMGaIAACn9FsAAD1KkD5AKCzooFAHfiTi4AAnOmMjaAAG3qYlNg5jToKmOAAizDGoMAAiaAApiKGlnAAnoDzAAAAEjIIiSAAgUDTHIAAkpkzAAirkUBAAAJgGKIXAAGEpileAAk3JIlZAADhJwmhirGIAAAdC+meAAHkIZH7AAk6AAAAAAA2CglFAAEEAACPi4DbEClhEJnQE8AABfo4GMAAAAJQIHlpjMAAiZpYAAFQDlquAAGYHFH2AAA0Jkh0AAhhGqkKAALMGWAAqDElrYG/KEsvldjclPmSJeIIq3ijMEJPo7IqAAC8kBiCgXAAAAJeF/AAj5qIEfpuFRq3nZkyH5qlgMFxplpmhdjhJcmIDko2Itn8kOAADmHOCNm4p0FVnvKBHAqHBSDbmRm4FrGpIImlIJD+ILmNAAkwCDkviWJpmKjvCOAAAAHHDKGVEthDAAm0I2CGkdkWEFmLmRKSAApiilIaAAqzjfJ1AAGVGWKqAAG2hOA8AADQDbFXEaAAoSijiYAAIZCvB8AAiEAAIHAAAAF6oHAAkVAAiNklnnK6AADdnzAAKIAKDCl2l/itjEh4EtAAoXAAhCmVmQIQHsibE0KBIAivmBEQoQCdGflHmeDpDQmKjGDTAAAADSkZG0mWITC9E8EUolmEIEGli+AAkDncAAAAB6hgEWAAEAm+E6AACEGmAAABCvoUoHAAmSAAIaoQEQAACpE1kDAAmSksiRAACyCcKdAAl9GXAAJJAAmbAAotAMHdAAi1HGAAAAgygfAAAAAAI8ounHkMAAi1kdmuAAIOmpiSAAGvG6h1AAAAl2AAAApShjCiDeCjAAj4l6EpAAouE5oKkOGXERrJksoVGYmpo8JeAAJSiRkfAAkXitHyAAkRG/AAAAAvnJBeAAo2k7AAAAmcGGAAj/o4sDLMKKC9MgEIjWHiqqGZJxkMAWAAH4APAAm5AAlOllKOCiCLkgqCBkrRGvk0DJpigUHOnnIfGvm5iuFUAAIiH2GvBalPI9o7mADjq3FzCFImFiCcn8H4AAjQIkjLg8AAnPBToekbi4GpCqAAE+DxIxDplZkqmHDbCYD0ECgdAEinHZjWFwECjQFEknomAABJGsk3AAFRjZIeAADrAAmgAAAUkkkXAAAAAAIHIGAAC9HaIzAAiBoXlbAAERmrhiAAChmQJCAAG5ofCqj9HlKyDQjVnEKYKOB2C+m7APHTETGoAAhgDjlUGPGNESoYm9ETF2LHEvoiGLAAkSAACRnWCth0iCCRmeFYmYluhlgOAABTHXmuGXgrAAgBBoAAiPC/AAAAAAnikLAAhKmUkLIQAAitE8GPAAnPGnjoAAHqAAiHkjAAAAkniyGrAAIOGNi0AAFdIYElAAFLmyE8AAj9AAAAjNGIAAAAAAn8AAAACGHTAAAAErkIAAAAlBGBCRhTAAoOgGHJnwi2mJlWFTEaIjjinAmoAAHlAAmRIbj4AAkth0GQAAHJHJEoAAGokuGDAAmFphFbl/jcmfAAAAEMgJAAiVn+g1AAn0AeC6AABqAAnQAAnnAAkOCRmBi1EninlUjjkblpkKGqi9IOA4IlnYlPAAgdGbjomGl6HuEZnPA0nch8AAigKLlMAAm0mugZEfAAAADcIyAAECDKCwHHC0AAoZi4GLE8AABMoJi4AAoFAAlQAAmrAAoXAAjNAAF8AAkPAAAAAABkAACOlziqCCAAAAE4icAAivlCgtGLknEICmlTjaCoAKAAAAAAkLoXEsJFCuprlBmLF1GJAAGVmUigAAkNF7hUAAFpKBFKAAGCDmGDAAnCmMkDAAETDdlHAAEeEDAADamPGSEvDEAmFVHlidBgCgHrmyCvCqAAGxifCfGzD0p0FJH1F0EPj5g0lBAAm6CRjlAAEREoAACUIyClAAFQnQFUAAiFBpozHUAAFpI5pqAAFXKnioCWilE4opIIAAoDGPJDAAhEE8sCAAkwFYKLAAkQo2KXAAHaAAAAkAiSAAAADdAAAAq9I2mFAACYGXEjAAGLjpi4E9hEAAAAAAFhAAAAnLjmAAAAibncAAAAmDF6AAAAF7nJiIkPnJKdECGDGcrEAAE9jrqVgfDbmtjgmUGRAAkrkqleAAFlG5INAAkbGzAAAAGHpOCKAAE3IxHoKWm9ANAApUmKlGAAAAgzAAAAA3CaklAAACCmFIAAImAWiaGVIriWgQIHokAAgqJHojI/GXqHpVGgi4oOrqgvAxAAqeAZrUAAoCksl5Bck0FOFvgLkvG1I0AAk4nMhvoNEJEHDUJOmOmQFum/lIFrk0AAkLmVg6GCAAEaAAGSAAgAAAICAAJLAALFAAijAAmpAADEAAC6lVsHofMKFbmAldMAkxGmEJKonQHPmSKmkKF6B8HTirkakBEzmmkHEZg0mkKZmfmeAAkPKmmylTCgk1IKAACAkYlcAAFUlnHfAAoUJ/GVAAkLmEAAAAndmfD5HajRAApyGvEembnMGNlwAAlnG3BLlVlqEOAAlfF0G+AwGCEuiYpimOGSkNCPnNopAADglKITEqgUjRmboxGQkUoVAAIbjUoHpzmjEeIfh5lMCpAAqHGqAAAPjkAJAAnvi3mmAAmXm9lrAAlnoiA/AADiG4AAAAJBAAAPlvktAAjrFLlKAAqulpodAAmJogEaAAC7FCnuEKlLAAAAoilIAAAAEEpBAAAAmHi9AAAApNjCAAAAkLGIlfj3AAGKmpEDELEYjMk5hEDxECo5IEHgjXlsAACNk2mRAAGwC1JgAAm/AAiYAAJFG4ISAAjNIgAAn2ickWAArLClloAAq9qAAAAAi7FIjwAAKjAvIMAAGOqHInhIpqqdD2gaoqrLDCmomQIbiEHvCTI2o0myHIFxAAjOAAFOlphBDuEXAAGcklAAAAAAlnk+IziUDQGYAAC7jPILAYkAKqEKJvKHGfGUn1nmG9AAJCAAAAlXAAlBAAocAAkQAAI/AAmEAAHzAAimAAEXAAjiAADZpvsUHDi5D8kSHYgbBolTGdlFkvKAn4AAhCk1lOhDAApYpuGukaE4FaHBkMDPAAIXoLFWmrmdkvm9AAIEizpYAAoskKDwAAmTm5AAAAhGo4AAAAGdq2AAFakvEQEMlyAAAAF2AAl3EhGfnnJPAADAlcIKhVCMGQlSAAFQmznTl/EEh/kpHnAAjCAAHHELlrE3m8pgGyidmyk9HcEzAAE5o3g6j6iulCqGDIimlfGBisBgjpgTAAnmFXiDAAAXIsDVAAD3GCprhuBjlHGYAAH3AAC/G/j6AAAAFejQAALgGqlEAAkxGEhYAABvAADaHlAAAAAAAAmYAAAAEQlbAAAAhDnJAAAApwK1AAAAnDFNAAAAmukHnIiqEwJpAAhHIJlnGjpxoWgxkCo2AAhvmhnHAAkXGWGDAAKzGmAAAAo1GXmyAAH9oOh3q5ErILAArhnaEAAAAAInjZAAo3oeAAAAnwGzCbAAI4J6GyFGpsGLB6AkG/jUmXkQGbGJkGoXCOjykgGMiOGoiMFxAAoSGRAAAAjiEmAAG1F6j4AAk+ocAAAApSAADEqhrsmCEvE8JRnKltEQkvFpGKofqvkvAIGfAADmAAAAAAGPAAkFAAogAAJFAAk0AADLAAAqAAAAk+JOmnAAFsoJgKi9FuKCEyiHBDpIFwkGgCilmkkHkjhBDyDwmEo/lVi1lPIZGXFom2GJGkATFglDmDDbAAF6jXq3AAAAGXqpAAIvKglhAAEzHkAAAAAAGIm7FkHfHBlKnQAAohAAEhFZAAiLkknVAAmwHKkBiEAAJxJLhpj0HCmWFECNiQGYmjizFGEPkdAAGPCkDeiklHnbpGAAltpDnUiAKEAAkLHclIG7i0g8EYlUB9lZCGDBAAFkEZAAAAjiICBTgOm6CjGPAAIJkClngtH7AACmgoikAAmdnACAAArxlsMAAAkZFwJQAAGSHCGLEPlbAAAAKLDyAAAAikBuAAAABfFLAAAAIkHTAAAAGbAAGBAAlOkMqoAAFimJIREpKgC9C2myFegToBGQAACDm0BKAAiciyq/AAnYiXpIAAqeEekmAAoQHDoIn7DcAAAArciKjHAAL4kFALAAnNG5kFAAKfC0FAAApMKKGDEQFDK7AAmxJlHsBIpwofg8GSlpoQq6DSHoAACJgIm0EhoglEIeAAqHkxDsnzpZGYi9JgrLHFCnEOGIAAgxAAlFEeD0phFaHkG5GyAAFnFIDWmPGMDDAAIqAAAAAAAAAAmjAAnKAABOAAliAAkgAAmQAACjmEA1ILEnICAAGkAAj3HMkoH2IEjwnIjvkYFimSAAimhCloAaAAHTIDnMFniYAAAAFQIbiXAAktkXkbHaAAo2EUpIAAAAAJHJAAIMEikbAAg5lHAAAADAgRhMCaJqI6Cij4HpogmsFsKSAAiBDwozlVAAAAqDm7CFkYEQAABjokj1CaCqHeKAIgEUjckEl8jDEWkFkpieIQAAgZiqI+j2AAF5JnCxmWHwmxArBMAACRgWjoBhh9CwAAIVCqlfAAEUHjEVAAHjhPi9AAmgAAiQAAAAHlCFGBGDFwmgD0AAg+ETmFgOBiF6I8ljgBFplnAAJID3AAAAG6GjAAAAlREDAnAAKfkRiUAArMERFsAAIKGeCNAVGopvAAAAE7KlEMhLKIqtAAC1HSq1l5E3Evl+kiC8DqGXAAAAAAmbJBAAgimFBVjFCWHqolDilVIKEQKDkkmTDNqCErlPBtqKAAD3KUKFjyoJq9naoXGliRmKH0l5piF/J7hglSAAGPkbLkJYk3CAJ2qQAAAAqjFAAAkHmNE+AAH/CyAAAAEnFzi8AACyIFjShQmUktjjGsEmCrklAAAAoUAVG4H3HmEuHQm2mYAAjqlwAAmNEKk+AAjhFoiRAAsdguAnAALeGnk+AAAArQFinNJqLbE2D0LbqOlbA1FtFSgOkzpqI1AFDqAABJAAA5DqDkAAAAI+ikqJCKIJEineAOK+GHEvGnDUFekvAAmZHHp+AAnhiyNcAAG9AAAAAAl8GSE9AAkJDGqTkSAAAALsIpAAkEpuoCAAoVG8EJAAK3kRAPCFFRm8AAkICrH+FDCxDxmfofGHkuAApFFgGwEcDPIdC7EfEMAAmmDIm5EwCFGOELCajwiQGGlGFQECGijundEpAAk1ERAAAAnBDmAAAAp7EakzAAm6EOhhAAAAj5EQEdGLHIARi/ilAAlYlfJYAOJBJOKRjppdKVosIBjEplAAAAn+FdAAoXoPHPAAIUAAGmAALrmTokAAlHFXlrgdgKnrE6mDIUqYEIojnZKCAAiYLhLnjhFAmZgdDRlIAeGLl8G2AAC7G+GugcDAn2lyAJH2i9AACFGlEAoBFClZCcgpGyAAAAFHAAhftMnLGkiUq8EOp9nAJZFAAAlQJBC9mWidmiB6BuAAm5JsgnmrjgFCAAjCE/EJAAonmIGHAAgPkVmOAAJsJHAAAAlOJfGUm5HFg7AAl2F7AAAAFCpHJ+j4JrAAAAnqpvqJKMAACMmMAADSnrlWAACEFDAjAAqhDJH0AAnAAAHTAAAALGG7n8myqlAAkil3oOF+AAJOAAAADdJOFqCLk8momikpj5mEjjF2AALwG/DYAAAAnJl6lAmrBTGOjtD8igHWAAr+IKkDAAhLlrMBAAIhjmkRAAlMi5nWAAAAmlp9I5AAlSIRjUAAp5K4nyAAnUAZFxAAE7kKCDgOIPEzF3nJAAG5GTnOESomJVI/ikEhBpn3DHCwgylbi/gGhdCUF1jEGwAArQAAotjegfEvm1E8oFmEjhAAAACNAAAAHpinAAIQFHnaAAo7AAAAAAoKm3EPAAH+ENAtkhkDhfFCGJAAFShhkmoaoVo8JJm3gcLlEYEMAACWHjAAqnFOIyAAgmkBh8AArGohAAAAk2DVoKAAoClJDTAACdAAGzp1AAAAIOpFBGIzJ8J3iBIPpBEdCQExiTAAqxBqmNmUKvnznXkCKSIODSEZFPrOFHoUnLkXCHl+kCK9C6mJAAjKgpE7G8k7icncGVAAJqmfEpILEgAAHpHYKPGsEojuFnC1AAAAlCkmkYD3AAD5AAgEJ6o0AAsilWC5AAMDAnCrAArdEhodAAkwobkDjUEUkFAAgCAAFmCUL3GjiYkVsBjUqIAAKlmiJWnFFYJbAAGMqJm4AAkmAAGWAAFdHpjuAAmBF9AAAADMF+o7oSAAiQmLkVkbJOJPh4lbGfkTGApJl2AAkTleoRDKAAI6mHlFH+ico8F7GPJDjHIDCxhzlsiaBjAAGWprAAFPFvG8AAAAGSGRAAmqE7IRAAmCkjChAAmOFIneJ/AACyEuKPAAHgGYj5AAh/DbAAAEAAg1lliFkQHUGTBHk1AJCoAACLFDIbGiguliGmGeAAAAGzhuEqAAhrEyn9FdAAibKlqwqWrEhEiWD+IHBhA9oiBBB2kBAAl4m5j3AAm6g2MJAAEuEBAAAAH/o/nLAAlQhfAAn1mbAuG3qVjGJWnYItNCJpqnpiJDE9KcEPolp7AAjvAAK5jnGJAAjPGcC+AABLp6GHAAhlGvmbAApLDgHJDrj/kCGeAYByF7CuHmiijKo0JuGhgrlTndlgCuGxBaqqEGKDG6rdlan0nJpQqoFSnaGtmfAAHQB1p8AAo6FVmlDUI+kYirkwnnl+igk1IjETlQJUnXkRo2jsHLkdhyCiEjgUAAkZGtnSHLijkPAAHnGbIDAAoInGAAAAjsFdqPAAklAtlJAAlIlyF1AAI7oGkErssQmJmiMyBDEiltNHGilxAApUiCGmEGK3kGJborEbgYAAimo9puAAEKISI3AAFOk+oMAAryjqD5AAGYDMgpKKAAkQkPmLEGAAAAECGGmejandlkFCDll7FqIaAApEGqm1BDiQjskZijnAG4oXJOnLDckhkmAACqktAAAACSIAj0AAgeAAqcAAC3nGlkAAkZjzAAAAGIFKhaKlgAk2mHrOB3lloLn4AAEBBuByAADBDsDTgQlkICkOnej0qUG9IDA6igm8EfDrjuGeijlfCZkuElDPmtovoAD0AAFLGwAAinHoqEDLldlqJzAAhpGfF/GGCpAAB7nNjQAABxBOL0AAnZn2kcAAImIIBIAAlJAAEPmJFRAAGQnjDWnklGoiqfH8KFqdpAmNslIxokFoEVl+AAFoAAGjAAC1lEGvAAkeFxDgAABRk5FNAAllmBDdAAAAD5kJqajiDKGgodlAmEjuqJCLEyJdETlrh/EakTLeC/lzJgqKnXlYHIIlpUFGAAkQmkCUDxAAmbDdpei7mOJZkrBiFAG5DHi6l/EIIlGRC3H8AAFrpMhNk9FZIflXHajAh2gkoDAAAYkmGIljG7A9BkAAAJGBJbAAoSFBIKAAHDALGXAAlDjBlHAAomE6EpsaAApTKoMbAhFAjGsSjuJLAArFAAH5AApeDxKxHqpWAAAAkkHcCBAAnGlJpZAAK1IFBFAAlrIDjfAAkPAMnTK6jgDNmtmOl8hEFthDmMAAFLgiDKBoAAh+m+IIEtiAAAm3BvoOmnk5hamNkmmSAAGlAAHEkcn5AAE4DVAAE5A+rYAAjdFYKIAAFImdEKAAoJkAhfAAm/AAl5rcAAkcEAAAAEjKDyqkAAAAiOmHAAA3AApbAACtFJHFkzFBHeBxhbFWHxjgFxG4mZm2m8kcjdmsipGRD6EHAAG/FFiejKjDAADAGIlAHLEBm1ndjhlDD9E0AAGnEgHTkRHCAEFSkWiIDnHVEGmGAAkQgUjGAAiwC9AAE9n8DhmYCWiRDYGkCTFKiFIRoxEKhfAYlYneAAAACwpjAApGAcLeGEl5D0KcmJIOBYKiBkKDAADlkxmOi9lrj3j/oEFljJg9LWEsAAAAodBIAAFPJzBpCMAAkLGNGlAAGCglm2p3l6A2E0oqFVlIAAKAC6AAFYHjE6AAAAEfHwAAo4JSAAAAkDAAiKAAkoIVAAC3gmp8G8oOh0pRkzAuAAC8FdG4HsqQlOIvkmIjpLn9HCJlmxAGndirInExAAJXlllrAAHblRAAikGsEXi+mlCXqGGOAAoKABBjk5FQiPCRjpG9HVEXjlAAFCoPDOnnkPFGAAAAEomgAAlKAAiLl6GqlGDugxGPA1r5GpAAFsLaBKAAGSoJkPAAkzLTKBAACRGSAAAACHAAiWFvstmLJTKHLxJbLootMlIaIsGvqSIlBBgFjlmwAAGiAAjOAAFCAAE1AAIaAAG+AAm0AAAAAAmJAAkFI2E4oOiFAAkEAAqNqRkelPiriHmfGMnOE3mUGGAAETHtARDSjXGMmvA3AAG1EAhSH+FeAthRG7jzkYoJhHH0igmPAAEZG0AAieH9jHlBiJFAsXhJjSlzCjh/i4AdDCjQoKCdj3GknVIkmUGQE3lAj6AAEbGVA7EtAAE3EaCpAAFsEYqmHNDoj/iSAAn1m8AAlbmLCyEVCdktEBpaGbKdGzAAlIl9I0hoGpmPEEjeocmiDQkLGiEOm0myJ4JZlVMVkmAAmukWAAmppsk4higFGTFCAAk2GtDOiDKDDEAABTmcmDEGHwkEFDCWihi4k2AAlKn5GNAAofnGIJAAmVoZAAAAlnHcAAAAi8i1AADjlZHpkbE+AAn8FHglBIAAAJq9obnIoICkiMGtopFrAAFgGbCBJBGYEPjlCsJZBNAAkmFpEfinmgH9jklxAAITgJmqEejcC1HHEuAADLknAAI1jMEXEkmEjdm0C9mBG1FEA9G2IUngFdn3AuknEQJ5mbmaAAnrDALhozAADYKHCdAAAAqxDFAAEpqbKrAADqAAEVAAAAqgjAnFrcp4mcp3scKnsNGcLWkOAAouK0jqlfAADUFDAAKFAAIdAAGgAAG4AAh/AAk+AAnnAAmJAAJQAAnqgQCaihG0IQEKECGbrCjjhSmEkLIThfAADci2IQiwGyEdnYkcICE5E7hbmtjiEqAAk/AAAACejdCmjiijE7mdlqAAh5AADIlMHpAXpRnPLvEYLHAAneorASIfqDEoAAGZGOi6AAh4moIZIzh1GEm/AAI2AAGNnOFFAzAAJGCbEVmyGjC0AkigIUkahGFEAAEeAADAAACriVjdEIKCG7AAkpjuISgwnijShhCqiWAAnNihAAlvAAEAgMpCKxAJIQGTsMHvDTJ+hBoRjEmpkIAAIAmEAYiJiQIklFmpK9IroYDikoFmAAg1k8F5m5g5EAAAlPGlmUAAAADWmeAAoPkAAAAAmKFxDuAAlhEWCViHC8I6kvlcoXmtFJILK+gLAAoHr/qrAAGKmnJzpGH0ITnulLIPpnoyhJAAAAoiHAALFeGViSEfGUFbjOAAkTH3i/AAocozAAKAjQnxAAjvESFsIxn9mAGQJ6nwEqnjB4jLi5HJBiiIpUI9D2GZmGIDn5DcDQDJnFApphAAFSJjAAAAAAG0nEAACRkLAaAAlGizi6AAgHAAAAniK1BjKlEQMCFFKBjqh+AAGcFOoIAAArkfjTD2AABgAAEZAAmRAAGKAAEnAACEAApgAAk6AAEcAAGNAAk4IiCEhLkzmSGDi4FxAAjJCelyBggRh3mgIlEOCWAAC/kMINEXF9l5EiAADbltHJjzDfFOEomFkSgbgrCCECHFIFD5HJAPjHHAqiAALaoMqnLOkOBCitiDD5hhkGkbAAAAE4HFrgiEneAAr5ApGeEHDNmMpdiACDlskqD9DRAAIHg5qmCzAACaoglUG8KKAAAAHfgUnnDQDgkTp4JhJMEOodpyIpKpgNAACkgqojlZEnIoD+IwAAE1JeAAE/k5qMGdKTFgqEj2ivAAnCkdmhAAGThAHFHvANCnmWm6ntAMhMEhIyhOCVDworAAj1AAmEoCKiAAgFISI6AADDEYBCAAEvDxIDAAC6B9nBEYmThwnNCCEZFrDjllMBIHk5AsrRDJIglapGkVqbHRAAi9iCDnnrAoAAGQIkD5F5CPEsljm7DDIOpXC9AAoGoMjambluB3LuHxmlnnLLFAHAAAIzl9G6DQG5Gtm6AAmFmEoelhJFH/psGCoZAAGOoYJiCOAAlZGlChpQAArJg3CLAAsgAAn5AAAAECG4AAEpjrAUAAEgCQlXIzAAAAAAAAoyBTHDqLogh0HkDMKAAAAAAAAWAAAAFFAAjJAAkXAAGeAAGFAAk1AAmcAAi2AAGvAACJFLJfDiEiFOoHDWDVnulFkrEYAyknmuEUAAkkF+hWnrAAjFhYmsmamtkvk0mHFRGGFTi6D/GFF9FPFGFaAVAAj6H9nDFtDrBmoBGnoRIALUHNq7oGIjA3j/AAFNFWliDfGfjvj9HjKHAAIsISIEDNpDgpFGi/oJBnD+CdAAFZGKDNiMFBLnnLL4merJkwLOj0jphdAAj+kzitiEqMnXK1HdAAIUnEIQmCgpAAimFUqIovkoibAAjKEfnzksGcoIIZHoKlH+m5AAFumwG5nuI7ISkBDtj2jvpakTAAmLAImKAAISnUgegNlsE9JKAADaAAGAi9qUAAAAHxpbAAgDh4jaAAiSGAAAAAjxAAJ4FSEzmhFgIXEaJGGIDSp4oWFkF/KEhMpIEmHZLUGpphIPmPIgGNnBmjnroPDsj1Fso0nGIvlJBimpmoKCFCgvgQkYqWE2AALrnOnxFCrrlGAAFGnKFGnFC3jdAAmvklI8FjAZmyLxAAGzl9CKAAqTAApQA0kAlTmmE2mQAApeAAGuAAqsCPIDAAITJvGYAAj9jKkjAAiIBKAArZITCXJ8COEBAALmHpDpksLiKIAAkjgHEDnCAAAAl4AAAAAAofAAGKAADAAACtAAmuAAhcAAn4AAm4AAkzkgAAEPFzCem2qNlxAAlaAAH4Gvh2G5mtAABOkZmAAkAAGRlCEcjMAAk/kdAAFViSnZjkChkREAFEAApVEdk2AJpPCNIciBLLHioCHzL5H0AAAAraEtAAG2AAnSAAAAiyCqAAk1AAEeAAFFgjooAAAAArnUHXhGnYAAkThyqqDPimlyNJjFjvlrm1GlnHHosUggAAEBAAEgAAqFi+I1E1LMmvJOBLIkEDH8CPm1ghm2EVFtoRC3KDmErLESJZBQsHAAo3E9MLIUAAgcsIpTEtAAoEBOEbAABdn4AAAAkQo9E8AAmlmapKAAIqIBj2NiIWH4hSsMBvIFBXrgmaFEmLM1LPKMEushr5pziBAAFzhei5AAH4GloBgsDvGgLIGQJbovG/jnjcChDHAAj3iVAAAAAAB4FOAAEWkKqAAAHzJAAAAAKDkPAAl4AAqZihlKAAEKk1EdAAIMAAjEAAFaDTmwAAqDkVgTAAEsGTAAAyjkoHDxAACLlbGGAMB4Fml8kWALBAAAEPAAjMAAAAAID4AAi9niEqAAm2F/GCAAAAkVKQEAk/E6qEAAhOGNsrk2nmIMKmj7EhAAAQGShYGqgqAIDZIrAADpG0nSkIm8kflAE7jClgAAi2h1mWCFjTmGkUF1AAH9D8lqAAE/HAFbgqBPDEDdFykJBqI4AAk/HNFQAAAAjQFoAADVAAIcAAiDiXhsAAHXm0GHAAGjHOgGEzGZmWhTlhFnLHDgoBAAMHlqpVg8MJBQAAFtllmHAADBEMCAAAlupHI8AAAAAAkKAAjtDnHHkrAApqjSgWimHsmkqWD2sBEhKGH+EKE9qAFRM/jSHApPAAheIFmNlZJMFRoAlNkEAAiroBAAI8pAj4E9kNDRG+BNJQoFDWAApuozMWEsAAk5ijkZmqIeshhZEYAAjNAAIMAAkEoGnkAAAAm4INAAF3Hto3AAjeDnm4L1CmI6AAHTmEAAhFGnkXgBo9ICJ3o7kvsSqzrynyAAhRlpqJBYG4GxoDkAAAj6A5H6HtnkJiHdFgosKgAAGNoGpJAAhKiLKRAAmDHLqbAAMIpKkkAAJlGmAAk7AAjelOHNAAiWqQCqAAKHkliJAApQH/jQAAoFElkEAEpTp4nGDZi+IqotDmAAj5mInmmMD/FaCDAAISAAGwpRqOAAEAiuitAAHZIqFGAAlIFhnCAAGGkPiVAAAAJMi4D+kUEHAAoDJDFxEPmVIQm7DWosHlFCC0AArYlEAAD8HUHPAAFfoNCWE+DZF8DkGGmOAfIZFChLByBtFKGTIHClirojAeIhAfkJGkGrCWELDsAAAAkXHgGDAAFHAAAAAAGEHRjDAAg5AAIPAAGGFEgnjFE4JJqDFmhMHOoApAAAqmm8pCGrszl6Ckk+MoBPAAkiELg+AAmvgdAAAAg3FfrwAAAAocE3AAnxivHZHNmdLHneIgooH0lwqsFeKlLKK1G5AAD/pkpeIqAAiem9B1l0mNoiEInBotqDFmJGqtInkUAAGQEUCnkWpDmMHDhtI6IYEFoEgFAAAAiLItFDJRAAHUo2lgDUmbAAE9GLIjAAAAnRopAADMAAGPAAIWn8CXAAqGFVAAH9HglXIKKJIfjKLKnjEYAApRD2gYE8iAJToJpFIkCVAAlSG7EdANAABCmhIYISCXjOGGGjiUAOARiWJ6AAkomsp7AAB3kDImAAmHmDFEAAhRFspTAAoOkZJtmJAAAAG+IMAACcqJGFAAkdm1j7AApNFvHkAAgyqfDdE5KcngqRJAiTl/DSE4hXBOowkRFJCMgtAwqVI6AAAAEAi3AAEckqmwAAhcFBGDAAFmCNGYAADzGICvohAAC9AJHOmriwosC/HtiSGcoaIOAAiTm+IZEsGzniqomdE7EUKQmDgZo7F+jXiolyGvlum4lLkIh0mNjaB2kaFGDPjiDEAAonAAAAlpA5AAp4FdAFghAAAAITFUoYAAnboFB3AAldAAkuAAAPkdlSAAi5FdmQAAGkl8qKGfAAmon/BEonrcnlprmhrANvJxCVs4mHAAE8ADmTAAD1Fbm1AAoPkzL/AAInlhJcAAF2AAEnmlAAAAjnoQGTjJEXKyAAJiGaKfHssPiDp+pxL8i9A3oyBYmcA1KCD4EYjEqSEZhsnLn8GUBtAAHyAAAAjRmtidjVo8KWC9AAJ0HIAAAAGmnlgflMqiLOGMkVCvAADgmXonAAFPGTpyAAAAiNH8AADTFIp5AAj0nPGZrBALKODYJAgcivjGMBl+AAIvrVkWEcjULgrLIEIfDnBcFmJLAAk6mqk4JVBJmtAAJbEgnTKUAAILD7qVAAnAIkrjAAiZFOJOAAocHiqNAAp0pKkfAALKAekuAAAAAAjBldAAE3MdAAAAGml4g9AAEoqKGfAAEho7AADvotnkJmE3BiGjpVrsoVmzljCNKPmFCDiGpQI0AAoDAAG9AAEpjtGLAAESlsEVAADUkIGSAABGjVBNEolcC2GOobHHAAgDl4gEkKECk2ptFFAAChEuAADVHeMHDamnAAsuidh/CKMHh/ADixmBlACPHBleCkiACNIgAAAADommm1grjLEEkUAAJIIlmrjeFQAAB/AAHfFXFMAAl1nnExAAE5jMGYAAAAldCPAAFcH2o3gUoGJLnuDnEZL0g7I9CGq/h1GFAAKmkDAAmJqngUAAG9F8AAAAEiAGCdAAkdi9pmAAktGYmkAAIaEZsDANmeL8AAmKAkLUDQDnmgKJmkgIIYlXAAEfAAiSAgC5nhAQkCnOn+EXCVmAI3kskSlACgEcAAkZnsiIERl4AAjrBOp1GUASm1oEpKAyhIJhF2rNkUHSiWLGI6CpAAIbjqEYAAEJJ1CuAAAADXipAAk3mYGZAAnEg6mJJ6gUGXkLkTCdnWoErMHEiNCeJMrJiSAAAIGhn7KJiGkpJiqNGVjvCGH1mbHEkkoBA+AAEyJiAAF/nJEMAAFyITCOAAgeAAmVAAAAjPHcAAI9DCAAAABujqihHSAAAAHaAAAAiMFjniAAq6BFFZAAnQGcoXAAECFGhIGgqooGCGAAEKGEmHAAIJAfFPFSm4lJihBJlZiuAAgPFaEbAAAAFZkBAAgej9GTAACgE6l2AAG4AAmbEQC+g4I6kZlEGAnWF8HnDQI/FZp1CFA2gUnOkFB/kqFQGOiXlpm7BUiNkQpEFDBommGjp6ivl8KLIHEUD/iYC1AAHJmICEhxG7DiERgSFeFMnMirnvIVo8AAFBHVlGAAAAE7ECAAnUoClFAAmsj+opAAkKGVmHofHmAAgBlVHSAUFkGJHYAAoPoOINkFIGmgF3kxJnCHGKiHAsjkAAmvjmEBmZmIo6CQFRAAiJFcAAAAhwAgAAAAEzEGAznAAAAACcA0HHAAAAH+AACpGSIcmIozGmlRFLAAlaAAqDLJC8DCJbGkG9AAJFrsnAlYqJAAkSn1BxJGjtGjHgHoAAEvFhkeCXhbhdI1iUAAF1h9kuAAFDAAjFAAjsAABOAAk/iqgCAAETEYHXAAmSENjaEyAADDLWhBkXIsLPmFmjEGsFi7FWDfq9FdGZGiGKjVD8AAkZhqINmzhsCCAAGPhdFiglGokTnWjXAsAAAAAAAAGXnvAAAUjToYHahOHSEWiRCrGTAGCrBaAAjkAAD8AAlsAAAAAAkXAAoIAAiCAAIPAAAhAACSlqDZlYoNmmAAAAB2AACukqAAmMpnqDmcFAiGAAn1kRIzowHCmUMfgGFbJsm2GaqOmsnrFBJKFwIFDCAADaAAi/ADkYCAhmltE/B3KSGbF+AApkAAAAAAEoAgiYAmAIkwAAnmBCFviWIBhJkJAAAOAlHFowAAjkojn5KMJiDIGDlWkgonAAAAgjp2hNoEAAmHiAmcAAkUAAj+B6jklYgjAAAAmuBFIBjKF+AAktDNGwoPE5AAiAG3F1k1FWAAAAKMmDL5lfAADkAAmQHlkYAAjog8EYEHkwnhFoIrIfBAFlCtorAAE1oNFxoRAAAAGHm/AAAAD/ipDRFQE9KZmFKFoBo2G4IAAAqKk2jhCwqOA8AAAAEQmlq4kxFbmZhwoYMBmvAAi/AAIEAAmKFejMF/IlIaqylpIMHFAAoAAdm0GwIsAAD/DKpPiBCFBUAADKqMAAAAIWKbsBAADmJOG2AABFAAqIAAFznNrVkEAADeJjDzGDJtstAACVo9K4KKAAjDrjmOg+jik1jIJgHZFtGpIgoUoOGMo/hHJ3B5AAJjllFuldIhAAAAimoAmOocmJnWrFDVF+icAAAAoWAAGKAAE0EfAAjhAAEKAAAAAAqKAAGcAAKbAAHZAAoBAAAAAAEAKWD5DgquAAKkkhprGVtMoCI6JBm4lUhfFvl0AAkMqJIDJGjpAAJfqLk8jTHwKLm3AAnWoXHiDiFOFmgvkfA4CuInH2EMh7ipAAIQoXHln9E0qQDOFfh3k3j7l3oQpfAABnqVAAAADalgGMk5h/FVl2itoNE5G6D3HMgDAAFKDqA3nCHiFogiHNiMFpAAjfhcFpAAAygTAAFQhSAAkxHdjNAeAAmrnamSIxAaAAjKEgGyFrimmsjgitmXk3oGAAGbBfMRoSico2jlkbixobHMIimvBXj5nUgzE0GAoRAADxkODPmEGZFxHzmspuHNElkvCCFVk7G7iqlgmWGwlhmGFvJHAznvI8IvAAjTiJAAmaiRidrEn/qkjqglq/KbAAiYC7AAkxAAGfAAFkiPG7F8CzGuHgE0J0EeHxAAjeoGk9nkjFKPHYEJkJmiiaAAkaqbEMAAjnq8ggAAIQpisDAAGmhijJAAkVIOHwl7kSAAH2AAAAlBlyoUg1kbL8J1D7mAo/mLAtCtE9mnE1pkmxEmEcnTm9oUo4rKIzoYGzkclPkkCWHwm+oJGBIqF7GEAhGRqXhxEvkeE2FvG/AAnRhllXKtAAmXAAqvAAp7AAqiAAGMAAHZAApSAAp2AAG1AAqEljiAFGMHr2IakksqKboWEnpGqdKBEUFbmXAcn1E2EqotGwEmqMmlrcINnAngpZINIVpUIgnGAAA7n4EXkZG/mfIJHoIFGRAAoRjVo+HblLIDqgGXpSg7E6EJAHKVqDAAGDGMIZA/meIiCPlvqJFWqHFMpJEZHqBWI3JDp6nZIVn0mEk5mfAAm5kYAAkHDpAeCMCeGkCcANGQoOhmhyG6GkAAFrAAmQDmm1AAnbhrjHCBoxiJHdkQDSAAoclwIqL/HJjPnXk8liKOHxkDG3INIZjrAAmdG5HAoGDQJgAqIumapBmMqOAAKsJ6odCQmTm9jmFVH1Gkn7DLLjnusAHJtGFNDpo1rHpZi0DXknHznIk3HBrTkiKrjMDOG1pwjujwDoCZFSg/mBlUEoIXAACIImE8HzhuIFhYsIlaGCJGnDBvAAmfIUJ9GRIBnNAAHvLShrAArLo0nGAAmRITpjAAiBobnHAAFvmVrMGulXHGrFH/hDoALgGDAAggLcqHA+GNpwodAAj/EHAAJhI2GfJuIBpJlhEGJNJfCKnknoqIoGD7kCpdhCIvIYIRmrIgGamSnKhEF7GYnaBkJSoHIEIKH7KkAAAAAAqSAALUAALEAAmUAAKIAAAAAAoNAAJtAAKiIrFvmfrvoknTIQKPG5MYmIHrGWCHjzEEA3kwGrB0pPn3l8nOH2qQqsmQsbFYroE9mHl/FEAAAAkJjRpBEYoSraqAGpl8IyAAG+oIEro8CXJgosmOkLklE8knC5ivJfAAFOGSnXDVl0iXHcAAGdCqpRAAIYG9FRGPKBoRiUgmk3FKlenIGkjdFUCLEvDsjCAAAAG7iMijAAG1FPluljmoEvGIllGvnpIrGuDIEBGloQnpKQnSiAAfGrGImVF/kbJqjxllk0ooAAAJkqBBlbjBGxAAJ0lNBxl6kXClAAgCmRAAmbl5GHGlKwncmGlmigljkFkfE5mJpFGVFaAApsi1q2CmJxGHkOAAE8jHENGzjoE6Duo2m2GWnwCgEfAlpEFZERhlpVoRHnCLpyC0AAi/GJKZoDkJIzH3qxmJHQljIrJWmGmMlwAAoNmvAAAADrieIcAAlgAAICAAD0hXIpAAmaCsILAAnbkYqXh0InDpLIAAFukrrfk5G7GlMdkzAAEirPoIHnAAGtCqGjIRlaGWkGngqRqBiyG2laBpIgmmnMDei0gCCtmWCnAcAAopmBAAFlJHlYAAC3IbAAiCF8Gvl9AAAAELAAFrAAj3AAkBAAAAAAi9AAmPAAqCAAF2AAFKoio1KjqinlHGraKDmRmonnnpnmHHKUlyCqCvikG1AfmQKbJDGqoJJbn5ozHMJnmMHkqXIdoCAACJGGi2EciJAPgNnuCXiUlLC5C4JkmrAAhzKYDJB9AADCAAAdlIFvBIFbGTgNjgizlTkLEFjXkHkpD5h3hNGJCvHZlznMKAmNEDlehmnIkoj7kBAAlfi4mRHLFyAAj7COFJFrAACwFvlAEBkNAADmEIGTFnHZkuoWETEUJ0koG1jhilEyCtkkDxAAlTHPjtiSGXpdAmhoo5AAE9HBAAj3mEotAAoSCGqxiTHbo+AAAADGihkWAAmTAAAAD1AAljjsAinBjSmUlgqPihkVm+G2kWHeEPAAkIAAhPnaKPAAm4MHlqmSmBq2j/E0EYllGwnwoBjUErmrAAmWDMotAAJbGHBwAAC/EbgbAAAAj4rdAADDFMAAAAi8EeAAAAEajmAAAAAABrAAJEgDD+AAI5CtCSFnF9GcHkn7mRIXl1GRIYgGHJn5nylXBpCJJxGHhqAAF2AAAAKGAADRAAgnoeEvAADynYGtAWqIlvnZAAIqAABtAAjeEVi8AAIWoSBmAAi4ozlqAAAqjDmtKcDxKVsVCfDDojCDjHigkOCgDPD+JQAAJOF3nwE3kqrEGLkbhTAApImdkOHNEEkLAAKaByHIBFj9AAiXLFAAGOi6KuAAhrAnIwAAEvAACMAAlfkaAAAAHahqBVigEvGWm7AAk+GcETlylIgbGRAAANkeFoknAoCDi0jbFLAAEznHoHAAGHAAF8AAAAiCC1AAAADrotAAjjqBiQAAAAi5ktAAh+AABRAAE4EtAAAAAAHtDcAAlQIfidhrmpAADfkZHQgMk6D+ACF6DmhGERAAEim5HBAAIFCamKAAkgAAIMGSAAl4gsMCk8IVAAnGAADNAAlICQjZFRG4k7mJmWpYFcoImmKsGuD5qDDHkJGqAAkYicn0oMmBCMFxnJnyF6F1AgFihMGjCNAAhVhqAAn/DqlEnQprFho5AAr7lgIFFUGCHDFYEeE/jRFgEkAAAAAWAAErAAqfAAkzAAgvI3k4AAAAj1HqAAklDbAAiFBNkdAAhfl4rKAAHflFCLAAJHETGPAAJLAAmRsdlWF6H9siCenbDJKVlsE4iwHIlcJ3lGozDxDOCoEKjejrmyDEF1CokDDMmcE7A/FLHuGIDjAAkpIeAACMGLAAAAorp1lPAAAAqIlCAApGp2gtAAGvDCGRJHF1K0KhguGSAAi/AABTo5AAEejCjxAAKIJNEcn6m9AAGMAAj+iPneoBiKjSIzJ9GhllAAoPGhAAGoBBAAAAGzAACIAAHEneFVAAlKjcEcAAixhsE5AAIODaEtlVkxAunfG6heFTEPDJJXCOGnm6lQlHCICIGGlyjcmblCAACDJVihAAiJFdibAAAAEhGXAABUj1p5AAhzAAoNC4kFkIjbEiC/mBAAl5hTFijel6H7kCl3m3FqIPEPAAIEA7AAGdnkI5GZBtHSFoEum7hKm8g8kxmVA1AAAAEOISC5E5IYiVmSqDjYHSo0oYm2mjkfD2AAkWE/AAFhCrkHjRA+qPKgoLFgIpkVnonFIVoZnsmbFeAAAAm9E0mdBBlSouDlLjDnKCAAmVDwnsCanLE5IeCgAAlPLgGLmpm8qWGkpbGrHGEaDKkCk9mBnDAADOAAjiF8C/AAoMCjGDAAGMk6K6AAFRGcmbAAkeAAAAjyhFpMAAoqh0JWAAH6nqjvAAp/rwl6AApYATnMMrEsIeiNqEEEHmAlAAA4AAEQnSmLlXiRHdEql4HHlniqh9pti1EZmdl6HTixMQCAHMAAIxkNG9l/pQAAFKJhAAAAoho4LAAAntJULvAAIYKGmJAADYkdAAJmANpPqKoVmoCiAVAAqjqVFghqGFonAAoYAFnGFZlEEwGoFYh2osDPJsClodKimukzI+AAjUk3AAlfAAiEAAIjKdGtAAD/LDEgAAILgrCBAAm+haE3AAAAhSpjJIK3HpHNpQEVIZFUIciDgxCuhIliDCiTF3kWjuECH3jmAAmsGfG2AAjZjyAAAAmCAAGgAAgcinnvAAFRocC4AAAAAAGvBqAAJwkODPGuISAAlGAAj5nhn7AgjuEolWoGlGk3jZmbHBAUC0HCEoDkEcIwGsCbAAEgAAEiG8hxjRCSAAmtGRhrm6gkqZEOoKAAE5DtmZFqDymFgiAAAAAJkAIUFfHNF6qGmVDslMI/GNknlMhhmxDhkqmMCmGElCoaHKHttTAAENFFqHmapvEXiSIOAAkhmQIcLQnuigCRpRGuAAmbHdG3AAIek+GWDuDflIAAlQGeotAAKrIKJ2AApIHWI8AAEwmmnEAAHkHoAAAAkSrUAAH0BiGYAAJpDfAiAAJBnTENAALVndkOHElWHMEuo6oPHelvGZAAEsjBj9G5AAAAG1GxFlDOnaABGyJQp5IJkXp0E0gsF4JICDKVoeJ3ndGaFgAAjbl2oEAAoXpGjSAAD9olLNAAKUripmAAk6JrFkIqlOplmdkQHFmmEYmzDDEcAAGhEMIJDHnEEnAxKmGLJqDbj6qqAArRIbLgDeh2JIFeKPnUpOkBkhDPGVkfAAGzJgmaAAIblIgwAACYKNAZAAnJFHkcAAlJDNJ0HVrPl6lumTJlmsGMFFK5EgICDDGhBvGymgAAKDgKBbl8AAAAlnCYAAAAAADdAAAAlOGaAAGIhnFvAAn8lXHJHlk/k0kCk0jvlTFOJDkKEJmAGvF4nsiQiigBB1CXFOEeDykvEdAAHYCSIeEHAfFLIjg/EuAACNkfAAAyAAEQkpAAkRmricAAhQGYjSAAB+GwDfjcAAE3GWFxlNIOEdi5gCGkiKAAHklRkflYHBhBjDhHCUJ7ktiImEknien0ksF7DOlUEZA+kFHKGiiekMGlAAGbEMlhh1DBDZoap/I9GQCblAo/jAmUlaHlAAmdD1BVIdAAkEm1AAAAgACSAAAAi2jxjDAAAAmHjJAAoFGfAAAAAAAAAAAAgJAAAAEDF7CXAAh4FDBQAAkGiXlwimlTIzEbEalVgYBhlohBBBAAHsmAAAgkowAAmqhHhoGDggFeCOk8CWhODRAACkCfgPAAmOgJEQj5GSAAmACDlHAAHigImsAAlcEZmbAAAAAAGCAAhiibDTimAAjGh9hiAABvjvAAEckUCrlnGmCWBeAAHGAEEaFjAADtDvkIi2AAAOAhg7EmEXECmeAAmDkSiDAAgllDAAAAlunoAAEYiAnEAAHZEyoZAAAdAAqJAAAAiXAADAAAAAk6mdEYjPFcm7AXkViWkVAAkqlgCUCDAAAAEymbAAieAslOAADNk4l6AAhqg2G3AAAAibGkAAjEkBFFAAAtm6ntFshkhtDvEqHlkPibjbhNjqAAlNAAEbAWlihPmwBJEFjEGYmDgFghEdAAlAiFF9m2nOCUDFlOD2lKFeFUBJCoGNJXFIkumuF6KkjJIYJBqGm7mGi4BgisGGiSDChWAAK8FsFQorBoC0olk2AACwj+BbGgD+gjEKCkjFIcGVGWEEnhH8FoKUHuChl9lhFoJcliiADukhEuldpTCxHfIfqFEDHYndGoG+H1IckdHOFXkWERogGAJMpCAjAAjtE0kfjYncImAAiJmUlNAAAABnK8LJCNFoGbAAkJBCl2NDAuG5F6pQEnkSlqogAAAAIjr4A7AAHWIaAAhlEsoBpuHhnKnFGfHqF7AAG+mPnkkZAAAOqpAAAAoBHgIwB3HcmDJyjIBUG6q2AAonoCq9AAgXHFpKAAoGltOIAAE3CZlDAAFGE/AAgjACAAAAh3AAHnAAAAFJnbAAhzAADAAAIyAAiaAAAAJmlBAAgSCHmqAAhzibH2AAoiIrnSAAkKFCmRlPpAICGOGSBlDOmjnFGsnbIpHAh8ijlQFSmYGnlIIaDHAAplktFVE+AAm+nBF2GBFOFamSn9IVhtCmArlOmVnfCCkwFnF/AAjBGoC8AAGFAAAAAAixAAAAmsAAAhkYAAAACRCfgvAAk3APGIAAEfGAAAAAAAI4AAgWEOjthXgshJk3AAGflSknAAAAj4jbAAGHl0GeiynNG9EhINlSialEn/BgoTkqAAm1nuCJj4h3oKAAisnFmdhRooAAoRAAJSEBrXpMpxiCKqjMjPIKAAAAgYCDmDCKC9GghUnlornVqpAAkCojnXEGGxlUjTlODfG3CdgUqOIaiXkCqaDRoCikAyACAAEDmDk9iKEFmbGFnICvGEEXqBr0idHHKMD3o7n/mbmXqVIZgxmEmJAAoAEDHdJdAAG5ghCgIuhPKVrEF2jvnHAAmymPI2qfE9AAF6sGIlotAAKDqWExHGJNKqAAAApzDTG7BjFBE7HXpsAAF/gsi3qiljpWAAnzkwrImCpMi/ILFfo+AAkVobkaAAAAiqM1AAC+DjKWAAImqRonAAhYlEAAAAG0oiAAjpDZG/AAnymtDgAAqHEcopAAI6mZAAAAAbrMkJAAnADNCUAAnhleAAAAESpWAAAACzJxixGJGKifjroDAAkcHfqbAAFVGhCcFPjvEtmcEEA+FojKGCDim/kqj8B0GFm1GQGeJHHGH6CCmqHuEJkbAAGnnsn0AAmmqwp7AAixEaFbgToPCKCsjxFVoLmJFKAAG3DAjCAAkLBtDEAAkDkKEHAAAAAShCAAkOGwAAIEiDGcAACFFPnMAAI6AADyAAkBndAAAqjEm5EXFOnHG7k0FUFaAADSlzAAmXAAoBJRmgAAIRAAoLj/l5gkICAAnACDIAAAmTmGE2KSFvIqFJGRAAmoAAHdmcC9ktkWlSlIG1CgDsEFmvBlkTLYHuAAnqAAm8jYFSG1EgAHiHk0jSENqdF8j6EEJwm2AAAAnDH1HrCgk4BbHgkBDIk6kFAAniEfnDI3qUF0hLFRJZETElFMHNncIEgXkeAAAAqgm9mGmwAAJPn0jDifoBrVH6qCCBJZG6DBJ4qRDBhjogodGmEsCMJbrAmMjFpYFkmRAAAAodAAklFvqXAAh1KMAAq5iap3KLAAnmCCH6B8muFPAAIPohsMAAJrGfnsAADilvH6AAJ3ozIIAACODkAAAAlmm4AACTFKAwAAmTmOCUAAmREfnpAAl0EVGeAAj6LLn1AAhelmGpAAlLHZEAAAGkq5GyAAE0EnERAAiHmsCao0kwjXE8mHIFmfj3kfjFjdkFh3CzDsGpk5nBAAIPgBKSkmlMmGGTCdGFFDmLAAEBEeGgDKAAidqnmMjhFjMVlXBBmBorAAhBkOjMmBmjEXFsiUjqAAG2AAjrAAmQjnhwAAGMlziUAAr8kyAAAAKIjSAAAAHgGiAAAAjtAAAAJTAAgxAAi5D/EPAABcJPkCAAmJGmAAFvFtoeFdE0i9mwq4FpIHHQKhGanroqEqhBmrhsAAnSghCEBGnCGarIHFH4laAACuJIIoAAo8hfkJnhAAEmk4ETGTgwjTHjmZF4GaFhEBEIFyFXlCGYmVGcheIPnDioobG0pREpE2FpEpAAnTArGQj9qYAAjYkmiaIAsfm1oqIasjFbAAo3kZAAmXp1LNmhlUm/G5FjAAKtr7kwJgAAMwECCKkhKyFRFJoaAAAjk1HNqTAAkwEiMXnPFaHalAGiCiEIrGCXggE7ISEriQAACSoKj/kSm8o+BBAAoQDuGGkCGqA6AAnZH+ERmQIYKyAAn2EHqSAAjYELsJAAlUJ0MUAAEHgFsTAAhZDlAAh/jTi8AAAAjPAAAAEwCqmKAAAAl/FrAApiAAnkAAFnLSEPAADblcmGAAh1mXJBAAlvHpl2AAAtF8AAG2kYjOB+AAAAiCkWijEHFohgIEFwiHAAmtF3AAGVEdh9AuEHFUjslwEilHHiAAlvo+oEDCExlkmNmPERHBh4CSAAkDAAmbAbEuDFlXCGjhgIg+CQFQD1ElAAAAjvDSAAAAllA7AAAACmD+B+AAAAm5iLAAolmQAAkKnYAAAAGgIGi+AAqillEdAAkFnWkBAAAAlsAEGhkTodF5HIkhkxlhDljrjwhEF3DMGZEfkeDGFPElHTAoioAAinGwAAAAEDD5ivCLFgAAgWA/lHDuAAlGDKCyEQAbCqC6nOkTHMEnGCh3AAAAD1E5AAg7GAAAAAl3EcIzmTlagvooICiXAAkgH4mek3muFiGNkdm+CEpAiFCOChmWEvj5kSC6AAkvjwk8AAEgl6GXkTEGHBkqjmAABAJIC8AAi/E0DGEVEJkbFfjGFpD4j6mYm4olGlEYGAjUnRhvkVlxkMBqk3qvlgERkpooBDD5hzAAD/Cwk+i1kTD2AAhfAAEFipBFBYmLGKGHgAAAEznIAAEMhelPAAEDCNDBAAE9mjiGAADimbmXAAkpAAAAAAlannAApGmKm3AAiECUDTAAAAJJGHAAgemfG8AAAAjLBNAAD3CAo6AAAAgrnXAAinAABKAAjmkLAAjvkOnZiKgJAADdjRjsEDGmljonDXCwiuAAFdkkCKjOmqJIAAliGYjeCioCAApXBXFLCDFOjRAAjdl2FqkNgSEZBfmwAABGCBAAAfh3AAF0AMCWAFGAiZkcDZAAAAlpAAAAAAEPhDAACFm4DEAAAAmIjcAAFdAAAAnHIHi/AAmviJkiAAjDlADNAAAAhxjIAAlXAjoFkXlLj3AlgpBIkACkCvA1i2MAikHumnIYmTj+rAsKGNGBAACWmzlhmzEujVmqjaJLFYizGzJcoTkbAAoBDGgvh3lEE0mAC8BWpfKxnMATDAAAHwjxilAAhpAAAZnJAAAAnRGCqgAAkineD7AAkwFbAAAAGHHNFeAAE9kzAAg+Fwm9AAkADvk4AAoOm2CFAAIsptGXAAjFlOAAAAE/G5roAAhpH2AAAAHDk7GKAAh4kxDYAAJ1odAAK/kqjpAAnpFYlLAAnND0o8AAnfAAmTAAh0mIpGMPIsAAJgoWGjAAEipNlNAABtlbh7AAInnSrXAApiCCmNF6IdG7Kbn7HzqRG5hygCoLH/IJIIjhF1lHAAggmnlcCumpKhA2H3HGAAmAprnGhHJXkoIAGqjJAAiIGgnroDAAGxJHB9jQo7HWGcAAqWldCWAAhaAAjFjSFECQlnnyoEllAAF3qAGJHok3iFAAjogekDIvGcBsGuEFlVl/iXkPFHCCH4njm0AAIWHDIsoLmaEGhPEmpzHNAAiHIYEnkzHekAD4jglOg1DbiTlMG5kCBto/AAmYhRmtAAjsAEFLAAi4E3hDAAmLAAkeAACBDFEdHWAAFelJHPF0EAFJGyiAhmjMIOAAAAozlMiDkWhvkNBugjlrivnLjmmNEZimH2H2GbG2AAFJlFIoGyAxDjEBFykhnTGwHJGMm0HuhInPAbIbnzAAmVoljyBil7AAHiEIo3DklaAAG/J2G6AAoFo3kkAAhZpthsiPluAAE8nmqfAAGwqwMCAAkokgAxAAiXAADIAAAAGlAAkCAAJ9AAI0AAEvAAI5mSlUAAJ1HMC5AAiAIZEBAAGYgLqBAAFXi3CFAACHFWEQAAGnGkGgAApgIrAAKmo3oWAAmNGmhyAAlwnFGjAAlgF0jSAAFIEULWI6qWAAAbpGpmAAoOG3HDAAJDpynuAAAbFpoeAApBFrJ2GLpvEWqPAAmqpOFgKAhxkJlQC4iOhpDRohobGPmRiKKxp5AAJcJIHBlZo0AApyAAIJH6mwnOl5GNqAmmAAqJFoITJvKDj4KwGvg2IBmRmtlLBikPGoEapBAAAABfGOp0HulRrLkonBkUg3EQHikrAAl/GwlNE3hkoUEUHMjWGqkukTCTmVDblzFfGXCDKelmEalLpMKQktD5Iep0l5lxn0ISCNm2FGisG+CBq7HRAABDniAAJ2DVlgAAkOCqG7AAmGEbEBAAk0ELAAAAgomaFUodCnEXAAJaHBEhJZibAAFVmdDfkukShfmpIJCijrhgAAFZjSk1AAlmIcESpij5i7Gqm5AAk1AAGjkjkcmLH5B6k4k9mwB/H3laHkE6AAobGuIKINBkAAEwlFlpnKGGmCGFAAmPMUmIgxk6iaoMHgofjOAAmIj8AAleAAhLhzLJAAkFHKkhAAmOhzmTAAAUC1CVAAE6lMAAliEgHlAAozj2qwAAEsicA7AAgynMAAAAHqiYg9AAlph6t0AACKoYESAAgVAAGUAAF1HvBTAAmjAAAAKEljCZAAkDAAFXAAIelHm2AAmAGen7AAAAhaL9o4q9AAk/MTqEAAH9IrpyAAkbqvnOAAm2KMovAAIuAAnajapMssoUEKFhG/GDixEVFjisFykqJljjAAoQmRGiiPKYC7ICAApNF4CGmVm2GuGXByohIpkNGHo/DfEeolI1MtsGoUlGpnGMEcAihBLLntGoAtAAgnn+LWFHBBiTqZKAg0AZIelDJJHFiQmtCuIIAAAAIckBiDnHAAjRiWlfGsmyGOEdkGhhHdHylxnmIPElkkk2FDAvgbmsJ1oQGREWlCHKBsEgj4GMgbhmj4AHm3EsGEAAnSCOmpAAEeCDGAAAEhAAAzAAFrAAlcAAjzGHmIHjFXC6DKGcCakOEnG0DrmwBaENqoFDoEmSoskmDvAAIHhSl5gFAAFflKFlK9h8G9K8KmlrFbrKIvkGlBiXCmDqBBi9AAESAcCmGpEEkJhXiymVAAEFkIkHAai4AAEMkbAAAAjAJvGPHQiQrIIgidC6mElMAql1mZAAAAF4IEKCAAlVjIEoAAAYiwj1AAgSHWjsAAiXEtAAAAlKAAAAiAHDmOAAAUmKH6AAmoICgOAAoKgogiAAAZldqBAAHYEAMQAAEAE5IGAAEokekjAAEljgAAqemKFlAAHAAAmCAAFAiQEjAAHXg9GHAAHXEhI/KhLpAAJEL2K+AAoupQoJAAlnI8IiAAnIlOKuAAj0GDHnHXAqFPJemYiisim/HiDQoymLAckdIqnWjyGih8qCAADkniHEApE9Eqp6ETGoGro1jOm3kvHJkWEYCiDOoQkOiBELHWDYEHnsIfC7FSK5nkCeAACmEBArECnjJ6CKmjGiEog/MIkFD1CsAjIxGrF/AAF1IjE3h7HEFZFVncrpEmFcCcqjHnnCmBKDEUAAAAKUGyGQGFI1HLAAlto9ktimGJGiCAjmi7FYEJAAhQiriYjhj0AAEhAADdAAFjAAHCAAHfC2ihAAEQCaAAAAHEAAkYAAEWAACbmvAAgSAAk/GwAAAvknkcAAEMEVCIAAAABWn1IuCjkAHLIeikDoAAFZEvE0C7AAkRmUAAEHkvhaDYG8DPAAAAIiBiChHDG7GCAAGmnPAAAAjNgaAAAAkBD7AAiWAAD8kLDqAAC/AAklD7DIgmCuFFqPGaAAAAnTmHj2AAH0oyAZAAAAm/AQAAG7mhE0AABpAAAAAAFrAAAAAADAAAAAAskWCSAAGInSDHAAAAEJgJAAhEAOhBAAEfGnAAAAAAl6HNAAFQJDkYAAEGmsAAlBC9h+AAm0p2llAAAAmkEBAAmSgQHVAAAAnHm8hOglAAjVCngSAAAAAAhgAAmKmvkyAAGzEQEbAAAAkGFnAAikAAmbC7AAkKAAj1h2hmAAlKFri+h+BcGMinmFAADQnBGNheC2FvFLkQAAAAAAAAC8gLEclFAAAIB8gxD8AAAAnbk6AOAAIdGDkTAAGEAAhbBShGEnAwENkNgWi0AAB+E3huEplNEUCboaAAkAAHDtG2DfiHh4AAkfAAFODTlYBVixCAlTi9ovC0haDWAAkkFOAAECAAgToyAAIhAAkwELFwAAFkFgCbgdnPDYECEVBphdh/hpFLAAmfAAgeAAAAhNAAAAlmmzDHAAAAj+kjGzAACmCLFKAACkAUCtjfFIltltApk5hXAABhB2i0G1GXAAEOFTCujiouCrkYF0pbBujqAAAAguB/ogAAAAE5mYAAkTFWEUAAA/kFkPAAi5iVlJAAl8FxAADqFDkjB+F2gqAAFxlEo6F8mfhjkoGnGUAAjFnJDFidCdAAijmPkFAAA8FDknAAp7mfC2AAp+nuiLAAAAEaAAAAAAmYAACSiqIMAAl9EZEFAAKJFxCnAAmjEKGEAAIYobKmFrKisAk3oaEvglAAksmWnckQnDHKiFoijPAwAoquIjnmqvEoqUg7qbkuqABNJXGdHDElqskhkqAAh3h1FTqlkVAAoRFeAAg4nJl8gSpTAWF9LekfAAEXpHIyAAAAD6AAAAmpJ8pbAAklKnAAAAE1KUAAIcIdAAAALZk2D7AAEkDeGQAAkTh2J0AApUAbGYAFAAAAlOpIAAAAikK1AAAAGbH4AAAAj6EdAAAAAAmCAnAAAAAAAAAAAAGLAAAAAAhCmqAAAAk7IGAAAAGDI2AAAAGsIDoYAAAABLmkAAmloGoAAAAAG0GkA2AAAAmTBjjJAAFqCiH2AAAHAxGFAAGXpVB8AAEJgpAAEAGLiDAAEAFNAAAACEAAAAAAAADJAAAADvA8AAAABrAAioAAAAmqAAAAFrEmAmAAAAG+C9AAHnFYFSAWBokGAAkIlwF0iFmZCLH9AhISmTCBAAAAhZhyjWAAiujeCbAAFUERmMAAgqCGljAAEkk7H1AAiGkLGjCBEICxECiXhnkZITqsi/iyoBpwi8JJHJBwiSIcAAEnmAAAH8jjGDAAAaLpmsAAAAEniFAAoYG6EbAAhhlqAAAAlZlMAAKNE0JzAAopgcJkAAG9AACsAAC6inkwAKibr0KjENmfLOqEniCrmFGeiHIPDRFDE2iPI5K/ImmfCgJfqbCeGlIAFdHYqyDppWHvLiF3AAGQq2jWLTI+J4EXrEnXAAqymakkBAnQofE9iFDWAAFyqIgcAAAAhxDXAAH5GVnmAAJwqLJxAAjbK2mFAAAAKQAAIbnDpYAAk3GhCcAAFDIBhLAAAAmSpPAAqekxJ6H5AAAAAvoCAAAAg5IBAAAAClHPAAAAhhAAAAAAAAG1liAAAAnngfAAAAGfi/AAAAGHkAAAAAAAF7AAAAjyHHAAAALvkGodAAEqHFm2AAAAoEE8AADum7iLAAG8AAplBcjXAAlWFNosAAivE7CVAAlOJrFeAAi8AAAADco0AAAAifgQAAAAA+jaALAAHBlZBJAAkRl0iSAAj1HUAAAACthXlAAADpiBGVAAgyAECJAAEnBKgPBaAAkIAAlZi4i7AACikAAAEBFspmBqDPG9kBCGlDAAkfmWkGAAmTmHAAAAAAFvAeAAEtI0kaAAErmiF5AAFzkwAAkDg4jLAAJynRjdIqrwHmIBl6DKFpJGFGl4i7AAgQLnChAAlPGPGpAAFMoPCcAAGci8GzAAkxiuAAAAAAGMAAqJlSAOAAoSB9jLAAFQHqkuAAEUoIGgDnmMOErhFPm4lzIkAjmQk/K6mJEehRExkRE9AAobHLD3mBrwIrkiKNF/g6muihGMIinkEVEYI0Drq5IJsQDEpEoGIIBqHPH7IIDdGJIlEMCNknipDEiRAApVAAl7KrB6AAIrJ2GLAAHEFqjAAAGBIcn6AAAAKHAAngopGwAAnRDxojAAi+njIMAAm5GHq4AAiMl1l/IDAAAAGOKdAAAAiRpXAAAAmXFWAAAAEAkKAAAAAAJTF0AAAAAAmEAAAAl+jsAAAAgnAAAAAAkck1AAAAkCouG/AAEhnWiIAAgoFtFTAAGikeAAAAmBAAAAlBkQAAGYCVjxAAk9AAluAAkZCIjZAAECDOAAAAF7AAAAhuimAAAAlTHAAAAACLGqAAAAAAEEhtAAkhGHBVAAAAGlAAAAgKGyAAAAh7AAAAAAl3E0hDAAlgnADLl8HBDXAAAAAAklghmdCBEDjIGBAqI2AAD5EMi7CuAAliHPIQAAlTAYDGAAqAClFbAAq0E/lNAAJZKFAAAAEsEAAADLEuAAAAAApUjHE6ByFPF+j2AAFHidIsibGUAAmOAAGWAAAxDHkLAAAAEdAAAABGAAgSAAGXmKAAFHIQkLAAF1ptG4AAklotgLAABbkBFKAAloAAgHC8iHiDktAAmKAAluiIpMAAEBikn9hdj9lpHRmnByhzh2hXFYimE/ini4DkAdAAFYBOi2FgGoBqmXmmCWAAEEFDkUAAFNmBELE9GaELlJEPAAkBHIAAAfCfCEAAmcCuAAAAkhibl6AAjfEpFcAAAAEuiAAAFGBRAAjWlpijAAkeDYAAAAh8izmLAAD/gECgAADci3AADGAAAAmVA7AAAAAAFFAAAAFElCAAAAAAhaAAAAAAjRk7AAAAgGkrAAAAAAhXAAAAFkBYAAAAiyJ7AAAAj9hdi1AAEwAXjGAAGDElA9AAG4grE2AAmEmPEDl7jlAADvE8HvAAEkjjl8AAlOkug9AADgh4huAAkcAAAAl7kUADAADqGCAAAAlBiFAAAAkQEkAAAAj5ipC8AAj5B2hTAAkBAAAAAAFIh3EdAAAUjrAAAACyELlOAVJIjLAngHGYB0AAmfFYo5GLhUGPIEEfmFBvJJmJAAAACYGfAAlyi9mcAAIfkFmgAAIcErlbAAKQHYE/AADYAMEtBRJJiKGXgOIRj0iHk+IvE9AAEHpSmAFYloCnAAldDemrAACbAAoCAAi8AAAAAADgi1FeAAH0mJAAktICF9AAEZn6EiAAD+DBATAABCERmhAAlmBhEKB/AAhpkWDHAAAAnjjnIwCGHrmSl7kckDA3mCmXhrirBtBzholAijhOkQk4DzgtAAD2Ehl3BHArk1k6hACLlLF5FLAAlWg6AdjFCKgtloE5h8AAFeCsENCSksAAAACWC9AADXg1nCAABUEdC/AAkMFYjYAAkCAAAAkMHLAAAAhEllAAAAEQg2hlAAEBmfDbAAAAjjEkApAAAAAACOAAAAknAAAAAAkfCcAAAAk/D+AAAAAAGykKAAAAnBG+AAAAlNHDAAAAiUDTAAAAAAKJAAAAiyjqhPAAgKAAjYAAEuFAIrAAIqAAjSAAAzgdDUAAlXAAAAAAnwAADYmhoSAADIkNHkAABaCCkTAABsCyAAkLg8AAAAkVkqAAAAmAkgAAAAG/m3AMAAHkBoCBAADlE6AAAAC6AAAAAAkpj+AAAACHkClzAAkrCpAAkvDdEfAACDAqFbBXDBAAn5AAAAgcHYhjC2jQkomfESAAF9EUCzAAmCFWEXAAgHi+BSAAB+kvgaAAmqiCh+DXAAD/GXkqEmDkHWhyo0Crn8oiCMmFqenNDclPDknDmcjsAAjGoHkJm4AAMJEsGuAAB9HLAbAABlHylHg9mBmDFLkxjUDKHPAADdnKB6FdJ1C0I4lnIXGDi9lQGJjamsn2q/AAiDmaC9AACPgljwK+G0m2GriUnvmaC1irA5jEKSgJEZAKGLizoZgxkDLXGuFIAaI6o9C9AvAAh3iNA+nTHLAAAAHHmFAADQAAoEl7AAoAk6NAovkXorJIHHk7HApvJjFAnQI4mlHcFCAAHbG+DUGmlwJbrCj2pJioAAAAGVAAovG4oRnOoVmTGnmIBSAAAAjshvAjmWiUrejZoKAADUkjEzmaAFAAGIFxGIpjr1C8lmpeuQHVjVJHLnDGHTkVsBEImkmTI3AAmaCxMmAAAACurkAAAAAAMEAAnimWtOAAjolpLZAAo2ggGDAADEEKGOAACjjTiIAAEjiNAAAAi3AAAAAAlVA6AAAAoIAXAAAADLAADbAAAAAACPAAAAhoiIAAF1AAAAAAhmAAnUAAA2AAAAAAkdAAC+AAk1BjAAAAGwjrAAAAAAi2kPgwjOD4ElAQhuGaAAAABDAAk7FcjRAAHaC1AAAAjziUCiAAD3mCiZAAmdkdAAAAhLj/m6jDAAkEisAAivHjHHAAi3AAkrAAmAggpIBClVFflRlSl1gNEsCSkcEpocCZHjFgAACOCqrEFDF+j0kRi+AADJmnFGAAkjmikgAAiQAAA6AAJvHYFriyGohAmiHFjzBzAAmColBQAyCUg0mAkLjCF1CsFwFcnpkcGAi2BFAADKBCFxiwEgAIEHnblBIjickFn7ndCJG9CNuSkUJHBiM2CQGenuAAmEAAnIhQAwAAm9B6FfGLhlNQmGmLIPDtAAjXG/D3ogEuAAjcmpGiHMl8H7EvI/iGAAlHlNEimfC5AAgWGflXEFAAFmoxqMJNmUjRlJBSGHhxpkAAkAB3AAAwjDCxEVBuiRGbi3AABjGoErkOJvBKhNFWMcAAmfAAJ/kXIbnxrWn7pQk4GhAAGUAALpAAGsGFrXAAHRCAqxAAB9GXMbAADEAAAAAAlTG5BtAAmNmdDzAADtAAidAAjACEAAAAkOgRgeAAAAAAmbAAldAAg5AAC9AAF9AAmSAAkrAAmzAAAAAACmBKAAAABUAAh9AAD9g9ErCDAAiBCOBjAAAAFlgFjOl4i2AACjAACRAAFcEgCaAAkEBzC9AACdBUF9AAiFAACfEJAAAAArCNAAAAoUjrgQAAmuAAAAAAlCCvj6AAF5gRB8nvDGGxDxMcGGl7mpJoEVj7FmpvAAiNEUgyIAFBAWhQl3mHBSCRAAmHoZCvEAErEyg6hcjUCFoqjcH+CkERjfAAn6E9EhF5nUF8AAk0ommtIfHlA5mdkYjuKOiTKJrxmuIbDLrioSmqmjlEMCEUGoGpmnAAAAqVHCEHgfJ9mugxDSppCbE6AAKHnCiIC1lbnNm0CRn+IFthDvB/DyAACpo7FZBtDmHXJVHBEsGnFqnaIeopitC/HuEjFVkoJeCdiHjIpLJNl1D5GMnKIIkdAAoRGZAAnQkzIfgnmci+AAkYmCm9BAEXlFGLodAAAKjUKIIAikiAG6iMlwhximmzgckIC0BAAAnPIEKKq5CbkUputelBi2pdMjIOEUKrrQkPkOAAJhAAHhCyLWAACMGFLdAAFQFmKuAAltFhKuAAidJ/r7AAlHAACCAAm5lKHiAAHFE5FnAAE8AAAAAADygiiLAAEDCaCFAAlPAAArAAGOAACqAAkJAAihAAozAAnuAAAAEEB7AAELCwAAAAlGAAAAAADGizDLAAAAhOGEAAkglrG4AACLAADvAAmHErAAgQAAFwAAAAgEEJD1D4BSAAGLlnAAAAAABMIfAAkXA2kTAAGaCUCuAAi6DGAACpFmAMj+lcIakXCilxEJFEIIAAGrFogEIhFmAAAAAAAAlUkWnMpEHfAAHaGxCrAAoXiLEpF9AAkBnuoKnXCilhAAG4FyoLCNJFmJkWDDGSFJh0mUk4AAIxnAlWAAFRjOjXhNC0jEGgEsmSDVIbhfIbkVm1GQmQIVGIGQlAIDqjGmDKCXjrEXg6jTHPAAoHmNl7kZmgAGEfFqhMk1EhpVGsAAAeFmkyFICxlAlhHLgqE5lEHBINGnAAmtDEgDmyk1FlmJAAAAEVkPH4iJm5mVoVAAlHiolmkonWjTjHAAFlg2ltjRHaGLECmOmWD1HygGkClrjDDkujAvAAHZgxj5gem2AAiZAAAAjOAAD+IRlOAAlUGdI9IuCwAAkRLaBhCHkhJbAAiyFGGXAAn1mlJhAAlZFvA8AAmoF2nLAAh9AAqFAAnMBPsdAAEKjcAjAAg2BuDDAAiQkuBuAAAAjTkCAAFbktkMAAl/AAjFAAGnAAg+AAGWAAEEAAEVA7m3AAiTC3jmAAmwgFAAAAnwAAAAAAAAgnimAAlvC3iAAAEuAvlgBoEYlSkSAAAAkXknAAAIEYGNCHiDBjleAAG2iZiNA2AAAAi6AAAAAAmFiuDTAAFLkHAAAAC6FLADAAjyCcAwDNgbiFEojpFlFFChoGEjGxi0GbAAEMl0AAiMEdGuIZBml2ELJBliAAiEG/GZkHirFpj+AqAAkQlQjgl7FaikAAmjDuE/KSIHHjAAAAAAAYIkiOEECChLE6EMhinMjPiFm4hqmPlDFyhNmsINisoDo8AAARjjlEAAKIEvAAFSojFzIxm+mGCCIyDgkGgboJG9GMAAmOAAAAAHBEndBpHZm8mcAAJDAAAAEOCHn+IvAABLkbgJmuFKGhGzAAihmxkKCilEmbBCiwDeFAnnnWAAEyiWEMiTEilKHxgtkfo3CgmFAAiIG8AAAABPkpicjZCNjgGskDFQC7j6EXGsgNiUElkEGWC5CqAmFYF4FjlqEMFzhcnQEvIamZHcE6mLlOpDHHnhAAk8mOi8AAGrAAG2AApRGDIeAAAAIdk+AAjtEiHZAAm5GUpxAADLnxAxAAAAEegpAAD5CfBAAAEnILAAAAjVklAAAAoPgyDIAAEUAAE2AAm5AAhoAAAAgRkYAAmbCUAAAAGdAAixAAAAAACMAAAAgFHXAAjrgUitgwEJiJC+AAiaAAiNAAgahfAAAAFUAADhAAixF1CfAAE6AAiDEAC6gxiqCaGhnDAAlEIojwislCDjHGo0GUHKihl6AACQjjgSAAHRkKh8AApUDUAAFnAAjSETAAAACSAAAGIvFAEGDxg2CkH2loAAGcgQAAgnmYoVkfFRosGwgli7G3AAFBmdHJGegtjEggoLGaFJDlnfBIn0kbGKEFFGmkgYDFm3IJHmAAi3oEmfhaiDHDmZCClZFKAAA5ktoKm7DSI3mnFnAAEIn4jUiqCdGSg3JHFui8GHEBmbqIo9jWILLJn7DnJBCAkxAApOqBERoPmuG+ipgWJQpnAAEAFCIHkmntE2AmD1KxGTlHB4JVoMkWionhkRC6g9kIr1CVAAAAI7ggHRCNAAISAAijIXpZkBEZLCGSIkAACEAAAAickTE3CzCOFBkOC/jImvDlmOAAphnxmbAAEOAAFqi9qEkDlJgiFkEJAAoGjKF9C3EQl/EIEPm4mvmdC8BZjyG2AAFMClk+iaB+E4G0i+kzmhBiFcAAFIDDBEAAo1g4Bpizkck8mgA9DGjTmLAAHZChBhAAmFAAAAAAGwAAAAAADBAAB7AAFCClAAAAgBAAiWAAAAAAAAAAAAAAg7AAkYBGAAAAGSAAAAAAlJF+AAAAAADWh8AAEdAABaAAD0iIDqAAAAAAAAl1GxFMiyEoBoDkFamNnaAAlWmQAAAAAHlIlSjMAAAABtA0AAAAFLBSAAgQm+FvjXAAnBEYjRBjH+AAAAGbFAEgg8kqGUkelgD8AAHVBGGaCWgUmylhkeIekCi3mVGUA+iMk1hWIAkeHrHzFPhgihhbGZGYi9oYlTCQmwG8k0C+rQGCFpkHlPAAG/AAE7HjC/B5CgCdHcBaFVodj4EMnqoVhiAAFRnEG/CdAAmTkoHKGcmrkFGFJYq/nlAvKstYhYl4mxnFHHAAAAnDAAFzE5AAloh2jNKFidHKl9kshfocq7pCkdGAAAAAhdGnkiCgCLlxjIkSEhg6IBAAiPmHooGGC/EZJgFjlAGcKVkFEgkVmlpVHkGLqJF9DNkgIzFzjgmomjERB7AAAElGgyGkgmnZCpGbsblQGqieJ6FdAAmilum5FyAAAAmdAAEQgrAAhaiYALGIEqDUALAAiwHaEtjwGxCjF2hlglAACuFuklCOEAj8k1gXDABvkGAAGfG6AKEcAAAAEEAAJQAAC0AAmDAAguAADWAAAPAAAAgmAAAAI3AACNAAjmAAiRAAAAAAAAAAC8AAAAAAjoCPA6AAAAAACvAAAAkZgYAAjCkaAAAAFOH2kBAAkBqXF4AABwIuAAgJGDCTDfFXAAC6hGjcFRBvGNAAleAADMBPilAoC1AACAIEAAAAj3FjAAAAnIqqAACklFiJC9B1AXn7AAEkAAE+AAgCGPIvDbG5EgAAFOi0muFHB4AAmbGhECEuEdAAkTpeIHGzFniLJRGfAAEmokpGnxGkJNAAGeHMAAnAi1LdqWFLIWF6IOhgn8nNF7AAGsn6AAG8C8H4mShhloKkExEDj0qZD8EAC6qmDIDaDwIUEHksAAmNiXqmkMngmoJMk9GkImpECXmaGcIjGhocgxmPAAImG7C2DKKpGWE0lvK/oGHdFOq6AHlnDYrQmyINAxkKCIqLiNAAHTKkAAD2mIpuhRAji4oJA9jXqUGuAAAlIAIjGrGLoTD7AAkPg8mjBkFYAAgrE1EJAAIJgNAAAAGemRAAGIm3AAAAIaF9D4AAJiHEioDVAAlUg8EeAAHDkUFjF2niAAGymTAAEokvAAi4ELgiAqEcAAisB/AAEAAAjQAAkIAAAAAAigAAEHGIAAibhBA0FPAAi6AAALAAlXAAAAAAlcAAAAAADZAACLAAAAAAkDAABLi6CyAAgKgLgVAAAqAAA8AACvAAAAAAAAAAlyAAkWlbAAAAEmEUAAAAAAhulJAAkzAAAAAAnWDVEREMAAAAG1G1E5BkBICVCCjnB6AAmBkPE8AAAAAAkXAAC7AAB3AAExESimAABKAAAABSkrk4BdAAgpk3FCAAC1naFzk9FCEojekDp2CuCZklAABJleE5lriRkiD/mPDxBkIHjsl7FFF8lDiPBWnBm5HLEbCBhABmAAKjBLAABVkZlOD0DuA+AAE2C5igGSEBBRprA2muEymXmtDMAAjTICjWjJIslPAAmNlzmCAAEiprCgAAjljcAADYAAkkAADzALoEAAh0FHAAGvFRhfjII3BKixoHAAhoCBm6kBi1AAq/gfgqGPJwlEFrAAAAAAmSEHHtCZnBnal+kTGqlOjUj5kTA0AABdH4mQknAAoolwkYAAmPCejfiIIMHXFgknAAjgCRnPAAmOGoiKgOFcAAAAAAj2khEkAAGBmaA2CGgeDYi8lkAAjQiAAAAAAAEWmMjlBYAACJAAkQAPnCguAAAsmZjaB+lIEmlhEtAADbjcAAofAAEkAAktAAEND7C8AAGDD+h+EdkjAAAAjfjhAAlGAAACAAFuAABtAAAACWCIAADDCclBAAg6ALgrAAhdAgDEAAAAAZAmAAAAgyAAAAETj9ANAAATDxAQAAh4AABVAAmmBJAAAAkPgdksAAkbBeBXhxktAAgVD+l1naFyCvGqG4AAEok7mOBJiLEEBXlMAAAAAAAAAAARilAAAAH0AAmICEFVEoAAAAD4EfGxFkAACAAAoIjHhIiyAfFXAAgamOoDANhJH/FHCJnGHem0g/AAlJqVg0GzoGkVGrklIIAAGiCWnznrmMjVGfAgHMiVlxFbD0EsBTnpCvifEbD2EkgkkkAAncD7o+lrFeGhj0IMkLANmaqKhfiqk3EgAqlaAADfmJodmZhuHajkn4myEEBwgym2kIFmGfHiAAC2IHGRnQAAIFh0HdAABdFLGji9p2ABgEC6JMg6HXCyAAEGkUArEPAAiZAAEEpRDMjEo+CDmFmWmvktI0EQGekcoADwiDAtAdl9E0kFBMlaAAmGjjAAEjpAFbAAAAkYD6CRAADBlblultAADvAAldl4lVi4keAAAADGjsCpgLjFAUAADgidEvAAjFAAAAE6G3AAAAhOlFCmGPHACWieDyHWGEGWAAjVEQAAg8DrDLlQi2kBG5FkkUAlmriGAADphaAAAAmFg/BjAAB3AAC4AAjWAACoAAGFBvEcAAjcAAiJAAE0AAizAAk4AACnAAkwAADcAAAAgwBw"}' }, stride: 3 }, bias: { isPot: true, width: 16, isFloat: true, data: '{"ne":4,"nf":7,"n":1024,"data":"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"}' }, index: 5, classesCount: false, connectivityUp: "squareFast", normalize: false, kernelsCount: false, maxPooling: false, remap: { isEnabled: false }, isReorganize: false, dynPelu: false }, { size: 16, sparsity: 5, activation: "elu01", connectivity: { fromLayerSize: 16, toLayerSize: 16, toSparsity: 5, weightsFromTo: false, fromBindings: false, toBindings: false, squareFast: true, weights: { isPot: false, width: 80, isFloat: true, data: '{"ne":4,"nf":7,"n":25600,"data":"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"}' }, stride: 1 }, bias: { isPot: true, width: 16, isFloat: true, data: '{"ne":4,"nf":7,"n":1024,"data":"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"}' }, index: 6, classesCount: false, connectivityUp: "squareFast", normalize: false, kernelsCount: false, maxPooling: false, remap: { isEnabled: false }, isReorganize: false, dynPelu: false }, { size: 8, sparsity: 16, activation: "copy", connectivity: { fromLayerSize: 16, toLayerSize: 8, toSparsity: 16, weightsFromTo: false, fromBindings: false, toBindings: false, square: false, weights: { isPot: true, width: 128, isFloat: true, data: '{"ne":4,"nf":7,"n":65536,"data":"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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"}' } }, bias: { isPot: true, width: 8, isFloat: true, data: '{"ne":4,"nf":7,"n":256,"data":"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAltFwlqICMGLyM5LRMKLkKXJJEDKVCXIPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJIKmKOLRGRAAIWHJIxLWMXLhJ7KwKpJMKvKvKhKcLNKpLYJeJfLpIkLxMdF2FLmlAcH9menikqHCouIvlnqnqglpNlN3NfNFtlt3tftFLyMWMkMqMAMzKeKpMlMVMDLc"}' }, index: 7, classesCount: false, connectivityUp: "full", normalize: false, kernelsCount: false, maxPooling: false, remap: { isEnabled: false }, isReorganize: false, dynPelu: false }];
  var exportData = {};
  var jeelizFaceExpressionsNNC_default = { layers, exportData };

  // src/FaceExpressionsController.js
  var FaceExpressionsController = class {
    constructor(stateRef) {
      this.canvas = document.createElement("canvas");
      this.stateRef = stateRef;
    }
    async control() {
      return new Promise((resolve, reject) => {
        import_jeelizFaceExpressions_module.default.init({
          NNC: jeelizFaceExpressionsNNC_default,
          canvas: this.canvas,
          callbackReady: (error) => {
            if (error) {
              return reject(error);
            }
            const monitor = () => {
              requestAnimationFrame(monitor);
              if (import_jeelizFaceExpressions_module.default.is_detected()) {
                const rot = import_jeelizFaceExpressions_module.default.get_rotationStabilized();
                this.stateRef.rotation = [-rot[0] * 1.5 + 0.25, -rot[1], rot[2]];
                const morphs = import_jeelizFaceExpressions_module.default.get_morphTargetInfluencesStabilized();
                this.stateRef.expression.A = morphs[6];
                this.stateRef.expression.BlinkR = morphs[8] * 100;
                this.stateRef.expression.BlinkL = morphs[9] * 100;
              }
            };
            monitor();
            resolve();
          }
        });
      });
    }
  };

  // src/index.js
  var width = 800;
  var height = 600;
  var renderer = new WebGLRenderer({
    antialias: true,
    alpha: true
  });
  renderer.setSize(width, height);
  renderer.setPixelRatio(devicePixelRatio);
  renderer.setClearColor(16777215);
  document.body.appendChild(renderer.domElement);
  var camera = new PerspectiveCamera(35, width / height, 0.1, 1e3);
  camera.position.set(0, 1.1, 3);
  var controls = new OrbitControls(camera, renderer.domElement);
  controls.target.set(0, 0.85, 0);
  controls.screenSpacePanning = true;
  controls.update();
  var scene = new Scene();
  scene.add(new GridHelper(10, 10));
  scene.add(new AxesHelper(0.5));
  var light = new AmbientLight(16777215, 10);
  scene.add(light);
  var pose = {
    [h.HumanoidBoneName.LeftShoulder]: {
      rotation: new Quaternion().setFromEuler(new Euler(0, 0, 0.2)).toArray()
    },
    [h.HumanoidBoneName.RightShoulder]: {
      rotation: new Quaternion().setFromEuler(new Euler(0, 0, -0.2)).toArray()
    },
    [h.HumanoidBoneName.LeftUpperArm]: {
      rotation: new Quaternion().setFromEuler(new Euler(0, 0, 1.1)).toArray()
    },
    [h.HumanoidBoneName.RightUpperArm]: {
      rotation: new Quaternion().setFromEuler(new Euler(0, 0, -1.1)).toArray()
    },
    [h.HumanoidBoneName.LeftLowerArm]: {
      rotation: new Quaternion().setFromEuler(new Euler(0, 0, 0.1)).toArray()
    },
    [h.HumanoidBoneName.RightLowerArm]: {
      rotation: new Quaternion().setFromEuler(new Euler(0, 0, -0.1)).toArray()
    }
  };
  var vrm;
  var loader = new GLTFLoader();
  loader.load("./8988580958909680445.vrm", async (gltf) => {
    vrm = await ye.from(gltf);
    scene.add(vrm.scene);
    const hips = vrm.humanoid.getBoneNode(h.HumanoidBoneName.Hips);
    hips.rotation.y = Math.PI;
    vrm.humanoid.setPose(pose);
    vrm.lookAt.target = camera;
  }, (progress) => {
    console.info((100 * progress.loaded / progress.total).toFixed(2) + "% loaded");
  }, (error) => {
    console.error(error);
  });
  var clock = new Clock();
  clock.start();
  var state = {
    rotation: [0, 0, 0],
    expression: { A: 0, BlinkL: 0, BlinkR: 0 }
  };
  function update() {
    requestAnimationFrame(update);
    const delta = clock.getDelta();
    if (vrm) {
      vrm.update(delta);
      vrm.blendShapeProxy.setValue(h.BlendShapePresetName.A, state.expression.A);
      vrm.blendShapeProxy.setValue(h.BlendShapePresetName.BlinkL, state.expression.BlinkL);
      vrm.blendShapeProxy.setValue(h.BlendShapePresetName.BlinkR, state.expression.BlinkR);
      const head = vrm.humanoid.getBoneNode(h.HumanoidBoneName.Head);
      head.rotation.set(...state.rotation, "ZXY");
    }
    renderer.render(scene, camera);
  }
  update();
  new FaceExpressionsController(state).control();
})();
/*! (c) 2019-2021 pixiv Inc. - https://github.com/pixiv/three-vrm/blob/release/LICENSE */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
